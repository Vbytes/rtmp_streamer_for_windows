; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.21005.1 

	TITLE	F:\songmm_moon_stone_obs\OBS\Source\OBSCapture.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_R4?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@6B@ ; std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void>::`RTTI Complete Object Locator'
PUBLIC	??_R3?$_Func_base@X$$$V@std@@8			; std::_Func_base<void>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@@8 ; <lambda_582637cdd8d6a2f689bc987be9ec55df> `RTTI Type Descriptor'
PUBLIC	??_R2?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@8 ; std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@8 ; std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@8 ; std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void> `RTTI Type Descriptor'
PUBLIC	??_7?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@6B@ ; std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void>::`vftable'
PUBLIC	??_R1A@?0A@EA@?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@8 ; std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R2?$_Func_base@X$$$V@std@@8			; std::_Func_base<void>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@8 ; std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$_Func_base@X$$$V@std@@6B@		; std::_Func_base<void>::`RTTI Complete Object Locator'
PUBLIC	??_7?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@6B@ ; std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void>::`vftable'
PUBLIC	??_R2?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@8 ; std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void>::`RTTI Base Class Array'
PUBLIC	??_R0?AV?$_Func_base@X$$$V@std@@@8		; std::_Func_base<void> `RTTI Type Descriptor'
PUBLIC	??_R3?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@8 ; std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AV<lambda_3b020cec0f1508adac4c896f138918cf>@@@8 ; <lambda_3b020cec0f1508adac4c896f138918cf> `RTTI Type Descriptor'
PUBLIC	??_7?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@6B@ ; std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void>::`vftable'
PUBLIC	??_R1A@?0A@EA@?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@8 ; std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?bLoggedSystemStats@@3HA			; bLoggedSystemStats
PUBLIC	??_R4?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@6B@ ; std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void>::`RTTI Complete Object Locator'
PUBLIC	??_R4?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@6B@ ; std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AUFrameAudio@@@8				; FrameAudio `RTTI Type Descriptor'
PUBLIC	??_R0?AV?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@8 ; std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void> `RTTI Type Descriptor'
PUBLIC	??_7?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@6B@ ; std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void>::`vftable'
PUBLIC	??_R0?AV?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@8 ; std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void> `RTTI Type Descriptor'
PUBLIC	??_R0?AV<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@@8 ; <lambda_7c9af1b141e25bc2e890d47a77a39da9> `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@8 ; std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_7?$_Func_base@X$$$V@std@@6B@			; std::_Func_base<void>::`vftable'
PUBLIC	??_R4?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@6B@ ; std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void>::`RTTI Complete Object Locator'
PUBLIC	??_R1A@?0A@EA@?$_Func_base@X$$$V@std@@8		; std::_Func_base<void>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@8 ; std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void> `RTTI Type Descriptor'
PUBLIC	??_R0?AV?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@8 ; std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void> `RTTI Type Descriptor'
PUBLIC	??_R0?AV<lambda_3648d362fc95221bbf9c4c4a922d1611>@@@8 ; <lambda_3648d362fc95221bbf9c4c4a922d1611> `RTTI Type Descriptor'
PUBLIC	??_R4?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@6B@ ; std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void>::`RTTI Complete Object Locator'
PUBLIC	??_R3?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@8 ; std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R3?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@8 ; std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R3?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@8 ; std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@8 ; std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void>::`RTTI Base Class Array'
PUBLIC	??_R2?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@8 ; std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void>::`RTTI Base Class Array'
PUBLIC	??_R2?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@8 ; std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void>::`RTTI Base Class Array'
PUBLIC	??_R3?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@8 ; std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_7?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@6B@ ; std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void>::`vftable'
PUBLIC	??_R0?AV<lambda_e856d28dddb7588070dd099cfda6c634>@@@8 ; <lambda_e856d28dddb7588070dd099cfda6c634> `RTTI Type Descriptor'
EXTRN	__imp_??9String@@QBEHABV0@@Z:PROC
EXTRN	__imp_?Select@SceneItem@@QAEX_N@Z:PROC
EXTRN	__imp_?OSIncompatiblePatchesLoaded@@YGHAAVString@@@Z:PROC
EXTRN	__imp_?GetPathDirectory@@YA?AVString@@PB_W@Z:PROC
EXTRN	__imp_?FreeProfileData@@YGXXZ:PROC
EXTRN	__imp_?Right@String@@QAE?AV1@I@Z:PROC
EXTRN	__imp_?AppendChar@String@@QAEAAV1@_W@Z:PROC
EXTRN	__imp_?IsSafeFilename@@YAHPB_W@Z:PROC
EXTRN	__imp_?CreateVertexShaderFromFile@GraphicsSystem@@QAEPAVShader@@PB_W@Z:PROC
EXTRN	__finite:PROC
EXTRN	__imp_?GetVolume@AudioSource@@QBEMXZ:PROC
EXTRN	__imp_?SortAudio@AudioSource@@QAEX_K@Z:PROC
EXTRN	__imp_?QueryAudio2@AudioSource@@QAEIM_N@Z:PROC
EXTRN	__imp__AvSetMmThreadCharacteristicsW@8:PROC
EXTRN	__imp_?OSCheckForBuggyDLLs@@YGXXZ:PROC
EXTRN	__imp_?DumpProfileData@@YGXXZ:PROC
EXTRN	__imp__InvalidateRect@12:PROC
EXTRN	__imp__SystemParametersInfoW@16:PROC
EXTRN	__imp_?MixAudio@@YAXPAM0I_N@Z:PROC
EXTRN	__imp__SetThreadExecutionState@4:PROC
EXTRN	__imp_?OSIncompatibleModulesLoaded@@YGHXZ:PROC
EXTRN	__imp_?CreatePath@@YAHPB_W@Z:PROC
EXTRN	__imp__CoUninitialize@0:PROC
EXTRN	__imp__SetPriorityClass@8:PROC
EXTRN	__imp_?OSGetDefaultVideoSavePath@@YG?AVString@@PB_W@Z:PROC
EXTRN	__imp__AvRevertMmThreadCharacteristics@4:PROC
?bLoggedSystemStats@@3HA DD 01H DUP (?)			; bLoggedSystemStats
_BSS	ENDS
;	COMDAT ??_R0?AV<lambda_e856d28dddb7588070dd099cfda6c634>@@@8
data$r	SEGMENT
??_R0?AV<lambda_e856d28dddb7588070dd099cfda6c634>@@@8 DD FLAT:??_7type_info@@6B@ ; <lambda_e856d28dddb7588070dd099cfda6c634> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV<lambda_e856d28dddb7588070dd099cfda6c634>@@', 00H
data$r	ENDS
;	COMDAT ??_7?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@6B@
CONST	SEGMENT
??_7?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@6B@ DD FLAT:??_R4?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@6B@ ; std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void>::`vftable'
	DD	FLAT:?_Copy@?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEPAV?$_Func_base@X$$$V@2@PAX@Z
	DD	FLAT:?_Move@?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEPAV?$_Func_base@X$$$V@2@PAX@Z
	DD	FLAT:?_Do_call@?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEXXZ
	DD	FLAT:?_Target_type@?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UBEABVtype_info@@XZ
	DD	FLAT:?_Delete_this@?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@EAEX_N@Z
	DD	FLAT:??_E?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEPAXI@Z
	DD	FLAT:?_Get@?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@EBEPBXXZ
CONST	ENDS
;	COMDAT ??_R3?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@8
rdata$r	SEGMENT
??_R3?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@8 DD 00H ; std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@8
rdata$r	SEGMENT
??_R2?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@8 DD FLAT:??_R1A@?0A@EA@?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@8 ; std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$_Func_base@X$$$V@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@8
rdata$r	SEGMENT
??_R2?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@8 DD FLAT:??_R1A@?0A@EA@?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@8 ; std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$_Func_base@X$$$V@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@8
rdata$r	SEGMENT
??_R2?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@8 DD FLAT:??_R1A@?0A@EA@?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@8 ; std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$_Func_base@X$$$V@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@8
rdata$r	SEGMENT
??_R3?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@8 DD 00H ; std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@8
rdata$r	SEGMENT
??_R3?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@8 DD 00H ; std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@8
rdata$r	SEGMENT
??_R3?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@8 DD 00H ; std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@8
rdata$r	ENDS
;	COMDAT ??_R4?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@6B@
rdata$r	SEGMENT
??_R4?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@6B@ DD 00H ; std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@8
	DD	FLAT:??_R3?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV<lambda_3648d362fc95221bbf9c4c4a922d1611>@@@8
data$r	SEGMENT
??_R0?AV<lambda_3648d362fc95221bbf9c4c4a922d1611>@@@8 DD FLAT:??_7type_info@@6B@ ; <lambda_3648d362fc95221bbf9c4c4a922d1611> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV<lambda_3648d362fc95221bbf9c4c4a922d1611>@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AV?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@8
data$r	SEGMENT
??_R0?AV?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25'
	DB	'bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X'
	DB	'$$$V@std@@@2@X$$$V@std@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AV?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@8
data$r	SEGMENT
??_R0?AV?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc952'
	DB	'21bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X'
	DB	'$$$V@std@@@2@X$$$V@std@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$_Func_base@X$$$V@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$_Func_base@X$$$V@std@@8 DD FLAT:??_R0?AV?$_Func_base@X$$$V@std@@@8 ; std::_Func_base<void>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$_Func_base@X$$$V@std@@8
rdata$r	ENDS
;	COMDAT ??_R4?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@6B@
rdata$r	SEGMENT
??_R4?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@6B@ DD 00H ; std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@8
	DD	FLAT:??_R3?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@8
rdata$r	ENDS
;	COMDAT ??_7?$_Func_base@X$$$V@std@@6B@
CONST	SEGMENT
??_7?$_Func_base@X$$$V@std@@6B@ DD FLAT:??_R4?$_Func_base@X$$$V@std@@6B@ ; std::_Func_base<void>::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:??_E?$_Func_base@X$$$V@std@@UAEPAXI@Z
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@8 DD FLAT:??_R0?AV?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@8 ; std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@@8
data$r	SEGMENT
??_R0?AV<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@@8 DD FLAT:??_7type_info@@6B@ ; <lambda_7c9af1b141e25bc2e890d47a77a39da9> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AV?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@8
data$r	SEGMENT
??_R0?AV?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb75'
	DB	'88070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X'
	DB	'$$$V@std@@@2@X$$$V@std@@', 00H
data$r	ENDS
;	COMDAT ??_7?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@6B@
CONST	SEGMENT
??_7?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@6B@ DD FLAT:??_R4?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@6B@ ; std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void>::`vftable'
	DD	FLAT:?_Copy@?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEPAV?$_Func_base@X$$$V@2@PAX@Z
	DD	FLAT:?_Move@?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEPAV?$_Func_base@X$$$V@2@PAX@Z
	DD	FLAT:?_Do_call@?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEXXZ
	DD	FLAT:?_Target_type@?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UBEABVtype_info@@XZ
	DD	FLAT:?_Delete_this@?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@EAEX_N@Z
	DD	FLAT:??_E?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEPAXI@Z
	DD	FLAT:?_Get@?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@EBEPBXXZ
CONST	ENDS
;	COMDAT ??_R0?AV?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@8
data$r	SEGMENT
??_R0?AV?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a'
	DB	'2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X'
	DB	'$$$V@std@@@2@X$$$V@std@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AUFrameAudio@@@8
data$r	SEGMENT
??_R0?AUFrameAudio@@@8 DD FLAT:??_7type_info@@6B@	; FrameAudio `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUFrameAudio@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@6B@
rdata$r	SEGMENT
??_R4?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@6B@ DD 00H ; std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@8
	DD	FLAT:??_R3?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@8
rdata$r	ENDS
;	COMDAT ??_R4?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@6B@
rdata$r	SEGMENT
??_R4?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@6B@ DD 00H ; std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@8
	DD	FLAT:??_R3?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@8 DD FLAT:??_R0?AV?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@8 ; std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@8
rdata$r	ENDS
;	COMDAT ??_7?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@6B@
CONST	SEGMENT
??_7?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@6B@ DD FLAT:??_R4?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@6B@ ; std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void>::`vftable'
	DD	FLAT:?_Copy@?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEPAV?$_Func_base@X$$$V@2@PAX@Z
	DD	FLAT:?_Move@?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEPAV?$_Func_base@X$$$V@2@PAX@Z
	DD	FLAT:?_Do_call@?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEXXZ
	DD	FLAT:?_Target_type@?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UBEABVtype_info@@XZ
	DD	FLAT:?_Delete_this@?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@EAEX_N@Z
	DD	FLAT:??_E?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEPAXI@Z
	DD	FLAT:?_Get@?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@EBEPBXXZ
CONST	ENDS
;	COMDAT ??_R0?AV<lambda_3b020cec0f1508adac4c896f138918cf>@@@8
data$r	SEGMENT
??_R0?AV<lambda_3b020cec0f1508adac4c896f138918cf>@@@8 DD FLAT:??_7type_info@@6B@ ; <lambda_3b020cec0f1508adac4c896f138918cf> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV<lambda_3b020cec0f1508adac4c896f138918cf>@@', 00H
data$r	ENDS
;	COMDAT ??_R3?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@8
rdata$r	SEGMENT
??_R3?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@8 DD 00H ; std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$_Func_base@X$$$V@std@@@8
data$r	SEGMENT
??_R0?AV?$_Func_base@X$$$V@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Func_base<void> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$_Func_base@X$$$V@std@@', 00H
data$r	ENDS
;	COMDAT ??_R2?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@8
rdata$r	SEGMENT
??_R2?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@8 DD FLAT:??_R1A@?0A@EA@?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@8 ; std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$_Func_base@X$$$V@std@@8
rdata$r	ENDS
;	COMDAT ??_7?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@6B@
CONST	SEGMENT
??_7?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@6B@ DD FLAT:??_R4?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@6B@ ; std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void>::`vftable'
	DD	FLAT:?_Copy@?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEPAV?$_Func_base@X$$$V@2@PAX@Z
	DD	FLAT:?_Move@?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEPAV?$_Func_base@X$$$V@2@PAX@Z
	DD	FLAT:?_Do_call@?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEXXZ
	DD	FLAT:?_Target_type@?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UBEABVtype_info@@XZ
	DD	FLAT:?_Delete_this@?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@EAEX_N@Z
	DD	FLAT:??_E?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEPAXI@Z
	DD	FLAT:?_Get@?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@EBEPBXXZ
CONST	ENDS
;	COMDAT ??_R4?$_Func_base@X$$$V@std@@6B@
rdata$r	SEGMENT
??_R4?$_Func_base@X$$$V@std@@6B@ DD 00H			; std::_Func_base<void>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$_Func_base@X$$$V@std@@@8
	DD	FLAT:??_R3?$_Func_base@X$$$V@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@8 DD FLAT:??_R0?AV?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@8 ; std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$_Func_base@X$$$V@std@@8
rdata$r	SEGMENT
??_R2?$_Func_base@X$$$V@std@@8 DD FLAT:??_R1A@?0A@EA@?$_Func_base@X$$$V@std@@8 ; std::_Func_base<void>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@8 DD FLAT:??_R0?AV?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@8 ; std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@8
rdata$r	ENDS
;	COMDAT ??_7?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@6B@
CONST	SEGMENT
??_7?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@6B@ DD FLAT:??_R4?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@6B@ ; std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void>::`vftable'
	DD	FLAT:?_Copy@?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEPAV?$_Func_base@X$$$V@2@PAX@Z
	DD	FLAT:?_Move@?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEPAV?$_Func_base@X$$$V@2@PAX@Z
	DD	FLAT:?_Do_call@?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEXXZ
	DD	FLAT:?_Target_type@?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UBEABVtype_info@@XZ
	DD	FLAT:?_Delete_this@?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@EAEX_N@Z
	DD	FLAT:??_E?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEPAXI@Z
	DD	FLAT:?_Get@?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@EBEPBXXZ
CONST	ENDS
;	COMDAT ??_R0?AV?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@8
data$r	SEGMENT
??_R0?AV?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f150'
	DB	'8adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X'
	DB	'$$$V@std@@@2@X$$$V@std@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@8 DD FLAT:??_R0?AV?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@8 ; std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@8
rdata$r	SEGMENT
??_R2?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@8 DD FLAT:??_R1A@?0A@EA@?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@8 ; std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$_Func_base@X$$$V@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@@8
data$r	SEGMENT
??_R0?AV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@@8 DD FLAT:??_7type_info@@6B@ ; <lambda_582637cdd8d6a2f689bc987be9ec55df> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@', 00H
data$r	ENDS
;	COMDAT ??_R3?$_Func_base@X$$$V@std@@8
rdata$r	SEGMENT
??_R3?$_Func_base@X$$$V@std@@8 DD 00H			; std::_Func_base<void>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$_Func_base@X$$$V@std@@8
rdata$r	ENDS
;	COMDAT ??_R4?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@6B@
rdata$r	SEGMENT
??_R4?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@6B@ DD 00H ; std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@8
	DD	FLAT:??_R3?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@8
	ORG $+2
$SG4294795313 DB 'R', 00H, 'e', 00H, 'p', 00H, 'l', 00H, 'a', 00H, 'y', 00H
	DB	'B', 00H, 'u', 00H, 'f', 00H, 'f', 00H, 'e', 00H, 'r', 00H, 'L'
	DB	00H, 'e', 00H, 'n', 00H, 'g', 00H, 't', 00H, 'h', 00H, 00H, 00H
	ORG $+2
$SG4294795312 DB 'P', 00H, 'u', 00H, 'b', 00H, 'l', 00H, 'i', 00H, 's', 00H
	DB	'h', 00H, 00H, 00H
$SG4294795305 DB '%', 00H, '0', 00H, '2', 00H, 'u', 00H, 00H, 00H
	ORG $+2
$SG4294795314 DB 'C', 00H, 'a', 00H, 'p', 00H, 't', 00H, 'u', 00H, 'r', 00H
	DB	'e', 00H, '.', 00H, 'S', 00H, 't', 00H, 'a', 00H, 'r', 00H, 't'
	DB	00H, '.', 00H, 'R', 00H, 'e', 00H, 'p', 00H, 'l', 00H, 'a', 00H
	DB	'y', 00H, 'B', 00H, 'u', 00H, 'f', 00H, 'f', 00H, 'e', 00H, 'r'
	DB	00H, '.', 00H, 'N', 00H, 'o', 00H, 'H', 00H, 'o', 00H, 't', 00H
	DB	'k', 00H, 'e', 00H, 'y', 00H, 00H, 00H
$SG4294795309 DB 'C', 00H, 'a', 00H, 'p', 00H, 't', 00H, 'u', 00H, 'r', 00H
	DB	'e', 00H, '.', 00H, 'S', 00H, 't', 00H, 'a', 00H, 'r', 00H, 't'
	DB	00H, '.', 00H, 'F', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'S', 00H
	DB	't', 00H, 'r', 00H, 'e', 00H, 'a', 00H, 'm', 00H, '.', 00H, 'S'
	DB	00H, 'a', 00H, 'v', 00H, 'e', 00H, 'R', 00H, 'e', 00H, 'p', 00H
	DB	'l', 00H, 'a', 00H, 'y', 00H, 'B', 00H, 'u', 00H, 'f', 00H, 'f'
	DB	00H, 'e', 00H, 'r', 00H, 'W', 00H, 'a', 00H, 'r', 00H, 'n', 00H
	DB	'i', 00H, 'n', 00H, 'g', 00H, 00H, 00H
	ORG $+2
$SG4294795304 DB '$', 00H, '0', 00H, 'M', 00H, 00H, 00H
$SG4294795302 DB '%', 00H, '0', 00H, '2', 00H, 'u', 00H, 00H, 00H
	ORG $+2
$SG4294795308 DB 'U', 00H, 's', 00H, 'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H
	DB	'R', 00H, 'e', 00H, 'p', 00H, 'l', 00H, 'a', 00H, 'y', 00H, 'B'
	DB	00H, 'u', 00H, 'f', 00H, 'f', 00H, 'e', 00H, 'r', 00H, ' ', 00H
	DB	'w', 00H, 'i', 00H, 't', 00H, 'h', 00H, ' ', 00H, 'a', 00H, ' '
	DB	00H, 'l', 00H, 'e', 00H, 'n', 00H, 'g', 00H, 't', 00H, 'h', 00H
	DB	' ', 00H, 'o', 00H, 'f', 00H, ' ', 00H, '%', 00H, 'd', 00H, ' '
	DB	00H, 's', 00H, 'e', 00H, 'c', 00H, 'o', 00H, 'n', 00H, 'd', 00H
	DB	's', 00H, 00H, 00H
	ORG $+2
$SG4294795311 DB 'I', 00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H
	DB	'd', 00H, ' ', 00H, 'R', 00H, 'e', 00H, 'p', 00H, 'l', 00H, 'a'
	DB	00H, 'y', 00H, 'B', 00H, 'u', 00H, 'f', 00H, 'f', 00H, 'e', 00H
	DB	'r', 00H, ' ', 00H, 'l', 00H, 'e', 00H, 'n', 00H, 'g', 00H, 't'
	DB	00H, 'h', 00H, ' ', 00H, 's', 00H, 'e', 00H, 't', 00H, ':', 00H
	DB	' ', 00H, '%', 00H, 'd', 00H, 00H, 00H
$SG4294795310 DB 'C', 00H, 'a', 00H, 'p', 00H, 't', 00H, 'u', 00H, 'r', 00H
	DB	'e', 00H, '.', 00H, 'S', 00H, 't', 00H, 'a', 00H, 'r', 00H, 't'
	DB	00H, '.', 00H, 'F', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'S', 00H
	DB	't', 00H, 'r', 00H, 'e', 00H, 'a', 00H, 'm', 00H, '.', 00H, 'W'
	DB	00H, 'a', 00H, 'r', 00H, 'n', 00H, 'i', 00H, 'n', 00H, 'g', 00H
	DB	'C', 00H, 'a', 00H, 'p', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n'
	DB	00H, 00H, 00H
$SG4294795307 DB '$', 00H, 'Y', 00H, 00H, 00H
	ORG $+2
$SG4294795306 DB '$', 00H, 'M', 00H, 00H, 00H
	ORG $+2
$SG4294795301 DB '$', 00H, '0', 00H, 'D', 00H, 00H, 00H
$SG4294795300 DB '$', 00H, 'h', 00H, 00H, 00H
	ORG $+2
$SG4294795303 DB '$', 00H, 'D', 00H, 00H, 00H
	ORG $+2
$SG4294795297 DB '$', 00H, 'm', 00H, 00H, 00H
	ORG $+2
$SG4294795296 DB '%', 00H, '0', 00H, '2', 00H, 'u', 00H, 00H, 00H
	ORG $+2
$SG4294795299 DB '%', 00H, '0', 00H, '2', 00H, 'u', 00H, 00H, 00H
	ORG $+2
$SG4294795298 DB '$', 00H, '0', 00H, 'h', 00H, 00H, 00H
$SG4294795293 DB '%', 00H, '0', 00H, '2', 00H, 'u', 00H, 00H, 00H
	ORG $+2
$SG4294795292 DB '$', 00H, '0', 00H, 's', 00H, 00H, 00H
$SG4294795295 DB '$', 00H, '0', 00H, 'm', 00H, 00H, 00H
$SG4294795294 DB '$', 00H, 's', 00H, 00H, 00H
	ORG $+2
$SG4294795289 DB '\', 00H, 'R', 00H, 'e', 00H, 'p', 00H, 'l', 00H, 'a', 00H
	DB	'y', 00H, '-', 00H, '$', 00H, 'T', 00H, '.', 00H, 'f', 00H, 'l'
	DB	00H, 'v', 00H, 00H, 00H
	ORG $+2
$SG4294795288 DB '\', 00H, '.', 00H, 'f', 00H, 'l', 00H, 'v', 00H, 00H, 00H
$SG4294795291 DB '%', 00H, 'u', 00H, '-', 00H, '%', 00H, '0', 00H, '2', 00H
	DB	'u', 00H, '-', 00H, '%', 00H, '0', 00H, '2', 00H, 'u', 00H, '-'
	DB	00H, '%', 00H, '0', 00H, '2', 00H, 'u', 00H, '%', 00H, '0', 00H
	DB	'2', 00H, 'u', 00H, '-', 00H, '%', 00H, '0', 00H, '2', 00H, 'u'
	DB	00H, 00H, 00H
	ORG $+2
$SG4294795290 DB '$', 00H, 'T', 00H, 00H, 00H
	ORG $+2
$SG4294795285 DB 'P', 00H, 'u', 00H, 'b', 00H, 'l', 00H, 'i', 00H, 's', 00H
	DB	'h', 00H, 00H, 00H
$SG4294795284 DB '/', 00H, 00H, 00H
$SG4294795287 DB 'R', 00H, 'e', 00H, 'p', 00H, 'l', 00H, 'a', 00H, 'y', 00H
	DB	'B', 00H, 'u', 00H, 'f', 00H, 'f', 00H, 'e', 00H, 'r', 00H, 'S'
	DB	00H, 'a', 00H, 'v', 00H, 'e', 00H, 'P', 00H, 'a', 00H, 't', 00H
	DB	'h', 00H, 00H, 00H
	ORG $+2
$SG4294795286 DB 'S', 00H, 'a', 00H, 'v', 00H, 'e', 00H, 'P', 00H, 'a', 00H
	DB	't', 00H, 'h', 00H, 00H, 00H
	ORG $+2
$SG4294795281 DB 'G', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 'r', 00H, 'a', 00H
	DB	'l', 00H, 00H, 00H
$SG4294795280 DB ' ', 00H, '(', 00H, 00H, 00H
	ORG $+2
$SG4294795283 DB '\', 00H, 00H, 00H
$SG4294795282 DB 'O', 00H, 'v', 00H, 'e', 00H, 'r', 00H, 'w', 00H, 'r', 00H
	DB	'i', 00H, 't', 00H, 'e', 00H, 'R', 00H, 'e', 00H, 'c', 00H, 'o'
	DB	00H, 'r', 00H, 'd', 00H, 'i', 00H, 'n', 00H, 'g', 00H, 's', 00H
	DB	00H, 00H
$SG4294795277 DB 'm', 00H, 'p', 00H, '4', 00H, 00H, 00H
$SG4294795276 DB '%', 00H, 's', 00H, '/', 00H, '%', 00H, 'u', 00H, '-', 00H
	DB	'%', 00H, '0', 00H, '2', 00H, 'u', 00H, '-', 00H, '%', 00H, '0'
	DB	00H, '2', 00H, 'u', 00H, '-', 00H, '%', 00H, '0', 00H, '2', 00H
	DB	'u', 00H, '%', 00H, '0', 00H, '2', 00H, 'u', 00H, '-', 00H, '%'
	DB	00H, '0', 00H, '2', 00H, 'u', 00H, '.', 00H, '%', 00H, 's', 00H
	DB	00H, 00H
	ORG $+2
$SG4294795279 DB '%', 00H, '0', 00H, '2', 00H, 'u', 00H, 00H, 00H
	ORG $+2
$SG4294795278 DB ')', 00H, '.', 00H, 00H, 00H
	ORG $+2
$SG4294795273 DB 'M', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG4294795272 DB 'P', 00H, 'u', 00H, 'b', 00H, 'l', 00H, 'i', 00H, 's', 00H
	DB	'h', 00H, 00H, 00H
$SG4294795275 DB 'f', 00H, 'l', 00H, 'v', 00H, 00H, 00H
$SG4294795274 DB 'm', 00H, 'p', 00H, '4', 00H, 00H, 00H
$SG4294795264 DB 'D', 00H, 'e', 00H, 'l', 00H, 'a', 00H, 'y', 00H, 00H, 00H
$SG4294795269 DB 'W', 00H, 'a', 00H, 'r', 00H, 'n', 00H, 'i', 00H, 'n', 00H
	DB	'g', 00H, ' ', 00H, '-', 00H, ' ', 00H, 'O', 00H, 'B', 00H, 'S'
	DB	00H, 'C', 00H, 'a', 00H, 'p', 00H, 't', 00H, 'u', 00H, 'r', 00H
	DB	'e', 00H, ':', 00H, ':', 00H, 'S', 00H, 't', 00H, 'a', 00H, 'r'
	DB	00H, 't', 00H, ':', 00H, ' ', 00H, 'U', 00H, 'n', 00H, 'a', 00H
	DB	'b', 00H, 'l', 00H, 'e', 00H, ' ', 00H, 't', 00H, 'o', 00H, ' '
	DB	00H, 'c', 00H, 'r', 00H, 'e', 00H, 'a', 00H, 't', 00H, 'e', 00H
	DB	' ', 00H, 't', 00H, 'h', 00H, 'e', 00H, ' ', 00H, 'f', 00H, 'i'
	DB	00H, 'l', 00H, 'e', 00H, ' ', 00H, 's', 00H, 't', 00H, 'r', 00H
	DB	'e', 00H, 'a', 00H, 'm', 00H, '.', 00H, ' ', 00H, 'C', 00H, 'h'
	DB	00H, 'e', 00H, 'c', 00H, 'k', 00H, ' ', 00H, 't', 00H, 'h', 00H
	DB	'e', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l', 00H, 'e', 00H, ' '
	DB	00H, 'p', 00H, 'a', 00H, 't', 00H, 'h', 00H, ' ', 00H, 'i', 00H
	DB	'n', 00H, ' ', 00H, 'B', 00H, 'r', 00H, 'o', 00H, 'a', 00H, 'd'
	DB	00H, 'c', 00H, 'a', 00H, 's', 00H, 't', 00H, ' ', 00H, 'S', 00H
	DB	'e', 00H, 't', 00H, 't', 00H, 'i', 00H, 'n', 00H, 'g', 00H, 's'
	DB	00H, '.', 00H, 00H, 00H
$SG4294795266 DB 'M', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG4294795268 DB 'C', 00H, 'a', 00H, 'p', 00H, 't', 00H, 'u', 00H, 'r', 00H
	DB	'e', 00H, '.', 00H, 'S', 00H, 't', 00H, 'a', 00H, 'r', 00H, 't'
	DB	00H, '.', 00H, 'F', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'S', 00H
	DB	't', 00H, 'r', 00H, 'e', 00H, 'a', 00H, 'm', 00H, '.', 00H, 'W'
	DB	00H, 'a', 00H, 'r', 00H, 'n', 00H, 'i', 00H, 'n', 00H, 'g', 00H
	DB	'C', 00H, 'a', 00H, 'p', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n'
	DB	00H, 00H, 00H
$SG4294795271 DB 'S', 00H, 'a', 00H, 'v', 00H, 'e', 00H, 'T', 00H, 'o', 00H
	DB	'F', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG4294795270 DB 'P', 00H, 'u', 00H, 'b', 00H, 'l', 00H, 'i', 00H, 's', 00H
	DB	'h', 00H, 00H, 00H
$SG4294795265 DB 'P', 00H, 'u', 00H, 'b', 00H, 'l', 00H, 'i', 00H, 's', 00H
	DB	'h', 00H, 00H, 00H
$SG4294795267 DB 'C', 00H, 'a', 00H, 'p', 00H, 't', 00H, 'u', 00H, 'r', 00H
	DB	'e', 00H, '.', 00H, 'S', 00H, 't', 00H, 'a', 00H, 'r', 00H, 't'
	DB	00H, '.', 00H, 'F', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'S', 00H
	DB	't', 00H, 'r', 00H, 'e', 00H, 'a', 00H, 'm', 00H, '.', 00H, 'W'
	DB	00H, 'a', 00H, 'r', 00H, 'n', 00H, 'i', 00H, 'n', 00H, 'g', 00H
	DB	00H, 00H
	ORG $+2
$SG4294795261 DB '\scenes.xconfig', 00H
$SG4294795260 DB 'F', 00H, 'P', 00H, 'S', 00H, 00H, 00H
$SG4294795263 DB 'P', 00H, 'u', 00H, 'b', 00H, 'l', 00H, 'i', 00H, 's', 00H
	DB	'h', 00H, 00H, 00H
$SG4294795259 DB 'V', 00H, 'i', 00H, 'd', 00H, 'e', 00H, 'o', 00H, 00H, 00H
$SG4294795262 DB '=', 00H, '=', 00H, '=', 00H, '=', 00H, '=', 00H, 'S', 00H
	DB	't', 00H, 'r', 00H, 'e', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'S'
	DB	00H, 't', 00H, 'a', 00H, 'r', 00H, 't', 00H, ' ', 00H, '(', 00H
	DB	'w', 00H, 'h', 00H, 'i', 00H, 'l', 00H, 'e', 00H, ' ', 00H, 'r'
	DB	00H, 'e', 00H, 'c', 00H, 'o', 00H, 'r', 00H, 'd', 00H, 'i', 00H
	DB	'n', 00H, 'g', 00H, ')', 00H, ':', 00H, ' ', 00H, '%', 00H, 's'
	DB	00H, '=', 00H, '=', 00H, '=', 00H, '=', 00H, '=', 00H, '=', 00H
	DB	'=', 00H, '=', 00H, '=', 00H, '=', 00H, '=', 00H, '=', 00H, '='
	DB	00H, '=', 00H, '=', 00H, '=', 00H, '=', 00H, '=', 00H, '=', 00H
	DB	'=', 00H, '=', 00H, '=', 00H, '=', 00H, '=', 00H, '=', 00H, '='
	DB	00H, '=', 00H, '=', 00H, '=', 00H, 00H, 00H
	ORG $+2
$SG4294795257 DB 'I', 00H, 'n', 00H, 'c', 00H, 'o', 00H, 'm', 00H, 'p', 00H
	DB	'a', 00H, 't', 00H, 'i', 00H, 'b', 00H, 'l', 00H, 'e', 00H, 'M'
	DB	00H, 'o', 00H, 'd', 00H, 'u', 00H, 'l', 00H, 'e', 00H, 's', 00H
	DB	00H, 00H
$SG4294795256 DB 'I', 00H, 'n', 00H, 'c', 00H, 'o', 00H, 'm', 00H, 'p', 00H
	DB	'a', 00H, 't', 00H, 'i', 00H, 'b', 00H, 'l', 00H, 'e', 00H, ' '
	DB	00H, 'p', 00H, 'a', 00H, 't', 00H, 'c', 00H, 'h', 00H, 'e', 00H
	DB	's', 00H, ' ', 00H, 'd', 00H, 'e', 00H, 't', 00H, 'e', 00H, 'c'
	DB	00H, 't', 00H, 'e', 00H, 'd', 00H, '.', 00H, 00H, 00H
	ORG $+2
$SG4294795254 DB 's', 00H, 'o', 00H, 'u', 00H, 'r', 00H, 'c', 00H, 'e', 00H
	DB	's', 00H, 00H, 00H
$SG4294795249 DB 'I', 00H, 'd', 00H, 'l', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG4294795258 DB 'I', 00H, 'n', 00H, 'c', 00H, 'o', 00H, 'm', 00H, 'p', 00H
	DB	'a', 00H, 't', 00H, 'i', 00H, 'b', 00H, 'l', 00H, 'e', 00H, ' '
	DB	00H, 'm', 00H, 'o', 00H, 'd', 00H, 'u', 00H, 'l', 00H, 'e', 00H
	DB	's', 00H, ' ', 00H, '(', 00H, 'p', 00H, 'r', 00H, 'e', 00H, '-'
	DB	00H, 'D', 00H, '3', 00H, 'D', 00H, ')', 00H, ' ', 00H, 'd', 00H
	DB	'e', 00H, 't', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'e', 00H, 'd'
	DB	00H, '.', 00H, 00H, 00H
	ORG $+2
$SG4294795253 DB 'N', 00H, 'o', 00H, 'S', 00H, 'o', 00H, 'u', 00H, 'r', 00H
	DB	'c', 00H, 'e', 00H, 's', 00H, 'F', 00H, 'o', 00H, 'u', 00H, 'n'
	DB	00H, 'd', 00H, 00H, 00H
	ORG $+2
$SG4294795252 DB 'N', 00H, 'o', 00H, 'r', 00H, 'm', 00H, 'a', 00H, 'l', 00H
	DB	00H, 00H
	ORG $+2
$SG4294795255 DB 's', 00H, 'c', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 's', 00H
	DB	00H, 00H
	ORG $+2
$SG4294795248 DB 'A', 00H, 'b', 00H, 'o', 00H, 'v', 00H, 'e', 00H, ' ', 00H
	DB	'N', 00H, 'o', 00H, 'r', 00H, 'm', 00H, 'a', 00H, 'l', 00H, 00H
	DB	00H
	ORG $+2
$SG4294795251 DB 'P', 00H, 'r', 00H, 'i', 00H, 'o', 00H, 'r', 00H, 'i', 00H
	DB	't', 00H, 'y', 00H, 00H, 00H
	ORG $+2
$SG4294795250 DB 'G', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 'r', 00H, 'a', 00H
	DB	'l', 00H, 00H, 00H
$SG4294795245 DB 'P', 00H, 'u', 00H, 'b', 00H, 'l', 00H, 'i', 00H, 's', 00H
	DB	'h', 00H, 00H, 00H
$SG4294795244 DB 'D', 00H, 'e', 00H, 'l', 00H, 'a', 00H, 'y', 00H, 00H, 00H
$SG4294795247 DB 'H', 00H, 'i', 00H, 'g', 00H, 'h', 00H, 00H, 00H
	ORG $+2
$SG4294795246 DB 'M', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG4294795241 DB 'E', 00H, 'n', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H
	DB	'P', 00H, 'r', 00H, 'o', 00H, 'j', 00H, 'e', 00H, 'c', 00H, 't'
	DB	00H, 'o', 00H, 'r', 00H, 'C', 00H, 'u', 00H, 'r', 00H, 's', 00H
	DB	'o', 00H, 'r', 00H, 00H, 00H
$SG4294795240 DB 'G', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 'r', 00H, 'a', 00H
	DB	'l', 00H, 00H, 00H
$SG4294795243 DB 'P', 00H, 'u', 00H, 'b', 00H, 'l', 00H, 'i', 00H, 's', 00H
	DB	'h', 00H, 00H, 00H
$SG4294795236 DB 'V', 00H, 'i', 00H, 'd', 00H, 'e', 00H, 'o', 00H, 00H, 00H
$SG4294795242 DB '=', 00H, '=', 00H, '=', 00H, '=', 00H, '=', 00H, 'S', 00H
	DB	't', 00H, 'r', 00H, 'e', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'S'
	DB	00H, 't', 00H, 'a', 00H, 'r', 00H, 't', 00H, ':', 00H, ' ', 00H
	DB	'%', 00H, 's', 00H, '=', 00H, '=', 00H, '=', 00H, '=', 00H, '='
	DB	00H, '=', 00H, '=', 00H, '=', 00H, '=', 00H, '=', 00H, '=', 00H
	DB	'=', 00H, '=', 00H, '=', 00H, '=', 00H, '=', 00H, '=', 00H, '='
	DB	00H, '=', 00H, '=', 00H, '=', 00H, '=', 00H, '=', 00H, '=', 00H
	DB	'=', 00H, '=', 00H, '=', 00H, '=', 00H, '=', 00H, '=', 00H, '='
	DB	00H, '=', 00H, '=', 00H, '=', 00H, '=', 00H, '=', 00H, '=', 00H
	DB	'=', 00H, '=', 00H, '=', 00H, '=', 00H, '=', 00H, '=', 00H, '='
	DB	00H, '=', 00H, '=', 00H, '=', 00H, 00H, 00H
	ORG $+2
$SG4294795237 DB 'F', 00H, 'i', 00H, 'l', 00H, 't', 00H, 'e', 00H, 'r', 00H
	DB	00H, 00H
	ORG $+2
$SG4294795239 DB 'M', 00H, 'o', 00H, 'n', 00H, 'i', 00H, 't', 00H, 'o', 00H
	DB	'r', 00H, 00H, 00H
$SG4294795238 DB 'V', 00H, 'i', 00H, 'd', 00H, 'e', 00H, 'o', 00H, 00H, 00H
$SG4294795233 DB 'B', 00H, 'a', 00H, 's', 00H, 'e', 00H, 'W', 00H, 'i', 00H
	DB	'd', 00H, 't', 00H, 'h', 00H, 00H, 00H
$SG4294795232 DB 'V', 00H, 'i', 00H, 'd', 00H, 'e', 00H, 'o', 00H, 00H, 00H
$SG4294795235 DB 'D', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 's', 00H, 'c', 00H
	DB	'a', 00H, 'l', 00H, 'e', 00H, 00H, 00H
$SG4294795234 DB 'V', 00H, 'i', 00H, 'd', 00H, 'e', 00H, 'o', 00H, 00H, 00H
$SG4294795229 DB 'U', 00H, 's', 00H, 'e', 00H, 'M', 00H, 'u', 00H, 'l', 00H
	DB	't', 00H, 'i', 00H, 't', 00H, 'h', 00H, 'r', 00H, 'e', 00H, 'a'
	DB	00H, 'd', 00H, 'e', 00H, 'd', 00H, 'O', 00H, 'p', 00H, 't', 00H
	DB	'i', 00H, 'm', 00H, 'i', 00H, 'z', 00H, 'a', 00H, 't', 00H, 'i'
	DB	00H, 'o', 00H, 'n', 00H, 's', 00H, 00H, 00H
$SG4294795228 DB 'G', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 'r', 00H, 'a', 00H
	DB	'l', 00H, 00H, 00H
$SG4294795231 DB 'B', 00H, 'a', 00H, 's', 00H, 'e', 00H, 'H', 00H, 'e', 00H
	DB	'i', 00H, 'g', 00H, 'h', 00H, 't', 00H, 00H, 00H
	ORG $+2
$SG4294795230 DB 'V', 00H, 'i', 00H, 'd', 00H, 'e', 00H, 'o', 00H, 00H, 00H
$SG4294795225 DB ' ', 00H, ' ', 00H, 'M', 00H, 'u', 00H, 'l', 00H, 't', 00H
	DB	'i', 00H, 't', 00H, 'h', 00H, 'r', 00H, 'e', 00H, 'a', 00H, 'd'
	DB	00H, 'e', 00H, 'd', 00H, ' ', 00H, 'o', 00H, 'p', 00H, 't', 00H
	DB	'i', 00H, 'm', 00H, 'i', 00H, 'z', 00H, 'a', 00H, 't', 00H, 'i'
	DB	00H, 'o', 00H, 'n', 00H, 's', 00H, ':', 00H, ' ', 00H, '%', 00H
	DB	's', 00H, 00H, 00H
$SG4294795224 DB 'E', 00H, 'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H
	DB	'r', 00H, 'S', 00H, 'k', 00H, 'i', 00H, 'p', 00H, 'T', 00H, 'h'
	DB	00H, 'r', 00H, 'e', 00H, 's', 00H, 'h', 00H, 'o', 00H, 'l', 00H
	DB	'd', 00H, 00H, 00H
	ORG $+2
$SG4294795227 DB 'O', 00H, 'n', 00H, 00H, 00H
	ORG $+2
$SG4294795226 DB 'O', 00H, 'f', 00H, 'f', 00H, 00H, 00H
$SG4294795221 DB ' ', 00H, ' ', 00H, 'O', 00H, 'u', 00H, 't', 00H, 'p', 00H
	DB	'u', 00H, 't', 00H, ' ', 00H, 'r', 00H, 'e', 00H, 's', 00H, 'o'
	DB	00H, 'l', 00H, 'u', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H
	DB	':', 00H, ' ', 00H, '%', 00H, 'u', 00H, 'x', 00H, '%', 00H, 'u'
	DB	00H, 00H, 00H
	ORG $+2
$SG4294795220 DB '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H
	DB	'-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-'
	DB	00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H
	DB	'-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-'
	DB	00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H
	DB	'-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-'
	DB	00H, '-', 00H, '-', 00H, '-', 00H, 00H, 00H
	ORG $+2
$SG4294795223 DB 'V', 00H, 'i', 00H, 'd', 00H, 'e', 00H, 'o', 00H, 00H, 00H
$SG4294795222 DB ' ', 00H, ' ', 00H, 'B', 00H, 'a', 00H, 's', 00H, 'e', 00H
	DB	' ', 00H, 'r', 00H, 'e', 00H, 's', 00H, 'o', 00H, 'l', 00H, 'u'
	DB	00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, ':', 00H, ' ', 00H
	DB	'%', 00H, 'u', 00H, 'x', 00H, '%', 00H, 'u', 00H, 00H, 00H
	ORG $+2
$SG4294795217 DB 's', 00H, 'h', 00H, 'a', 00H, 'd', 00H, 'e', 00H, 'r', 00H
	DB	's', 00H, '/', 00H, 'D', 00H, 'r', 00H, 'a', 00H, 'w', 00H, 'T'
	DB	00H, 'e', 00H, 'x', 00H, 't', 00H, 'u', 00H, 'r', 00H, 'e', 00H
	DB	'.', 00H, 'v', 00H, 'S', 00H, 'h', 00H, 'a', 00H, 'd', 00H, 'e'
	DB	00H, 'r', 00H, 00H, 00H
$SG4294795216 DB 's', 00H, 'h', 00H, 'a', 00H, 'd', 00H, 'e', 00H, 'r', 00H
	DB	's', 00H, '/', 00H, 'D', 00H, 'r', 00H, 'a', 00H, 'w', 00H, 'T'
	DB	00H, 'e', 00H, 'x', 00H, 't', 00H, 'u', 00H, 'r', 00H, 'e', 00H
	DB	'.', 00H, 'p', 00H, 'S', 00H, 'h', 00H, 'a', 00H, 'd', 00H, 'e'
	DB	00H, 'r', 00H, 00H, 00H
$SG4294795219 DB 'I', 00H, 'n', 00H, 'c', 00H, 'o', 00H, 'm', 00H, 'p', 00H
	DB	'a', 00H, 't', 00H, 'i', 00H, 'b', 00H, 'l', 00H, 'e', 00H, ' '
	DB	00H, 'm', 00H, 'o', 00H, 'd', 00H, 'u', 00H, 'l', 00H, 'e', 00H
	DB	's', 00H, ' ', 00H, '(', 00H, 'p', 00H, 'o', 00H, 's', 00H, 't'
	DB	00H, '-', 00H, 'D', 00H, '3', 00H, 'D', 00H, ')', 00H, ' ', 00H
	DB	'd', 00H, 'e', 00H, 't', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'e'
	DB	00H, 'd', 00H, '.', 00H, 00H, 00H
$SG4294795218 DB 'I', 00H, 'n', 00H, 'c', 00H, 'o', 00H, 'm', 00H, 'p', 00H
	DB	'a', 00H, 't', 00H, 'i', 00H, 'b', 00H, 'l', 00H, 'e', 00H, 'M'
	DB	00H, 'o', 00H, 'd', 00H, 'u', 00H, 'l', 00H, 'e', 00H, 's', 00H
	DB	00H, 00H
$SG4294795215 DB 's', 00H, 'h', 00H, 'a', 00H, 'd', 00H, 'e', 00H, 'r', 00H
	DB	's', 00H, '/', 00H, 'D', 00H, 'r', 00H, 'a', 00H, 'w', 00H, 'S'
	DB	00H, 'o', 00H, 'l', 00H, 'i', 00H, 'd', 00H, '.', 00H, 'v', 00H
	DB	'S', 00H, 'h', 00H, 'a', 00H, 'd', 00H, 'e', 00H, 'r', 00H, 00H
	DB	00H
$SG4294795213 DB 's', 00H, 'h', 00H, 'a', 00H, 'd', 00H, 'e', 00H, 'r', 00H
	DB	's', 00H, '/', 00H, 'S', 00H, 'c', 00H, 'e', 00H, 'n', 00H, 'e'
	DB	00H, 'T', 00H, 'r', 00H, 'a', 00H, 'n', 00H, 's', 00H, 'i', 00H
	DB	't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, '.', 00H, 'p', 00H, 'S'
	DB	00H, 'h', 00H, 'a', 00H, 'd', 00H, 'e', 00H, 'r', 00H, 00H, 00H
$SG4294795212 DB 'U', 00H, 'n', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H
	DB	' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'l', 00H, 'o', 00H, 'a'
	DB	00H, 'd', 00H, ' ', 00H, 'D', 00H, 'r', 00H, 'a', 00H, 'w', 00H
	DB	'T', 00H, 'e', 00H, 'x', 00H, 't', 00H, 'u', 00H, 'r', 00H, 'e'
	DB	00H, ' ', 00H, 's', 00H, 'h', 00H, 'a', 00H, 'd', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, 00H, 00H
	ORG $+2
$SG4294795214 DB 's', 00H, 'h', 00H, 'a', 00H, 'd', 00H, 'e', 00H, 'r', 00H
	DB	's', 00H, '/', 00H, 'D', 00H, 'r', 00H, 'a', 00H, 'w', 00H, 'S'
	DB	00H, 'o', 00H, 'l', 00H, 'i', 00H, 'd', 00H, '.', 00H, 'p', 00H
	DB	'S', 00H, 'h', 00H, 'a', 00H, 'd', 00H, 'e', 00H, 'r', 00H, 00H
	DB	00H
$SG4294795209 DB 's', 00H, 'h', 00H, 'a', 00H, 'd', 00H, 'e', 00H, 'r', 00H
	DB	's', 00H, '/', 00H, 'D', 00H, 'r', 00H, 'a', 00H, 'w', 00H, 'Y'
	DB	00H, 'U', 00H, 'V', 00H, 'T', 00H, 'e', 00H, 'x', 00H, 't', 00H
	DB	'u', 00H, 'r', 00H, 'e', 00H, '.', 00H, 'p', 00H, 'S', 00H, 'h'
	DB	00H, 'a', 00H, 'd', 00H, 'e', 00H, 'r', 00H, 00H, 00H
	ORG $+2
$SG4294795201 DB 'A', 00H, 'A', 00H, 'C', 00H, 00H, 00H
$SG4294795200 DB 'C', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'c', 00H, 00H, 00H
$SG4294795208 DB 's', 00H, 'h', 00H, 'a', 00H, 'd', 00H, 'e', 00H, 'r', 00H
	DB	's', 00H, '/', 00H, 'D', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 's'
	DB	00H, 'c', 00H, 'a', 00H, 'l', 00H, 'e', 00H, 'B', 00H, 'i', 00H
	DB	'l', 00H, 'i', 00H, 'n', 00H, 'e', 00H, 'a', 00H, 'r', 00H, '1'
	DB	00H, 'Y', 00H, 'U', 00H, 'V', 00H, '.', 00H, 'p', 00H, 'S', 00H
	DB	'h', 00H, 'a', 00H, 'd', 00H, 'e', 00H, 'r', 00H, 00H, 00H
$SG4294795202 DB 'U', 00H, 'n', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H
	DB	' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'c', 00H, 'r', 00H, 'e'
	DB	00H, 'a', 00H, 't', 00H, 'e', 00H, ' ', 00H, 'c', 00H, 'o', 00H
	DB	'p', 00H, 'y', 00H, ' ', 00H, 't', 00H, 'e', 00H, 'x', 00H, 't'
	DB	00H, 'u', 00H, 'r', 00H, 'e', 00H, 00H, 00H
$SG4294795211 DB 'U', 00H, 'n', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H
	DB	' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'l', 00H, 'o', 00H, 'a'
	DB	00H, 'd', 00H, ' ', 00H, 'D', 00H, 'r', 00H, 'a', 00H, 'w', 00H
	DB	'S', 00H, 'o', 00H, 'l', 00H, 'i', 00H, 'd', 00H, ' ', 00H, 's'
	DB	00H, 'h', 00H, 'a', 00H, 'd', 00H, 'e', 00H, 'r', 00H, 's', 00H
	DB	00H, 00H
	ORG $+2
$SG4294795198 DB 'A', 00H, 'A', 00H, 'C', 00H, 00H, 00H
$SG4294795193 DB 'i', 00H, 's', 00H, 'S', 00H, 't', 00H, 'e', 00H, 'r', 00H
	DB	'e', 00H, 'o', 00H, 00H, 00H
	ORG $+2
$SG4294795210 DB 'U', 00H, 'n', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H
	DB	' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'l', 00H, 'o', 00H, 'a'
	DB	00H, 'd', 00H, ' ', 00H, 'S', 00H, 'c', 00H, 'e', 00H, 'n', 00H
	DB	'e', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'n', 00H, 's', 00H, 'i'
	DB	00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, ' ', 00H, 's', 00H
	DB	'h', 00H, 'a', 00H, 'd', 00H, 'e', 00H, 'r', 00H, 00H, 00H
$SG4294795188 DB 'A', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, 00H, 00H
$SG4294795205 DB 's', 00H, 'h', 00H, 'a', 00H, 'd', 00H, 'e', 00H, 'r', 00H
	DB	's', 00H, '/', 00H, 'D', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 's'
	DB	00H, 'c', 00H, 'a', 00H, 'l', 00H, 'e', 00H, 'B', 00H, 'i', 00H
	DB	'l', 00H, 'i', 00H, 'n', 00H, 'e', 00H, 'a', 00H, 'r', 00H, '9'
	DB	00H, 'Y', 00H, 'U', 00H, 'V', 00H, '.', 00H, 'p', 00H, 'S', 00H
	DB	'h', 00H, 'a', 00H, 'd', 00H, 'e', 00H, 'r', 00H, 00H, 00H
$SG4294795190 DB 'A', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, ' ', 00H
	DB	'C', 00H, 'h', 00H, 'a', 00H, 'n', 00H, 'n', 00H, 'e', 00H, 'l'
	DB	00H, 's', 00H, ':', 00H, ' ', 00H, '%', 00H, 'u', 00H, ' ', 00H
	DB	'C', 00H, 'h', 00H, 00H, 00H
$SG4294795204 DB 'I', 00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H
	DB	'd', 00H, ' ', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 's'
	DB	00H, 'c', 00H, 'a', 00H, 'l', 00H, 'e', 00H, ' ', 00H, 'v', 00H
	DB	'a', 00H, 'l', 00H, 'u', 00H, 'e', 00H, ' ', 00H, '(', 00H, 'm'
	DB	00H, 'u', 00H, 's', 00H, 't', 00H, ' ', 00H, 'b', 00H, 'e', 00H
	DB	' ', 00H, 'e', 00H, 'i', 00H, 't', 00H, 'h', 00H, 'e', 00H, 'r'
	DB	00H, ' ', 00H, '1', 00H, '.', 00H, '0', 00H, ',', 00H, ' ', 00H
	DB	'1', 00H, '.', 00H, '5', 00H, ',', 00H, ' ', 00H, '2', 00H, '.'
	DB	00H, '0', 00H, ',', 00H, ' ', 00H, '2', 00H, '.', 00H, '2', 00H
	DB	'5', 00H, ',', 00H, ' ', 00H, 'o', 00H, 'r', 00H, ' ', 00H, '3'
	DB	00H, '.', 00H, '0', 00H, ')', 00H, 00H, 00H
	ORG $+2
$SG4294795194 DB 'A', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, ' ', 00H
	DB	'F', 00H, 'o', 00H, 'r', 00H, 'm', 00H, 'a', 00H, 't', 00H, ':'
	DB	00H, ' ', 00H, '%', 00H, 'u', 00H, ' ', 00H, 'H', 00H, 'z', 00H
	DB	00H, 00H
$SG4294795185 DB 'A', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, 00H, 00H
$SG4294795207 DB 's', 00H, 'h', 00H, 'a', 00H, 'd', 00H, 'e', 00H, 'r', 00H
	DB	's', 00H, '/', 00H, 'D', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 's'
	DB	00H, 'c', 00H, 'a', 00H, 'l', 00H, 'e', 00H, 'B', 00H, 'i', 00H
	DB	'c', 00H, 'u', 00H, 'b', 00H, 'i', 00H, 'c', 00H, 'Y', 00H, 'U'
	DB	00H, 'V', 00H, '.', 00H, 'p', 00H, 'S', 00H, 'h', 00H, 'a', 00H
	DB	'd', 00H, 'e', 00H, 'r', 00H, 00H, 00H
$SG4294795206 DB 's', 00H, 'h', 00H, 'a', 00H, 'd', 00H, 'e', 00H, 'r', 00H
	DB	's', 00H, '/', 00H, 'D', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 's'
	DB	00H, 'c', 00H, 'a', 00H, 'l', 00H, 'e', 00H, 'L', 00H, 'a', 00H
	DB	'n', 00H, 'c', 00H, 'z', 00H, 'o', 00H, 's', 00H, '6', 00H, 't'
	DB	00H, 'a', 00H, 'p', 00H, 'Y', 00H, 'U', 00H, 'V', 00H, '.', 00H
	DB	'p', 00H, 'S', 00H, 'h', 00H, 'a', 00H, 'd', 00H, 'e', 00H, 'r'
	DB	00H, 00H, 00H
$SG4294795203 DB 'U', 00H, 'n', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H
	DB	' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'c', 00H, 'r', 00H, 'e'
	DB	00H, 'a', 00H, 't', 00H, 'e', 00H, ' ', 00H, 's', 00H, 'h', 00H
	DB	'a', 00H, 'd', 00H, 'e', 00H, 'r', 00H, ' ', 00H, 'f', 00H, 'r'
	DB	00H, 'o', 00H, 'm', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l', 00H
	DB	'e', 00H, ' ', 00H, '%', 00H, 's', 00H, 00H, 00H
	ORG $+2
$SG4294795197 DB 'F', 00H, 'o', 00H, 'r', 00H, 'm', 00H, 'a', 00H, 't', 00H
	DB	00H, 00H
	ORG $+2
$SG4294795196 DB 'A', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, ' ', 00H
	DB	'E', 00H, 'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'i', 00H, 'n'
	DB	00H, 'g', 00H, 00H, 00H
	ORG $+2
$SG4294795199 DB 'A', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, ' ', 00H
	DB	'E', 00H, 'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'i', 00H, 'n'
	DB	00H, 'g', 00H, 00H, 00H
	ORG $+2
$SG4294795192 DB 'A', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, ' ', 00H
	DB	'E', 00H, 'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'i', 00H, 'n'
	DB	00H, 'g', 00H, 00H, 00H
	ORG $+2
$SG4294795189 DB 'I', 00H, 'n', 00H, 'p', 00H, 'u', 00H, 't', 00H, 'D', 00H
	DB	'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H, 's', 00H, 'F'
	DB	00H, 'o', 00H, 'r', 00H, 'D', 00H, 'e', 00H, 's', 00H, 'k', 00H
	DB	't', 00H, 'o', 00H, 'p', 00H, 'S', 00H, 'o', 00H, 'u', 00H, 'n'
	DB	00H, 'd', 00H, 00H, 00H
$SG4294795179 DB 'A', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, 00H, 00H
$SG4294795195 DB '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H
	DB	'-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-'
	DB	00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H
	DB	'-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-'
	DB	00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H
	DB	'-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-'
	DB	00H, '-', 00H, '-', 00H, '-', 00H, 00H, 00H
	ORG $+2
$SG4294795191 DB '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H
	DB	'-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-'
	DB	00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H
	DB	'-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-'
	DB	00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H
	DB	'-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-'
	DB	00H, '-', 00H, '-', 00H, '-', 00H, 00H, 00H
	ORG $+2
$SG4294795184 DB 'D', 00H, 'e', 00H, 'f', 00H, 'a', 00H, 'u', 00H, 'l', 00H
	DB	't', 00H, 00H, 00H
$SG4294795187 DB 'D', 00H, 'e', 00H, 'f', 00H, 'a', 00H, 'u', 00H, 'l', 00H
	DB	't', 00H, 00H, 00H
$SG4294795186 DB 'P', 00H, 'l', 00H, 'a', 00H, 'y', 00H, 'b', 00H, 'a', 00H
	DB	'c', 00H, 'k', 00H, 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c'
	DB	00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG4294795181 DB 'U', 00H, 's', 00H, 'e', 00H, ' ', 00H, 'I', 00H, 'n', 00H
	DB	'p', 00H, 'u', 00H, 't', 00H, ' ', 00H, 'D', 00H, 'e', 00H, 'v'
	DB	00H, 'i', 00H, 'c', 00H, 'e', 00H, 's', 00H, ' ', 00H, 'e', 00H
	DB	'n', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, 'd', 00H, ','
	DB	00H, ' ', 00H, 'n', 00H, 'o', 00H, 't', 00H, ' ', 00H, 'r', 00H
	DB	'e', 00H, 'c', 00H, 'o', 00H, 'r', 00H, 'd', 00H, 'i', 00H, 'n'
	DB	00H, 'g', 00H, ' ', 00H, 's', 00H, 't', 00H, 'a', 00H, 'n', 00H
	DB	'd', 00H, 'a', 00H, 'r', 00H, 'd', 00H, ' ', 00H, 'd', 00H, 'e'
	DB	00H, 's', 00H, 'k', 00H, 't', 00H, 'o', 00H, 'p', 00H, ' ', 00H
	DB	'a', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, 00H, 00H
$SG4294795180 DB 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H
	DB	00H, 00H
	ORG $+2
$SG4294795183 DB 'P', 00H, 'l', 00H, 'a', 00H, 'y', 00H, 'b', 00H, 'a', 00H
	DB	'c', 00H, 'k', 00H, ' ', 00H, 'd', 00H, 'e', 00H, 'v', 00H, 'i'
	DB	00H, 'c', 00H, 'e', 00H, ' ', 00H, '%', 00H, 's', 00H, 00H, 00H
	ORG $+2
$SG4294795182 DB 'C', 00H, 'a', 00H, 'n', 00H, 'n', 00H, 'o', 00H, 't', 00H
	DB	' ', 00H, 'i', 00H, 'n', 00H, 'i', 00H, 't', 00H, 'i', 00H, 'a'
	DB	00H, 'l', 00H, 'i', 00H, 'z', 00H, 'e', 00H, ' ', 00H, 'd', 00H
	DB	'e', 00H, 's', 00H, 'k', 00H, 't', 00H, 'o', 00H, 'p', 00H, ' '
	DB	00H, 'a', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, ' ', 00H
	DB	's', 00H, 'o', 00H, 'u', 00H, 'n', 00H, 'd', 00H, ',', 00H, ' '
	DB	00H, 'm', 00H, 'o', 00H, 'r', 00H, 'e', 00H, ' ', 00H, 'i', 00H
	DB	'n', 00H, 'f', 00H, 'o', 00H, ' ', 00H, 'i', 00H, 'n', 00H, ' '
	DB	00H, 't', 00H, 'h', 00H, 'e', 00H, ' ', 00H, 'l', 00H, 'o', 00H
	DB	'g', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l', 00H, 'e', 00H, '.'
	DB	00H, 00H, 00H
$SG4294795177 DB 'D', 00H, 'i', 00H, 's', 00H, 'a', 00H, 'b', 00H, 'l', 00H
	DB	'e', 00H, 00H, 00H
$SG4294795176 DB 'D', 00H, 'e', 00H, 'f', 00H, 'a', 00H, 'u', 00H, 'l', 00H
	DB	't', 00H, 00H, 00H
$SG4294795178 DB 'D', 00H, 'i', 00H, 's', 00H, 'a', 00H, 'b', 00H, 'l', 00H
	DB	'e', 00H, 00H, 00H
$SG4294795173 DB 'A', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, 00H, 00H
$SG4294795172 DB 'M', 00H, 'i', 00H, 'c', 00H, ' ', 00H, 't', 00H, 'i', 00H
	DB	'm', 00H, 'e', 00H, ' ', 00H, 'o', 00H, 'f', 00H, 'f', 00H, 's'
	DB	00H, 'e', 00H, 't', 00H, ':', 00H, ' ', 00H, '%', 00H, 'd', 00H
	DB	00H, 00H
$SG4294795175 DB 'M', 00H, 'i', 00H, 'c', 00H, 'r', 00H, 'o', 00H, 'p', 00H
	DB	'h', 00H, 'o', 00H, 'n', 00H, 'e', 00H, 'F', 00H, 'a', 00H, 'i'
	DB	00H, 'l', 00H, 'u', 00H, 'r', 00H, 'e', 00H, 00H, 00H
$SG4294795174 DB 'M', 00H, 'i', 00H, 'c', 00H, 'T', 00H, 'i', 00H, 'm', 00H
	DB	'e', 00H, 'O', 00H, 'f', 00H, 'f', 00H, 's', 00H, 'e', 00H, 't'
	DB	00H, 00H, 00H
$SG4294795169 DB 'B', 00H, 'i', 00H, 't', 00H, 'r', 00H, 'a', 00H, 't', 00H
	DB	'e', 00H, 00H, 00H
$SG4294795168 DB 'A', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, ' ', 00H
	DB	'E', 00H, 'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'i', 00H, 'n'
	DB	00H, 'g', 00H, 00H, 00H
	ORG $+2
$SG4294795171 DB 'D', 00H, 'i', 00H, 's', 00H, 'a', 00H, 'b', 00H, 'l', 00H
	DB	'e', 00H, 'P', 00H, 'r', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'e'
	DB	00H, 'w', 00H, 'E', 00H, 'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H
	DB	'i', 00H, 'n', 00H, 'g', 00H, 00H, 00H
	ORG $+2
$SG4294795170 DB 'G', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 'r', 00H, 'a', 00H
	DB	'l', 00H, 00H, 00H
$SG4294795165 DB 'M', 00H, 'i', 00H, 'c', 00H, 'V', 00H, 'o', 00H, 'l', 00H
	DB	'u', 00H, 'm', 00H, 'e', 00H, 00H, 00H
$SG4294795164 DB 'A', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, 00H, 00H
$SG4294795167 DB 'D', 00H, 'e', 00H, 's', 00H, 'k', 00H, 't', 00H, 'o', 00H
	DB	'p', 00H, 'V', 00H, 'o', 00H, 'l', 00H, 'u', 00H, 'm', 00H, 'e'
	DB	00H, 00H, 00H
$SG4294795166 DB 'A', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, 00H, 00H
$SG4294795161 DB 's', 00H, 'o', 00H, 'u', 00H, 'r', 00H, 'c', 00H, 'e', 00H
	DB	's', 00H, 00H, 00H
$SG4294795160 DB 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H, 00H, 00H
$SG4294795163 DB 'd', 00H, 'a', 00H, 't', 00H, 'a', 00H, 00H, 00H
	ORG $+2
$SG4294795162 DB 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H, 00H, 00H
$SG4294795157 DB 'n', 00H, 'a', 00H, 'm', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG4294795156 DB 'S', 00H, 'c', 00H, 'e', 00H, 'n', 00H, 'e', 00H, '.', 00H
	DB	'M', 00H, 'i', 00H, 's', 00H, 's', 00H, 'i', 00H, 'n', 00H, 'g'
	DB	00H, 'S', 00H, 'o', 00H, 'u', 00H, 'r', 00H, 'c', 00H, 'e', 00H
	DB	's', 00H, 00H, 00H
	ORG $+2
$SG4294795159 DB 'GlobalSource', 00H
	ORG $+3
$SG4294795158 DB 'd', 00H, 'a', 00H, 't', 00H, 'a', 00H, 00H, 00H
	ORG $+2
$SG4294795153 DB 'U', 00H, 's', 00H, 'e', 00H, 'B', 00H, 'u', 00H, 'f', 00H
	DB	'f', 00H, 'e', 00H, 'r', 00H, 'S', 00H, 'i', 00H, 'z', 00H, 'e'
	DB	00H, 00H, 00H
$SG4294795152 DB 'V', 00H, 'i', 00H, 'd', 00H, 'e', 00H, 'o', 00H, ' ', 00H
	DB	'E', 00H, 'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'i', 00H, 'n'
	DB	00H, 'g', 00H, 00H, 00H
	ORG $+2
$SG4294795155 DB 'M', 00H, 'a', 00H, 'x', 00H, 'B', 00H, 'i', 00H, 't', 00H
	DB	'r', 00H, 'a', 00H, 't', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG4294795154 DB 'V', 00H, 'i', 00H, 'd', 00H, 'e', 00H, 'o', 00H, ' ', 00H
	DB	'E', 00H, 'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'i', 00H, 'n'
	DB	00H, 'g', 00H, 00H, 00H
	ORG $+2
$SG4294795149 DB 'Q', 00H, 'u', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 't', 00H
	DB	'y', 00H, 00H, 00H
$SG4294795148 DB 'V', 00H, 'i', 00H, 'd', 00H, 'e', 00H, 'o', 00H, ' ', 00H
	DB	'E', 00H, 'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'i', 00H, 'n'
	DB	00H, 'g', 00H, 00H, 00H
	ORG $+2
$SG4294795151 DB 'B', 00H, 'u', 00H, 'f', 00H, 'f', 00H, 'e', 00H, 'r', 00H
	DB	'S', 00H, 'i', 00H, 'z', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG4294795150 DB 'V', 00H, 'i', 00H, 'd', 00H, 'e', 00H, 'o', 00H, ' ', 00H
	DB	'E', 00H, 'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'i', 00H, 'n'
	DB	00H, 'g', 00H, 00H, 00H
	ORG $+2
$SG4294795145 DB 'V', 00H, 'i', 00H, 'd', 00H, 'e', 00H, 'o', 00H, ' ', 00H
	DB	'E', 00H, 'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'i', 00H, 'n'
	DB	00H, 'g', 00H, 00H, 00H
	ORG $+2
$SG4294795144 DB 'U', 00H, 's', 00H, 'e', 00H, 'C', 00H, 'F', 00H, 'R', 00H
	DB	00H, 00H
	ORG $+2
$SG4294795147 DB 'v', 00H, 'e', 00H, 'r', 00H, 'y', 00H, 'f', 00H, 'a', 00H
	DB	's', 00H, 't', 00H, 00H, 00H
	ORG $+2
$SG4294795146 DB 'P', 00H, 'r', 00H, 'e', 00H, 's', 00H, 'e', 00H, 't', 00H
	DB	00H, 00H
	ORG $+2
$SG4294795141 DB 'G', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 'r', 00H, 'a', 00H
	DB	'l', 00H, 00H, 00H
$SG4294795140 DB 'S', 00H, 'c', 00H, 'e', 00H, 'n', 00H, 'e', 00H, ' ', 00H
	DB	'b', 00H, 'u', 00H, 'f', 00H, 'f', 00H, 'e', 00H, 'r', 00H, 'i'
	DB	00H, 'n', 00H, 'g', 00H, ' ', 00H, 't', 00H, 'i', 00H, 'm', 00H
	DB	'e', 00H, ' ', 00H, 's', 00H, 'e', 00H, 't', 00H, ' ', 00H, 't'
	DB	00H, 'o', 00H, ' ', 00H, '%', 00H, 'u', 00H, 00H, 00H
	ORG $+2
$SG4294795143 DB 'V', 00H, 'i', 00H, 'd', 00H, 'e', 00H, 'o', 00H, ' ', 00H
	DB	'E', 00H, 'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'i', 00H, 'n'
	DB	00H, 'g', 00H, 00H, 00H
	ORG $+2
$SG4294795142 DB 'S', 00H, 'c', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 'B', 00H
	DB	'u', 00H, 'f', 00H, 'f', 00H, 'e', 00H, 'r', 00H, 'i', 00H, 'n'
	DB	00H, 'g', 00H, 'T', 00H, 'i', 00H, 'm', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG4294795137 DB 'F', 00H, 'u', 00H, 'l', 00H, 'l', 00H, 'R', 00H, 'a', 00H
	DB	'n', 00H, 'g', 00H, 'e', 00H, 00H, 00H
$SG4294795136 DB 'V', 00H, 'i', 00H, 'd', 00H, 'e', 00H, 'o', 00H, 00H, 00H
$SG4294795139 DB 'F', 00H, 'o', 00H, 'r', 00H, 'c', 00H, 'e', 00H, 'M', 00H
	DB	'i', 00H, 'c', 00H, 'M', 00H, 'o', 00H, 'n', 00H, 'o', 00H, 00H
	DB	00H
	ORG $+2
$SG4294795138 DB 'A', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, 00H, 00H
$SG4294795133 DB 'Q', 00H, 'S', 00H, 'V', 00H, 00H, 00H
$SG4294795132 DB 'N', 00H, 'V', 00H, 'E', 00H, 'N', 00H, 'C', 00H, 00H, 00H
$SG4294795135 DB 'E', 00H, 'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H
	DB	'r', 00H, 00H, 00H
$SG4294795134 DB 'V', 00H, 'i', 00H, 'd', 00H, 'e', 00H, 'o', 00H, ' ', 00H
	DB	'E', 00H, 'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'i', 00H, 'n'
	DB	00H, 'g', 00H, 00H, 00H
	ORG $+2
$SG4294795129 DB 'E', 00H, 'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H
	DB	'r', 00H, '.', 00H, 'I', 00H, 'n', 00H, 'i', 00H, 't', 00H, 'F'
	DB	00H, 'a', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H, 'W', 00H
	DB	'i', 00H, 't', 00H, 'h', 00H, 'R', 00H, 'e', 00H, 'a', 00H, 's'
	DB	00H, 'o', 00H, 'n', 00H, 00H, 00H
	ORG $+2
$SG4294795128 DB 'M', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG4294795131 DB 'C', 00H, 'o', 00H, 'u', 00H, 'l', 00H, 'd', 00H, 'n', 00H
	DB	'''', 00H, 't', 00H, ' ', 00H, 'i', 00H, 'n', 00H, 'i', 00H, 't'
	DB	00H, 'i', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'z', 00H, 'e', 00H
	DB	' ', 00H, 'e', 00H, 'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e'
	DB	00H, 'r', 00H, 00H, 00H
$SG4294795130 DB 'E', 00H, 'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H
	DB	'r', 00H, '.', 00H, 'I', 00H, 'n', 00H, 'i', 00H, 't', 00H, 'F'
	DB	00H, 'a', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H, 00H, 00H
	ORG $+2
$SG4294795125 DB 'A', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, 00H, 00H
$SG4294795124 DB 'D', 00H, 'i', 00H, 's', 00H, 'a', 00H, 'b', 00H, 'l', 00H
	DB	'e', 00H, 00H, 00H
$SG4294795127 DB 'P', 00H, 'u', 00H, 'b', 00H, 'l', 00H, 'i', 00H, 's', 00H
	DB	'h', 00H, 00H, 00H
$SG4294795126 DB 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H
	DB	00H, 00H
	ORG $+2
$SG4294795121 DB 'D', 00H, 'i', 00H, 's', 00H, 'a', 00H, 'b', 00H, 'l', 00H
	DB	'e', 00H, 00H, 00H
$SG4294795120 DB 'D', 00H, 'i', 00H, 's', 00H, 'a', 00H, 'b', 00H, 'l', 00H
	DB	'e', 00H, 00H, 00H
$SG4294795123 DB 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H
	DB	00H, 00H
	ORG $+2
$SG4294795122 DB 'A', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, 00H, 00H
$SG4294795117 DB 'P', 00H, 'r', 00H, 'i', 00H, 'o', 00H, 'r', 00H, 'i', 00H
	DB	't', 00H, 'y', 00H, 00H, 00H
	ORG $+2
$SG4294795116 DB 'G', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 'r', 00H, 'a', 00H
	DB	'l', 00H, 00H, 00H
$SG4294795119 DB '=', 00H, '=', 00H, '=', 00H, '=', 00H, '=', 00H, 'S', 00H
	DB	't', 00H, 'r', 00H, 'e', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'E'
	DB	00H, 'n', 00H, 'd', 00H, ':', 00H, ' ', 00H, '%', 00H, 's', 00H
	DB	'=', 00H, '=', 00H, '=', 00H, '=', 00H, '=', 00H, '=', 00H, '='
	DB	00H, '=', 00H, '=', 00H, '=', 00H, '=', 00H, '=', 00H, '=', 00H
	DB	'=', 00H, '=', 00H, '=', 00H, '=', 00H, '=', 00H, '=', 00H, '='
	DB	00H, '=', 00H, '=', 00H, '=', 00H, '=', 00H, '=', 00H, '=', 00H
	DB	'=', 00H, '=', 00H, '=', 00H, '=', 00H, '=', 00H, '=', 00H, '='
	DB	00H, '=', 00H, '=', 00H, '=', 00H, '=', 00H, '=', 00H, '=', 00H
	DB	'=', 00H, '=', 00H, '=', 00H, '=', 00H, '=', 00H, '=', 00H, '='
	DB	00H, '=', 00H, '=', 00H, '=', 00H, 00H, 00H
	ORG $+2
$SG4294795118 DB 'N', 00H, 'o', 00H, 'r', 00H, 'm', 00H, 'a', 00H, 'l', 00H
	DB	00H, 00H
	ORG $+2
$SG4294795112 DB 'P', 00H, 'r', 00H, 'o', 00H, ' ', 00H, 'A', 00H, 'u', 00H
	DB	'd', 00H, 'i', 00H, 'o', 00H, 00H, 00H
$SG4294795113 DB 'A', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, ' ', 00H
	DB	'i', 00H, 's', 00H, ' ', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'c'
	DB	00H, 'e', 00H, 's', 00H, 's', 00H, 'i', 00H, 'n', 00H, 'g', 00H
	DB	' ', 00H, 't', 00H, 'o', 00H, 'o', 00H, ' ', 00H, 's', 00H, 'l'
	DB	00H, 'o', 00H, 'w', 00H, '.', 00H, ' ', 00H, 'F', 00H, 'r', 00H
	DB	'e', 00H, 'e', 00H, ' ', 00H, 'u', 00H, 'p', 00H, ' ', 00H, 'C'
	DB	00H, 'P', 00H, 'U', 00H, ',', 00H, ' ', 00H, 'r', 00H, 'e', 00H
	DB	'd', 00H, 'u', 00H, 'c', 00H, 'e', 00H, ' ', 00H, 't', 00H, 'h'
	DB	00H, 'e', 00H, ' ', 00H, 'n', 00H, 'u', 00H, 'm', 00H, 'b', 00H
	DB	'e', 00H, 'r', 00H, ' ', 00H, 'o', 00H, 'f', 00H, ' ', 00H, 'a'
	DB	00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, ' ', 00H, 's', 00H
	DB	'o', 00H, 'u', 00H, 'r', 00H, 'c', 00H, 'e', 00H, 's', 00H, ' '
	DB	00H, 'o', 00H, 'r', 00H, ' ', 00H, 'a', 00H, 'v', 00H, 'o', 00H
	DB	'i', 00H, 'd', 00H, ' ', 00H, 'r', 00H, 'e', 00H, 's', 00H, 'a'
	DB	00H, 'm', 00H, 'p', 00H, 'l', 00H, 'i', 00H, 'n', 00H, 'g', 00H
	DB	'.', 00H, 00H, 00H
	ORG $+2
$SG4294795115 DB 'N', 00H, 'o', 00H, 'r', 00H, 'm', 00H, 'a', 00H, 'l', 00H
	DB	00H, 00H
	ORG $+2
$SG4294795114 DB '=', 00H, '=', 00H, '=', 00H, '=', 00H, '=', 00H, 'S', 00H
	DB	't', 00H, 'r', 00H, 'e', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'E'
	DB	00H, 'n', 00H, 'd', 00H, ' ', 00H, '(', 00H, 'r', 00H, 'e', 00H
	DB	'c', 00H, 'o', 00H, 'r', 00H, 'd', 00H, 'i', 00H, 'n', 00H, 'g'
	DB	00H, ' ', 00H, 'c', 00H, 'o', 00H, 'n', 00H, 't', 00H, 'i', 00H
	DB	'n', 00H, 'u', 00H, 'e', 00H, 's', 00H, ')', 00H, ':', 00H, ' '
	DB	00H, '%', 00H, 's', 00H, '=', 00H, '=', 00H, '=', 00H, '=', 00H
	DB	'=', 00H, '=', 00H, '=', 00H, '=', 00H, '=', 00H, '=', 00H, '='
	DB	00H, '=', 00H, '=', 00H, '=', 00H, '=', 00H, '=', 00H, '=', 00H
	DB	'=', 00H, '=', 00H, '=', 00H, '=', 00H, '=', 00H, '=', 00H, '='
	DB	00H, '=', 00H, 00H, 00H
	ORG $+2
$SG4294795111 DB 'S', 00H, 't', 00H, 'r', 00H, 'e', 00H, 'a', 00H, 'm', 00H
	DB	'C', 00H, 'l', 00H, 'o', 00H, 's', 00H, 'e', 00H, 'P', 00H, 'e'
	DB	00H, 'n', 00H, 'd', 00H, 'i', 00H, 'n', 00H, 'g', 00H, 00H, 00H
PUBLIC	??0?$_Unique_ptr_base@XU?$ThreadTerminator@$0A@@@$00@std@@QAE@PAX@Z ; std::_Unique_ptr_base<void,ThreadTerminator<0>,1>::_Unique_ptr_base<void,ThreadTerminator<0>,1>
PUBLIC	??0?$_Callable_base@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@QAE@ABV<lambda_e856d28dddb7588070dd099cfda6c634>@@@Z ; std::_Callable_base<<lambda_e856d28dddb7588070dd099cfda6c634>,0>::_Callable_base<<lambda_e856d28dddb7588070dd099cfda6c634>,0>
PUBLIC	??0?$_Callable_base@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@QAE@ABV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@@Z ; std::_Callable_base<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>::_Callable_base<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>
PUBLIC	??0?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@QAE@PAX@Z ; std::unique_ptr<void,ThreadTerminator<0> >::unique_ptr<void,ThreadTerminator<0> >
PUBLIC	??$forward@AAU?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@@std@@YAAAU?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@0@AAU10@@Z ; std::forward<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0> &>
PUBLIC	??$forward@AAU?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@@std@@YAAAU?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@0@AAU10@@Z ; std::forward<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0> &>
PUBLIC	??$forward@AAU?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@@std@@YAAAU?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@0@AAU10@@Z ; std::forward<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0> &>
PUBLIC	??$forward@AAU?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@@std@@YAAAU?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@0@AAU10@@Z ; std::forward<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0> &>
PUBLIC	??$forward@AAU?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@@std@@YAAAU?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@0@AAU10@@Z ; std::forward<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0> &>
PUBLIC	??$construct@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@AAPAX@?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@QAEXPAV?$unique_ptr@XU?$ThreadTerminator@$0A@@@@1@AAPAX@Z ; std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> >::construct<std::unique_ptr<void,ThreadTerminator<0> >,void * &>
PUBLIC	??$construct@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@QAEXPAV?$unique_ptr@XU?$ThreadTerminator@$0A@@@@1@$$QAPAX@Z ; std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> >::construct<std::unique_ptr<void,ThreadTerminator<0> >,void *>
PUBLIC	??$_Test_callable@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@@std@@YA_NAAV<lambda_3648d362fc95221bbf9c4c4a922d1611>@@U?$integral_constant@_N$0A@@0@@Z ; std::_Test_callable<<lambda_3648d362fc95221bbf9c4c4a922d1611> >
PUBLIC	??$_Test_callable@V<lambda_3b020cec0f1508adac4c896f138918cf>@@@std@@YA_NAAV<lambda_3b020cec0f1508adac4c896f138918cf>@@U?$integral_constant@_N$0A@@0@@Z ; std::_Test_callable<<lambda_3b020cec0f1508adac4c896f138918cf> >
PUBLIC	??$_Test_callable@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@@std@@YA_NAAV<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@U?$integral_constant@_N$0A@@0@@Z ; std::_Test_callable<<lambda_7c9af1b141e25bc2e890d47a77a39da9> >
PUBLIC	??$?0AAV<lambda_e856d28dddb7588070dd099cfda6c634>@@@?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@QAE@AAV<lambda_e856d28dddb7588070dd099cfda6c634>@@@Z ; std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0><<lambda_e856d28dddb7588070dd099cfda6c634> &>
PUBLIC	??$_Test_callable@V<lambda_e856d28dddb7588070dd099cfda6c634>@@@std@@YA_NAAV<lambda_e856d28dddb7588070dd099cfda6c634>@@U?$integral_constant@_N$0A@@0@@Z ; std::_Test_callable<<lambda_e856d28dddb7588070dd099cfda6c634> >
PUBLIC	??$?0AAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@@?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@QAE@AAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@@Z ; std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0><<lambda_582637cdd8d6a2f689bc987be9ec55df> &>
PUBLIC	??$_Test_callable@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@@std@@YA_NAAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@U?$integral_constant@_N$0A@@0@@Z ; std::_Test_callable<<lambda_582637cdd8d6a2f689bc987be9ec55df> >
PUBLIC	?_Get@?$_Callable_base@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@QAEAAV<lambda_3648d362fc95221bbf9c4c4a922d1611>@@XZ ; std::_Callable_base<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>::_Get
PUBLIC	??0?$_Callable_base@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@QAE@ABV<lambda_3648d362fc95221bbf9c4c4a922d1611>@@@Z ; std::_Callable_base<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>::_Callable_base<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>
PUBLIC	?_Get@?$_Callable_base@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@QAEAAV<lambda_3b020cec0f1508adac4c896f138918cf>@@XZ ; std::_Callable_base<<lambda_3b020cec0f1508adac4c896f138918cf>,0>::_Get
PUBLIC	??0?$_Callable_base@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@QAE@ABV<lambda_3b020cec0f1508adac4c896f138918cf>@@@Z ; std::_Callable_base<<lambda_3b020cec0f1508adac4c896f138918cf>,0>::_Callable_base<<lambda_3b020cec0f1508adac4c896f138918cf>,0>
PUBLIC	?_Get@?$_Callable_base@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@QAEAAV<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@XZ ; std::_Callable_base<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>::_Get
PUBLIC	??0?$_Callable_base@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@QAE@ABV<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@@Z ; std::_Callable_base<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>::_Callable_base<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>
PUBLIC	?_Get@?$_Callable_base@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@QAEAAV<lambda_e856d28dddb7588070dd099cfda6c634>@@XZ ; std::_Callable_base<<lambda_e856d28dddb7588070dd099cfda6c634>,0>::_Get
PUBLIC	?_Get@?$_Callable_base@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@QAEAAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@XZ ; std::_Callable_base<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>::_Get
PUBLIC	??$?0U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@@?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@QAE@$$QAU01@@Z ; std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0><std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0> >
PUBLIC	??$forward@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@@std@@YA$$QAU?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@0@AAU10@@Z ; std::forward<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0> >
PUBLIC	??$?0AAU?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@@?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@QAE@AAU01@@Z ; std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0><std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0> &>
PUBLIC	??$?0U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@@?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@QAE@$$QAU01@@Z ; std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0><std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0> >
PUBLIC	??$forward@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@@std@@YA$$QAU?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@0@AAU10@@Z ; std::forward<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0> >
PUBLIC	??$?0AAU?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@@?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@QAE@AAU01@@Z ; std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0><std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0> &>
PUBLIC	??$?0U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@@?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@QAE@$$QAU01@@Z ; std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0><std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0> >
PUBLIC	??$forward@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@@std@@YA$$QAU?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@0@AAU10@@Z ; std::forward<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0> >
PUBLIC	??$?0AAU?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@@?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@QAE@AAU01@@Z ; std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0><std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0> &>
PUBLIC	??$?0U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@@?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@QAE@$$QAU01@@Z ; std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0><std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0> >
PUBLIC	??$forward@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@@std@@YA$$QAU?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@0@AAU10@@Z ; std::forward<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0> >
PUBLIC	??$?0AAU?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@@?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@QAE@AAU01@@Z ; std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0><std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0> &>
PUBLIC	??$?0U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@@?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@QAE@$$QAU01@@Z ; std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0><std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0> >
PUBLIC	??$forward@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@@std@@YA$$QAU?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@0@AAU10@@Z ; std::forward<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0> >
PUBLIC	??$?0AAU?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@@?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@QAE@AAU01@@Z ; std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0><std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0> &>
PUBLIC	??$_Allocate@V?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@YAPAV?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@0@IPAV10@@Z ; std::_Allocate<std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void> >
PUBLIC	??$destroy@V?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEXPAV?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@1@@Z ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void> >::destroy<std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void> >
PUBLIC	??$_ApplyX@X$$$V@?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@QAEXXZ ; std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>::_ApplyX<void>
PUBLIC	??$move@AAV?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@YA$$QAV?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@0@AAV10@@Z ; std::move<std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void> &>
PUBLIC	??$?0V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@@?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@QAE@$$QAV<lambda_3648d362fc95221bbf9c4c4a922d1611>@@@Z ; std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0><<lambda_3648d362fc95221bbf9c4c4a922d1611> >
PUBLIC	??$_Allocate@V?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@YAPAV?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@0@IPAV10@@Z ; std::_Allocate<std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void> >
PUBLIC	??$destroy@V?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEXPAV?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@1@@Z ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void> >::destroy<std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void> >
PUBLIC	??$_ApplyX@X$$$V@?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@QAEXXZ ; std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>::_ApplyX<void>
PUBLIC	??$move@AAV?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@YA$$QAV?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@0@AAV10@@Z ; std::move<std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void> &>
PUBLIC	??$?0V<lambda_3b020cec0f1508adac4c896f138918cf>@@@?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@QAE@$$QAV<lambda_3b020cec0f1508adac4c896f138918cf>@@@Z ; std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0><<lambda_3b020cec0f1508adac4c896f138918cf> >
PUBLIC	??$_Allocate@V?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@YAPAV?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@0@IPAV10@@Z ; std::_Allocate<std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void> >
PUBLIC	??$destroy@V?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEXPAV?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@1@@Z ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void> >::destroy<std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void> >
PUBLIC	??$_ApplyX@X$$$V@?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@QAEXXZ ; std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>::_ApplyX<void>
PUBLIC	??$move@AAV?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@YA$$QAV?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@0@AAV10@@Z ; std::move<std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void> &>
PUBLIC	??$?0V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@@?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@QAE@$$QAV<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@@Z ; std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0><<lambda_7c9af1b141e25bc2e890d47a77a39da9> >
PUBLIC	??$_Allocate@V?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@YAPAV?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@0@IPAV10@@Z ; std::_Allocate<std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void> >
PUBLIC	??$destroy@V?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEXPAV?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@1@@Z ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void> >::destroy<std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void> >
PUBLIC	??$_ApplyX@X$$$V@?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@QAEXXZ ; std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>::_ApplyX<void>
PUBLIC	??$move@AAV?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@YA$$QAV?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@0@AAV10@@Z ; std::move<std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void> &>
PUBLIC	??$_Allocate@V?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@YAPAV?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@0@IPAV10@@Z ; std::_Allocate<std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void> >
PUBLIC	??$destroy@V?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEXPAV?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@1@@Z ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void> >::destroy<std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void> >
PUBLIC	??$_ApplyX@X$$$V@?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@QAEXXZ ; std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>::_ApplyX<void>
PUBLIC	??$move@AAV?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@YA$$QAV?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@0@AAV10@@Z ; std::move<std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void> &>
PUBLIC	??$construct@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@AAPAX@?$allocator_traits@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@1@PAV?$unique_ptr@XU?$ThreadTerminator@$0A@@@@1@AAPAX@Z ; std::allocator_traits<std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> > >::construct<std::unique_ptr<void,ThreadTerminator<0> >,void * &>
PUBLIC	??$construct@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@?$allocator_traits@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@1@PAV?$unique_ptr@XU?$ThreadTerminator@$0A@@@@1@$$QAPAX@Z ; std::allocator_traits<std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> > >::construct<std::unique_ptr<void,ThreadTerminator<0> >,void *>
PUBLIC	??$?0V?$_Func_class@X$$$V@std@@@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@ABV?$allocator@V?$_Func_class@X$$$V@std@@@1@@Z ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void> >::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void> ><std::_Func_class<void> >
PUBLIC	??$_Test_callable@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@@std@@YA_NAAV<lambda_3648d362fc95221bbf9c4c4a922d1611>@@@Z ; std::_Test_callable<<lambda_3648d362fc95221bbf9c4c4a922d1611> >
PUBLIC	??$?0V?$_Func_class@X$$$V@std@@@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@ABV?$allocator@V?$_Func_class@X$$$V@std@@@1@@Z ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void> >::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void> ><std::_Func_class<void> >
PUBLIC	??$_Test_callable@V<lambda_3b020cec0f1508adac4c896f138918cf>@@@std@@YA_NAAV<lambda_3b020cec0f1508adac4c896f138918cf>@@@Z ; std::_Test_callable<<lambda_3b020cec0f1508adac4c896f138918cf> >
PUBLIC	??$?0V?$_Func_class@X$$$V@std@@@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@ABV?$allocator@V?$_Func_class@X$$$V@std@@@1@@Z ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void> >::allocator<std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void> ><std::_Func_class<void> >
PUBLIC	??$_Test_callable@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@@std@@YA_NAAV<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@@Z ; std::_Test_callable<<lambda_7c9af1b141e25bc2e890d47a77a39da9> >
PUBLIC	??$?0V?$_Func_class@X$$$V@std@@@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@ABV?$allocator@V?$_Func_class@X$$$V@std@@@1@@Z ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void> >::allocator<std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void> ><std::_Func_class<void> >
PUBLIC	??$?0AAV<lambda_e856d28dddb7588070dd099cfda6c634>@@@?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@QAE@AAV<lambda_e856d28dddb7588070dd099cfda6c634>@@ABV?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@1@@Z ; std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void>::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void><<lambda_e856d28dddb7588070dd099cfda6c634> &>
PUBLIC	??$_Test_callable@V<lambda_e856d28dddb7588070dd099cfda6c634>@@@std@@YA_NAAV<lambda_e856d28dddb7588070dd099cfda6c634>@@@Z ; std::_Test_callable<<lambda_e856d28dddb7588070dd099cfda6c634> >
PUBLIC	??$?0V?$_Func_class@X$$$V@std@@@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@ABV?$allocator@V?$_Func_class@X$$$V@std@@@1@@Z ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void> >::allocator<std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void> ><std::_Func_class<void> >
PUBLIC	??$?0AAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@@?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@QAE@AAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@ABV?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@1@@Z ; std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void>::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void><<lambda_582637cdd8d6a2f689bc987be9ec55df> &>
PUBLIC	??$_Test_callable@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@@std@@YA_NAAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@@Z ; std::_Test_callable<<lambda_582637cdd8d6a2f689bc987be9ec55df> >
PUBLIC	?deallocate@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEXPAV?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@2@I@Z ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void> >::deallocate
PUBLIC	??0?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void> >::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void> >
PUBLIC	?_Get@?$_Callable_base@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@QBEABV<lambda_3648d362fc95221bbf9c4c4a922d1611>@@XZ ; std::_Callable_base<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>::_Get
PUBLIC	??0?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@QAE@$$QAV01@@Z ; std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void>::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void>
PUBLIC	??0?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@QAE@AAV01@@Z ; std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void>::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void>
PUBLIC	?deallocate@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEXPAV?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@2@I@Z ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void> >::deallocate
PUBLIC	??0?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void> >::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void> >
PUBLIC	?_Get@?$_Callable_base@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@QBEABV<lambda_3b020cec0f1508adac4c896f138918cf>@@XZ ; std::_Callable_base<<lambda_3b020cec0f1508adac4c896f138918cf>,0>::_Get
PUBLIC	??0?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@QAE@$$QAV01@@Z ; std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void>::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void>
PUBLIC	??0?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@QAE@AAV01@@Z ; std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void>::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void>
PUBLIC	?deallocate@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEXPAV?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@2@I@Z ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void> >::deallocate
PUBLIC	??0?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void> >::allocator<std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void> >
PUBLIC	?_Get@?$_Callable_base@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@QBEABV<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@XZ ; std::_Callable_base<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>::_Get
PUBLIC	??0?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@QAE@$$QAV01@@Z ; std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void>::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void>
PUBLIC	??0?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@QAE@AAV01@@Z ; std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void>::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void>
PUBLIC	?deallocate@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEXPAV?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@2@I@Z ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void> >::deallocate
PUBLIC	??0?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void> >::allocator<std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void> >
PUBLIC	?_Get@?$_Callable_base@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@QBEABV<lambda_e856d28dddb7588070dd099cfda6c634>@@XZ ; std::_Callable_base<<lambda_e856d28dddb7588070dd099cfda6c634>,0>::_Get
PUBLIC	??0?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@QAE@$$QAV01@@Z ; std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void>::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void>
PUBLIC	??0?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@QAE@AAV01@@Z ; std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void>::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void>
PUBLIC	?deallocate@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEXPAV?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@2@I@Z ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void> >::deallocate
PUBLIC	??0?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void> >::allocator<std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void> >
PUBLIC	?_Get@?$_Callable_base@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@QBEABV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@XZ ; std::_Callable_base<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>::_Get
PUBLIC	??0?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@QAE@$$QAV01@@Z ; std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void>::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void>
PUBLIC	??0?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@QAE@AAV01@@Z ; std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void>::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void>
PUBLIC	??_G?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEPAXI@Z ; std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void>::`scalar deleting destructor'
PUBLIC	??_G?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEPAXI@Z ; std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void>::`scalar deleting destructor'
PUBLIC	??0?$_Func_base@X$$$V@std@@QAE@XZ		; std::_Func_base<void>::_Func_base<void>
PUBLIC	??_G?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEPAXI@Z ; std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void>::`scalar deleting destructor'
PUBLIC	??_G?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEPAXI@Z ; std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void>::`scalar deleting destructor'
PUBLIC	??_G?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEPAXI@Z ; std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void>::`scalar deleting destructor'
PUBLIC	?allocate@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEPAV?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@2@I@Z ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void> >::allocate
PUBLIC	??0?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@XZ ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void> >::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void> >
PUBLIC	?_Delete_this@?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@EAEX_N@Z ; std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void>::_Delete_this
PUBLIC	?_Get@?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@EBEPBXXZ ; std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void>::_Get
PUBLIC	?_Target_type@?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UBEABVtype_info@@XZ ; std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void>::_Target_type
PUBLIC	?_Do_call@?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEXXZ ; std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void>::_Do_call
PUBLIC	??1?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAE@XZ ; std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void>::~_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void>
PUBLIC	?_Move@?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEPAV?$_Func_base@X$$$V@2@PAX@Z ; std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void>::_Move
PUBLIC	?_Copy@?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEPAV?$_Func_base@X$$$V@2@PAX@Z ; std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void>::_Copy
PUBLIC	??0?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@QAE@$$QAV<lambda_3648d362fc95221bbf9c4c4a922d1611>@@ABV?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@1@@Z ; std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void>::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void>
PUBLIC	?allocate@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEPAV?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@2@I@Z ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void> >::allocate
PUBLIC	??0?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@XZ ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void> >::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void> >
PUBLIC	?_Delete_this@?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@EAEX_N@Z ; std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void>::_Delete_this
PUBLIC	?_Get@?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@EBEPBXXZ ; std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void>::_Get
PUBLIC	?_Target_type@?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UBEABVtype_info@@XZ ; std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void>::_Target_type
PUBLIC	?_Do_call@?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEXXZ ; std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void>::_Do_call
PUBLIC	??1?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAE@XZ ; std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void>::~_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void>
PUBLIC	?_Move@?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEPAV?$_Func_base@X$$$V@2@PAX@Z ; std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void>::_Move
PUBLIC	?_Copy@?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEPAV?$_Func_base@X$$$V@2@PAX@Z ; std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void>::_Copy
PUBLIC	??0?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@QAE@$$QAV<lambda_3b020cec0f1508adac4c896f138918cf>@@ABV?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@1@@Z ; std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void>::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void>
PUBLIC	?allocate@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEPAV?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@2@I@Z ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void> >::allocate
PUBLIC	??0?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@XZ ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void> >::allocator<std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void> >
PUBLIC	?_Delete_this@?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@EAEX_N@Z ; std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void>::_Delete_this
PUBLIC	?_Get@?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@EBEPBXXZ ; std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void>::_Get
PUBLIC	?_Target_type@?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UBEABVtype_info@@XZ ; std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void>::_Target_type
PUBLIC	?_Do_call@?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEXXZ ; std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void>::_Do_call
PUBLIC	??1?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAE@XZ ; std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void>::~_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void>
PUBLIC	?_Move@?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEPAV?$_Func_base@X$$$V@2@PAX@Z ; std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void>::_Move
PUBLIC	?_Copy@?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEPAV?$_Func_base@X$$$V@2@PAX@Z ; std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void>::_Copy
PUBLIC	??0?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@QAE@$$QAV<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@ABV?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@1@@Z ; std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void>::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void>
PUBLIC	?allocate@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEPAV?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@2@I@Z ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void> >::allocate
PUBLIC	??0?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@XZ ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void> >::allocator<std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void> >
PUBLIC	?_Delete_this@?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@EAEX_N@Z ; std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void>::_Delete_this
PUBLIC	?_Get@?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@EBEPBXXZ ; std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void>::_Get
PUBLIC	?_Target_type@?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UBEABVtype_info@@XZ ; std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void>::_Target_type
PUBLIC	?_Do_call@?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEXXZ ; std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void>::_Do_call
PUBLIC	??1?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAE@XZ ; std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void>::~_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void>
PUBLIC	?_Move@?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEPAV?$_Func_base@X$$$V@2@PAX@Z ; std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void>::_Move
PUBLIC	?_Copy@?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEPAV?$_Func_base@X$$$V@2@PAX@Z ; std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void>::_Copy
PUBLIC	?allocate@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEPAV?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@2@I@Z ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void> >::allocate
PUBLIC	??0?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@XZ ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void> >::allocator<std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void> >
PUBLIC	?_Delete_this@?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@EAEX_N@Z ; std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void>::_Delete_this
PUBLIC	?_Get@?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@EBEPBXXZ ; std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void>::_Get
PUBLIC	?_Target_type@?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UBEABVtype_info@@XZ ; std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void>::_Target_type
PUBLIC	?_Do_call@?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEXXZ ; std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void>::_Do_call
PUBLIC	??1?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAE@XZ ; std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void>::~_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void>
PUBLIC	?_Move@?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEPAV?$_Func_base@X$$$V@2@PAX@Z ; std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void>::_Move
PUBLIC	?_Copy@?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEPAV?$_Func_base@X$$$V@2@PAX@Z ; std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void>::_Copy
PUBLIC	??$construct@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@AAPAX@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@QAEXPAV?$unique_ptr@XU?$ThreadTerminator@$0A@@@@1@AAPAX@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> > >::construct<std::unique_ptr<void,ThreadTerminator<0> >,void * &>
PUBLIC	??$construct@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@QAEXPAV?$unique_ptr@XU?$ThreadTerminator@$0A@@@@1@$$QAPAX@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> > >::construct<std::unique_ptr<void,ThreadTerminator<0> >,void *>
PUBLIC	??$_Do_alloc@V?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@@?$_Func_class@X$$$V@std@@AAEX$$QAV<lambda_3648d362fc95221bbf9c4c4a922d1611>@@V?$allocator@V?$_Func_class@X$$$V@std@@@1@@Z ; std::_Func_class<void>::_Do_alloc<std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void>,<lambda_3648d362fc95221bbf9c4c4a922d1611>,std::allocator<std::_Func_class<void> > >
PUBLIC	??$_Do_alloc@V?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@V<lambda_3b020cec0f1508adac4c896f138918cf>@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@@?$_Func_class@X$$$V@std@@AAEX$$QAV<lambda_3b020cec0f1508adac4c896f138918cf>@@V?$allocator@V?$_Func_class@X$$$V@std@@@1@@Z ; std::_Func_class<void>::_Do_alloc<std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void>,<lambda_3b020cec0f1508adac4c896f138918cf>,std::allocator<std::_Func_class<void> > >
PUBLIC	??$_Do_alloc@V?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@@?$_Func_class@X$$$V@std@@AAEX$$QAV<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@V?$allocator@V?$_Func_class@X$$$V@std@@@1@@Z ; std::_Func_class<void>::_Do_alloc<std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void>,<lambda_7c9af1b141e25bc2e890d47a77a39da9>,std::allocator<std::_Func_class<void> > >
PUBLIC	??$_Do_alloc@V?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@AAV<lambda_e856d28dddb7588070dd099cfda6c634>@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@@?$_Func_class@X$$$V@std@@AAEXAAV<lambda_e856d28dddb7588070dd099cfda6c634>@@V?$allocator@V?$_Func_class@X$$$V@std@@@1@@Z ; std::_Func_class<void>::_Do_alloc<std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void>,<lambda_e856d28dddb7588070dd099cfda6c634> &,std::allocator<std::_Func_class<void> > >
PUBLIC	??$_Do_alloc@V?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@AAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@@?$_Func_class@X$$$V@std@@AAEXAAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@V?$allocator@V?$_Func_class@X$$$V@std@@@1@@Z ; std::_Func_class<void>::_Do_alloc<std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void>,<lambda_582637cdd8d6a2f689bc987be9ec55df> &,std::allocator<std::_Func_class<void> > >
PUBLIC	??0?$allocator@V?$_Func_class@X$$$V@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::_Func_class<void> >::allocator<std::_Func_class<void> >
PUBLIC	??$forward@AAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@std@@YAAAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@0@AAV10@@Z ; std::forward<std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > &>
PUBLIC	??$forward@AAPAUReplayBuffer@@@std@@YAAAPAUReplayBuffer@@AAPAU1@@Z ; std::forward<ReplayBuffer * &>
PUBLIC	??$construct@PAXPAX@?$allocator@PAX@std@@QAEXPAPAX$$QAPAX@Z ; std::allocator<void *>::construct<void *,void *>
PUBLIC	??$_Buynode@AAPAX@?$_List_buy@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAEPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@PAU21@0AAPAX@Z ; std::_List_buy<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >::_Buynode<void * &>
PUBLIC	??$_Buynode@PAX@?$_List_buy@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAEPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@PAU21@0$$QAPAX@Z ; std::_List_buy<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >::_Buynode<void *>
PUBLIC	??$_Reset_alloc@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@V?$allocator@V?$_Func_class@X$$$V@std@@@std@@@?$_Func_class@X$$$V@std@@IAEX$$QAV<lambda_3648d362fc95221bbf9c4c4a922d1611>@@V?$allocator@V?$_Func_class@X$$$V@std@@@1@@Z ; std::_Func_class<void>::_Reset_alloc<<lambda_3648d362fc95221bbf9c4c4a922d1611>,std::allocator<std::_Func_class<void> > >
PUBLIC	??$_Reset_alloc@V<lambda_3b020cec0f1508adac4c896f138918cf>@@V?$allocator@V?$_Func_class@X$$$V@std@@@std@@@?$_Func_class@X$$$V@std@@IAEX$$QAV<lambda_3b020cec0f1508adac4c896f138918cf>@@V?$allocator@V?$_Func_class@X$$$V@std@@@1@@Z ; std::_Func_class<void>::_Reset_alloc<<lambda_3b020cec0f1508adac4c896f138918cf>,std::allocator<std::_Func_class<void> > >
PUBLIC	??$_Reset_alloc@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@V?$allocator@V?$_Func_class@X$$$V@std@@@std@@@?$_Func_class@X$$$V@std@@IAEX$$QAV<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@V?$allocator@V?$_Func_class@X$$$V@std@@@1@@Z ; std::_Func_class<void>::_Reset_alloc<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,std::allocator<std::_Func_class<void> > >
PUBLIC	??$_Reset_alloc@AAV<lambda_e856d28dddb7588070dd099cfda6c634>@@V?$allocator@V?$_Func_class@X$$$V@std@@@std@@@?$_Func_class@X$$$V@std@@IAEXAAV<lambda_e856d28dddb7588070dd099cfda6c634>@@V?$allocator@V?$_Func_class@X$$$V@std@@@1@@Z ; std::_Func_class<void>::_Reset_alloc<<lambda_e856d28dddb7588070dd099cfda6c634> &,std::allocator<std::_Func_class<void> > >
PUBLIC	??$_Reset_alloc@AAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@V?$allocator@V?$_Func_class@X$$$V@std@@@std@@@?$_Func_class@X$$$V@std@@IAEXAAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@V?$allocator@V?$_Func_class@X$$$V@std@@@1@@Z ; std::_Func_class<void>::_Reset_alloc<<lambda_582637cdd8d6a2f689bc987be9ec55df> &,std::allocator<std::_Func_class<void> > >
PUBLIC	??$forward@V?$tuple@$$$V@std@@@std@@YA$$QAV?$tuple@$$$V@0@AAV10@@Z ; std::forward<std::tuple<> >
PUBLIC	??$?0V?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@?$_Tuple_val@V?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@std@@QAE@$$QAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@1@@Z ; std::_Tuple_val<std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > >::_Tuple_val<std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > ><std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > >
PUBLIC	?max_size@?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@QBEIXZ ; std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> >::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@2@@Z ; std::allocator_traits<std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> > >::max_size
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> > >::max_size
PUBLIC	?max_size@?$list@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QBEIXZ ; std::list<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >::max_size
PUBLIC	??0?$allocator@V?$_Func_class@X$$$V@std@@@std@@QAE@XZ ; std::allocator<std::_Func_class<void> >::allocator<std::_Func_class<void> >
PUBLIC	?_Get_rest@?$tuple@V?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@std@@QAEAAV?$tuple@$$$V@2@XZ ; std::tuple<std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > >::_Get_rest
PUBLIC	?_Mynode@?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > >,std::_Iterator_base0>::_Mynode
PUBLIC	?_Incsize@?$list@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAEXI@Z ; std::list<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >::_Incsize
PUBLIC	??4?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@QAEAAV01@$$QAV01@@Z ; std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> >::operator=
PUBLIC	??$?0AAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@?$_Tuple_val@AAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@std@@QAE@AAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@1@@Z ; std::_Tuple_val<std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > &>::_Tuple_val<std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > &><std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > &>
PUBLIC	??$?0AAPAUReplayBuffer@@@?$_Tuple_val@AAPAUReplayBuffer@@@std@@QAE@AAPAUReplayBuffer@@@Z ; std::_Tuple_val<ReplayBuffer * &>::_Tuple_val<ReplayBuffer * &><ReplayBuffer * &>
PUBLIC	??$construct@PAXPAX@?$allocator_traits@V?$allocator@PAX@std@@@std@@SAXAAV?$allocator@PAX@1@PAPAX$$QAPAX@Z ; std::allocator_traits<std::allocator<void *> >::construct<void *,void *>
PUBLIC	??$_Insert@AAPAX@?$list@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@U_Iterator_base0@2@@1@AAPAX@Z ; std::list<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >::_Insert<void * &>
PUBLIC	??$_Insert@PAX@?$list@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@U_Iterator_base0@2@@1@$$QAPAX@Z ; std::list<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >::_Insert<void *>
PUBLIC	??$forward@AAPAUClosableStream@@@std@@YAAAPAUClosableStream@@AAPAU1@@Z ; std::forward<ClosableStream * &>
PUBLIC	??$_Reset@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@@?$_Func_class@X$$$V@std@@IAEX$$QAV<lambda_3648d362fc95221bbf9c4c4a922d1611>@@@Z ; std::_Func_class<void>::_Reset<<lambda_3648d362fc95221bbf9c4c4a922d1611> >
PUBLIC	??$forward@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@@std@@YA$$QAV<lambda_3648d362fc95221bbf9c4c4a922d1611>@@AAV1@@Z ; std::forward<<lambda_3648d362fc95221bbf9c4c4a922d1611> >
PUBLIC	??$_Reset@V<lambda_3b020cec0f1508adac4c896f138918cf>@@@?$_Func_class@X$$$V@std@@IAEX$$QAV<lambda_3b020cec0f1508adac4c896f138918cf>@@@Z ; std::_Func_class<void>::_Reset<<lambda_3b020cec0f1508adac4c896f138918cf> >
PUBLIC	??$forward@V<lambda_3b020cec0f1508adac4c896f138918cf>@@@std@@YA$$QAV<lambda_3b020cec0f1508adac4c896f138918cf>@@AAV1@@Z ; std::forward<<lambda_3b020cec0f1508adac4c896f138918cf> >
PUBLIC	??$_Reset@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@@?$_Func_class@X$$$V@std@@IAEX$$QAV<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@@Z ; std::_Func_class<void>::_Reset<<lambda_7c9af1b141e25bc2e890d47a77a39da9> >
PUBLIC	??$forward@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@@std@@YA$$QAV<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@AAV1@@Z ; std::forward<<lambda_7c9af1b141e25bc2e890d47a77a39da9> >
PUBLIC	??$_Reset@AAV<lambda_e856d28dddb7588070dd099cfda6c634>@@@?$_Func_class@X$$$V@std@@IAEXAAV<lambda_e856d28dddb7588070dd099cfda6c634>@@@Z ; std::_Func_class<void>::_Reset<<lambda_e856d28dddb7588070dd099cfda6c634> &>
PUBLIC	??$forward@AAV<lambda_e856d28dddb7588070dd099cfda6c634>@@@std@@YAAAV<lambda_e856d28dddb7588070dd099cfda6c634>@@AAV1@@Z ; std::forward<<lambda_e856d28dddb7588070dd099cfda6c634> &>
PUBLIC	??$_Reset@AAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@@?$_Func_class@X$$$V@std@@IAEXAAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@@Z ; std::_Func_class<void>::_Reset<<lambda_582637cdd8d6a2f689bc987be9ec55df> &>
PUBLIC	??$forward@AAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@@std@@YAAAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@AAV1@@Z ; std::forward<<lambda_582637cdd8d6a2f689bc987be9ec55df> &>
PUBLIC	??$?4V?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@?$tuple@AAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@std@@QAEAAV01@$$QAV?$tuple@V?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@1@@Z ; std::tuple<std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > &>::operator=<std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > >
PUBLIC	??$?0V?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@$$$VPAPAX@?$tuple@V?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@std@@QAE@$$QAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@1@@Z ; std::tuple<std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > >::tuple<std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > ><std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> >,void * *>
PUBLIC	??$forward@V?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@std@@YA$$QAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@0@AAV10@@Z ; std::forward<std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > >
PUBLIC	??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@1@@Z ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > > >
PUBLIC	??0?$tuple@AAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@std@@QAE@AAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@1@@Z ; std::tuple<std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > &>::tuple<std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > &>
PUBLIC	??0?$tuple@AAPAUReplayBuffer@@AAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@std@@QAE@AAPAUReplayBuffer@@AAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@1@@Z ; std::tuple<ReplayBuffer * &,std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > &>::tuple<ReplayBuffer * &,std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > &>
PUBLIC	?_Unchecked_end@?$list@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@@2@XZ ; std::list<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >::_Unchecked_end
PUBLIC	??1?$_Tuple_val@V?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@std@@QAE@XZ ; std::_Tuple_val<std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > >::~_Tuple_val<std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > >
PUBLIC	??1?$tuple@V?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@std@@QAE@XZ ; std::tuple<std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > >::~tuple<std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > >
PUBLIC	??$addressof@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@std@@YAPAUargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@0@@Z@AAU1?1??23@QAEX01@Z@@Z ; std::addressof<`OBS::AddPendingStream'::`2'::args_t>
PUBLIC	??$construct@PAXPAX@?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@QAEXPAPAX$$QAPAX@Z ; std::_Wrap_alloc<std::allocator<void *> >::construct<void *,void *>
PUBLIC	??$forward@PAX@std@@YA$$QAPAXAAPAX@Z		; std::forward<void *>
PUBLIC	??$addressof@PAX@std@@YAPAPAXAAPAX@Z		; std::addressof<void *>
PUBLIC	??$forward@U?$default_delete@VVideoFileStream@@@std@@@std@@YA$$QAU?$default_delete@VVideoFileStream@@@0@AAU10@@Z ; std::forward<std::default_delete<VideoFileStream> >
PUBLIC	??$forward@U?$default_delete@VNetworkStream@@@std@@@std@@YA$$QAU?$default_delete@VNetworkStream@@@0@AAU10@@Z ; std::forward<std::default_delete<NetworkStream> >
PUBLIC	??$forward@V?$function@$$A6AXXZ@std@@@std@@YA$$QAV?$function@$$A6AXXZ@0@AAV10@@Z ; std::forward<std::function<void __cdecl(void)> >
PUBLIC	??$emplace_back@AAPAX@?$list@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAEXAAPAX@Z ; std::list<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >::emplace_back<void * &>
PUBLIC	??$emplace_back@PAX@?$list@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAEX$$QAPAX@Z ; std::list<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >::emplace_back<void *>
PUBLIC	??$make_unique@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@AAPAU4@V56@@std@@YA?AV?$unique_ptr@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@U?$default_delete@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@6@@0@AAPAUClosableStream@@$$QAV?$function@$$A6AXXZ@0@@Z ; std::make_unique<`OBS::AddPendingStream'::`2'::args_t,ClosableStream * &,std::function<void __cdecl(void)> >
PUBLIC	??$move@AAV?$function@$$A6AXXZ@std@@@std@@YA$$QAV?$function@$$A6AXXZ@0@AAV10@@Z ; std::move<std::function<void __cdecl(void)> &>
PUBLIC	??$?0V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@@?$function@$$A6AXXZ@std@@QAE@$$QAV<lambda_3648d362fc95221bbf9c4c4a922d1611>@@@Z ; std::function<void __cdecl(void)>::function<void __cdecl(void)><<lambda_3648d362fc95221bbf9c4c4a922d1611> >
PUBLIC	??$?0V<lambda_3b020cec0f1508adac4c896f138918cf>@@@?$function@$$A6AXXZ@std@@QAE@$$QAV<lambda_3b020cec0f1508adac4c896f138918cf>@@@Z ; std::function<void __cdecl(void)>::function<void __cdecl(void)><<lambda_3b020cec0f1508adac4c896f138918cf> >
PUBLIC	??$?4V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@@?$function@$$A6AXXZ@std@@QAEAAV01@$$QAV<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@@Z ; std::function<void __cdecl(void)>::operator=<<lambda_7c9af1b141e25bc2e890d47a77a39da9> >
PUBLIC	??$move@AAV?$unique_ptr@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@@std@@@std@@YA$$QAV?$unique_ptr@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@@0@AAV10@@Z ; std::move<std::unique_ptr<NetworkStream,std::default_delete<NetworkStream> > &>
PUBLIC	??$?4AAV<lambda_e856d28dddb7588070dd099cfda6c634>@@@?$function@$$A6AXXZ@std@@QAEAAV01@AAV<lambda_e856d28dddb7588070dd099cfda6c634>@@@Z ; std::function<void __cdecl(void)>::operator=<<lambda_e856d28dddb7588070dd099cfda6c634> &>
PUBLIC	??$?4AAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@@?$function@$$A6AXXZ@std@@QAEAAV01@AAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@@Z ; std::function<void __cdecl(void)>::operator=<<lambda_582637cdd8d6a2f689bc987be9ec55df> &>
PUBLIC	??$move@AAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@std@@YA$$QAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@0@AAV10@@Z ; std::move<std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > &>
PUBLIC	??$?4PAUReplayBuffer@@V?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@?$tuple@AAPAUReplayBuffer@@AAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@std@@QAEAAV01@$$QAU?$pair@PAUReplayBuffer@@V?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@1@@Z ; std::tuple<ReplayBuffer * &,std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > &>::operator=<ReplayBuffer *,std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > >
PUBLIC	??$tie@PAUReplayBuffer@@V?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@std@@YA?AV?$tuple@AAPAUReplayBuffer@@AAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@0@AAPAUReplayBuffer@@AAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@0@@Z ; std::tie<ReplayBuffer *,std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > >
PUBLIC	??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > >,std::_Iterator_base0>
PUBLIC	??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@1@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > > >::_List_const_iterator<std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > > >
PUBLIC	??0?$default_delete@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@std@@QAE@XZ ; std::default_delete<`OBS::AddPendingStream'::`2'::args_t>::default_delete<`OBS::AddPendingStream'::`2'::args_t>
PUBLIC	??0?$default_delete@UClosableStream@@@std@@QAE@XZ ; std::default_delete<ClosableStream>::default_delete<ClosableStream>
PUBLIC	?SetSize@?$List@_K@@QAEHI@Z			; List<unsigned __int64>::SetSize
PUBLIC	??1args_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@QAE@XZ ; `OBS::AddPendingStream'::`2'::args_t::~args_t
PUBLIC	??_G?$_Func_base@X$$$V@std@@UAEPAXI@Z		; std::_Func_base<void>::`scalar deleting destructor'
PUBLIC	??_Gargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@QAEPAXI@Z ; `OBS::AddPendingStream'::`2'::args_t::`scalar deleting destructor'
PUBLIC	?pointer_to@?$pointer_traits@PAUargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@std@@SAPAUargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@2@@Z@AAU3?1??45@QAEX01@Z@@Z ; std::pointer_traits<`OBS::AddPendingStream'::`2'::args_t *>::pointer_to
PUBLIC	??1?$_Func_base@X$$$V@std@@UAE@XZ		; std::_Func_base<void>::~_Func_base<void>
PUBLIC	??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > > >::operator==
PUBLIC	??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > > >::operator++
PUBLIC	??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@@std@@QBEABV?$unique_ptr@XU?$ThreadTerminator@$0A@@@@1@XZ ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > > >::operator*
PUBLIC	??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@1@@Z ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > > >::_List_iterator<std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > > >
PUBLIC	?get_deleter@?$_Unique_ptr_base@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@U?$default_delete@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@6@$00@std@@QAEAAU?$default_delete@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@2@XZ ; std::_Unique_ptr_base<`OBS::AddPendingStream'::`2'::args_t,std::default_delete<`OBS::AddPendingStream'::`2'::args_t>,1>::get_deleter
PUBLIC	??0?$_Unique_ptr_base@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@U?$default_delete@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@6@$00@std@@QAE@PAUargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@1@@Z@@Z ; std::_Unique_ptr_base<`OBS::AddPendingStream'::`2'::args_t,std::default_delete<`OBS::AddPendingStream'::`2'::args_t>,1>::_Unique_ptr_base<`OBS::AddPendingStream'::`2'::args_t,std::default_delete<`OBS::AddPendingStream'::`2'::args_t>,1>
PUBLIC	??R?$default_delete@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@std@@QBEXPAUargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@1@@Z@@Z ; std::default_delete<`OBS::AddPendingStream'::`2'::args_t>::operator()
PUBLIC	??D?$unique_ptr@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@U?$default_delete@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@6@@std@@QBEAAUargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@1@@Z@XZ ; std::unique_ptr<`OBS::AddPendingStream'::`2'::args_t,std::default_delete<`OBS::AddPendingStream'::`2'::args_t> >::operator*
PUBLIC	?get_deleter@?$_Unique_ptr_base@UClosableStream@@U?$default_delete@UClosableStream@@@std@@$00@std@@QAEAAU?$default_delete@UClosableStream@@@2@XZ ; std::_Unique_ptr_base<ClosableStream,std::default_delete<ClosableStream>,1>::get_deleter
PUBLIC	??0?$_Unique_ptr_base@UClosableStream@@U?$default_delete@UClosableStream@@@std@@$00@std@@QAE@PAUClosableStream@@@Z ; std::_Unique_ptr_base<ClosableStream,std::default_delete<ClosableStream>,1>::_Unique_ptr_base<ClosableStream,std::default_delete<ClosableStream>,1>
PUBLIC	??R?$default_delete@UClosableStream@@@std@@QBEXPAUClosableStream@@@Z ; std::default_delete<ClosableStream>::operator()
PUBLIC	?SetSize@?$List@UFrameAudio@@@@QAEHI@Z		; List<FrameAudio>::SetSize
PUBLIC	?Add@?$CircularList@_K@@QAEIAB_K@Z		; CircularList<unsigned __int64>::Add
PUBLIC	?GetRealIndex@?$CircularList@_K@@AAEII@Z	; CircularList<unsigned __int64>::GetRealIndex
PUBLIC	??0?$_Unique_ptr_base@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@$00@std@@QAE@PAVVideoFileStream@@U?$default_delete@VVideoFileStream@@@1@@Z ; std::_Unique_ptr_base<VideoFileStream,std::default_delete<VideoFileStream>,1>::_Unique_ptr_base<VideoFileStream,std::default_delete<VideoFileStream>,1>
PUBLIC	??0?$_Unique_ptr_base@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@$00@std@@QAE@PAVNetworkStream@@U?$default_delete@VNetworkStream@@@1@@Z ; std::_Unique_ptr_base<NetworkStream,std::default_delete<NetworkStream>,1>::_Unique_ptr_base<NetworkStream,std::default_delete<NetworkStream>,1>
PUBLIC	?_Resetm@?$_Func_class@X$$$V@std@@IAEX$$QAV12@@Z ; std::_Func_class<void>::_Resetm
PUBLIC	?_Empty@?$_Func_class@X$$$V@std@@QBE_NXZ	; std::_Func_class<void>::_Empty
PUBLIC	?get@?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@QBEPAXXZ ; std::unique_ptr<void,ThreadTerminator<0> >::get
PUBLIC	??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > > >::operator!=
PUBLIC	??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > > >::operator++
PUBLIC	??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@@std@@QBEAAV?$unique_ptr@XU?$ThreadTerminator@$0A@@@@1@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > > >::operator*
PUBLIC	?data@?$vector@PAXV?$allocator@PAX@std@@@std@@QAEPAPAXXZ ; std::vector<void *,std::allocator<void *> >::data
PUBLIC	?push_back@?$vector@PAXV?$allocator@PAX@std@@@std@@QAEX$$QAPAX@Z ; std::vector<void *,std::allocator<void *> >::push_back
PUBLIC	?release@?$unique_ptr@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@U?$default_delete@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@6@@std@@QAEPAUargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@2@@Z@XZ ; std::unique_ptr<`OBS::AddPendingStream'::`2'::args_t,std::default_delete<`OBS::AddPendingStream'::`2'::args_t> >::release
PUBLIC	??C?$unique_ptr@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@U?$default_delete@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@6@@std@@QBEPAUargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@1@@Z@XZ ; std::unique_ptr<`OBS::AddPendingStream'::`2'::args_t,std::default_delete<`OBS::AddPendingStream'::`2'::args_t> >::operator->
PUBLIC	??1?$unique_ptr@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@U?$default_delete@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@6@@std@@QAE@XZ ; std::unique_ptr<`OBS::AddPendingStream'::`2'::args_t,std::default_delete<`OBS::AddPendingStream'::`2'::args_t> >::~unique_ptr<`OBS::AddPendingStream'::`2'::args_t,std::default_delete<`OBS::AddPendingStream'::`2'::args_t> >
PUBLIC	??0?$unique_ptr@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@U?$default_delete@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@6@@std@@QAE@PAUargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@1@@Z@@Z ; std::unique_ptr<`OBS::AddPendingStream'::`2'::args_t,std::default_delete<`OBS::AddPendingStream'::`2'::args_t> >::unique_ptr<`OBS::AddPendingStream'::`2'::args_t,std::default_delete<`OBS::AddPendingStream'::`2'::args_t> >
PUBLIC	?reset@?$unique_ptr@UClosableStream@@U?$default_delete@UClosableStream@@@std@@@std@@QAEXPAUClosableStream@@@Z ; std::unique_ptr<ClosableStream,std::default_delete<ClosableStream> >::reset
PUBLIC	??1?$unique_ptr@UClosableStream@@U?$default_delete@UClosableStream@@@std@@@std@@QAE@XZ ; std::unique_ptr<ClosableStream,std::default_delete<ClosableStream> >::~unique_ptr<ClosableStream,std::default_delete<ClosableStream> >
PUBLIC	??0?$unique_ptr@UClosableStream@@U?$default_delete@UClosableStream@@@std@@@std@@QAE@PAUClosableStream@@@Z ; std::unique_ptr<ClosableStream,std::default_delete<ClosableStream> >::unique_ptr<ClosableStream,std::default_delete<ClosableStream> >
PUBLIC	?empty@?$list@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QBE_NXZ ; std::list<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >::empty
PUBLIC	?end@?$list@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@@2@XZ ; std::list<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >::end
PUBLIC	?begin@?$list@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@@2@XZ ; std::list<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >::begin
PUBLIC	??A?$List@UFrameAudio@@@@QAEAAUFrameAudio@@I@Z	; List<FrameAudio>::operator[]
PUBLIC	?CreateNew@?$List@UFrameAudio@@@@QAEPAUFrameAudio@@XZ ; List<FrameAudio>::CreateNew
PUBLIC	?Num@?$List@UFrameAudio@@@@QBEIXZ		; List<FrameAudio>::Num
PUBLIC	??A?$CircularList@_K@@QAEAA_KI@Z		; CircularList<unsigned __int64>::operator[]
PUBLIC	??6?$CircularList@_K@@QAEAAV0@AB_K@Z		; CircularList<unsigned __int64>::operator<<
PUBLIC	?Clear@?$CircularList@_K@@QAEXXZ		; CircularList<unsigned __int64>::Clear
PUBLIC	?Remove@?$CircularList@_K@@QAEXI@Z		; CircularList<unsigned __int64>::Remove
PUBLIC	?release@?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@QAEPAVVideoFileStream@@XZ ; std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> >::release
PUBLIC	??0?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@QAE@$$QAV01@@Z ; std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> >::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> >
PUBLIC	?release@?$unique_ptr@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@@std@@QAEPAVNetworkStream@@XZ ; std::unique_ptr<NetworkStream,std::default_delete<NetworkStream> >::release
PUBLIC	??0?$unique_ptr@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@@std@@QAE@$$QAV01@@Z ; std::unique_ptr<NetworkStream,std::default_delete<NetworkStream> >::unique_ptr<NetworkStream,std::default_delete<NetworkStream> >
PUBLIC	??R?$_Func_class@X$$$V@std@@QBEXXZ		; std::_Func_class<void>::operator()
PUBLIC	??B?$function@$$A6AXXZ@std@@QBE_NXZ		; std::function<void __cdecl(void)>::operator bool
PUBLIC	??0?$function@$$A6AXXZ@std@@QAE@$$QAV01@@Z	; std::function<void __cdecl(void)>::function<void __cdecl(void)>
PUBLIC	??0?$function@$$A6AXXZ@std@@QAE@$$T@Z		; std::function<void __cdecl(void)>::function<void __cdecl(void)>
PUBLIC	?AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z ; OBS::AddPendingStream
PUBLIC	?RequestKeyframe@OBS@@QAEXH@Z			; OBS::RequestKeyframe
PUBLIC	?MainAudioLoop@OBS@@AAEXXZ			; OBS::MainAudioLoop
PUBLIC	?EncodeAudioSegment@OBS@@AAEXPAMI_K@Z		; OBS::EncodeAudioSegment
PUBLIC	?QueryNewAudio@OBS@@AAE_NXZ			; OBS::QueryNewAudio
PUBLIC	?QueryAudioBuffers@OBS@@AAE_N_N@Z		; OBS::QueryAudioBuffers
PUBLIC	?toDB@@YAMM@Z					; toDB
PUBLIC	?CalculateVolumeLevels@@YAXPAMHMAAM1@Z		; CalculateVolumeLevels
PUBLIC	?MainAudioThread@OBS@@CGKPAX@Z			; OBS::MainAudioThread
PUBLIC	?Start@OBS@@AAEX_N0@Z				; OBS::Start
PUBLIC	?StopRecording@OBS@@AAEX_N@Z			; OBS::StopRecording
PUBLIC	?StartRecording@OBS@@AAE_N_N@Z			; OBS::StartRecording
PUBLIC	?GetExpandedRecordingDirectoryBase@@YA?AVString@@V1@@Z ; GetExpandedRecordingDirectoryBase
PUBLIC	?ExpandRecordingFilename@@YA?AVString@@V1@@Z	; ExpandRecordingFilename
PUBLIC	?StopReplayBuffer@OBS@@AAEX_N@Z			; OBS::StopReplayBuffer
PUBLIC	?StartReplayBuffer@OBS@@AAEXXZ			; OBS::StartReplayBuffer
PUBLIC	?ToggleReplayBuffer@OBS@@AAEXXZ			; OBS::ToggleReplayBuffer
PUBLIC	?ToggleCapturing@OBS@@AAEXXZ			; OBS::ToggleCapturing
PUBLIC	?ToggleRecording@OBS@@AAEXXZ			; OBS::ToggleRecording
PUBLIC	?PostStopMessage@OBS@@QAEX_N@Z			; OBS::PostStopMessage
PUBLIC	?ClearStreamInfo@OBS@@AAEXXZ			; OBS::ClearStreamInfo
PUBLIC	?FreeData@GlobalSourceInfo@@QAEXXZ		; GlobalSourceInfo::FreeData
PUBLIC	?CreateVertexShaderFromFile@@YAPAVShader@@PB_W@Z ; CreateVertexShaderFromFile
PUBLIC	?CreateRenderTarget@@YAPAVTexture@@IIW4GSColorFormat@@H@Z ; CreateRenderTarget
PUBLIC	?sqrt@@YAMM@Z					; sqrt
PUBLIC	?log10@@YAMM@Z					; log10
PUBLIC	_sqrtf
PUBLIC	_log10f
PUBLIC	?ClosePendingStreams@OBS@@QAEXXZ		; OBS::ClosePendingStreams
PUBLIC	?Stop@OBS@@AAEX_N0@Z				; OBS::Stop
PUBLIC	?AddPendingStreamThread@OBS@@QAEXPAX@Z		; OBS::AddPendingStreamThread
PUBLIC	?GetOutputFilename@@YA?AVString@@_N@Z		; GetOutputFilename
PUBLIC	?CreateFileStream@@YAPAVVideoFileStream@@VString@@@Z ; CreateFileStream
EXTRN	??_E?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEPAXI@Z:PROC ; std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void>::`vector deleting destructor'
EXTRN	??_E?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEPAXI@Z:PROC ; std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void>::`vector deleting destructor'
EXTRN	??_E?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEPAXI@Z:PROC ; std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void>::`vector deleting destructor'
EXTRN	??_E?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEPAXI@Z:PROC ; std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void>::`vector deleting destructor'
EXTRN	??_E?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEPAXI@Z:PROC ; std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void>::`vector deleting destructor'
EXTRN	??_E?$_Func_base@X$$$V@std@@UAEPAXI@Z:PROC	; std::_Func_base<void>::`vector deleting destructor'
	ALIGN	4

__Tuple_alloc DB 01H DUP (?)
	ALIGN	4

_ignore	DB	01H DUP (?)
	ALIGN	4

_allocator_arg DB 01H DUP (?)
	ALIGN	4

_piecewise_construct DB 01H DUP (?)
_BSS	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Buynode@PAX@?$_List_buy@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAEPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@PAU21@0$$QAPAX@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Buynode@PAX@?$_List_buy@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAEPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@PAU21@0$$QAPAX@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Buynode@PAX@?$_List_buy@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAEPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@PAU21@0$$QAPAX@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??$_Buynode@PAX@?$_List_buy@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAEPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@PAU21@0$$QAPAX@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Buynode@PAX@?$_List_buy@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAEPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@PAU21@0$$QAPAX@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Buynode@PAX@?$_List_buy@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAEPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@PAU21@0$$QAPAX@Z$2
__catchsym$??$_Buynode@PAX@?$_List_buy@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAEPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@PAU21@0$$QAPAX@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Buynode@PAX@?$_List_buy@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAEPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@PAU21@0$$QAPAX@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Buynode@AAPAX@?$_List_buy@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAEPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@PAU21@0AAPAX@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Buynode@AAPAX@?$_List_buy@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAEPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@PAU21@0AAPAX@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Buynode@AAPAX@?$_List_buy@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAEPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@PAU21@0AAPAX@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??$_Buynode@AAPAX@?$_List_buy@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAEPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@PAU21@0AAPAX@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Buynode@AAPAX@?$_List_buy@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAEPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@PAU21@0AAPAX@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Buynode@AAPAX@?$_List_buy@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAEPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@PAU21@0AAPAX@Z$2
__catchsym$??$_Buynode@AAPAX@?$_List_buy@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAEPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@PAU21@0AAPAX@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Buynode@AAPAX@?$_List_buy@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAEPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@PAU21@0AAPAX@Z$0
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
_ignore$initializer$ DD FLAT:??__Eignore@std@@YAXXZ
__Tuple_alloc$initializer$ DD FLAT:??__E_Tuple_alloc@std@@YAXXZ
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obscapture.cpp
;	COMDAT ?CreateFileStream@@YAPAVVideoFileStream@@VString@@@Z
_TEXT	SEGMENT
_strFileExtension$ = -20				; size = 8
$T1 = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
_strOutputFile$ = 8					; size = 8
?CreateFileStream@@YAPAVVideoFileStream@@VString@@@Z PROC ; CreateFileStream, COMDAT

; 258  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 259  :     String strFileExtension = GetPathExtension(strOutputFile);

	lea	ecx, DWORD PTR _strOutputFile$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	lea	eax, DWORD PTR _strFileExtension$[ebp]
	push	eax
	call	DWORD PTR __imp_?GetPathExtension@@YA?AVString@@PB_W@Z
	add	esp, 8

; 260  : 
; 261  :     if (strFileExtension.CompareI(TEXT("flv")))

	push	OFFSET $SG4294795275
	lea	ecx, DWORD PTR _strFileExtension$[ebp]
	call	DWORD PTR __imp_?CompareI@String@@QBEHPB_W@Z
	test	eax, eax
	je	SHORT $LN3@CreateFile

; 262  :         return CreateFLVFileStream(strOutputFile);

	lea	ecx, DWORD PTR _strOutputFile$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	call	?CreateFLVFileStream@@YAPAVVideoFileStream@@PB_W@Z ; CreateFLVFileStream
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	lea	ecx, DWORD PTR _strFileExtension$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strOutputFile$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR $T3[ebp]
	jmp	SHORT $LN4@CreateFile
	jmp	SHORT $LN2@CreateFile
$LN3@CreateFile:

; 263  :     else if (strFileExtension.CompareI(TEXT("mp4")))

	push	OFFSET $SG4294795274
	lea	ecx, DWORD PTR _strFileExtension$[ebp]
	call	DWORD PTR __imp_?CompareI@String@@QBEHPB_W@Z
	test	eax, eax
	je	SHORT $LN2@CreateFile

; 264  :         return CreateMP4FileStream(strOutputFile);

	lea	ecx, DWORD PTR _strOutputFile$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	call	?CreateMP4FileStream@@YAPAVVideoFileStream@@PB_W@Z ; CreateMP4FileStream
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	lea	ecx, DWORD PTR _strFileExtension$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strOutputFile$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR $T2[ebp]
	jmp	SHORT $LN4@CreateFile
$LN2@CreateFile:

; 265  : 
; 266  :     return nullptr;

	mov	DWORD PTR $T1[ebp], 0
	lea	ecx, DWORD PTR _strFileExtension$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strOutputFile$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR $T1[ebp]
$LN4@CreateFile:

; 267  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CreateFileStream@@YAPAVVideoFileStream@@VString@@@Z ENDP ; CreateFileStream
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obscapture.cpp
;	COMDAT ?GetOutputFilename@@YA?AVString@@_N@Z
_TEXT	SEGMENT
$T1 = -692						; size = 8
$T2 = -684						; size = 8
$T3 = -676						; size = 8
$T4 = -668						; size = 8
$T5 = -660						; size = 8
_strFileWithoutExtension$6 = -652			; size = 8
_strFileName$7 = -644					; size = 8
_file$8 = -636						; size = 8
_strDirectory$9 = -628					; size = 8
_path$ = -620						; size = 8
_strFileExtension$10 = -612				; size = 8
_strNewFilePath$11 = -604				; size = 8
tv67 = -596						; size = 4
tv128 = -592						; size = 4
tv78 = -588						; size = 4
_extension$12 = -584					; size = 8
tv82 = -576						; size = 4
_curFile$13 = -572					; size = 4
_hFind$ = -568						; size = 4
_bOverwrite$ = -561					; size = 1
_strOutputFile$ = -560					; size = 8
_bUseDateTimeName$ = -549				; size = 1
_st$14 = -548						; size = 16
_ofd$ = -532						; size = 528
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_replayBuffer$ = 12					; size = 1
?GetOutputFilename@@YA?AVString@@_N@Z PROC		; GetOutputFilename, COMDAT

; 192  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 692				; 000002b4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 193  :     String path = OSGetDefaultVideoSavePath(replayBuffer ? L"\\Replay-$T.flv" : L"\\.flv");

	movzx	eax, BYTE PTR _replayBuffer$[ebp]
	test	eax, eax
	je	SHORT $LN14@GetOutputF
	mov	DWORD PTR tv67[ebp], OFFSET $SG4294795289
	jmp	SHORT $LN15@GetOutputF
$LN14@GetOutputF:
	mov	DWORD PTR tv67[ebp], OFFSET $SG4294795288
$LN15@GetOutputF:
	mov	ecx, DWORD PTR tv67[ebp]
	push	ecx
	lea	edx, DWORD PTR _path$[ebp]
	push	edx
	call	DWORD PTR __imp_?OSGetDefaultVideoSavePath@@YG?AVString@@PB_W@Z

; 194  :     String strOutputFile = AppConfig->GetString(TEXT("Publish"), replayBuffer ? L"ReplayBufferSavePath" : L"SavePath", path.IsValid() ? path.Array() : nullptr);

	lea	ecx, DWORD PTR _path$[ebp]
	call	DWORD PTR __imp_?IsValid@String@@QBEHXZ
	test	eax, eax
	je	SHORT $LN16@GetOutputF
	lea	ecx, DWORD PTR _path$[ebp]
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	mov	DWORD PTR tv78[ebp], eax
	jmp	SHORT $LN17@GetOutputF
$LN16@GetOutputF:
	mov	DWORD PTR tv78[ebp], 0
$LN17@GetOutputF:
	movzx	eax, BYTE PTR _replayBuffer$[ebp]
	test	eax, eax
	je	SHORT $LN18@GetOutputF
	mov	DWORD PTR tv82[ebp], OFFSET $SG4294795287
	jmp	SHORT $LN19@GetOutputF
$LN18@GetOutputF:
	mov	DWORD PTR tv82[ebp], OFFSET $SG4294795286
$LN19@GetOutputF:
	mov	ecx, DWORD PTR tv78[ebp]
	push	ecx
	mov	edx, DWORD PTR tv82[ebp]
	push	edx
	push	OFFSET $SG4294795285
	lea	eax, DWORD PTR _strOutputFile$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetString@ConfigFile@@QAE?AVString@@PB_W00@Z

; 195  :     strOutputFile.FindReplace(TEXT("\\"), TEXT("/"));

	push	OFFSET $SG4294795284
	push	OFFSET $SG4294795283
	lea	ecx, DWORD PTR _strOutputFile$[ebp]
	call	DWORD PTR __imp_?FindReplace@String@@QAEAAV1@PB_W0@Z

; 196  : 
; 197  :     OSFindData ofd;
; 198  :     HANDLE hFind = NULL;

	mov	DWORD PTR _hFind$[ebp], 0

; 199  :     bool bUseDateTimeName = true;

	mov	BYTE PTR _bUseDateTimeName$[ebp], 1

; 200  :     bool bOverwrite = GlobalConfig->GetInt(L"General", L"OverwriteRecordings", false) != 0;

	push	0
	push	OFFSET $SG4294795282
	push	OFFSET $SG4294795281
	mov	ecx, DWORD PTR ?GlobalConfig@@3PAVConfigFile@@A ; GlobalConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	test	eax, eax
	je	SHORT $LN20@GetOutputF
	mov	DWORD PTR tv128[ebp], 1
	jmp	SHORT $LN21@GetOutputF
$LN20@GetOutputF:
	mov	DWORD PTR tv128[ebp], 0
$LN21@GetOutputF:
	mov	cl, BYTE PTR tv128[ebp]
	mov	BYTE PTR _bOverwrite$[ebp], cl

; 201  :     
; 202  :     strOutputFile = ExpandRecordingFilename(strOutputFile);

	sub	esp, 8
	mov	ecx, esp
	lea	edx, DWORD PTR _strOutputFile$[ebp]
	push	edx
	call	DWORD PTR __imp_??0String@@QAE@ABV0@@Z
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	call	?ExpandRecordingFilename@@YA?AVString@@V1@@Z ; ExpandRecordingFilename
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _strOutputFile$[ebp]
	call	DWORD PTR __imp_??4String@@QAEAAV0@ABV0@@Z
	lea	ecx, DWORD PTR $T3[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 203  : 
; 204  :     CreatePath(GetPathDirectory(strOutputFile));

	lea	ecx, DWORD PTR _strOutputFile$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	lea	ecx, DWORD PTR $T5[ebp]
	push	ecx
	call	DWORD PTR __imp_?GetPathDirectory@@YA?AVString@@PB_W@Z
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	call	DWORD PTR __imp_?CreatePath@@YAHPB_W@Z
	add	esp, 4
	lea	ecx, DWORD PTR $T5[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 205  : 
; 206  :     if (!bOverwrite && (hFind = OSFindFirstFile(strOutputFile, ofd)))

	movzx	edx, BYTE PTR _bOverwrite$[ebp]
	test	edx, edx
	jne	$LN11@GetOutputF
	lea	eax, DWORD PTR _ofd$[ebp]
	push	eax
	lea	ecx, DWORD PTR _strOutputFile$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	call	DWORD PTR __imp_?OSFindFirstFile@@YGPAXPB_WAAUOSFindData@@@Z
	mov	DWORD PTR _hFind$[ebp], eax
	cmp	DWORD PTR _hFind$[ebp], 0
	je	$LN11@GetOutputF

; 207  :     {
; 208  :         String strFileExtension = GetPathExtension(strOutputFile);

	lea	ecx, DWORD PTR _strOutputFile$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	lea	ecx, DWORD PTR _strFileExtension$10[ebp]
	push	ecx
	call	DWORD PTR __imp_?GetPathExtension@@YA?AVString@@PB_W@Z
	add	esp, 8

; 209  :         String strFileWithoutExtension = GetPathWithoutExtension(strOutputFile);

	lea	ecx, DWORD PTR _strOutputFile$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	lea	edx, DWORD PTR _strFileWithoutExtension$6[ebp]
	push	edx
	call	DWORD PTR __imp_?GetPathWithoutExtension@@YA?AVString@@PB_W@Z
	add	esp, 8

; 210  : 
; 211  :         if (strFileExtension.IsValid() && !ofd.bDirectory)

	lea	ecx, DWORD PTR _strFileExtension$10[ebp]
	call	DWORD PTR __imp_?IsValid@String@@QBEHXZ
	test	eax, eax
	je	$LN10@GetOutputF
	cmp	DWORD PTR _ofd$[ebp+520], 0
	jne	$LN10@GetOutputF

; 212  :         {
; 213  :             String strNewFilePath;

	lea	ecx, DWORD PTR _strNewFilePath$11[ebp]
	call	DWORD PTR __imp_??0String@@QAE@XZ

; 214  :             UINT curFile = 0;

	mov	DWORD PTR _curFile$13[ebp], 0
$LN9@GetOutputF:

; 215  : 
; 216  :             do
; 217  :             {
; 218  :                 strNewFilePath.Clear() << strFileWithoutExtension << TEXT(" (") << FormattedString(TEXT("%02u"), ++curFile) << TEXT(").") << strFileExtension;

	mov	eax, DWORD PTR _curFile$13[ebp]
	add	eax, 1
	mov	DWORD PTR _curFile$13[ebp], eax
	lea	ecx, DWORD PTR _strFileExtension$10[ebp]
	push	ecx
	push	OFFSET $SG4294795278
	mov	edx, DWORD PTR _curFile$13[ebp]
	push	edx
	push	OFFSET $SG4294795279
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	DWORD PTR __imp_?FormattedString@@YA?AVString@@PB_WZZ
	add	esp, 12					; 0000000cH
	push	eax
	push	OFFSET $SG4294795280
	lea	ecx, DWORD PTR _strFileWithoutExtension$6[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strNewFilePath$11[ebp]
	call	DWORD PTR __imp_?Clear@String@@QAEAAV1@XZ
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@ABV0@@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@ABV0@@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@ABV0@@Z
	lea	ecx, DWORD PTR $T1[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 219  :             } while (OSFileExists(strNewFilePath));

	lea	ecx, DWORD PTR _strNewFilePath$11[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	call	DWORD PTR __imp_?OSFileExists@@YGHPB_W@Z
	test	eax, eax
	jne	$LN9@GetOutputF

; 220  : 
; 221  :             strOutputFile = strNewFilePath;

	lea	edx, DWORD PTR _strNewFilePath$11[ebp]
	push	edx
	lea	ecx, DWORD PTR _strOutputFile$[ebp]
	call	DWORD PTR __imp_??4String@@QAEAAV0@ABV0@@Z

; 222  : 
; 223  :             bUseDateTimeName = false;

	mov	BYTE PTR _bUseDateTimeName$[ebp], 0

; 224  :         }

	lea	ecx, DWORD PTR _strNewFilePath$11[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
$LN10@GetOutputF:

; 225  : 
; 226  :         if (ofd.bDirectory)

	cmp	DWORD PTR _ofd$[ebp+520], 0
	je	SHORT $LN6@GetOutputF

; 227  :             strOutputFile.AppendChar('/');

	push	47					; 0000002fH
	lea	ecx, DWORD PTR _strOutputFile$[ebp]
	call	DWORD PTR __imp_?AppendChar@String@@QAEAAV1@_W@Z
$LN6@GetOutputF:

; 228  : 
; 229  :         OSFindClose(hFind);

	mov	eax, DWORD PTR _hFind$[ebp]
	push	eax
	call	DWORD PTR __imp_?OSFindClose@@YGXPAX@Z

; 230  :     }

	lea	ecx, DWORD PTR _strFileWithoutExtension$6[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strFileExtension$10[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
$LN11@GetOutputF:

; 231  : 
; 232  :     if (bUseDateTimeName)

	movzx	ecx, BYTE PTR _bUseDateTimeName$[ebp]
	test	ecx, ecx
	je	$LN5@GetOutputF

; 233  :     {
; 234  :         String strFileName = GetPathFileName(strOutputFile);

	push	0
	lea	ecx, DWORD PTR _strOutputFile$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	lea	edx, DWORD PTR _strFileName$7[ebp]
	push	edx
	call	DWORD PTR __imp_?GetPathFileName@@YA?AVString@@PB_WH@Z
	add	esp, 12					; 0000000cH

; 235  : 
; 236  :         if (!strFileName.IsValid() || !IsSafeFilename(strFileName))

	lea	ecx, DWORD PTR _strFileName$7[ebp]
	call	DWORD PTR __imp_?IsValid@String@@QBEHXZ
	test	eax, eax
	je	SHORT $LN3@GetOutputF
	lea	ecx, DWORD PTR _strFileName$7[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	call	DWORD PTR __imp_?IsSafeFilename@@YAHPB_W@Z
	add	esp, 4
	test	eax, eax
	jne	$LN4@GetOutputF
$LN3@GetOutputF:

; 237  :         {
; 238  :             SYSTEMTIME st;
; 239  :             GetLocalTime(&st);

	lea	eax, DWORD PTR _st$14[ebp]
	push	eax
	call	DWORD PTR __imp__GetLocalTime@4

; 240  : 
; 241  :             String strDirectory = GetPathDirectory(strOutputFile);

	lea	ecx, DWORD PTR _strOutputFile$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	lea	ecx, DWORD PTR _strDirectory$9[ebp]
	push	ecx
	call	DWORD PTR __imp_?GetPathDirectory@@YA?AVString@@PB_W@Z
	add	esp, 8

; 242  :             String file = strOutputFile.Right(strOutputFile.Length() - strDirectory.Length());

	lea	ecx, DWORD PTR _strOutputFile$[ebp]
	call	DWORD PTR __imp_?Length@String@@QBEIXZ
	mov	esi, eax
	lea	ecx, DWORD PTR _strDirectory$9[ebp]
	call	DWORD PTR __imp_?Length@String@@QBEIXZ
	sub	esi, eax
	push	esi
	lea	edx, DWORD PTR _file$8[ebp]
	push	edx
	lea	ecx, DWORD PTR _strOutputFile$[ebp]
	call	DWORD PTR __imp_?Right@String@@QAE?AV1@I@Z

; 243  :             String extension;

	lea	ecx, DWORD PTR _extension$12[ebp]
	call	DWORD PTR __imp_??0String@@QAE@XZ

; 244  : 
; 245  :             if (!file.IsEmpty())

	lea	ecx, DWORD PTR _file$8[ebp]
	call	DWORD PTR __imp_?IsEmpty@String@@QBEHXZ
	test	eax, eax
	jne	SHORT $LN2@GetOutputF

; 246  :                 extension = GetPathExtension(file.Array());

	lea	ecx, DWORD PTR _file$8[ebp]
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	DWORD PTR __imp_?GetPathExtension@@YA?AVString@@PB_W@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _extension$12[ebp]
	call	DWORD PTR __imp_??4String@@QAEAAV0@ABV0@@Z
	lea	ecx, DWORD PTR $T2[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
$LN2@GetOutputF:

; 247  : 
; 248  :             if (extension.IsEmpty())

	lea	ecx, DWORD PTR _extension$12[ebp]
	call	DWORD PTR __imp_?IsEmpty@String@@QBEHXZ
	test	eax, eax
	je	SHORT $LN1@GetOutputF

; 249  :                 extension = TEXT("mp4");

	push	OFFSET $SG4294795277
	lea	ecx, DWORD PTR _extension$12[ebp]
	call	DWORD PTR __imp_??4String@@QAEAAV0@PB_W@Z
$LN1@GetOutputF:

; 250  :             strOutputFile = FormattedString(TEXT("%s/%u-%02u-%02u-%02u%02u-%02u.%s"), strDirectory.Array(), st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond, extension.Array());

	lea	ecx, DWORD PTR _extension$12[ebp]
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	movzx	ecx, WORD PTR _st$14[ebp+12]
	push	ecx
	movzx	edx, WORD PTR _st$14[ebp+10]
	push	edx
	movzx	eax, WORD PTR _st$14[ebp+8]
	push	eax
	movzx	ecx, WORD PTR _st$14[ebp+6]
	push	ecx
	movzx	edx, WORD PTR _st$14[ebp+2]
	push	edx
	movzx	eax, WORD PTR _st$14[ebp]
	push	eax
	lea	ecx, DWORD PTR _strDirectory$9[ebp]
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	push	OFFSET $SG4294795276
	lea	ecx, DWORD PTR $T4[ebp]
	push	ecx
	call	DWORD PTR __imp_?FormattedString@@YA?AVString@@PB_WZZ
	add	esp, 40					; 00000028H
	push	eax
	lea	ecx, DWORD PTR _strOutputFile$[ebp]
	call	DWORD PTR __imp_??4String@@QAEAAV0@ABV0@@Z
	lea	ecx, DWORD PTR $T4[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 251  :         }

	lea	ecx, DWORD PTR _extension$12[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _file$8[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strDirectory$9[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
$LN4@GetOutputF:

; 252  :     }

	lea	ecx, DWORD PTR _strFileName$7[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
$LN5@GetOutputF:

; 253  : 
; 254  :     return strOutputFile;

	lea	edx, DWORD PTR _strOutputFile$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0String@@QAE@ABV0@@Z
	lea	ecx, DWORD PTR _strOutputFile$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _path$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 255  : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?GetOutputFilename@@YA?AVString@@_N@Z ENDP		; GetOutputFilename
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obscapture.cpp
;	COMDAT ?AddPendingStreamThread@OBS@@QAEXPAX@Z
_TEXT	SEGMENT
_l$ = -12						; size = 8
_this$ = -4						; size = 4
_thread$ = 8						; size = 4
?AddPendingStreamThread@OBS@@QAEXPAX@Z PROC		; OBS::AddPendingStreamThread, COMDAT
; _this$ = ecx

; 1625 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1626 :     ScopedLock l(pendingStreams.mutex);

	push	1
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1424				; 00000590H
	push	eax
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0ScopedLock@@QAE@ABV?$unique_ptr@XUMutexDeleter@@@std@@_N1@Z ; ScopedLock::ScopedLock

; 1627 :     pendingStreams.streams.emplace_back(thread);

	lea	ecx, DWORD PTR _thread$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1416				; 00000588H
	call	??$emplace_back@AAPAX@?$list@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAEXAAPAX@Z ; std::list<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >::emplace_back<void * &>

; 1628 : }

	lea	ecx, DWORD PTR _l$[ebp]
	call	??1ScopedLock@@QAE@XZ			; ScopedLock::~ScopedLock
	mov	esp, ebp
	pop	ebp
	ret	4
?AddPendingStreamThread@OBS@@QAEXPAX@Z ENDP		; OBS::AddPendingStreamThread
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obscapture.cpp
;	COMDAT ?Stop@OBS@@AAEX_N0@Z
_TEXT	SEGMENT
$T1 = -284						; size = 8
$T2 = -276						; size = 4
$T3 = -272						; size = 4
_processPriority$ = -268				; size = 8
$T4 = -260						; size = 4
tv289 = -256						; size = 4
$T5 = -252						; size = 4
$T6 = -248						; size = 4
_networkMode$ = -244					; size = 4
$T7 = -240						; size = 4
$T8 = -236						; size = 4
$T9 = -232						; size = 4
tv554 = -228						; size = 4
$T10 = -224						; size = 4
$T11 = -220						; size = 4
$T12 = -216						; size = 4
tv541 = -212						; size = 4
$T13 = -208						; size = 4
$T14 = -204						; size = 4
tv460 = -200						; size = 4
tv533 = -196						; size = 4
tv447 = -192						; size = 4
$T15 = -188						; size = 4
tv405 = -184						; size = 4
tv525 = -180						; size = 4
tv391 = -176						; size = 4
$T16 = -172						; size = 4
tv373 = -168						; size = 4
tv517 = -164						; size = 4
tv344 = -160						; size = 4
$T17 = -156						; size = 4
tv316 = -152						; size = 4
tv477 = -148						; size = 4
tv307 = -144						; size = 4
$T18 = -140						; size = 4
tv298 = -136						; size = 4
tv469 = -132						; size = 4
$T19 = -128						; size = 4
$T20 = -124						; size = 4
_audioDevices$ = -120					; size = 8
tv216 = -112						; size = 4
tv597 = -108						; size = 4
_strDevice$ = -104					; size = 8
$T21 = -96						; size = 4
$T22 = -92						; size = 4
$T23 = -88						; size = 4
$T24 = -84						; size = 4
$T25 = -80						; size = 4
$T26 = -76						; size = 4
$T27 = -72						; size = 4
$T28 = -68						; size = 4
$T29 = -64						; size = 4
$T30 = -60						; size = 4
$T31 = -56						; size = 4
$T32 = -52						; size = 4
$T33 = -48						; size = 4
$T34 = -44						; size = 4
$T35 = -40						; size = 4
$T36 = -36						; size = 4
$T37 = -32						; size = 4
_i$38 = -28						; size = 4
_i$39 = -24						; size = 4
_i$40 = -20						; size = 4
_i$41 = -16						; size = 4
_i$42 = -12						; size = 4
_i$43 = -8						; size = 4
_this$ = -4						; size = 4
_overrideKeepRecording$ = 8				; size = 1
_stopReplayBuffer$ = 12					; size = 1
?Stop@OBS@@AAEX_N0@Z PROC				; OBS::Stop, COMDAT
; _this$ = ecx

; 929  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 284				; 0000011cH
	mov	DWORD PTR _this$[ebp], ecx

; 930  :     if((!bStreaming && !bRecording && !bRunning && !bRecordingReplayBuffer) && (!bTestStream)) return;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+627]
	test	ecx, ecx
	jne	SHORT $LN39@Stop
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+623]
	test	eax, eax
	jne	SHORT $LN39@Stop
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+622]
	test	edx, edx
	jne	SHORT $LN39@Stop
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+624]
	test	ecx, ecx
	jne	SHORT $LN39@Stop
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+620]
	test	eax, eax
	jne	SHORT $LN39@Stop
	jmp	$LN40@Stop
$LN39@Stop:

; 931  : 
; 932  :     //ugly hack to prevent hotkeys from being processed while we're stopping otherwise we end up
; 933  :     //with callbacks from the ProcessEvents call in DelayedPublisher which causes havoc.
; 934  :     OSEnterMutex(hHotkeyMutex);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1232]
	push	edx
	call	DWORD PTR __imp_?OSEnterMutex@@YGXPAX@Z

; 935  : 
; 936  :     int networkMode = AppConfig->GetInt(TEXT("Publish"), TEXT("Mode"), 2);

	push	2
	push	OFFSET $SG4294795128
	push	OFFSET $SG4294795127
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	mov	DWORD PTR _networkMode$[ebp], eax

; 937  : 
; 938  :     if((!overrideKeepRecording && ((bRecording && bKeepRecording) || (!stopReplayBuffer && bRecordingReplayBuffer))) && networkMode == 0) {

	movzx	eax, BYTE PTR _overrideKeepRecording$[ebp]
	test	eax, eax
	jne	$LN38@Stop
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+623]
	test	edx, edx
	je	SHORT $LN36@Stop
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+629]
	test	ecx, ecx
	jne	SHORT $LN37@Stop
$LN36@Stop:
	movzx	edx, BYTE PTR _stopReplayBuffer$[ebp]
	test	edx, edx
	jne	$LN38@Stop
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+624]
	test	ecx, ecx
	je	$LN38@Stop
$LN37@Stop:
	cmp	DWORD PTR _networkMode$[ebp], 0
	jne	$LN38@Stop

; 939  :         videoEncoder->RequestKeyframe();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+148]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 940  : 
; 941  :         if (!networkStop.func && network)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 88					; 00000058H
	call	??B?$function@$$A6AXXZ@std@@QBE_NXZ	; std::function<void __cdecl(void)>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN35@Stop
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 76					; 0000004cH
	call	??B?$unique_ptr@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@@std@@QBE_NXZ ; std::unique_ptr<NetworkStream,std::default_delete<NetworkStream> >::operator bool
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN35@Stop

; 942  :         {
; 943  :             networkStop.func = [this]()
; 944  :             {
; 945  :                 videoEncoder->RequestKeyframe();
; 946  : 
; 947  :                 auto stream = move(network);
; 948  : 
; 949  :                 Log(TEXT("=====Stream End (recording continues): %s========================="), CurrentDateTimeString().Array());
; 950  : 
; 951  :                 bStreamFlushed = false;
; 952  : 
; 953  :                 ConfigureStreamButtons();
; 954  : 
; 955  :                 AddPendingStream(stream.release(), [this]()
; 956  :                 {
; 957  :                     bStreaming = false;
; 958  :                     bSentHeaders = false;
; 959  : 
; 960  :                     ReportStopStreamingTrigger();
; 961  : 
; 962  :                     bStreamFlushed = true;
; 963  : 
; 964  :                     ConfigureStreamButtons();
; 965  : 
; 966  :                     if (!bStreaming && !bRecordingReplayBuffer && bRunning && !bRecording) PostStopMessage(true);
; 967  :                 });
; 968  :             };

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@QAE@PAVOBS@@@Z ; <lambda_7c9af1b141e25bc2e890d47a77a39da9>::<lambda_7c9af1b141e25bc2e890d47a77a39da9>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 88					; 00000058H
	call	??$?4V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@@?$function@$$A6AXXZ@std@@QAEAAV01@$$QAV<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@@Z ; std::function<void __cdecl(void)>::operator=<<lambda_7c9af1b141e25bc2e890d47a77a39da9> >

; 969  :             networkStop.time = (DWORD)(GetVideoTime() - firstFrameTimestamp);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetVideoTime@OBS@@QBE_KXZ		; OBS::GetVideoTime
	mov	ecx, DWORD PTR _this$[ebp]
	sub	eax, DWORD PTR [ecx+1112]
	sbb	edx, DWORD PTR [ecx+1116]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+80], eax
$LN35@Stop:

; 970  :         }
; 971  : 
; 972  :         OSLeaveMutex(hHotkeyMutex);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1232]
	push	ecx
	call	DWORD PTR __imp_?OSLeaveMutex@@YGXPAX@Z

; 973  : 
; 974  :         if (bRecordingReplayBuffer && (bRecording && (overrideKeepRecording || !bKeepRecording)))

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+624]
	test	eax, eax
	je	SHORT $LN34@Stop
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+623]
	test	edx, edx
	je	SHORT $LN34@Stop
	movzx	eax, BYTE PTR _overrideKeepRecording$[ebp]
	test	eax, eax
	jne	SHORT $LN33@Stop
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+629]
	test	edx, edx
	jne	SHORT $LN34@Stop
$LN33@Stop:

; 975  :             StopRecording();

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?StopRecording@OBS@@AAEX_N@Z		; OBS::StopRecording
$LN34@Stop:

; 976  : 
; 977  :         return;

	jmp	$LN40@Stop
$LN38@Stop:

; 978  :     }
; 979  : 
; 980  :     OSEnterMutex(hStartupShutdownMutex);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1400]
	push	ecx
	call	DWORD PTR __imp_?OSEnterMutex@@YGXPAX@Z

; 981  : 
; 982  :     //we only want the capture thread to stop first, so we can ensure all packets are flushed
; 983  :     bShutdownEncodeThread = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+632], 1

; 984  :     ShowWindow(hwndProjector, SW_HIDE);

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+732]
	push	ecx
	call	DWORD PTR __imp__ShowWindow@8

; 985  : 
; 986  :     if(hEncodeThread)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+948], 0
	je	SHORT $LN32@Stop

; 987  :     {
; 988  :         OSTerminateThread(hEncodeThread, 30001);

	push	30001					; 00007531H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+948]
	push	ecx
	call	DWORD PTR __imp_?OSTerminateThread@@YGHPAXK@Z

; 989  :         hEncodeThread = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+948], 0
$LN32@Stop:

; 990  :     }
; 991  : 
; 992  :     bShutdownVideoThread = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+631], 1

; 993  :     SetEvent(hVideoEvent);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1124]
	push	edx
	call	DWORD PTR __imp__SetEvent@4

; 994  : 
; 995  :     if(hVideoThread)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+952], 0
	je	SHORT $LN31@Stop

; 996  :     {
; 997  :         OSTerminateThread(hVideoThread, 30002);

	push	30002					; 00007532H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+952]
	push	edx
	call	DWORD PTR __imp_?OSTerminateThread@@YGHPAXK@Z

; 998  :         hVideoThread = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+952], 0
$LN31@Stop:

; 999  :     }
; 1000 : 
; 1001 :     bRunning = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+622], 0

; 1002 : 
; 1003 :     ReportStopStreamTrigger();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+72]
	call	edx

; 1004 : 
; 1005 :     for(UINT i=0; i<globalSources.Num(); i++)

	mov	DWORD PTR _i$41[ebp], 0
	jmp	SHORT $LN30@Stop
$LN29@Stop:
	mov	eax, DWORD PTR _i$41[ebp]
	add	eax, 1
	mov	DWORD PTR _i$41[ebp], eax
$LN30@Stop:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1376				; 00000560H
	call	?Num@?$List@UGlobalSourceInfo@@@@QBEIXZ	; List<GlobalSourceInfo>::Num
	cmp	DWORD PTR _i$41[ebp], eax
	jae	SHORT $LN28@Stop

; 1006 :         globalSources[i].source->EndScene();

	mov	ecx, DWORD PTR _i$41[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1376				; 00000560H
	call	??A?$List@UGlobalSourceInfo@@@@QAEAAUGlobalSourceInfo@@I@Z ; List<GlobalSourceInfo>::operator[]
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR tv216[ebp], edx
	mov	eax, DWORD PTR tv216[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv216[ebp]
	mov	eax, DWORD PTR [edx+28]
	call	eax
	jmp	SHORT $LN29@Stop
$LN28@Stop:

; 1007 : 
; 1008 :     if(scene)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+144], 0
	je	SHORT $LN27@Stop

; 1009 :         scene->EndScene();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+144]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+144]
	mov	eax, DWORD PTR [edx+40]
	call	eax
$LN27@Stop:

; 1010 : 
; 1011 :     //-------------------------------------------------------------
; 1012 : 
; 1013 :     if(hSoundThread)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1148], 0
	je	SHORT $LN26@Stop

; 1014 :     {
; 1015 :         //ReleaseSemaphore(hRequestAudioEvent, 1, NULL);
; 1016 :         OSTerminateThread(hSoundThread, 20000);

	push	20000					; 00004e20H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1148]
	push	eax
	call	DWORD PTR __imp_?OSTerminateThread@@YGHPAXK@Z
$LN26@Stop:

; 1017 :     }
; 1018 : 
; 1019 :     //if(hRequestAudioEvent)
; 1020 :     //    CloseHandle(hRequestAudioEvent);
; 1021 :     if(hSoundDataMutex)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1152], 0
	je	SHORT $LN25@Stop

; 1022 :         OSCloseMutex(hSoundDataMutex);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1152]
	push	eax
	call	DWORD PTR __imp_?OSCloseMutex@@YGXPAX@Z
$LN25@Stop:

; 1023 : 
; 1024 :     hSoundThread = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1148], 0

; 1025 :     //hRequestAudioEvent = NULL;
; 1026 :     hSoundDataMutex = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1152], 0

; 1027 : 
; 1028 :     //-------------------------------------------------------------
; 1029 : 
; 1030 :     StopBlankSoundPlayback();

	call	?StopBlankSoundPlayback@@YAXXZ		; StopBlankSoundPlayback

; 1031 : 
; 1032 :     //-------------------------------------------------------------
; 1033 : 
; 1034 :     if (bStreaming)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+627]
	test	ecx, ecx
	je	SHORT $LN24@Stop

; 1035 :     {
; 1036 :         bStreamFlushed = false;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+628], 0

; 1037 :         AddPendingStream(network.release(), [this]()
; 1038 :         {
; 1039 :             ReportStopStreamingTrigger();
; 1040 :             bStreaming = false;
; 1041 :             bStreamFlushed = true;
; 1042 :             bTestStream = false;
; 1043 :             ConfigureStreamButtons();
; 1044 :         });

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0<lambda_3b020cec0f1508adac4c896f138918cf>@@QAE@PAVOBS@@@Z ; <lambda_3b020cec0f1508adac4c896f138918cf>::<lambda_3b020cec0f1508adac4c896f138918cf>
	sub	esp, 24					; 00000018H
	mov	ecx, esp
	push	eax
	call	??$?0V<lambda_3b020cec0f1508adac4c896f138918cf>@@@?$function@$$A6AXXZ@std@@QAE@$$QAV<lambda_3b020cec0f1508adac4c896f138918cf>@@@Z ; std::function<void __cdecl(void)>::function<void __cdecl(void)><<lambda_3b020cec0f1508adac4c896f138918cf> >
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 76					; 0000004cH
	call	?release@?$unique_ptr@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@@std@@QAEPAVNetworkStream@@XZ ; std::unique_ptr<NetworkStream,std::default_delete<NetworkStream> >::release
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z ; OBS::AddPendingStream

; 1045 :     }
; 1046 :     else

	jmp	SHORT $LN23@Stop
$LN24@Stop:

; 1047 :     {
; 1048 :         network.reset();

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 76					; 0000004cH
	call	?reset@?$unique_ptr@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@@std@@QAEXPAVNetworkStream@@@Z ; std::unique_ptr<NetworkStream,std::default_delete<NetworkStream> >::reset

; 1049 :         bStreaming = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+627], 0

; 1050 :         bTestStream = false;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+620], 0
$LN23@Stop:

; 1051 :     }
; 1052 :     
; 1053 :     if (bRecording) StopRecording(true);

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+623]
	test	ecx, ecx
	je	SHORT $LN22@Stop
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?StopRecording@OBS@@AAEX_N@Z		; OBS::StopRecording
$LN22@Stop:

; 1054 :     if (bRecordingReplayBuffer) StopReplayBuffer(true);

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+624]
	test	eax, eax
	je	SHORT $LN21@Stop
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?StopReplayBuffer@OBS@@AAEX_N@Z		; OBS::StopReplayBuffer
$LN21@Stop:

; 1055 : 
; 1056 :     delete micAudio;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+116]
	mov	DWORD PTR $T4[ebp], edx
	mov	eax, DWORD PTR $T4[ebp]
	mov	DWORD PTR $T28[ebp], eax
	cmp	DWORD PTR $T28[ebp], 0
	je	SHORT $LN42@Stop
	push	1
	mov	ecx, DWORD PTR $T28[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR $T28[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR tv289[ebp], eax
	jmp	SHORT $LN43@Stop
$LN42@Stop:
	mov	DWORD PTR tv289[ebp], 0
$LN43@Stop:

; 1057 :     micAudio = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+116], 0

; 1058 : 
; 1059 :     delete desktopAudio;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+112]
	mov	DWORD PTR $T6[ebp], eax
	mov	ecx, DWORD PTR $T6[ebp]
	mov	DWORD PTR $T26[ebp], ecx
	cmp	DWORD PTR $T26[ebp], 0
	je	SHORT $LN44@Stop
	push	1
	mov	edx, DWORD PTR $T26[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR $T26[ebp]
	mov	edx, DWORD PTR [eax+12]
	call	edx
	mov	DWORD PTR tv298[ebp], eax
	jmp	SHORT $LN45@Stop
$LN44@Stop:
	mov	DWORD PTR tv298[ebp], 0
$LN45@Stop:

; 1060 :     desktopAudio = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+112], 0

; 1061 : 
; 1062 :     delete audioEncoder;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+140]
	mov	DWORD PTR $T13[ebp], edx
	mov	eax, DWORD PTR $T13[ebp]
	mov	DWORD PTR $T34[ebp], eax
	cmp	DWORD PTR $T34[ebp], 0
	je	SHORT $LN46@Stop
	push	1
	mov	ecx, DWORD PTR $T34[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR $T34[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	DWORD PTR tv307[ebp], eax
	jmp	SHORT $LN47@Stop
$LN46@Stop:
	mov	DWORD PTR tv307[ebp], 0
$LN47@Stop:

; 1063 :     audioEncoder = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+140], 0

; 1064 : 
; 1065 :     delete videoEncoder;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	mov	DWORD PTR $T20[ebp], eax
	mov	ecx, DWORD PTR $T20[ebp]
	mov	DWORD PTR $T22[ebp], ecx
	cmp	DWORD PTR $T22[ebp], 0
	je	SHORT $LN48@Stop
	push	1
	mov	edx, DWORD PTR $T22[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR $T22[ebp]
	mov	edx, DWORD PTR [eax+8]
	call	edx
	mov	DWORD PTR tv316[ebp], eax
	jmp	SHORT $LN49@Stop
$LN48@Stop:
	mov	DWORD PTR tv316[ebp], 0
$LN49@Stop:

; 1066 :     videoEncoder = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+148], 0

; 1067 : 
; 1068 :     //-------------------------------------------------------------
; 1069 : 
; 1070 :     for(UINT i=0; i<pendingAudioFrames.Num(); i++)

	mov	DWORD PTR _i$39[ebp], 0
	jmp	SHORT $LN20@Stop
$LN19@Stop:
	mov	ecx, DWORD PTR _i$39[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$39[ebp], ecx
$LN20@Stop:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1208				; 000004b8H
	call	?Num@?$List@UFrameAudio@@@@QBEIXZ	; List<FrameAudio>::Num
	cmp	DWORD PTR _i$39[ebp], eax
	jae	SHORT $LN18@Stop

; 1071 :         pendingAudioFrames[i].audioData.Clear();

	mov	edx, DWORD PTR _i$39[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1208				; 000004b8H
	call	??A?$List@UFrameAudio@@@@QAEAAUFrameAudio@@I@Z ; List<FrameAudio>::operator[]
	mov	ecx, eax
	call	?Clear@?$List@E@@QAEXXZ			; List<unsigned char>::Clear
	jmp	SHORT $LN19@Stop
$LN18@Stop:

; 1072 :     pendingAudioFrames.Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1208				; 000004b8H
	call	?Clear@?$List@UFrameAudio@@@@QAEXXZ	; List<FrameAudio>::Clear

; 1073 : 
; 1074 :     //-------------------------------------------------------------
; 1075 : 
; 1076 :     if(GS)

	mov	eax, DWORD PTR __imp_?GS@@3PAVGraphicsSystem@@A
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN17@Stop

; 1077 :         GS->UnloadAllData();

	mov	ecx, DWORD PTR __imp_?GS@@3PAVGraphicsSystem@@A
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __imp_?GS@@3PAVGraphicsSystem@@A
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+4]
	call	eax
$LN17@Stop:

; 1078 : 
; 1079 :     //-------------------------------------------------------------
; 1080 : 
; 1081 :     delete scene;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+144]
	mov	DWORD PTR $T12[ebp], edx
	mov	eax, DWORD PTR $T12[ebp]
	mov	DWORD PTR $T32[ebp], eax
	cmp	DWORD PTR $T32[ebp], 0
	je	SHORT $LN50@Stop
	push	1
	mov	ecx, DWORD PTR $T32[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR $T32[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	mov	DWORD PTR tv344[ebp], eax
	jmp	SHORT $LN51@Stop
$LN50@Stop:
	mov	DWORD PTR tv344[ebp], 0
$LN51@Stop:

; 1082 :     scene = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+144], 0

; 1083 : 
; 1084 :     for(UINT i=0; i<globalSources.Num(); i++)

	mov	DWORD PTR _i$40[ebp], 0
	jmp	SHORT $LN16@Stop
$LN15@Stop:
	mov	edx, DWORD PTR _i$40[ebp]
	add	edx, 1
	mov	DWORD PTR _i$40[ebp], edx
$LN16@Stop:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1376				; 00000560H
	call	?Num@?$List@UGlobalSourceInfo@@@@QBEIXZ	; List<GlobalSourceInfo>::Num
	cmp	DWORD PTR _i$40[ebp], eax
	jae	SHORT $LN14@Stop

; 1085 :         globalSources[i].FreeData();

	mov	eax, DWORD PTR _i$40[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1376				; 00000560H
	call	??A?$List@UGlobalSourceInfo@@@@QAEAAUGlobalSourceInfo@@I@Z ; List<GlobalSourceInfo>::operator[]
	mov	ecx, eax
	call	?FreeData@GlobalSourceInfo@@QAEXXZ	; GlobalSourceInfo::FreeData
	jmp	SHORT $LN15@Stop
$LN14@Stop:

; 1086 :     globalSources.Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1376				; 00000560H
	call	?Clear@?$List@UGlobalSourceInfo@@@@QAEXXZ ; List<GlobalSourceInfo>::Clear

; 1087 : 
; 1088 :     //-------------------------------------------------------------
; 1089 : 
; 1090 :     for(UINT i=0; i<auxAudioSources.Num(); i++)

	mov	DWORD PTR _i$38[ebp], 0
	jmp	SHORT $LN13@Stop
$LN12@Stop:
	mov	ecx, DWORD PTR _i$38[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$38[ebp], ecx
$LN13@Stop:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 120				; 00000078H
	call	?Num@?$List@PAVAudioSource@@@@QBEIXZ	; List<AudioSource *>::Num
	cmp	DWORD PTR _i$38[ebp], eax
	jae	SHORT $LN11@Stop

; 1091 :         delete auxAudioSources[i];

	mov	edx, DWORD PTR _i$38[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 120				; 00000078H
	call	??A?$List@PAVAudioSource@@@@QAEAAPAVAudioSource@@I@Z ; List<AudioSource *>::operator[]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR $T5[ebp], eax
	mov	ecx, DWORD PTR $T5[ebp]
	mov	DWORD PTR $T29[ebp], ecx
	cmp	DWORD PTR $T29[ebp], 0
	je	SHORT $LN52@Stop
	push	1
	mov	edx, DWORD PTR $T29[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR $T29[ebp]
	mov	edx, DWORD PTR [eax+12]
	call	edx
	mov	DWORD PTR tv373[ebp], eax
	jmp	SHORT $LN53@Stop
$LN52@Stop:
	mov	DWORD PTR tv373[ebp], 0
$LN53@Stop:
	jmp	SHORT $LN12@Stop
$LN11@Stop:

; 1092 :     auxAudioSources.Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 120				; 00000078H
	call	?Clear@?$List@PAVAudioSource@@@@QAEXXZ	; List<AudioSource *>::Clear

; 1093 : 
; 1094 :     //-------------------------------------------------------------
; 1095 : 
; 1096 :     for(UINT i=0; i<NUM_RENDER_BUFFERS; i++)

	mov	DWORD PTR _i$43[ebp], 0
	jmp	SHORT $LN10@Stop
$LN9@Stop:
	mov	eax, DWORD PTR _i$43[ebp]
	add	eax, 1
	mov	DWORD PTR _i$43[ebp], eax
$LN10@Stop:
	cmp	DWORD PTR _i$43[ebp], 2
	jae	$LN8@Stop

; 1097 :     {
; 1098 :         delete mainRenderTextures[i];

	mov	ecx, DWORD PTR _i$43[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+20]
	mov	DWORD PTR $T10[ebp], eax
	mov	ecx, DWORD PTR $T10[ebp]
	mov	DWORD PTR $T37[ebp], ecx
	cmp	DWORD PTR $T37[ebp], 0
	je	SHORT $LN54@Stop
	push	1
	mov	edx, DWORD PTR $T37[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR $T37[ebp]
	mov	edx, DWORD PTR [eax]
	call	edx
	mov	DWORD PTR tv391[ebp], eax
	jmp	SHORT $LN55@Stop
$LN54@Stop:
	mov	DWORD PTR tv391[ebp], 0
$LN55@Stop:

; 1099 :         delete yuvRenderTextures[i];

	mov	eax, DWORD PTR _i$43[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+28]
	mov	DWORD PTR $T8[ebp], edx
	mov	eax, DWORD PTR $T8[ebp]
	mov	DWORD PTR $T30[ebp], eax
	cmp	DWORD PTR $T30[ebp], 0
	je	SHORT $LN56@Stop
	push	1
	mov	ecx, DWORD PTR $T30[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR $T30[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	mov	DWORD PTR tv405[ebp], eax
	jmp	SHORT $LN57@Stop
$LN56@Stop:
	mov	DWORD PTR tv405[ebp], 0
$LN57@Stop:

; 1100 : 
; 1101 :         mainRenderTextures[i] = NULL;

	mov	ecx, DWORD PTR _i$43[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx*4+20], 0

; 1102 :         yuvRenderTextures[i] = NULL;

	mov	eax, DWORD PTR _i$43[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax*4+28], 0

; 1103 :     }

	jmp	$LN9@Stop
$LN8@Stop:

; 1104 : 
; 1105 :     for(UINT i=0; i<NUM_RENDER_BUFFERS; i++)

	mov	DWORD PTR _i$42[ebp], 0
	jmp	SHORT $LN7@Stop
$LN6@Stop:
	mov	edx, DWORD PTR _i$42[ebp]
	add	edx, 1
	mov	DWORD PTR _i$42[ebp], edx
$LN7@Stop:
	cmp	DWORD PTR _i$42[ebp], 2
	jae	SHORT $LN5@Stop

; 1106 :     {
; 1107 :         SafeRelease(copyTextures[i]);

	mov	eax, DWORD PTR _i$42[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+eax*4+12], 0
	je	SHORT $LN4@Stop
	mov	edx, DWORD PTR _i$42[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+12]
	mov	edx, DWORD PTR _i$42[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+edx*4+12]
	mov	eax, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR [eax+8]
	call	ecx
	mov	edx, DWORD PTR _i$42[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx*4+12], 0
$LN4@Stop:

; 1108 :     }

	jmp	SHORT $LN6@Stop
$LN5@Stop:

; 1109 : 
; 1110 :     delete transitionTexture;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR $T9[ebp], edx
	mov	eax, DWORD PTR $T9[ebp]
	mov	DWORD PTR $T27[ebp], eax
	cmp	DWORD PTR $T27[ebp], 0
	je	SHORT $LN58@Stop
	push	1
	mov	ecx, DWORD PTR $T27[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR $T27[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	mov	DWORD PTR tv447[ebp], eax
	jmp	SHORT $LN59@Stop
$LN58@Stop:
	mov	DWORD PTR tv447[ebp], 0
$LN59@Stop:

; 1111 :     transitionTexture = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+40], 0

; 1112 : 
; 1113 :     delete lastRenderTexture;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR $T7[ebp], eax
	mov	ecx, DWORD PTR $T7[ebp]
	mov	DWORD PTR $T24[ebp], ecx
	cmp	DWORD PTR $T24[ebp], 0
	je	SHORT $LN60@Stop
	push	1
	mov	edx, DWORD PTR $T24[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR $T24[ebp]
	mov	edx, DWORD PTR [eax]
	call	edx
	mov	DWORD PTR tv460[ebp], eax
	jmp	SHORT $LN61@Stop
$LN60@Stop:
	mov	DWORD PTR tv460[ebp], 0
$LN61@Stop:

; 1114 :     lastRenderTexture = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+36], 0

; 1115 : 
; 1116 :     //-------------------------------------------------------------
; 1117 : 
; 1118 :     delete mainVertexShader;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	DWORD PTR $T19[ebp], edx
	mov	eax, DWORD PTR $T19[ebp]
	mov	DWORD PTR $T36[ebp], eax
	cmp	DWORD PTR $T36[ebp], 0
	je	SHORT $LN62@Stop
	push	1
	mov	ecx, DWORD PTR $T36[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR $T36[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	mov	DWORD PTR tv469[ebp], eax
	jmp	SHORT $LN63@Stop
$LN62@Stop:
	mov	DWORD PTR tv469[ebp], 0
$LN63@Stop:

; 1119 :     delete mainPixelShader;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	DWORD PTR $T18[ebp], edx
	mov	eax, DWORD PTR $T18[ebp]
	mov	DWORD PTR $T35[ebp], eax
	cmp	DWORD PTR $T35[ebp], 0
	je	SHORT $LN64@Stop
	push	1
	mov	ecx, DWORD PTR $T35[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR $T35[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	mov	DWORD PTR tv477[ebp], eax
	jmp	SHORT $LN65@Stop
$LN64@Stop:
	mov	DWORD PTR tv477[ebp], 0
$LN65@Stop:

; 1120 :     delete yuvScalePixelShader;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	mov	DWORD PTR $T17[ebp], edx
	mov	eax, DWORD PTR $T17[ebp]
	mov	DWORD PTR $T33[ebp], eax
	cmp	DWORD PTR $T33[ebp], 0
	je	SHORT $LN66@Stop
	push	1
	mov	ecx, DWORD PTR $T33[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR $T33[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	mov	DWORD PTR tv517[ebp], eax
	jmp	SHORT $LN67@Stop
$LN66@Stop:
	mov	DWORD PTR tv517[ebp], 0
$LN67@Stop:

; 1121 :     delete transitionPixelShader;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	mov	DWORD PTR $T16[ebp], edx
	mov	eax, DWORD PTR $T16[ebp]
	mov	DWORD PTR $T31[ebp], eax
	cmp	DWORD PTR $T31[ebp], 0
	je	SHORT $LN68@Stop
	push	1
	mov	ecx, DWORD PTR $T31[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR $T31[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	mov	DWORD PTR tv525[ebp], eax
	jmp	SHORT $LN69@Stop
$LN68@Stop:
	mov	DWORD PTR tv525[ebp], 0
$LN69@Stop:

; 1122 : 
; 1123 :     delete solidVertexShader;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	mov	DWORD PTR $T15[ebp], edx
	mov	eax, DWORD PTR $T15[ebp]
	mov	DWORD PTR $T25[ebp], eax
	cmp	DWORD PTR $T25[ebp], 0
	je	SHORT $LN70@Stop
	push	1
	mov	ecx, DWORD PTR $T25[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR $T25[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	mov	DWORD PTR tv533[ebp], eax
	jmp	SHORT $LN71@Stop
$LN70@Stop:
	mov	DWORD PTR tv533[ebp], 0
$LN71@Stop:

; 1124 :     delete solidPixelShader;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	DWORD PTR $T14[ebp], edx
	mov	eax, DWORD PTR $T14[ebp]
	mov	DWORD PTR $T23[ebp], eax
	cmp	DWORD PTR $T23[ebp], 0
	je	SHORT $LN72@Stop
	push	1
	mov	ecx, DWORD PTR $T23[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR $T23[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	mov	DWORD PTR tv541[ebp], eax
	jmp	SHORT $LN73@Stop
$LN72@Stop:
	mov	DWORD PTR tv541[ebp], 0
$LN73@Stop:

; 1125 : 
; 1126 :     mainVertexShader = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+52], 0

; 1127 :     mainPixelShader = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+56], 0

; 1128 :     yuvScalePixelShader = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+60], 0

; 1129 :     transitionPixelShader = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+64], 0

; 1130 : 
; 1131 :     solidVertexShader = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+68], 0

; 1132 :     solidPixelShader = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+72], 0

; 1133 : 
; 1134 :     //-------------------------------------------------------------
; 1135 : 
; 1136 :     delete GS;

	mov	ecx, DWORD PTR __imp_?GS@@3PAVGraphicsSystem@@A
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T11[ebp], edx
	mov	eax, DWORD PTR $T11[ebp]
	mov	DWORD PTR $T21[ebp], eax
	cmp	DWORD PTR $T21[ebp], 0
	je	SHORT $LN74@Stop
	push	1
	mov	ecx, DWORD PTR $T21[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR $T21[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	DWORD PTR tv554[ebp], eax
	jmp	SHORT $LN75@Stop
$LN74@Stop:
	mov	DWORD PTR tv554[ebp], 0
$LN75@Stop:

; 1137 :     GS = NULL;

	mov	ecx, DWORD PTR __imp_?GS@@3PAVGraphicsSystem@@A
	mov	DWORD PTR [ecx], 0

; 1138 : 
; 1139 :     //-------------------------------------------------------------
; 1140 : 
; 1141 :     ResizeRenderFrame(false);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResizeRenderFrame@OBS@@AAEX_N@Z	; OBS::ResizeRenderFrame

; 1142 :     RedrawWindow(hwndRenderFrame, NULL, NULL, RDW_INVALIDATE|RDW_UPDATENOW);

	push	257					; 00000101H
	push	0
	push	0
	mov	edx, DWORD PTR ?hwndRenderFrame@@3PAUHWND__@@A ; hwndRenderFrame
	push	edx
	call	DWORD PTR __imp__RedrawWindow@16

; 1143 : 
; 1144 :     //-------------------------------------------------------------
; 1145 : 
; 1146 :     AudioDeviceList audioDevices;

	lea	ecx, DWORD PTR _audioDevices$[ebp]
	call	??0AudioDeviceList@@QAE@XZ

; 1147 :     GetAudioDevices(audioDevices, ADT_RECORDING, false, true);

	push	1
	push	0
	push	1
	lea	eax, DWORD PTR _audioDevices$[ebp]
	push	eax
	call	?GetAudioDevices@@YAXAAUAudioDeviceList@@W4AudioDeviceType@@_N2@Z ; GetAudioDevices
	add	esp, 16					; 00000010H

; 1148 : 
; 1149 :     String strDevice = AppConfig->GetString(TEXT("Audio"), TEXT("Device"), NULL);

	push	0
	push	OFFSET $SG4294795126
	push	OFFSET $SG4294795125
	lea	ecx, DWORD PTR _strDevice$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetString@ConfigFile@@QAE?AVString@@PB_W00@Z

; 1150 :     if(strDevice.IsEmpty() || !audioDevices.HasID(strDevice))

	lea	ecx, DWORD PTR _strDevice$[ebp]
	call	DWORD PTR __imp_?IsEmpty@String@@QBEHXZ
	test	eax, eax
	jne	SHORT $LN2@Stop
	lea	ecx, DWORD PTR _strDevice$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	lea	ecx, DWORD PTR _audioDevices$[ebp]
	call	?HasID@AudioDeviceList@@QBE_NPB_W@Z	; AudioDeviceList::HasID
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN3@Stop
$LN2@Stop:

; 1151 :     {
; 1152 :         AppConfig->SetString(TEXT("Audio"), TEXT("Device"), TEXT("Disable"));

	push	OFFSET $SG4294795124
	push	OFFSET $SG4294795123
	push	OFFSET $SG4294795122
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?SetString@ConfigFile@@QAEXPB_W00@Z

; 1153 :         strDevice = TEXT("Disable");

	push	OFFSET $SG4294795121
	lea	ecx, DWORD PTR _strDevice$[ebp]
	call	DWORD PTR __imp_??4String@@QAEAAV0@PB_W@Z
$LN3@Stop:

; 1154 :     }
; 1155 : 
; 1156 :     audioDevices.FreeData();

	lea	ecx, DWORD PTR _audioDevices$[ebp]
	call	?FreeData@AudioDeviceList@@QAEXXZ	; AudioDeviceList::FreeData

; 1157 :     EnableWindow(GetDlgItem(hwndMain, ID_MICVOLUME), !strDevice.CompareI(TEXT("Disable")));

	push	OFFSET $SG4294795120
	lea	ecx, DWORD PTR _strDevice$[ebp]
	call	DWORD PTR __imp_?CompareI@String@@QBEHPB_W@Z
	test	eax, eax
	jne	SHORT $LN76@Stop
	mov	DWORD PTR tv597[ebp], 1
	jmp	SHORT $LN77@Stop
$LN76@Stop:
	mov	DWORD PTR tv597[ebp], 0
$LN77@Stop:
	mov	eax, DWORD PTR tv597[ebp]
	push	eax
	push	5007					; 0000138fH
	mov	ecx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	ecx
	call	DWORD PTR __imp__GetDlgItem@8
	push	eax
	call	DWORD PTR __imp__EnableWindow@8

; 1158 : 
; 1159 :     //-------------------------------------------------------------
; 1160 : 
; 1161 :     ClearStreamInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearStreamInfo@OBS@@AAEXXZ		; OBS::ClearStreamInfo

; 1162 : 
; 1163 :     audioWarningId = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+996], 0

; 1164 : 
; 1165 :     DumpProfileData();

	call	DWORD PTR __imp_?DumpProfileData@@YGXXZ

; 1166 :     FreeProfileData();

	call	DWORD PTR __imp_?FreeProfileData@@YGXXZ

; 1167 :     Log(TEXT("=====Stream End: %s================================================="), CurrentDateTimeString().Array());

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	DWORD PTR __imp_?CurrentDateTimeString@@YA?AVString@@XZ
	add	esp, 4
	mov	ecx, eax
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	push	OFFSET $SG4294795119
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 8
	lea	ecx, DWORD PTR $T1[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 1168 : 
; 1169 :     //update notification icon to reflect current status
; 1170 :     UpdateNotificationAreaIcon();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?UpdateNotificationAreaIcon@OBS@@QAEHXZ	; OBS::UpdateNotificationAreaIcon

; 1171 : 
; 1172 :     bEditMode = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+741], 0

; 1173 :  //   SendMessage(GetDlgItem(hwndMain, ID_SCENEEDITOR), BM_SETCHECK, BST_UNCHECKED, 0);
; 1174 :  //   EnableWindow(GetDlgItem(hwndMain, ID_SCENEEDITOR), FALSE);
; 1175 :   //  ClearStatusBar();
; 1176 : 
; 1177 :     InvalidateRect(hwndRenderFrame, NULL, TRUE);

	push	1
	push	0
	mov	edx, DWORD PTR ?hwndRenderFrame@@3PAUHWND__@@A ; hwndRenderFrame
	push	edx
	call	DWORD PTR __imp__InvalidateRect@12

; 1178 : 
; 1179 :     SystemParametersInfo(SPI_SETSCREENSAVEACTIVE, 1, 0, 0);

	push	0
	push	0
	push	1
	push	17					; 00000011H
	call	DWORD PTR __imp__SystemParametersInfoW@16

; 1180 :     SetThreadExecutionState(ES_CONTINUOUS);

	push	-2147483648				; 80000000H
	call	DWORD PTR __imp__SetThreadExecutionState@4

; 1181 : 
; 1182 :     String processPriority = AppConfig->GetString(TEXT("General"), TEXT("Priority"), TEXT("Normal"));

	push	OFFSET $SG4294795118
	push	OFFSET $SG4294795117
	push	OFFSET $SG4294795116
	lea	eax, DWORD PTR _processPriority$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetString@ConfigFile@@QAE?AVString@@PB_W00@Z

; 1183 :     if (scmp(processPriority, TEXT("Normal")))

	push	OFFSET $SG4294795115
	lea	ecx, DWORD PTR _processPriority$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	call	DWORD PTR __imp_?scmp@@YGHPB_W0@Z
	test	eax, eax
	je	SHORT $LN1@Stop

; 1184 :         SetPriorityClass(GetCurrentProcess(), NORMAL_PRIORITY_CLASS);

	push	32					; 00000020H
	call	DWORD PTR __imp__GetCurrentProcess@0
	push	eax
	call	DWORD PTR __imp__SetPriorityClass@8
$LN1@Stop:

; 1185 : 
; 1186 :     ConfigureStreamButtons();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ConfigureStreamButtons@OBS@@AAEXXZ	; OBS::ConfigureStreamButtons

; 1187 : 
; 1188 :     UpdateRenderViewMessage();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?UpdateRenderViewMessage@OBS@@AAEXXZ	; OBS::UpdateRenderViewMessage

; 1189 : 
; 1190 :    // DisableMenusWhileStreaming(false);
; 1191 : 
; 1192 :     OSLeaveMutex(hStartupShutdownMutex);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1400]
	push	edx
	call	DWORD PTR __imp_?OSLeaveMutex@@YGXPAX@Z

; 1193 : 
; 1194 :     OSLeaveMutex(hHotkeyMutex);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1232]
	push	ecx
	call	DWORD PTR __imp_?OSLeaveMutex@@YGXPAX@Z

; 1195 : }

	lea	ecx, DWORD PTR _processPriority$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strDevice$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _audioDevices$[ebp]
	call	??1AudioDeviceList@@QAE@XZ		; AudioDeviceList::~AudioDeviceList
$LN40@Stop:
	mov	esp, ebp
	pop	ebp
	ret	8
?Stop@OBS@@AAEX_N0@Z ENDP				; OBS::Stop
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obscapture.cpp
;	COMDAT ?ClosePendingStreams@OBS@@QAEXXZ
_TEXT	SEGMENT
_handles$ = -52						; size = 12
_l$ = -40						; size = 8
_res$1 = -32						; size = 4
_res$2 = -28						; size = 4
$T3 = -24						; size = 4
_pendingStream$4 = -20					; size = 4
_$S3$5 = -16						; size = 4
_$S1$6 = -12						; size = 4
_$S2$7 = -8						; size = 4
_this$ = -4						; size = 4
?ClosePendingStreams@OBS@@QAEXXZ PROC			; OBS::ClosePendingStreams, COMDAT
; _this$ = ecx

; 1631 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 1632 :     ScopedLock l(pendingStreams.mutex);

	push	1
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1424				; 00000590H
	push	eax
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0ScopedLock@@QAE@ABV?$unique_ptr@XUMutexDeleter@@@std@@_N1@Z ; ScopedLock::ScopedLock

; 1633 :     if (pendingStreams.streams.empty())

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1416				; 00000588H
	call	?empty@?$list@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QBE_NXZ ; std::list<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >::empty
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN10@ClosePendi

; 1634 :         return;

	lea	ecx, DWORD PTR _l$[ebp]
	call	??1ScopedLock@@QAE@XZ			; ScopedLock::~ScopedLock
	jmp	$LN11@ClosePendi
$LN10@ClosePendi:

; 1635 : 
; 1636 :     using namespace std;
; 1637 :     vector<HANDLE> handles;

	lea	ecx, DWORD PTR _handles$[ebp]
	call	??0?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@XZ ; std::vector<void *,std::allocator<void *> >::vector<void *,std::allocator<void *> >

; 1638 :     for (auto &pendingStream : pendingStreams.streams)

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1416				; 00000588H
	mov	DWORD PTR _$S1$6[ebp], edx
	lea	eax, DWORD PTR _$S2$7[ebp]
	push	eax
	mov	ecx, DWORD PTR _$S1$6[ebp]
	call	?begin@?$list@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@@2@XZ ; std::list<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >::begin
	lea	ecx, DWORD PTR _$S3$5[ebp]
	push	ecx
	mov	ecx, DWORD PTR _$S1$6[ebp]
	call	?end@?$list@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@@2@XZ ; std::list<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >::end
	jmp	SHORT $LN9@ClosePendi
$LN8@ClosePendi:
	lea	ecx, DWORD PTR _$S2$7[ebp]
	call	??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > > >::operator++
$LN9@ClosePendi:
	lea	edx, DWORD PTR _$S3$5[ebp]
	push	edx
	lea	ecx, DWORD PTR _$S2$7[ebp]
	call	??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > > >::operator!=
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN7@ClosePendi
	lea	ecx, DWORD PTR _$S2$7[ebp]
	call	??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@@std@@QBEAAV?$unique_ptr@XU?$ThreadTerminator@$0A@@@@1@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > > >::operator*
	mov	DWORD PTR _pendingStream$4[ebp], eax

; 1639 :         handles.push_back(pendingStream.get());

	mov	ecx, DWORD PTR _pendingStream$4[ebp]
	call	?get@?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@QBEPAXXZ ; std::unique_ptr<void,ThreadTerminator<0> >::get
	mov	DWORD PTR $T3[ebp], eax
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	lea	ecx, DWORD PTR _handles$[ebp]
	call	?push_back@?$vector@PAXV?$allocator@PAX@std@@@std@@QAEX$$QAPAX@Z ; std::vector<void *,std::allocator<void *> >::push_back
	jmp	SHORT $LN8@ClosePendi
$LN7@ClosePendi:

; 1640 : 
; 1641 :     if (WaitForMultipleObjects(handles.size(), handles.data(), true, 5) != WAIT_OBJECT_0)

	push	5
	push	1
	lea	ecx, DWORD PTR _handles$[ebp]
	call	?data@?$vector@PAXV?$allocator@PAX@std@@@std@@QAEPAPAXXZ ; std::vector<void *,std::allocator<void *> >::data
	push	eax
	lea	ecx, DWORD PTR _handles$[ebp]
	call	?size@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEIXZ ; std::vector<void *,std::allocator<void *> >::size
	push	eax
	call	DWORD PTR __imp__WaitForMultipleObjects@16
	test	eax, eax
	je	$LN6@ClosePendi

; 1642 :     {
; 1643 :         using ::locale;
; 1644 :         int res = IDNO;

	mov	DWORD PTR _res$1[ebp], 7
$LN5@ClosePendi:

; 1645 :         do
; 1646 :         {
; 1647 :             auto res = OBSMessageBox(hwndMain, Str("StreamClosePending"), nullptr, MB_YESNO | MB_ICONEXCLAMATION);

	push	52					; 00000034H
	push	0
	push	OFFSET $SG4294795111
	mov	edx, DWORD PTR __imp_?locale@@3PAVLocaleStringLookup@@A
	mov	ecx, DWORD PTR [edx]
	call	DWORD PTR __imp_?LookupString@LocaleStringLookup@@QAEPB_WPB_W@Z
	push	eax
	mov	eax, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	eax
	call	DWORD PTR __imp_?OBSMessageBox@@YAHPAUHWND__@@PB_W1I@Z
	add	esp, 16					; 00000010H
	mov	DWORD PTR _res$2[ebp], eax

; 1648 : 
; 1649 :             if (res != IDYES)

	cmp	DWORD PTR _res$2[ebp], 6
	je	SHORT $LN2@ClosePendi

; 1650 :                 return;

	lea	ecx, DWORD PTR _handles$[ebp]
	call	??1?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@XZ ; std::vector<void *,std::allocator<void *> >::~vector<void *,std::allocator<void *> >
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1ScopedLock@@QAE@XZ			; ScopedLock::~ScopedLock
	jmp	SHORT $LN11@ClosePendi
$LN2@ClosePendi:

; 1651 : 
; 1652 :             if (WaitForMultipleObjects(handles.size(), handles.data(), true, 15 * 1000) == WAIT_OBJECT_0)

	push	15000					; 00003a98H
	push	1
	lea	ecx, DWORD PTR _handles$[ebp]
	call	?data@?$vector@PAXV?$allocator@PAX@std@@@std@@QAEPAPAXXZ ; std::vector<void *,std::allocator<void *> >::data
	push	eax
	lea	ecx, DWORD PTR _handles$[ebp]
	call	?size@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEIXZ ; std::vector<void *,std::allocator<void *> >::size
	push	eax
	call	DWORD PTR __imp__WaitForMultipleObjects@16
	test	eax, eax
	jne	SHORT $LN4@ClosePendi

; 1653 :                 return;

	lea	ecx, DWORD PTR _handles$[ebp]
	call	??1?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@XZ ; std::vector<void *,std::allocator<void *> >::~vector<void *,std::allocator<void *> >
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1ScopedLock@@QAE@XZ			; ScopedLock::~ScopedLock
	jmp	SHORT $LN11@ClosePendi
$LN4@ClosePendi:

; 1654 : 
; 1655 :         } while (res == IDYES);

	cmp	DWORD PTR _res$1[ebp], 6
	je	SHORT $LN5@ClosePendi
$LN6@ClosePendi:

; 1656 :     }
; 1657 : }

	lea	ecx, DWORD PTR _handles$[ebp]
	call	??1?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@XZ ; std::vector<void *,std::allocator<void *> >::~vector<void *,std::allocator<void *> >
	lea	ecx, DWORD PTR _l$[ebp]
	call	??1ScopedLock@@QAE@XZ			; ScopedLock::~ScopedLock
$LN11@ClosePendi:
	mov	esp, ebp
	pop	ebp
	ret	0
?ClosePendingStreams@OBS@@QAEXXZ ENDP			; OBS::ClosePendingStreams
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\math.h
;	COMDAT _log10f
_TEXT	SEGMENT
tv70 = -4						; size = 4
__X$ = 8						; size = 4
_log10f	PROC						; COMDAT

; 741  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 742  :     return (float)log10(_X);

	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	call	__libm_sse2_log10_precise
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv70[ebp], xmm0
	fld	DWORD PTR tv70[ebp]

; 743  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_log10f	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\math.h
;	COMDAT _sqrtf
_TEXT	SEGMENT
tv70 = -4						; size = 4
__X$ = 8						; size = 4
_sqrtf	PROC						; COMDAT

; 774  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 775  :     return (float)sqrt(_X);

	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	call	__libm_sse2_sqrt_precise
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv70[ebp], xmm0
	fld	DWORD PTR tv70[ebp]

; 776  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_sqrtf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\math.h
;	COMDAT ?log10@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?log10@@YAMM@Z PROC					; log10, COMDAT

; 1096 :         {return (log10f(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_log10f
	add	esp, 4
	pop	ebp
	ret	0
?log10@@YAMM@Z ENDP					; log10
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\math.h
;	COMDAT ?sqrt@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?sqrt@@YAMM@Z PROC					; sqrt, COMDAT

; 1136 :         {return (sqrtf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_sqrtf
	add	esp, 4
	pop	ebp
	ret	0
?sqrt@@YAMM@Z ENDP					; sqrt
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$di	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 70   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$di	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$di	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3451 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$di	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\tuple
;	COMDAT ??__Eignore@std@@YAXXZ
text$di	SEGMENT
??__Eignore@std@@YAXXZ PROC				; std::`dynamic initializer for 'ignore'', COMDAT

; 59   : const _Ignore ignore;

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET _ignore
	call	??0_Ignore@std@@QAE@XZ			; std::_Ignore::_Ignore
	pop	ebp
	ret	0
??__Eignore@std@@YAXXZ ENDP				; std::`dynamic initializer for 'ignore''
text$di	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\tuple
;	COMDAT ??__E_Tuple_alloc@std@@YAXXZ
text$di	SEGMENT
$T1 = -1						; size = 1
??__E_Tuple_alloc@std@@YAXXZ PROC			; std::`dynamic initializer for '_Tuple_alloc'', COMDAT

; 66   : const _Tuple_alloc_t _Tuple_alloc = _Tuple_alloc_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__E_Tuple_alloc@std@@YAXXZ ENDP			; std::`dynamic initializer for '_Tuple_alloc''
text$di	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\graphicssystem.h
;	COMDAT ?CreateRenderTarget@@YAPAVTexture@@IIW4GSColorFormat@@H@Z
_TEXT	SEGMENT
_width$ = 8						; size = 4
_height$ = 12						; size = 4
_colorFormat$ = 16					; size = 4
_bGenMipMaps$ = 20					; size = 4
?CreateRenderTarget@@YAPAVTexture@@IIW4GSColorFormat@@H@Z PROC ; CreateRenderTarget, COMDAT

; 646  :     {return GS->CreateRenderTarget(width, height, colorFormat, bGenMipMaps);}

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _bGenMipMaps$[ebp]
	push	eax
	mov	ecx, DWORD PTR _colorFormat$[ebp]
	push	ecx
	mov	edx, DWORD PTR _height$[ebp]
	push	edx
	mov	eax, DWORD PTR _width$[ebp]
	push	eax
	mov	ecx, DWORD PTR __imp_?GS@@3PAVGraphicsSystem@@A
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __imp_?GS@@3PAVGraphicsSystem@@A
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+32]
	call	eax
	pop	ebp
	ret	0
?CreateRenderTarget@@YAPAVTexture@@IIW4GSColorFormat@@H@Z ENDP ; CreateRenderTarget
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\graphicssystem.h
;	COMDAT ?CreateVertexShaderFromFile@@YAPAVShader@@PB_W@Z
_TEXT	SEGMENT
_lpFileName$ = 8					; size = 4
?CreateVertexShaderFromFile@@YAPAVShader@@PB_W@Z PROC	; CreateVertexShaderFromFile, COMDAT

; 663  : inline Shader* CreateVertexShaderFromFile(CTSTR lpFileName)         {return GS->CreateVertexShaderFromFile(lpFileName);}

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _lpFileName$[ebp]
	push	eax
	mov	ecx, DWORD PTR __imp_?GS@@3PAVGraphicsSystem@@A
	mov	ecx, DWORD PTR [ecx]
	call	DWORD PTR __imp_?CreateVertexShaderFromFile@GraphicsSystem@@QAEPAVShader@@PB_W@Z
	pop	ebp
	ret	0
?CreateVertexShaderFromFile@@YAPAVShader@@PB_W@Z ENDP	; CreateVertexShaderFromFile
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.h
;	COMDAT ?FreeData@GlobalSourceInfo@@QAEXXZ
_TEXT	SEGMENT
tv73 = -16						; size = 4
$T1 = -12						; size = 4
_this$ = -8						; size = 4
$T2 = -4						; size = 4
?FreeData@GlobalSourceInfo@@QAEXXZ PROC			; GlobalSourceInfo::FreeData, COMDAT
; _this$ = ecx

; 387  :     inline void FreeData() {strName.Clear(); delete source; source = NULL;}

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_?Clear@String@@QAEAAV1@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	mov	DWORD PTR $T2[ebp], edx
	cmp	DWORD PTR $T2[ebp], 0
	je	SHORT $LN3@FreeData
	push	1
	mov	eax, DWORD PTR $T2[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR $T2[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	mov	DWORD PTR tv73[ebp], eax
	jmp	SHORT $LN4@FreeData
$LN3@FreeData:
	mov	DWORD PTR tv73[ebp], 0
$LN4@FreeData:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	esp, ebp
	pop	ebp
	ret	0
?FreeData@GlobalSourceInfo@@QAEXXZ ENDP			; GlobalSourceInfo::FreeData
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.h
;	COMDAT ?ClearStreamInfo@OBS@@AAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$1 = -4						; size = 4
?ClearStreamInfo@OBS@@AAEXXZ PROC			; OBS::ClearStreamInfo, COMDAT
; _this$ = ecx

; 1001 :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1002 :         for(UINT i=0; i<streamInfoList.Num(); i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN3@ClearStrea
$LN2@ClearStrea:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN3@ClearStrea:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1388				; 0000056cH
	call	?Num@?$List@UStreamInfo@@@@QBEIXZ	; List<StreamInfo>::Num
	cmp	DWORD PTR _i$1[ebp], eax
	jae	SHORT $LN1@ClearStrea

; 1003 :             streamInfoList[i].FreeData();

	mov	ecx, DWORD PTR _i$1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1388				; 0000056cH
	call	??A?$List@UStreamInfo@@@@QAEAAUStreamInfo@@I@Z ; List<StreamInfo>::operator[]
	mov	ecx, eax
	call	?FreeData@StreamInfo@@QAEXXZ		; StreamInfo::FreeData
	jmp	SHORT $LN2@ClearStrea
$LN1@ClearStrea:

; 1004 :         streamInfoList.Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1388				; 0000056cH
	call	?Clear@?$List@UStreamInfo@@@@QAEXXZ	; List<StreamInfo>::Clear

; 1005 :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?ClearStreamInfo@OBS@@AAEXXZ ENDP			; OBS::ClearStreamInfo
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.h
;	COMDAT ?PostStopMessage@OBS@@QAEX_N@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv69 = -4						; size = 4
_forceStop$ = 8						; size = 1
?PostStopMessage@OBS@@QAEX_N@Z PROC			; OBS::PostStopMessage, COMDAT
; _this$ = ecx

; 1206 :     inline void PostStopMessage(bool forceStop=false) {if(hwndMain) PostMessage(hwndMain, OBS_REQUESTSTOP, forceStop ? 1 : 0, 0);}

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	cmp	DWORD PTR ?hwndMain@@3PAUHWND__@@A, 0	; hwndMain
	je	SHORT $LN2@PostStopMe
	movzx	eax, BYTE PTR _forceStop$[ebp]
	test	eax, eax
	je	SHORT $LN4@PostStopMe
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN5@PostStopMe
$LN4@PostStopMe:
	mov	DWORD PTR tv69[ebp], 0
$LN5@PostStopMe:
	push	0
	mov	ecx, DWORD PTR tv69[ebp]
	push	ecx
	push	1025					; 00000401H
	mov	edx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	edx
	call	DWORD PTR __imp__PostMessageW@16
$LN2@PostStopMe:
	mov	esp, ebp
	pop	ebp
	ret	4
?PostStopMessage@OBS@@QAEX_N@Z ENDP			; OBS::PostStopMessage
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obscapture.cpp
;	COMDAT ?ToggleRecording@OBS@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ToggleRecording@OBS@@AAEXXZ PROC			; OBS::ToggleRecording, COMDAT
; _this$ = ecx

; 54   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 55   :     if (!bRecording)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+623]
	test	ecx, ecx
	jne	SHORT $LN4@ToggleReco

; 56   :     {
; 57   :         if (!bRunning && !bStreaming) Start(true);

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+622]
	test	eax, eax
	jne	SHORT $LN3@ToggleReco
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+627]
	test	edx, edx
	jne	SHORT $LN3@ToggleReco
	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Start@OBS@@AAEX_N0@Z			; OBS::Start
	jmp	SHORT $LN2@ToggleReco
$LN3@ToggleReco:

; 58   :         else StartRecording(true);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?StartRecording@OBS@@AAE_N_N@Z		; OBS::StartRecording
$LN2@ToggleReco:

; 59   :     }
; 60   :     else

	jmp	SHORT $LN5@ToggleReco
$LN4@ToggleReco:

; 61   :         StopRecording();

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?StopRecording@OBS@@AAEX_N@Z		; OBS::StopRecording
$LN5@ToggleReco:

; 62   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ToggleRecording@OBS@@AAEXXZ ENDP			; OBS::ToggleRecording
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obscapture.cpp
;	COMDAT ?ToggleCapturing@OBS@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ToggleCapturing@OBS@@AAEXXZ PROC			; OBS::ToggleCapturing, COMDAT
; _this$ = ecx

; 65   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 66   : 	if (!bRunning || (!bStreaming && (bRecording || bRecordingReplayBuffer)))

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+622]
	test	ecx, ecx
	je	SHORT $LN3@ToggleCapt
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+627]
	test	eax, eax
	jne	SHORT $LN4@ToggleCapt
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+623]
	test	edx, edx
	jne	SHORT $LN3@ToggleCapt
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+624]
	test	ecx, ecx
	je	SHORT $LN4@ToggleCapt
$LN3@ToggleCapt:

; 67   : 	{
; 68   : 		Start();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Start@OBS@@AAEX_N0@Z			; OBS::Start

; 69   : 		bEditMode = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+741], 1

; 70   : 	}
; 71   :      else

	jmp	SHORT $LN5@ToggleCapt
$LN4@ToggleCapt:

; 72   : 	{
; 73   : 		Stop();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Stop@OBS@@AAEX_N0@Z			; OBS::Stop

; 74   : 		bEditMode = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+741], 0
$LN5@ToggleCapt:

; 75   : 	}
; 76   :         
; 77   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ToggleCapturing@OBS@@AAEXXZ ENDP			; OBS::ToggleCapturing
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obscapture.cpp
;	COMDAT ?ToggleReplayBuffer@OBS@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ToggleReplayBuffer@OBS@@AAEXXZ PROC			; OBS::ToggleReplayBuffer, COMDAT
; _this$ = ecx

; 80   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 81   :     if (!bRecordingReplayBuffer)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+624]
	test	ecx, ecx
	jne	SHORT $LN2@ToggleRepl

; 82   :         StartReplayBuffer();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?StartReplayBuffer@OBS@@AAEXXZ		; OBS::StartReplayBuffer

; 83   :     else

	jmp	SHORT $LN3@ToggleRepl
$LN2@ToggleRepl:

; 84   :         StopReplayBuffer();

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?StopReplayBuffer@OBS@@AAEX_N@Z		; OBS::StopReplayBuffer
$LN3@ToggleRepl:

; 85   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ToggleReplayBuffer@OBS@@AAEXXZ ENDP			; OBS::ToggleReplayBuffer
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obscapture.cpp
;	COMDAT ?StartReplayBuffer@OBS@@AAEXXZ
_TEXT	SEGMENT
$T1 = -24						; size = 8
$T2 = -16						; size = 8
_length$ = -8						; size = 4
_this$ = -4						; size = 4
?StartReplayBuffer@OBS@@AAEXXZ PROC			; OBS::StartReplayBuffer, COMDAT
; _this$ = ecx

; 88   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 89   :     if (bTestStream || bRecordingReplayBuffer) return;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+620]
	test	ecx, ecx
	jne	SHORT $LN6@StartRepla
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+624]
	test	eax, eax
	je	SHORT $LN7@StartRepla
$LN6@StartRepla:
	jmp	$LN8@StartRepla
$LN7@StartRepla:

; 90   : 
; 91   :     if (!saveReplayBufferHotkeyID && !recordFromReplayBufferHotkeyID)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1304], 0
	jne	SHORT $LN5@StartRepla
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1308], 0
	jne	SHORT $LN5@StartRepla

; 92   :         OBSMessageBox(hwndMain, Str("Capture.Start.ReplayBuffer.NoHotkey"), nullptr, MB_OK | MB_ICONWARNING);

	push	48					; 00000030H
	push	0
	push	OFFSET $SG4294795314
	mov	eax, DWORD PTR __imp_?locale@@3PAVLocaleStringLookup@@A
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR __imp_?LookupString@LocaleStringLookup@@QAEPB_WPB_W@Z
	push	eax
	mov	ecx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	ecx
	call	DWORD PTR __imp_?OBSMessageBox@@YAHPAUHWND__@@PB_W1I@Z
	add	esp, 16					; 00000010H
$LN5@StartRepla:

; 93   : 
; 94   :     int length = AppConfig->GetInt(L"Publish", L"ReplayBufferLength", 1);

	push	1
	push	OFFSET $SG4294795313
	push	OFFSET $SG4294795312
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	mov	DWORD PTR _length$[ebp], eax

; 95   :     std::tie(replayBuffer, replayBufferStream) = CreateReplayBuffer(length);

	mov	edx, DWORD PTR _length$[ebp]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?CreateReplayBuffer@@YA?AU?$pair@PAUReplayBuffer@@V?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@std@@H@Z ; CreateReplayBuffer
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1064				; 00000428H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1068				; 0000042cH
	push	edx
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	??$tie@PAUReplayBuffer@@V?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@std@@YA?AV?$tuple@AAPAUReplayBuffer@@AAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@0@AAPAUReplayBuffer@@AAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@0@@Z ; std::tie<ReplayBuffer *,std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > >
	add	esp, 12					; 0000000cH
	mov	ecx, eax
	call	??$?4PAUReplayBuffer@@V?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@?$tuple@AAPAUReplayBuffer@@AAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@std@@QAEAAV01@$$QAU?$pair@PAUReplayBuffer@@V?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@1@@Z ; std::tuple<ReplayBuffer * &,std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > &>::operator=<ReplayBuffer *,std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > >
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$pair@PAUReplayBuffer@@V?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@std@@QAE@XZ

; 96   :     if (!replayBuffer)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1068], 0
	jne	SHORT $LN4@StartRepla

; 97   :     {
; 98   :         Log(L"Invalid ReplayBuffer length set: %d", length);

	mov	edx, DWORD PTR _length$[ebp]
	push	edx
	push	OFFSET $SG4294795311
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 8

; 99   :         OBSMessageBox(hwndMain, Str("Capture.Start.FileStream.SaveReplayBufferWarning"), Str("Capture.Start.FileStream.WarningCaption"), MB_OK | MB_ICONWARNING);

	push	48					; 00000030H
	push	OFFSET $SG4294795310
	mov	eax, DWORD PTR __imp_?locale@@3PAVLocaleStringLookup@@A
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR __imp_?LookupString@LocaleStringLookup@@QAEPB_WPB_W@Z
	push	eax
	push	OFFSET $SG4294795309
	mov	ecx, DWORD PTR __imp_?locale@@3PAVLocaleStringLookup@@A
	mov	ecx, DWORD PTR [ecx]
	call	DWORD PTR __imp_?LookupString@LocaleStringLookup@@QAEPB_WPB_W@Z
	push	eax
	mov	edx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	edx
	call	DWORD PTR __imp_?OBSMessageBox@@YAHPAUHWND__@@PB_W1I@Z
	add	esp, 16					; 00000010H

; 100  :         ConfigureStreamButtons();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ConfigureStreamButtons@OBS@@AAEXXZ	; OBS::ConfigureStreamButtons

; 101  :         return;

	jmp	$LN8@StartRepla
$LN4@StartRepla:

; 102  :     }
; 103  : 
; 104  :     if (!bRunning)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+622]
	test	ecx, ecx
	jne	SHORT $LN3@StartRepla

; 105  :         Start(false, true);

	push	1
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Start@OBS@@AAEX_N0@Z			; OBS::Start

; 106  :     else

	jmp	SHORT $LN2@StartRepla
$LN3@StartRepla:

; 107  :         videoEncoder->RequestKeyframe();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+148]
	mov	eax, DWORD PTR [edx+32]
	call	eax
$LN2@StartRepla:

; 108  :     if (!bRunning)

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+622]
	test	edx, edx
	jne	SHORT $LN1@StartRepla

; 109  :         return StopReplayBuffer();

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?StopReplayBuffer@OBS@@AAEX_N@Z		; OBS::StopReplayBuffer
	jmp	SHORT $LN8@StartRepla
$LN1@StartRepla:

; 110  : 
; 111  :     Log(L"Using ReplayBuffer with a length of %d seconds", length);

	mov	eax, DWORD PTR _length$[ebp]
	push	eax
	push	OFFSET $SG4294795308
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 8

; 112  : 
; 113  :     bRecordingReplayBuffer = true;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+624], 1

; 114  :     ReportStartRecordingReplayBufferTrigger();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+92]
	call	edx

; 115  : 
; 116  :     ConfigureStreamButtons();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ConfigureStreamButtons@OBS@@AAEXXZ	; OBS::ConfigureStreamButtons
$LN8@StartRepla:

; 117  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?StartReplayBuffer@OBS@@AAEXXZ ENDP			; OBS::StartReplayBuffer
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obscapture.cpp
;	COMDAT ?StopReplayBuffer@OBS@@AAEX_N@Z
_TEXT	SEGMENT
_shutdown$ = -8						; size = 4
_this$ = -4						; size = 4
_immediate$ = 8						; size = 1
?StopReplayBuffer@OBS@@AAEX_N@Z PROC			; OBS::StopReplayBuffer, COMDAT
; _this$ = ecx

; 120  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 121  :     if (!replayBufferStream) return;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1064				; 00000428H
	call	??B?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@QBE_NXZ ; std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> >::operator bool
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@StopReplay
	jmp	SHORT $LN4@StopReplay
$LN3@StopReplay:

; 122  : 
; 123  :     if (!immediate && replayBufferStop.func) return;

	movzx	ecx, BYTE PTR _immediate$[ebp]
	test	ecx, ecx
	jne	SHORT $LN2@StopReplay
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1080				; 00000438H
	call	??B?$function@$$A6AXXZ@std@@QBE_NXZ	; std::function<void __cdecl(void)>::operator bool
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN2@StopReplay
	jmp	SHORT $LN4@StopReplay
$LN2@StopReplay:

; 124  : 
; 125  :     auto shutdown = [this]()
; 126  :     {
; 127  :         bRecordingReplayBuffer = false;
; 128  :         ReportStopRecordingReplayBufferTrigger();
; 129  : 
; 130  :         if (!bStreaming && !bRecording && bRunning) PostStopMessage(true);
; 131  : 
; 132  :         auto stream = move(replayBufferStream);
; 133  : 
; 134  :         replayBuffer = nullptr;
; 135  : 
; 136  :         ConfigureStreamButtons();
; 137  :     };

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR _shutdown$[ebp]
	call	??0<lambda_582637cdd8d6a2f689bc987be9ec55df>@@QAE@PAVOBS@@@Z ; <lambda_582637cdd8d6a2f689bc987be9ec55df>::<lambda_582637cdd8d6a2f689bc987be9ec55df>

; 138  : 
; 139  :     if (immediate)

	movzx	ecx, BYTE PTR _immediate$[ebp]
	test	ecx, ecx
	je	SHORT $LN1@StopReplay

; 140  :         return shutdown();

	lea	ecx, DWORD PTR _shutdown$[ebp]
	call	??R<lambda_582637cdd8d6a2f689bc987be9ec55df>@@QBEXXZ ; <lambda_582637cdd8d6a2f689bc987be9ec55df>::operator()
	jmp	SHORT $LN4@StopReplay
$LN1@StopReplay:

; 141  : 
; 142  :     replayBufferStop.func = shutdown;

	lea	edx, DWORD PTR _shutdown$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1080				; 00000438H
	call	??$?4AAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@@?$function@$$A6AXXZ@std@@QAEAAV01@AAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@@Z ; std::function<void __cdecl(void)>::operator=<<lambda_582637cdd8d6a2f689bc987be9ec55df> &>

; 143  : 
; 144  :     replayBufferStop.time = (DWORD)(GetVideoTime() - firstFrameTimestamp);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetVideoTime@OBS@@QBE_KXZ		; OBS::GetVideoTime
	mov	ecx, DWORD PTR _this$[ebp]
	sub	eax, DWORD PTR [ecx+1112]
	sbb	edx, DWORD PTR [ecx+1116]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1072], eax
$LN4@StopReplay:

; 145  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?StopReplayBuffer@OBS@@AAEX_N@Z ENDP			; OBS::StopReplayBuffer
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obscapture.cpp
;	COMDAT ??0<lambda_582637cdd8d6a2f689bc987be9ec55df>@@QAE@PAVOBS@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__This$ = 8						; size = 4
??0<lambda_582637cdd8d6a2f689bc987be9ec55df>@@QAE@PAVOBS@@@Z PROC ; <lambda_582637cdd8d6a2f689bc987be9ec55df>::<lambda_582637cdd8d6a2f689bc987be9ec55df>, COMDAT
; _this$ = ecx

; 137  :     };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __This$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0<lambda_582637cdd8d6a2f689bc987be9ec55df>@@QAE@PAVOBS@@@Z ENDP ; <lambda_582637cdd8d6a2f689bc987be9ec55df>::<lambda_582637cdd8d6a2f689bc987be9ec55df>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obscapture.cpp
;	COMDAT ??R<lambda_582637cdd8d6a2f689bc987be9ec55df>@@QBEXXZ
_TEXT	SEGMENT
_stream$ = -8						; size = 4
_this$ = -4						; size = 4
??R<lambda_582637cdd8d6a2f689bc987be9ec55df>@@QBEXXZ PROC ; <lambda_582637cdd8d6a2f689bc987be9ec55df>::operator(), COMDAT
; _this$ = ecx

; 126  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 127  :         bRecordingReplayBuffer = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	BYTE PTR [ecx+624], 0

; 128  :         ReportStopRecordingReplayBufferTrigger();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+96]
	call	eax

; 129  : 
; 130  :         if (!bStreaming && !bRecording && bRunning) PostStopMessage(true);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx+627]
	test	eax, eax
	jne	SHORT $LN1@operator
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx+623]
	test	eax, eax
	jne	SHORT $LN1@operator
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx+622]
	test	eax, eax
	je	SHORT $LN1@operator
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?PostStopMessage@OBS@@QAEX_N@Z		; OBS::PostStopMessage
$LN1@operator:

; 131  : 
; 132  :         auto stream = move(replayBufferStream);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 1064				; 00000428H
	push	eax
	call	??$move@AAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@std@@YA$$QAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@0@AAV10@@Z ; std::move<std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > &>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR _stream$[ebp]
	call	??0?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@QAE@$$QAV01@@Z ; std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> >::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> >

; 133  : 
; 134  :         replayBuffer = nullptr;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [edx+1068], 0

; 135  : 
; 136  :         ConfigureStreamButtons();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?ConfigureStreamButtons@OBS@@AAEXXZ	; OBS::ConfigureStreamButtons

; 137  :     };

	lea	ecx, DWORD PTR _stream$[ebp]
	call	??1?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@QAE@XZ ; std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> >::~unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> >
	mov	esp, ebp
	pop	ebp
	ret	0
??R<lambda_582637cdd8d6a2f689bc987be9ec55df>@@QBEXXZ ENDP ; <lambda_582637cdd8d6a2f689bc987be9ec55df>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obscapture.cpp
;	COMDAT ?ExpandRecordingFilename@@YA?AVString@@V1@@Z
_TEXT	SEGMENT
$T1 = -116						; size = 8
$T2 = -108						; size = 8
$T3 = -100						; size = 8
$T4 = -92						; size = 8
$T5 = -84						; size = 8
$T6 = -76						; size = 8
$T7 = -68						; size = 8
$T8 = -60						; size = 8
$T9 = -52						; size = 8
$T10 = -44						; size = 8
$T11 = -36						; size = 8
$T12 = -28						; size = 8
_st$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_filename$ = 12						; size = 8
?ExpandRecordingFilename@@YA?AVString@@V1@@Z PROC	; ExpandRecordingFilename, COMDAT

; 148  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 149  :     SYSTEMTIME st;
; 150  :     GetLocalTime(&st);

	lea	eax, DWORD PTR _st$[ebp]
	push	eax
	call	DWORD PTR __imp__GetLocalTime@4

; 151  :     filename.FindReplace(L"$Y", UIntString(st.wYear).Array());

	push	10					; 0000000aH
	movzx	ecx, WORD PTR _st$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T6[ebp]
	push	edx
	call	DWORD PTR __imp_?UIntString@@YA?AVString@@IH@Z
	add	esp, 12					; 0000000cH
	mov	ecx, eax
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	push	OFFSET $SG4294795307
	lea	ecx, DWORD PTR _filename$[ebp]
	call	DWORD PTR __imp_?FindReplace@String@@QAEAAV1@PB_W0@Z
	lea	ecx, DWORD PTR $T6[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 152  :     filename.FindReplace(L"$M", UIntString(st.wMonth).Array());

	push	10					; 0000000aH
	movzx	eax, WORD PTR _st$[ebp+2]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	DWORD PTR __imp_?UIntString@@YA?AVString@@IH@Z
	add	esp, 12					; 0000000cH
	mov	ecx, eax
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	push	OFFSET $SG4294795306
	lea	ecx, DWORD PTR _filename$[ebp]
	call	DWORD PTR __imp_?FindReplace@String@@QAEAAV1@PB_W0@Z
	lea	ecx, DWORD PTR $T1[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 153  :     filename.FindReplace(L"$0M", FormattedString(L"%02u", st.wMonth).Array());

	movzx	edx, WORD PTR _st$[ebp+2]
	push	edx
	push	OFFSET $SG4294795305
	lea	eax, DWORD PTR $T10[ebp]
	push	eax
	call	DWORD PTR __imp_?FormattedString@@YA?AVString@@PB_WZZ
	add	esp, 12					; 0000000cH
	mov	ecx, eax
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	push	OFFSET $SG4294795304
	lea	ecx, DWORD PTR _filename$[ebp]
	call	DWORD PTR __imp_?FindReplace@String@@QAEAAV1@PB_W0@Z
	lea	ecx, DWORD PTR $T10[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 154  :     filename.FindReplace(L"$D", UIntString(st.wDay).Array());

	push	10					; 0000000aH
	movzx	ecx, WORD PTR _st$[ebp+6]
	push	ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	call	DWORD PTR __imp_?UIntString@@YA?AVString@@IH@Z
	add	esp, 12					; 0000000cH
	mov	ecx, eax
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	push	OFFSET $SG4294795303
	lea	ecx, DWORD PTR _filename$[ebp]
	call	DWORD PTR __imp_?FindReplace@String@@QAEAAV1@PB_W0@Z
	lea	ecx, DWORD PTR $T2[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 155  :     filename.FindReplace(L"$0D", FormattedString(L"%02u", st.wDay).Array());

	movzx	eax, WORD PTR _st$[ebp+6]
	push	eax
	push	OFFSET $SG4294795302
	lea	ecx, DWORD PTR $T8[ebp]
	push	ecx
	call	DWORD PTR __imp_?FormattedString@@YA?AVString@@PB_WZZ
	add	esp, 12					; 0000000cH
	mov	ecx, eax
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	push	OFFSET $SG4294795301
	lea	ecx, DWORD PTR _filename$[ebp]
	call	DWORD PTR __imp_?FindReplace@String@@QAEAAV1@PB_W0@Z
	lea	ecx, DWORD PTR $T8[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 156  :     filename.FindReplace(L"$h", UIntString(st.wHour).Array());

	push	10					; 0000000aH
	movzx	edx, WORD PTR _st$[ebp+8]
	push	edx
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	call	DWORD PTR __imp_?UIntString@@YA?AVString@@IH@Z
	add	esp, 12					; 0000000cH
	mov	ecx, eax
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	push	OFFSET $SG4294795300
	lea	ecx, DWORD PTR _filename$[ebp]
	call	DWORD PTR __imp_?FindReplace@String@@QAEAAV1@PB_W0@Z
	lea	ecx, DWORD PTR $T4[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 157  :     filename.FindReplace(L"$0h", FormattedString(L"%02u", st.wHour).Array());

	movzx	ecx, WORD PTR _st$[ebp+8]
	push	ecx
	push	OFFSET $SG4294795299
	lea	edx, DWORD PTR $T12[ebp]
	push	edx
	call	DWORD PTR __imp_?FormattedString@@YA?AVString@@PB_WZZ
	add	esp, 12					; 0000000cH
	mov	ecx, eax
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	push	OFFSET $SG4294795298
	lea	ecx, DWORD PTR _filename$[ebp]
	call	DWORD PTR __imp_?FindReplace@String@@QAEAAV1@PB_W0@Z
	lea	ecx, DWORD PTR $T12[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 158  :     filename.FindReplace(L"$m", UIntString(st.wMinute).Array());

	push	10					; 0000000aH
	movzx	eax, WORD PTR _st$[ebp+10]
	push	eax
	lea	ecx, DWORD PTR $T11[ebp]
	push	ecx
	call	DWORD PTR __imp_?UIntString@@YA?AVString@@IH@Z
	add	esp, 12					; 0000000cH
	mov	ecx, eax
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	push	OFFSET $SG4294795297
	lea	ecx, DWORD PTR _filename$[ebp]
	call	DWORD PTR __imp_?FindReplace@String@@QAEAAV1@PB_W0@Z
	lea	ecx, DWORD PTR $T11[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 159  :     filename.FindReplace(L"$0m", FormattedString(L"%02u", st.wMinute).Array());

	movzx	edx, WORD PTR _st$[ebp+10]
	push	edx
	push	OFFSET $SG4294795296
	lea	eax, DWORD PTR $T9[ebp]
	push	eax
	call	DWORD PTR __imp_?FormattedString@@YA?AVString@@PB_WZZ
	add	esp, 12					; 0000000cH
	mov	ecx, eax
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	push	OFFSET $SG4294795295
	lea	ecx, DWORD PTR _filename$[ebp]
	call	DWORD PTR __imp_?FindReplace@String@@QAEAAV1@PB_W0@Z
	lea	ecx, DWORD PTR $T9[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 160  :     filename.FindReplace(L"$s", UIntString(st.wSecond).Array());

	push	10					; 0000000aH
	movzx	ecx, WORD PTR _st$[ebp+12]
	push	ecx
	lea	edx, DWORD PTR $T7[ebp]
	push	edx
	call	DWORD PTR __imp_?UIntString@@YA?AVString@@IH@Z
	add	esp, 12					; 0000000cH
	mov	ecx, eax
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	push	OFFSET $SG4294795294
	lea	ecx, DWORD PTR _filename$[ebp]
	call	DWORD PTR __imp_?FindReplace@String@@QAEAAV1@PB_W0@Z
	lea	ecx, DWORD PTR $T7[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 161  :     filename.FindReplace(L"$0s", FormattedString(L"%02u", st.wSecond).Array());

	movzx	eax, WORD PTR _st$[ebp+12]
	push	eax
	push	OFFSET $SG4294795293
	lea	ecx, DWORD PTR $T5[ebp]
	push	ecx
	call	DWORD PTR __imp_?FormattedString@@YA?AVString@@PB_WZZ
	add	esp, 12					; 0000000cH
	mov	ecx, eax
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	push	OFFSET $SG4294795292
	lea	ecx, DWORD PTR _filename$[ebp]
	call	DWORD PTR __imp_?FindReplace@String@@QAEAAV1@PB_W0@Z
	lea	ecx, DWORD PTR $T5[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 162  : 
; 163  :     filename.FindReplace(L"$T", FormattedString(L"%u-%02u-%02u-%02u%02u-%02u", st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond).Array());

	movzx	edx, WORD PTR _st$[ebp+12]
	push	edx
	movzx	eax, WORD PTR _st$[ebp+10]
	push	eax
	movzx	ecx, WORD PTR _st$[ebp+8]
	push	ecx
	movzx	edx, WORD PTR _st$[ebp+6]
	push	edx
	movzx	eax, WORD PTR _st$[ebp+2]
	push	eax
	movzx	ecx, WORD PTR _st$[ebp]
	push	ecx
	push	OFFSET $SG4294795291
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	call	DWORD PTR __imp_?FormattedString@@YA?AVString@@PB_WZZ
	add	esp, 32					; 00000020H
	mov	ecx, eax
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	push	OFFSET $SG4294795290
	lea	ecx, DWORD PTR _filename$[ebp]
	call	DWORD PTR __imp_?FindReplace@String@@QAEAAV1@PB_W0@Z
	lea	ecx, DWORD PTR $T3[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 164  :     return filename;

	lea	eax, DWORD PTR _filename$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0String@@QAE@ABV0@@Z
	lea	ecx, DWORD PTR _filename$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 165  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?ExpandRecordingFilename@@YA?AVString@@V1@@Z ENDP	; ExpandRecordingFilename
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obscapture.cpp
;	COMDAT ?GetExpandedRecordingDirectoryBase@@YA?AVString@@V1@@Z
_TEXT	SEGMENT
$T1 = -44						; size = 8
$T2 = -36						; size = 8
$T3 = -28						; size = 8
$T4 = -20						; size = 8
_expanded$ = -12					; size = 8
$T5 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_path$ = 12						; size = 8
?GetExpandedRecordingDirectoryBase@@YA?AVString@@V1@@Z PROC ; GetExpandedRecordingDirectoryBase, COMDAT

; 168  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH

; 169  :     if (GetPathExtension(path))

	lea	ecx, DWORD PTR _path$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	call	DWORD PTR __imp_?GetPathExtension@@YA?AVString@@PB_W@Z
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	mov	DWORD PTR $T5[ebp], eax
	lea	ecx, DWORD PTR $T4[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	cmp	DWORD PTR $T5[ebp], 0
	je	SHORT $LN6@GetExpande

; 170  :         path = GetPathDirectory(path);

	lea	ecx, DWORD PTR _path$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	DWORD PTR __imp_?GetPathDirectory@@YA?AVString@@PB_W@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _path$[ebp]
	call	DWORD PTR __imp_??4String@@QAEAAV0@ABV0@@Z
	lea	ecx, DWORD PTR $T3[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
$LN6@GetExpande:

; 171  : 
; 172  :     String expanded = path;

	lea	edx, DWORD PTR _path$[ebp]
	push	edx
	lea	ecx, DWORD PTR _expanded$[ebp]
	call	DWORD PTR __imp_??0String@@QAE@ABV0@@Z
$LN5@GetExpande:

; 173  :     do
; 174  :     {
; 175  :         expanded = ExpandRecordingFilename(path);

	sub	esp, 8
	mov	ecx, esp
	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	call	DWORD PTR __imp_??0String@@QAE@ABV0@@Z
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	call	?ExpandRecordingFilename@@YA?AVString@@V1@@Z ; ExpandRecordingFilename
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _expanded$[ebp]
	call	DWORD PTR __imp_??4String@@QAEAAV0@ABV0@@Z
	lea	ecx, DWORD PTR $T2[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 176  : 
; 177  :         if (expanded == path)

	lea	edx, DWORD PTR _path$[ebp]
	push	edx
	lea	ecx, DWORD PTR _expanded$[ebp]
	call	DWORD PTR __imp_??8String@@QBEHABV0@@Z
	test	eax, eax
	je	SHORT $LN2@GetExpande

; 178  :             break;

	jmp	SHORT $LN3@GetExpande
$LN2@GetExpande:

; 179  : 
; 180  :         if (OSFileIsDirectory(expanded))

	lea	ecx, DWORD PTR _expanded$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	call	DWORD PTR __imp_?OSFileIsDirectory@@YG_NPB_W@Z
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@GetExpande

; 181  :             break;

	jmp	SHORT $LN3@GetExpande
$LN1@GetExpande:

; 182  : 
; 183  :         path = GetPathDirectory(path);

	lea	ecx, DWORD PTR _path$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	DWORD PTR __imp_?GetPathDirectory@@YA?AVString@@PB_W@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _path$[ebp]
	call	DWORD PTR __imp_??4String@@QAEAAV0@ABV0@@Z
	lea	ecx, DWORD PTR $T1[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 184  :     } while (expanded != path);

	lea	edx, DWORD PTR _path$[ebp]
	push	edx
	lea	ecx, DWORD PTR _expanded$[ebp]
	call	DWORD PTR __imp_??9String@@QBEHABV0@@Z
	test	eax, eax
	jne	$LN5@GetExpande
$LN3@GetExpande:

; 185  : 
; 186  :     CreatePath(expanded);

	lea	ecx, DWORD PTR _expanded$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	call	DWORD PTR __imp_?CreatePath@@YAHPB_W@Z
	add	esp, 4

; 187  : 
; 188  :     return expanded;

	lea	eax, DWORD PTR _expanded$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0String@@QAE@ABV0@@Z
	lea	ecx, DWORD PTR _expanded$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _path$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 189  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetExpandedRecordingDirectoryBase@@YA?AVString@@V1@@Z ENDP ; GetExpandedRecordingDirectoryBase
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obscapture.cpp
;	COMDAT ?StartRecording@OBS@@AAE_N_N@Z
_TEXT	SEGMENT
$T1 = -36						; size = 8
_strOutputFile$ = -28					; size = 8
_networkMode$ = -20					; size = 4
tv89 = -16						; size = 4
tv81 = -12						; size = 4
_this$ = -8						; size = 4
$T2 = -3						; size = 1
_saveToFile$ = -2					; size = 1
_success$ = -1						; size = 1
_force$ = 8						; size = 1
?StartRecording@OBS@@AAE_N_N@Z PROC			; OBS::StartRecording, COMDAT
; _this$ = ecx

; 270  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 271  :     if (!bRunning || bRecording) return true;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+622]
	test	ecx, ecx
	je	SHORT $LN6@StartRecor
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+623]
	test	eax, eax
	je	SHORT $LN7@StartRecor
$LN6@StartRecor:
	mov	al, 1
	jmp	$LN8@StartRecor
$LN7@StartRecor:

; 272  :     int networkMode = AppConfig->GetInt(TEXT("Publish"), TEXT("Mode"), 2);

	push	2
	push	OFFSET $SG4294795273
	push	OFFSET $SG4294795272
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	mov	DWORD PTR _networkMode$[ebp], eax

; 273  :     bool saveToFile = AppConfig->GetInt(L"Publish", L"SaveToFile") != 0;

	push	0
	push	OFFSET $SG4294795271
	push	OFFSET $SG4294795270
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	test	eax, eax
	je	SHORT $LN10@StartRecor
	mov	DWORD PTR tv81[ebp], 1
	jmp	SHORT $LN11@StartRecor
$LN10@StartRecor:
	mov	DWORD PTR tv81[ebp], 0
$LN11@StartRecor:
	mov	cl, BYTE PTR tv81[ebp]
	mov	BYTE PTR _saveToFile$[ebp], cl

; 274  : 
; 275  :     bWriteToFile = force || networkMode == 1 || saveToFile;

	movzx	edx, BYTE PTR _force$[ebp]
	test	edx, edx
	jne	SHORT $LN12@StartRecor
	cmp	DWORD PTR _networkMode$[ebp], 1
	je	SHORT $LN12@StartRecor
	movzx	eax, BYTE PTR _saveToFile$[ebp]
	test	eax, eax
	jne	SHORT $LN12@StartRecor
	mov	DWORD PTR tv89[ebp], 0
	jmp	SHORT $LN13@StartRecor
$LN12@StartRecor:
	mov	DWORD PTR tv89[ebp], 1
$LN13@StartRecor:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR tv89[ebp]
	mov	BYTE PTR [ecx+1025], dl

; 276  : 
; 277  :     // Don't request a keyframe while everything is starting up for the first time
; 278  :     if(!bStartingUp) videoEncoder->RequestKeyframe();

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+626]
	test	ecx, ecx
	jne	SHORT $LN5@StartRecor
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+148]
	mov	eax, DWORD PTR [edx+32]
	call	eax
$LN5@StartRecor:

; 279  : 
; 280  :     String strOutputFile;

	lea	ecx, DWORD PTR _strOutputFile$[ebp]
	call	DWORD PTR __imp_??0String@@QAE@XZ

; 281  :     if (bWriteToFile)

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+1025]
	test	edx, edx
	je	SHORT $LN4@StartRecor

; 282  : 		//
; 283  :         strOutputFile = GetOutputFilename();

	push	0
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	?GetOutputFilename@@YA?AVString@@_N@Z	; GetOutputFilename
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strOutputFile$[ebp]
	call	DWORD PTR __imp_??4String@@QAEAAV0@ABV0@@Z
	lea	ecx, DWORD PTR $T1[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
$LN4@StartRecor:

; 284  : 
; 285  :     bool success = true;

	mov	BYTE PTR _success$[ebp], 1

; 286  :     if(!bTestStream && bWriteToFile && strOutputFile.IsValid())

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+620]
	test	edx, edx
	jne	$LN3@StartRecor
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+1025]
	test	ecx, ecx
	je	$LN3@StartRecor
	lea	ecx, DWORD PTR _strOutputFile$[ebp]
	call	DWORD PTR __imp_?IsValid@String@@QBEHXZ
	test	eax, eax
	je	$LN3@StartRecor

; 287  :     {
; 288  :         fileStream.reset(CreateFileStream(strOutputFile));

	sub	esp, 8
	mov	ecx, esp
	lea	edx, DWORD PTR _strOutputFile$[ebp]
	push	edx
	call	DWORD PTR __imp_??0String@@QAE@ABV0@@Z
	call	?CreateFileStream@@YAPAVVideoFileStream@@VString@@@Z ; CreateFileStream
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1028				; 00000404H
	call	?reset@?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@QAEXPAVVideoFileStream@@@Z ; std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> >::reset

; 289  : 
; 290  :         if(!fileStream)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1028				; 00000404H
	call	??B?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@QBE_NXZ ; std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> >::operator bool
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@StartRecor

; 291  :         {
; 292  :             Log(TEXT("Warning - OBSCapture::Start: Unable to create the file stream. Check the file path in Broadcast Settings."));

	push	OFFSET $SG4294795269
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 4

; 293  :             OBSMessageBox(hwndMain, Str("Capture.Start.FileStream.Warning"), Str("Capture.Start.FileStream.WarningCaption"), MB_OK | MB_ICONWARNING);        

	push	48					; 00000030H
	push	OFFSET $SG4294795268
	mov	ecx, DWORD PTR __imp_?locale@@3PAVLocaleStringLookup@@A
	mov	ecx, DWORD PTR [ecx]
	call	DWORD PTR __imp_?LookupString@LocaleStringLookup@@QAEPB_WPB_W@Z
	push	eax
	push	OFFSET $SG4294795267
	mov	edx, DWORD PTR __imp_?locale@@3PAVLocaleStringLookup@@A
	mov	ecx, DWORD PTR [edx]
	call	DWORD PTR __imp_?LookupString@LocaleStringLookup@@QAEPB_WPB_W@Z
	push	eax
	mov	eax, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	eax
	call	DWORD PTR __imp_?OBSMessageBox@@YAHPAUHWND__@@PB_W1I@Z
	add	esp, 16					; 00000010H

; 294  :             bRecording = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+623], 0

; 295  :             success = false;

	mov	BYTE PTR _success$[ebp], 0

; 296  :         }
; 297  :         else {

	jmp	SHORT $LN1@StartRecor
$LN2@StartRecor:

; 298  :             bRecording = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+623], 1

; 299  :             ReportStartRecordingTrigger();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+84]
	call	eax

; 300  :             lastOutputFile = strOutputFile;

	lea	ecx, DWORD PTR _strOutputFile$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1336				; 00000538H
	call	DWORD PTR __imp_??4String@@QAEAAV0@ABV0@@Z
$LN1@StartRecor:

; 301  :         }
; 302  :         ConfigureStreamButtons();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ConfigureStreamButtons@OBS@@AAEXXZ	; OBS::ConfigureStreamButtons
$LN3@StartRecor:

; 303  :     }
; 304  :     return success;

	mov	dl, BYTE PTR _success$[ebp]
	mov	BYTE PTR $T2[ebp], dl
	lea	ecx, DWORD PTR _strOutputFile$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	al, BYTE PTR $T2[ebp]
$LN8@StartRecor:

; 305  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?StartRecording@OBS@@AAE_N_N@Z ENDP			; OBS::StartRecording
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obscapture.cpp
;	COMDAT ?StopRecording@OBS@@AAEX_N@Z
_TEXT	SEGMENT
_shutdown$ = -8						; size = 4
_this$ = -4						; size = 4
_immediate$ = 8						; size = 1
?StopRecording@OBS@@AAEX_N@Z PROC			; OBS::StopRecording, COMDAT
; _this$ = ecx

; 308  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 309  :     if (!bStreaming && !bRecordingReplayBuffer && bRunning && bRecording) Stop(true);

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+627]
	test	ecx, ecx
	jne	SHORT $LN4@StopRecord
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+624]
	test	eax, eax
	jne	SHORT $LN4@StopRecord
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+622]
	test	edx, edx
	je	SHORT $LN4@StopRecord
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+623]
	test	ecx, ecx
	je	SHORT $LN4@StopRecord
	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Stop@OBS@@AAEX_N0@Z			; OBS::Stop
$LN4@StopRecord:

; 310  : 
; 311  :     if(!bRecording) return;

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+623]
	test	eax, eax
	jne	SHORT $LN3@StopRecord
	jmp	SHORT $LN5@StopRecord
$LN3@StopRecord:

; 312  : 
; 313  :     // Prevent the encoder thread from trying to write to fileStream while it's closing
; 314  : 
; 315  :     if (!immediate && fileStreamStop.func)

	movzx	ecx, BYTE PTR _immediate$[ebp]
	test	ecx, ecx
	jne	SHORT $LN2@StopRecord
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1040				; 00000410H
	call	??B?$function@$$A6AXXZ@std@@QBE_NXZ	; std::function<void __cdecl(void)>::operator bool
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN2@StopRecord

; 316  :         return;

	jmp	SHORT $LN5@StopRecord
$LN2@StopRecord:

; 317  : 
; 318  :     auto shutdown = [this]()
; 319  :     {
; 320  :         AddPendingStream(fileStream.release());
; 321  : 
; 322  :         bRecording = false;
; 323  : 
; 324  :         ReportStopRecordingTrigger();
; 325  : 
; 326  :         ConfigureStreamButtons();
; 327  : 
; 328  :         if (!bStreaming && !bRecordingReplayBuffer && bRunning && !bRecording) PostStopMessage(true);
; 329  :     };

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR _shutdown$[ebp]
	call	??0<lambda_e856d28dddb7588070dd099cfda6c634>@@QAE@PAVOBS@@@Z ; <lambda_e856d28dddb7588070dd099cfda6c634>::<lambda_e856d28dddb7588070dd099cfda6c634>

; 330  : 
; 331  :     if (immediate)

	movzx	ecx, BYTE PTR _immediate$[ebp]
	test	ecx, ecx
	je	SHORT $LN1@StopRecord

; 332  :         return shutdown();

	lea	ecx, DWORD PTR _shutdown$[ebp]
	call	??R<lambda_e856d28dddb7588070dd099cfda6c634>@@QBEXXZ ; <lambda_e856d28dddb7588070dd099cfda6c634>::operator()
	jmp	SHORT $LN5@StopRecord
$LN1@StopRecord:

; 333  : 
; 334  :     fileStreamStop.func = shutdown;

	lea	edx, DWORD PTR _shutdown$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1040				; 00000410H
	call	??$?4AAV<lambda_e856d28dddb7588070dd099cfda6c634>@@@?$function@$$A6AXXZ@std@@QAEAAV01@AAV<lambda_e856d28dddb7588070dd099cfda6c634>@@@Z ; std::function<void __cdecl(void)>::operator=<<lambda_e856d28dddb7588070dd099cfda6c634> &>

; 335  : 
; 336  :     fileStreamStop.time = (DWORD)(GetVideoTime() - firstFrameTimestamp);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetVideoTime@OBS@@QBE_KXZ		; OBS::GetVideoTime
	mov	ecx, DWORD PTR _this$[ebp]
	sub	eax, DWORD PTR [ecx+1112]
	sbb	edx, DWORD PTR [ecx+1116]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1032], eax
$LN5@StopRecord:

; 337  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?StopRecording@OBS@@AAEX_N@Z ENDP			; OBS::StopRecording
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obscapture.cpp
;	COMDAT ??0<lambda_e856d28dddb7588070dd099cfda6c634>@@QAE@PAVOBS@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__This$ = 8						; size = 4
??0<lambda_e856d28dddb7588070dd099cfda6c634>@@QAE@PAVOBS@@@Z PROC ; <lambda_e856d28dddb7588070dd099cfda6c634>::<lambda_e856d28dddb7588070dd099cfda6c634>, COMDAT
; _this$ = ecx

; 329  :     };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __This$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0<lambda_e856d28dddb7588070dd099cfda6c634>@@QAE@PAVOBS@@@Z ENDP ; <lambda_e856d28dddb7588070dd099cfda6c634>::<lambda_e856d28dddb7588070dd099cfda6c634>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obscapture.cpp
;	COMDAT ??R<lambda_e856d28dddb7588070dd099cfda6c634>@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??R<lambda_e856d28dddb7588070dd099cfda6c634>@@QBEXXZ PROC ; <lambda_e856d28dddb7588070dd099cfda6c634>::operator(), COMDAT
; _this$ = ecx

; 319  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 320  :         AddPendingStream(fileStream.release());

	sub	esp, 24					; 00000018H
	mov	ecx, esp
	push	0
	call	??0?$function@$$A6AXXZ@std@@QAE@$$T@Z	; std::function<void __cdecl(void)>::function<void __cdecl(void)>
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1028				; 00000404H
	call	?release@?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@QAEPAVVideoFileStream@@XZ ; std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> >::release
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z ; OBS::AddPendingStream

; 321  : 
; 322  :         bRecording = false;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	BYTE PTR [eax+623], 0

; 323  : 
; 324  :         ReportStopRecordingTrigger();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+88]
	call	eax

; 325  : 
; 326  :         ConfigureStreamButtons();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?ConfigureStreamButtons@OBS@@AAEXXZ	; OBS::ConfigureStreamButtons

; 327  : 
; 328  :         if (!bStreaming && !bRecordingReplayBuffer && bRunning && !bRecording) PostStopMessage(true);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	movzx	ecx, BYTE PTR [eax+627]
	test	ecx, ecx
	jne	SHORT $LN2@operator
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	movzx	ecx, BYTE PTR [eax+624]
	test	ecx, ecx
	jne	SHORT $LN2@operator
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	movzx	ecx, BYTE PTR [eax+622]
	test	ecx, ecx
	je	SHORT $LN2@operator
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	movzx	ecx, BYTE PTR [eax+623]
	test	ecx, ecx
	jne	SHORT $LN2@operator
	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?PostStopMessage@OBS@@QAEX_N@Z		; OBS::PostStopMessage
$LN2@operator:

; 329  :     };

	mov	esp, ebp
	pop	ebp
	ret	0
??R<lambda_e856d28dddb7588070dd099cfda6c634>@@QBEXXZ ENDP ; <lambda_e856d28dddb7588070dd099cfda6c634>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obscapture.cpp
;	COMDAT ?Start@OBS@@AAEX_N0@Z
_TEXT	SEGMENT
$T1 = -508						; size = 8
$T2 = -500						; size = 8
$T3 = -492						; size = 8
$T4 = -484						; size = 8
$T5 = -476						; size = 8
_className$6 = -468					; size = 8
$T7 = -460						; size = 8
$T8 = -452						; size = 8
_err$9 = -444						; size = 4
tv822 = -440						; size = 4
tv621 = -436						; size = 4
tv809 = -432						; size = 4
_numScenes$10 = -428					; size = 4
_isStereo$ = -424					; size = 4
_numSources$11 = -420					; size = 4
_sceneElement$12 = -416					; size = 4
_numSources$13 = -412					; size = 4
$T14 = -408						; size = 4
_globalSourceName$15 = -404				; size = 8
_defCX$ = -396						; size = 4
_globalSourceData$16 = -392				; size = 4
_defCY$ = -388						; size = 4
_strEncoder$ = -384					; size = 8
$T17 = -376						; size = 4
_strDefaultMic$ = -372					; size = 8
_offset$18 = -364					; size = 4
_vencoder$ = -360					; size = 8
_bitRate$ = -352					; size = 4
tv514 = -348						; size = 4
_format$ = -344						; size = 4
tv513 = -340						; size = 4
tv1700 = -336						; size = 4
tv508 = -332						; size = 4
tv1018 = -328						; size = 4
tv424 = -324						; size = 4
tv845 = -320						; size = 4
tv378 = -316						; size = 4
_ret$19 = -312						; size = 4
tv371 = -308						; size = 4
tv553 = -304						; size = 4
tv355 = -300						; size = 4
tv519 = -296						; size = 4
_sources$20 = -292					; size = 4
_isAAC$ = -288						; size = 4
_ret$21 = -284						; size = 4
tv999 = -280						; size = 4
tv524 = -276						; size = 4
tv961 = -272						; size = 4
tv1333 = -268						; size = 4
tv148 = -264						; size = 4
tv1322 = -260						; size = 4
tv749 = -256						; size = 4
tv1305 = -252						; size = 4
tv591 = -248						; size = 4
tv1287 = -244						; size = 4
tv558 = -240						; size = 4
tv1202 = -236						; size = 4
tv1711 = -232						; size = 4
_source$22 = -228					; size = 4
tv525 = -224						; size = 4
tv1175 = -220						; size = 4
_item$23 = -216						; size = 4
tv839 = -212						; size = 4
_strError$ = -208					; size = 8
_audioDevices$ = -200					; size = 8
_playbackDevices$ = -192				; size = 8
_preset$ = -184						; size = 8
tv664 = -176						; size = 4
_sources$24 = -172					; size = 4
$T25 = -168						; size = 4
_monitorID$ = -164					; size = 4
tv1461 = -160						; size = 4
_quality$ = -156					; size = 4
_scenes$26 = -152					; size = 4
_strPlaybackDevice$ = -148				; size = 8
_processPriority$ = -140				; size = 8
_maxBitRate$ = -132					; size = 4
_strPatchesError$ = -128				; size = 8
_i$27 = -120						; size = 4
_screenRect$ = -116					; size = 4
_i$28 = -112						; size = 4
_delayTime$ = -108					; size = 4
_bufferSize$ = -104					; size = 4
_videoEncoderErrors$ = -100				; size = 8
_strDevice$ = -92					; size = 8
$T29 = -84						; size = 4
_i$30 = -80						; size = 4
_i$31 = -76						; size = 4
_i$32 = -72						; size = 4
_networkMode$ = -68					; size = 4
_lpShader$ = -64					; size = 4
_bHasDefault$ = -59					; size = 1
$T33 = -58						; size = 1
_alreadyWarnedAboutModules$ = -57			; size = 1
_useInputDevices$ = -56					; size = 1
_foundSource$34 = -55					; size = 1
_bUseDefault$35 = -54					; size = 1
_bDisableEncoding$ = -53				; size = 1
_this$ = -52						; size = 4
_td$ = -48						; size = 44
__$ArrayPad$ = -4					; size = 4
_recordingOnly$ = 8					; size = 1
_replayBufferOnly$ = 12					; size = 1
?Start@OBS@@AAEX_N0@Z PROC				; OBS::Start, COMDAT
; _this$ = ecx

; 340  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 508				; 000001fcH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T29[ebp], 0

; 341  : 	//bRunning is a flag determine whethore already run
; 342  :     if(bRunning && !bRecording && !bRecordingReplayBuffer) return;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+622]
	test	ecx, ecx
	je	SHORT $LN118@Start
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+623]
	test	eax, eax
	jne	SHORT $LN118@Start
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+624]
	test	edx, edx
	jne	SHORT $LN118@Start
	jmp	$LN119@Start
$LN118@Start:

; 343  : 
; 344  :     int networkMode = AppConfig->GetInt(TEXT("Publish"), TEXT("Mode"), 2);

	push	2
	push	OFFSET $SG4294795266
	push	OFFSET $SG4294795265
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	mov	DWORD PTR _networkMode$[ebp], eax

; 345  :     DWORD delayTime = (DWORD)AppConfig->GetInt(TEXT("Publish"), TEXT("Delay"));

	push	0
	push	OFFSET $SG4294795264
	push	OFFSET $SG4294795263
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	mov	DWORD PTR _delayTime$[ebp], eax

; 346  : 
; 347  :     if (bRecording && networkMode != 0) return;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+623]
	test	ecx, ecx
	je	SHORT $LN117@Start
	cmp	DWORD PTR _networkMode$[ebp], 0
	je	SHORT $LN117@Start
	jmp	$LN119@Start
$LN117@Start:

; 348  : 
; 349  :     if (!bRunning && !bStreamFlushed && !recordingOnly && !replayBufferOnly) return;

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+622]
	test	eax, eax
	jne	SHORT $LN116@Start
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+628]
	test	edx, edx
	jne	SHORT $LN116@Start
	movzx	eax, BYTE PTR _recordingOnly$[ebp]
	test	eax, eax
	jne	SHORT $LN116@Start
	movzx	ecx, BYTE PTR _replayBufferOnly$[ebp]
	test	ecx, ecx
	jne	SHORT $LN116@Start
	jmp	$LN119@Start
$LN116@Start:

; 350  : 
; 351  :     if((bRecording || bRecordingReplayBuffer) && networkMode == 0 && delayTime == 0 && !recordingOnly && !replayBufferOnly && bStreamFlushed) {

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+623]
	test	eax, eax
	jne	SHORT $LN114@Start
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+624]
	test	edx, edx
	je	$LN115@Start
$LN114@Start:
	cmp	DWORD PTR _networkMode$[ebp], 0
	jne	$LN115@Start
	cmp	DWORD PTR _delayTime$[ebp], 0
	jne	$LN115@Start
	movzx	eax, BYTE PTR _recordingOnly$[ebp]
	test	eax, eax
	jne	$LN115@Start
	movzx	ecx, BYTE PTR _replayBufferOnly$[ebp]
	test	ecx, ecx
	jne	$LN115@Start
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+628]
	test	eax, eax
	je	$LN115@Start

; 352  :         bFirstConnect = !bReconnecting;

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+697]
	test	edx, edx
	jne	SHORT $LN121@Start
	mov	DWORD PTR tv148[ebp], 1
	jmp	SHORT $LN122@Start
$LN121@Start:
	mov	DWORD PTR tv148[ebp], 0
$LN122@Start:
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR tv148[ebp]
	mov	BYTE PTR [eax+932], cl

; 353  :         
; 354  :         network.reset(CreateRTMPPublisher());

	call	?CreateRTMPPublisher@@YAPAVNetworkStream@@XZ ; CreateRTMPPublisher
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 76					; 0000004cH
	call	?reset@?$unique_ptr@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@@std@@QAEXPAVNetworkStream@@@Z ; std::unique_ptr<NetworkStream,std::default_delete<NetworkStream> >::reset

; 355  : 
; 356  :         Log(TEXT("=====Stream Start (while recording): %s============================="), CurrentDateTimeString().Array());

	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	call	DWORD PTR __imp_?CurrentDateTimeString@@YA?AVString@@XZ
	add	esp, 4
	mov	ecx, eax
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	push	OFFSET $SG4294795262
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 8
	lea	ecx, DWORD PTR $T2[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 357  : 
; 358  :         bSentHeaders = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+989], 0

; 359  :         bStreaming = true;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+627], 1

; 360  : 
; 361  :         ReportStartStreamingTrigger();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+76]
	call	edx

; 362  :         ConfigureStreamButtons();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ConfigureStreamButtons@OBS@@AAEXXZ	; OBS::ConfigureStreamButtons

; 363  :         return;

	jmp	$LN119@Start
$LN115@Start:

; 364  :     }
; 365  : 
; 366  :     bStartingUp = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+626], 1

; 367  : 
; 368  :     OSEnterMutex(hStartupShutdownMutex);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1400]
	push	edx
	call	DWORD PTR __imp_?OSEnterMutex@@YGXPAX@Z

; 369  : 
; 370  :    // DisableMenusWhileStreaming(true);
; 371  : 
; 372  :     scenesConfig.SaveTo(String() << lpAppDataPath << "\\scenes.xconfig");

	push	OFFSET $SG4294795261
	lea	ecx, DWORD PTR $T8[ebp]
	call	DWORD PTR __imp_??0String@@QAE@PBD@Z
	lea	eax, DWORD PTR $T8[ebp]
	push	eax
	push	OFFSET ?lpAppDataPath@@3PA_WA		; lpAppDataPath
	lea	ecx, DWORD PTR $T1[ebp]
	call	DWORD PTR __imp_??0String@@QAE@XZ
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@ABV0@@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 168				; 000000a8H
	call	DWORD PTR __imp_?SaveTo@XConfig@@QAEXPB_W@Z
	lea	ecx, DWORD PTR $T1[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR $T8[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 373  :     scenesConfig.Save();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 168				; 000000a8H
	call	DWORD PTR __imp_?Save@XConfig@@QAEXXZ

; 374  : 
; 375  :     //-------------------------------------------------------------
; 376  : 
; 377  :     fps = AppConfig->GetInt(TEXT("Video"), TEXT("FPS"), 30);

	push	30					; 0000001eH
	push	OFFSET $SG4294795260
	push	OFFSET $SG4294795259
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+892], eax

; 378  :     frameTime = 1000/fps;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, 1000				; 000003e8H
	xor	edx, edx
	div	DWORD PTR [ecx+892]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+888], eax

; 379  : 
; 380  :     //-------------------------------------------------------------
; 381  : 
; 382  :     if(!bLoggedSystemStats)

	cmp	DWORD PTR ?bLoggedSystemStats@@3HA, 0	; bLoggedSystemStats
	jne	SHORT $LN113@Start

; 383  :     {
; 384  :         LogSystemStats();

	call	?LogSystemStats@@YAXXZ			; LogSystemStats

; 385  :         bLoggedSystemStats = TRUE;

	mov	DWORD PTR ?bLoggedSystemStats@@3HA, 1	; bLoggedSystemStats
$LN113@Start:

; 386  :     }
; 387  : 	//check dll haha
; 388  :     OSCheckForBuggyDLLs();

	call	DWORD PTR __imp_?OSCheckForBuggyDLLs@@YGXXZ
$retryHookTest$172:

; 389  : 
; 390  :     //-------------------------------------------------------------
; 391  : retryHookTest:
; 392  :     bool alreadyWarnedAboutModules = false;

	mov	BYTE PTR _alreadyWarnedAboutModules$[ebp], 0

; 393  :     if (OSIncompatibleModulesLoaded())

	call	DWORD PTR __imp_?OSIncompatibleModulesLoaded@@YGHXZ
	test	eax, eax
	je	SHORT $LN112@Start

; 394  :     {
; 395  :         Log(TEXT("Incompatible modules (pre-D3D) detected."));

	push	OFFSET $SG4294795258
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 4

; 396  :         int ret = OBSMessageBox(hwndMain, Str("IncompatibleModules"), NULL, MB_ICONERROR | MB_ABORTRETRYIGNORE);

	push	18					; 00000012H
	push	0
	push	OFFSET $SG4294795257
	mov	eax, DWORD PTR __imp_?locale@@3PAVLocaleStringLookup@@A
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR __imp_?LookupString@LocaleStringLookup@@QAEPB_WPB_W@Z
	push	eax
	mov	ecx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	ecx
	call	DWORD PTR __imp_?OBSMessageBox@@YAHPAUHWND__@@PB_W1I@Z
	add	esp, 16					; 00000010H
	mov	DWORD PTR _ret$21[ebp], eax

; 397  :         if (ret == IDABORT)

	cmp	DWORD PTR _ret$21[ebp], 3
	jne	SHORT $LN111@Start

; 398  :         {
; 399  :            // DisableMenusWhileStreaming(false);
; 400  :             OSLeaveMutex (hStartupShutdownMutex);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1400]
	push	eax
	call	DWORD PTR __imp_?OSLeaveMutex@@YGXPAX@Z

; 401  :             bStartingUp = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+626], 0

; 402  :             return;

	jmp	$LN119@Start
	jmp	SHORT $LN109@Start
$LN111@Start:

; 403  :         }
; 404  :         else if (ret == IDRETRY)

	cmp	DWORD PTR _ret$21[ebp], 4
	jne	SHORT $LN109@Start

; 405  :         {
; 406  :             goto retryHookTest;

	jmp	SHORT $retryHookTest$172
$LN109@Start:

; 407  :         }
; 408  : 
; 409  :         alreadyWarnedAboutModules = true;

	mov	BYTE PTR _alreadyWarnedAboutModules$[ebp], 1
$LN112@Start:

; 410  :     }
; 411  : 
; 412  :     String strPatchesError;

	lea	ecx, DWORD PTR _strPatchesError$[ebp]
	call	DWORD PTR __imp_??0String@@QAE@XZ

; 413  :     if (OSIncompatiblePatchesLoaded(strPatchesError))

	lea	edx, DWORD PTR _strPatchesError$[ebp]
	push	edx
	call	DWORD PTR __imp_?OSIncompatiblePatchesLoaded@@YGHAAVString@@@Z
	test	eax, eax
	je	SHORT $LN108@Start

; 414  :     {
; 415  :        // DisableMenusWhileStreaming(false);
; 416  :         OSLeaveMutex (hStartupShutdownMutex);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1400]
	push	ecx
	call	DWORD PTR __imp_?OSLeaveMutex@@YGXPAX@Z

; 417  :         OBSMessageBox(hwndMain, strPatchesError.Array(), NULL, MB_ICONERROR);

	push	16					; 00000010H
	push	0
	lea	ecx, DWORD PTR _strPatchesError$[ebp]
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	mov	edx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	edx
	call	DWORD PTR __imp_?OBSMessageBox@@YAHPAUHWND__@@PB_W1I@Z
	add	esp, 16					; 00000010H

; 418  :         Log(TEXT("Incompatible patches detected."));

	push	OFFSET $SG4294795256
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 4

; 419  :         bStartingUp = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+626], 0

; 420  :         return;

	lea	ecx, DWORD PTR _strPatchesError$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	jmp	$LN119@Start
$LN108@Start:

; 421  :     }
; 422  : 
; 423  :     //check the user isn't trying to stream or record with no sources which is typically
; 424  :     //a configuration error
; 425  :     if (!bTestStream)

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+620]
	test	edx, edx
	jne	$LN100@Start

; 426  :     {
; 427  :         bool foundSource = false;

	mov	BYTE PTR _foundSource$34[ebp], 0

; 428  :         XElement *scenes = App->scenesConfig.GetElement(TEXT("scenes"));

	push	OFFSET $SG4294795255
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	add	ecx, 168				; 000000a8H
	call	DWORD PTR __imp_?GetElement@XConfig@@QAEPAVXElement@@PB_W@Z
	mov	DWORD PTR _scenes$26[ebp], eax

; 429  :         if (scenes)

	cmp	DWORD PTR _scenes$26[ebp], 0
	je	$LN103@Start

; 430  :         {
; 431  :             UINT numScenes = scenes->NumElements();

	push	0
	mov	ecx, DWORD PTR _scenes$26[ebp]
	call	DWORD PTR __imp_?NumElements@XElement@@QAEKPB_W@Z
	mov	DWORD PTR _numScenes$10[ebp], eax

; 432  : 
; 433  :             for (UINT i = 0; i<numScenes; i++)

	mov	DWORD PTR _i$28[ebp], 0
	jmp	SHORT $LN105@Start
$LN104@Start:
	mov	eax, DWORD PTR _i$28[ebp]
	add	eax, 1
	mov	DWORD PTR _i$28[ebp], eax
$LN105@Start:
	mov	ecx, DWORD PTR _i$28[ebp]
	cmp	ecx, DWORD PTR _numScenes$10[ebp]
	jae	SHORT $LN103@Start

; 434  :             {
; 435  :                 XElement *sceneElement = scenes->GetElementByID(i);

	mov	edx, DWORD PTR _i$28[ebp]
	push	edx
	mov	ecx, DWORD PTR _scenes$26[ebp]
	call	DWORD PTR __imp_?GetElementByID@XElement@@QBEPAV1@K@Z
	mov	DWORD PTR _sceneElement$12[ebp], eax

; 436  :                 XElement *sources = sceneElement->GetElement(TEXT("sources"));

	push	OFFSET $SG4294795254
	mov	ecx, DWORD PTR _sceneElement$12[ebp]
	call	DWORD PTR __imp_?GetElement@XElement@@QBEPAV1@PB_W@Z
	mov	DWORD PTR _sources$20[ebp], eax

; 437  :                 if (sources && sources->NumElements())

	cmp	DWORD PTR _sources$20[ebp], 0
	je	SHORT $LN102@Start
	push	0
	mov	ecx, DWORD PTR _sources$20[ebp]
	call	DWORD PTR __imp_?NumElements@XElement@@QAEKPB_W@Z
	test	eax, eax
	je	SHORT $LN102@Start

; 438  :                 {
; 439  :                     foundSource = true;

	mov	BYTE PTR _foundSource$34[ebp], 1

; 440  :                     break;

	jmp	SHORT $LN103@Start
$LN102@Start:

; 441  :                 }
; 442  :             }

	jmp	SHORT $LN104@Start
$LN103@Start:

; 443  :         }
; 444  : 
; 445  :         if (!foundSource)

	movzx	eax, BYTE PTR _foundSource$34[ebp]
	test	eax, eax
	jne	SHORT $LN100@Start

; 446  :         {
; 447  :             if (OBSMessageBox(hwndMain, Str("NoSourcesFound"), NULL, MB_ICONWARNING|MB_YESNO) == IDNO)

	push	52					; 00000034H
	push	0
	push	OFFSET $SG4294795253
	mov	ecx, DWORD PTR __imp_?locale@@3PAVLocaleStringLookup@@A
	mov	ecx, DWORD PTR [ecx]
	call	DWORD PTR __imp_?LookupString@LocaleStringLookup@@QAEPB_WPB_W@Z
	push	eax
	mov	edx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	edx
	call	DWORD PTR __imp_?OBSMessageBox@@YAHPAUHWND__@@PB_W1I@Z
	add	esp, 16					; 00000010H
	cmp	eax, 7
	jne	SHORT $LN100@Start

; 448  :             {
; 449  :                // DisableMenusWhileStreaming(false);
; 450  :                 OSLeaveMutex(hStartupShutdownMutex);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1400]
	push	ecx
	call	DWORD PTR __imp_?OSLeaveMutex@@YGXPAX@Z

; 451  :                 bStartingUp = false;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+626], 0

; 452  :                 return;

	lea	ecx, DWORD PTR _strPatchesError$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	jmp	$LN119@Start
$LN100@Start:

; 453  :             }
; 454  :         }
; 455  :     }
; 456  : 
; 457  :     //-------------------------------------------------------------
; 458  : 
; 459  :     String processPriority = AppConfig->GetString(TEXT("General"), TEXT("Priority"), TEXT("Normal"));

	push	OFFSET $SG4294795252
	push	OFFSET $SG4294795251
	push	OFFSET $SG4294795250
	lea	eax, DWORD PTR _processPriority$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetString@ConfigFile@@QAE?AVString@@PB_W00@Z

; 460  :     if (!scmp(processPriority, TEXT("Idle")))

	push	OFFSET $SG4294795249
	lea	ecx, DWORD PTR _processPriority$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	call	DWORD PTR __imp_?scmp@@YGHPB_W0@Z
	test	eax, eax
	jne	SHORT $LN99@Start

; 461  :         SetPriorityClass(GetCurrentProcess(), IDLE_PRIORITY_CLASS);

	push	64					; 00000040H
	call	DWORD PTR __imp__GetCurrentProcess@0
	push	eax
	call	DWORD PTR __imp__SetPriorityClass@8
	jmp	SHORT $LN95@Start
$LN99@Start:

; 462  :     else if (!scmp(processPriority, TEXT("Above Normal")))

	push	OFFSET $SG4294795248
	lea	ecx, DWORD PTR _processPriority$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	call	DWORD PTR __imp_?scmp@@YGHPB_W0@Z
	test	eax, eax
	jne	SHORT $LN97@Start

; 463  :         SetPriorityClass(GetCurrentProcess(), ABOVE_NORMAL_PRIORITY_CLASS);

	push	32768					; 00008000H
	call	DWORD PTR __imp__GetCurrentProcess@0
	push	eax
	call	DWORD PTR __imp__SetPriorityClass@8
	jmp	SHORT $LN95@Start
$LN97@Start:

; 464  :     else if (!scmp(processPriority, TEXT("High")))

	push	OFFSET $SG4294795247
	lea	ecx, DWORD PTR _processPriority$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	call	DWORD PTR __imp_?scmp@@YGHPB_W0@Z
	test	eax, eax
	jne	SHORT $LN95@Start

; 465  :         SetPriorityClass(GetCurrentProcess(), HIGH_PRIORITY_CLASS);

	push	128					; 00000080H
	call	DWORD PTR __imp__GetCurrentProcess@0
	push	eax
	call	DWORD PTR __imp__SetPriorityClass@8
$LN95@Start:

; 466  : 
; 467  :     networkMode = AppConfig->GetInt(TEXT("Publish"), TEXT("Mode"), 2);

	push	2
	push	OFFSET $SG4294795246
	push	OFFSET $SG4294795245
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	mov	DWORD PTR _networkMode$[ebp], eax

; 468  :     delayTime = (DWORD)AppConfig->GetInt(TEXT("Publish"), TEXT("Delay"));

	push	0
	push	OFFSET $SG4294795244
	push	OFFSET $SG4294795243
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	mov	DWORD PTR _delayTime$[ebp], eax

; 469  : 
; 470  :     String strError;

	lea	ecx, DWORD PTR _strError$[ebp]
	call	DWORD PTR __imp_??0String@@QAE@XZ

; 471  : 
; 472  :     bFirstConnect = !bReconnecting;

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+697]
	test	edx, edx
	jne	SHORT $LN123@Start
	mov	DWORD PTR tv355[ebp], 1
	jmp	SHORT $LN124@Start
$LN123@Start:
	mov	DWORD PTR tv355[ebp], 0
$LN124@Start:
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR tv355[ebp]
	mov	BYTE PTR [eax+932], cl

; 473  : 
; 474  :     if(bTestStream || recordingOnly || replayBufferOnly || !bStreamFlushed)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+620]
	test	eax, eax
	jne	SHORT $LN93@Start
	movzx	ecx, BYTE PTR _recordingOnly$[ebp]
	test	ecx, ecx
	jne	SHORT $LN93@Start
	movzx	edx, BYTE PTR _replayBufferOnly$[ebp]
	test	edx, edx
	jne	SHORT $LN93@Start
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+628]
	test	ecx, ecx
	jne	SHORT $LN94@Start
$LN93@Start:

; 475  :         network.reset(CreateNullNetwork());

	call	?CreateNullNetwork@@YAPAVNetworkStream@@XZ ; CreateNullNetwork
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 76					; 0000004cH
	call	?reset@?$unique_ptr@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@@std@@QAEXPAVNetworkStream@@@Z ; std::unique_ptr<NetworkStream,std::default_delete<NetworkStream> >::reset

; 476  :     else

	jmp	SHORT $LN90@Start
$LN94@Start:

; 477  :     {
; 478  :         switch(networkMode)

	mov	edx, DWORD PTR _networkMode$[ebp]
	mov	DWORD PTR tv371[ebp], edx
	cmp	DWORD PTR tv371[ebp], 0
	je	SHORT $LN89@Start
	cmp	DWORD PTR tv371[ebp], 1
	je	SHORT $LN88@Start
	jmp	SHORT $LN90@Start
$LN89@Start:

; 479  :         {
; 480  :         case 0: network.reset((delayTime > 0) ? CreateDelayedPublisher(delayTime) : CreateRTMPPublisher()); break;

	cmp	DWORD PTR _delayTime$[ebp], 0
	jbe	SHORT $LN125@Start
	mov	eax, DWORD PTR _delayTime$[ebp]
	push	eax
	call	?CreateDelayedPublisher@@YAPAVNetworkStream@@K@Z ; CreateDelayedPublisher
	add	esp, 4
	mov	DWORD PTR tv378[ebp], eax
	jmp	SHORT $LN126@Start
$LN125@Start:
	call	?CreateRTMPPublisher@@YAPAVNetworkStream@@XZ ; CreateRTMPPublisher
	mov	DWORD PTR tv378[ebp], eax
$LN126@Start:
	mov	ecx, DWORD PTR tv378[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 76					; 0000004cH
	call	?reset@?$unique_ptr@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@@std@@QAEXPAVNetworkStream@@@Z ; std::unique_ptr<NetworkStream,std::default_delete<NetworkStream> >::reset
	jmp	SHORT $LN90@Start
$LN88@Start:

; 481  :         case 1: network.reset(CreateNullNetwork()); break;

	call	?CreateNullNetwork@@YAPAVNetworkStream@@XZ ; CreateNullNetwork
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 76					; 0000004cH
	call	?reset@?$unique_ptr@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@@std@@QAEXPAVNetworkStream@@@Z ; std::unique_ptr<NetworkStream,std::default_delete<NetworkStream> >::reset
$LN90@Start:

; 482  :         }
; 483  :     }
; 484  : 
; 485  :     if(!network)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 76					; 0000004cH
	call	??B?$unique_ptr@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@@std@@QBE_NXZ ; std::unique_ptr<NetworkStream,std::default_delete<NetworkStream> >::operator bool
	movzx	edx, al
	test	edx, edx
	jne	$LN87@Start

; 486  :     {
; 487  :        // DisableMenusWhileStreaming(false);
; 488  :         OSLeaveMutex (hStartupShutdownMutex);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1400]
	push	ecx
	call	DWORD PTR __imp_?OSLeaveMutex@@YGXPAX@Z

; 489  : 
; 490  :         if(!bReconnecting)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+697]
	test	eax, eax
	jne	SHORT $LN86@Start

; 491  :             OBSMessageBox(hwndMain, strError, NULL, MB_ICONERROR);

	push	16					; 00000010H
	push	0
	lea	ecx, DWORD PTR _strError$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	mov	ecx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	ecx
	call	DWORD PTR __imp_?OBSMessageBox@@YAHPAUHWND__@@PB_W1I@Z
	add	esp, 16					; 00000010H

; 492  :         else

	jmp	SHORT $LN85@Start
$LN86@Start:

; 493  :             OBSDialogBox(hinstMain, MAKEINTRESOURCE(IDD_RECONNECTING), hwndMain, OBS::ReconnectDialogProc);

	push	0
	push	OFFSET ?ReconnectDialogProc@OBS@@CGHPAUHWND__@@IIJ@Z ; OBS::ReconnectDialogProc
	mov	edx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	edx
	push	131					; 00000083H
	mov	eax, DWORD PTR ?hinstMain@@3PAUHINSTANCE__@@A ; hinstMain
	push	eax
	call	DWORD PTR __imp_?OBSDialogBox@@YAHPAUHINSTANCE__@@PB_WPAUHWND__@@P6GH2IIJ@ZJ@Z
	add	esp, 20					; 00000014H
$LN85@Start:

; 494  :         bStartingUp = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+626], 0

; 495  :         return;

	lea	ecx, DWORD PTR _strError$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _processPriority$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strPatchesError$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	jmp	$LN119@Start
$LN87@Start:

; 496  :     }
; 497  : 
; 498  :     bReconnecting = false;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+697], 0

; 499  : 
; 500  :     //-------------------------------------------------------------
; 501  : 
; 502  :     Log(TEXT("=====Stream Start: %s==============================================="), CurrentDateTimeString().Array());

	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	call	DWORD PTR __imp_?CurrentDateTimeString@@YA?AVString@@XZ
	add	esp, 4
	mov	ecx, eax
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	push	OFFSET $SG4294795242
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 8
	lea	ecx, DWORD PTR $T5[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 503  : 
; 504  :     //-------------------------------------------------------------
; 505  : 
; 506  :     bEnableProjectorCursor = GlobalConfig->GetInt(L"General", L"EnableProjectorCursor", 1) != 0;

	push	1
	push	OFFSET $SG4294795241
	push	OFFSET $SG4294795240
	mov	ecx, DWORD PTR ?GlobalConfig@@3PAVConfigFile@@A ; GlobalConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	test	eax, eax
	je	SHORT $LN127@Start
	mov	DWORD PTR tv424[ebp], 1
	jmp	SHORT $LN128@Start
$LN127@Start:
	mov	DWORD PTR tv424[ebp], 0
$LN128@Start:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR tv424[ebp]
	mov	BYTE PTR [ecx+710], dl

; 507  :     bPleaseEnableProjector = bPleaseDisableProjector = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+708], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+707], 0

; 508  : 
; 509  :     int monitorID = AppConfig->GetInt(TEXT("Video"), TEXT("Monitor"));

	push	0
	push	OFFSET $SG4294795239
	push	OFFSET $SG4294795238
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	mov	DWORD PTR _monitorID$[ebp], eax

; 510  :     if(monitorID >= (int)monitors.Num())

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 156				; 0000009cH
	call	?Num@?$List@UMonitorInfo@@@@QBEIXZ	; List<MonitorInfo>::Num
	cmp	DWORD PTR _monitorID$[ebp], eax
	jl	SHORT $LN84@Start

; 511  :         monitorID = 0;

	mov	DWORD PTR _monitorID$[ebp], 0
$LN84@Start:

; 512  : 
; 513  :     RECT &screenRect = monitors[monitorID].rect;

	mov	edx, DWORD PTR _monitorID$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 156				; 0000009cH
	call	??A?$List@UMonitorInfo@@@@QAEAAUMonitorInfo@@I@Z ; List<MonitorInfo>::operator[]
	add	eax, 4
	mov	DWORD PTR _screenRect$[ebp], eax

; 514  :     int defCX = screenRect.right  - screenRect.left;

	mov	eax, DWORD PTR _screenRect$[ebp]
	mov	ecx, DWORD PTR _screenRect$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx]
	mov	DWORD PTR _defCX$[ebp], edx

; 515  :     int defCY = screenRect.bottom - screenRect.top;

	mov	eax, DWORD PTR _screenRect$[ebp]
	mov	ecx, DWORD PTR _screenRect$[ebp]
	mov	edx, DWORD PTR [eax+12]
	sub	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _defCY$[ebp], edx

; 516  : 
; 517  :     downscaleType = AppConfig->GetInt(TEXT("Video"), TEXT("Filter"), 0);

	push	0
	push	OFFSET $SG4294795237
	push	OFFSET $SG4294795236
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+884], eax

; 518  :     downscale = AppConfig->GetFloat(TEXT("Video"), TEXT("Downscale"), 1.0f);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG4294795235
	push	OFFSET $SG4294795234
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetFloat@ConfigFile@@QAEMPB_W0M@Z
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+880]

; 519  :     baseCX = AppConfig->GetInt(TEXT("Video"), TEXT("BaseWidth"),  defCX);

	mov	eax, DWORD PTR _defCX$[ebp]
	push	eax
	push	OFFSET $SG4294795233
	push	OFFSET $SG4294795232
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+856], eax

; 520  :     baseCY = AppConfig->GetInt(TEXT("Video"), TEXT("BaseHeight"), defCY);

	mov	edx, DWORD PTR _defCY$[ebp]
	push	edx
	push	OFFSET $SG4294795231
	push	OFFSET $SG4294795230
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+860], eax

; 521  : 
; 522  :     baseCX = MIN(MAX(baseCX, 128), 4096);

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+856], 128		; 00000080H
	jbe	SHORT $LN129@Start
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	DWORD PTR tv508[ebp], ecx
	jmp	SHORT $LN130@Start
$LN129@Start:
	mov	DWORD PTR tv508[ebp], 128		; 00000080H
$LN130@Start:
	cmp	DWORD PTR tv508[ebp], 4096		; 00001000H
	jae	SHORT $LN133@Start
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+856], 128		; 00000080H
	jbe	SHORT $LN131@Start
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	DWORD PTR tv513[ebp], ecx
	jmp	SHORT $LN132@Start
$LN131@Start:
	mov	DWORD PTR tv513[ebp], 128		; 00000080H
$LN132@Start:
	mov	edx, DWORD PTR tv513[ebp]
	mov	DWORD PTR tv514[ebp], edx
	jmp	SHORT $LN134@Start
$LN133@Start:
	mov	DWORD PTR tv514[ebp], 4096		; 00001000H
$LN134@Start:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR tv514[ebp]
	mov	DWORD PTR [eax+856], ecx

; 523  :     baseCY = MIN(MAX(baseCY, 128), 4096);

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+860], 128		; 00000080H
	jbe	SHORT $LN135@Start
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+860]
	mov	DWORD PTR tv519[ebp], ecx
	jmp	SHORT $LN136@Start
$LN135@Start:
	mov	DWORD PTR tv519[ebp], 128		; 00000080H
$LN136@Start:
	cmp	DWORD PTR tv519[ebp], 4096		; 00001000H
	jae	SHORT $LN139@Start
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+860], 128		; 00000080H
	jbe	SHORT $LN137@Start
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+860]
	mov	DWORD PTR tv524[ebp], ecx
	jmp	SHORT $LN138@Start
$LN137@Start:
	mov	DWORD PTR tv524[ebp], 128		; 00000080H
$LN138@Start:
	mov	edx, DWORD PTR tv524[ebp]
	mov	DWORD PTR tv525[ebp], edx
	jmp	SHORT $LN140@Start
$LN139@Start:
	mov	DWORD PTR tv525[ebp], 4096		; 00001000H
$LN140@Start:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR tv525[ebp]
	mov	DWORD PTR [eax+860], ecx

; 524  : 
; 525  :     scaleCX = UINT(double(baseCX) / double(downscale));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+856]
	mov	DWORD PTR tv1700[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv1700[ebp]
	mov	ecx, DWORD PTR tv1700[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	mov	edx, DWORD PTR _this$[ebp]
	cvtss2sd xmm1, DWORD PTR [edx+880]
	divsd	xmm0, xmm1
	call	__dtoui3
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+864], eax

; 526  :     scaleCY = UINT(double(baseCY) / double(downscale));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+860]
	mov	DWORD PTR tv1711[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv1711[ebp]
	mov	ecx, DWORD PTR tv1711[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	mov	edx, DWORD PTR _this$[ebp]
	cvtss2sd xmm1, DWORD PTR [edx+880]
	divsd	xmm0, xmm1
	call	__dtoui3
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+868], eax

; 527  : 
; 528  :     //align width to 128bit for fast SSE YUV4:2:0 conversion
; 529  :     outputCX = scaleCX & 0xFFFFFFFC;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+864]
	and	eax, -4					; fffffffcH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+872], eax

; 530  :     outputCY = scaleCY & 0xFFFFFFFE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+868]
	and	eax, -2					; fffffffeH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+876], eax

; 531  : 
; 532  :     bUseMultithreadedOptimizations = AppConfig->GetInt(TEXT("General"), TEXT("UseMultithreadedOptimizations"), TRUE) != 0;

	push	1
	push	OFFSET $SG4294795229
	push	OFFSET $SG4294795228
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	test	eax, eax
	je	SHORT $LN141@Start
	mov	DWORD PTR tv553[ebp], 1
	jmp	SHORT $LN142@Start
$LN141@Start:
	mov	DWORD PTR tv553[ebp], 0
$LN142@Start:
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR tv553[ebp]
	mov	BYTE PTR [edx+621], al

; 533  :     Log(TEXT("  Multithreaded optimizations: %s"), (CTSTR)(bUseMultithreadedOptimizations ? TEXT("On") : TEXT("Off")));

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+621]
	test	edx, edx
	je	SHORT $LN143@Start
	mov	DWORD PTR tv558[ebp], OFFSET $SG4294795227
	jmp	SHORT $LN144@Start
$LN143@Start:
	mov	DWORD PTR tv558[ebp], OFFSET $SG4294795226
$LN144@Start:
	mov	eax, DWORD PTR tv558[ebp]
	push	eax
	push	OFFSET $SG4294795225
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 8

; 534  : 
; 535  :     encoderSkipThreshold = GlobalConfig->GetInt(TEXT("Video"), TEXT("EncoderSkipThreshold"), fps/4);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+892]
	shr	edx, 2
	push	edx
	push	OFFSET $SG4294795224
	push	OFFSET $SG4294795223
	mov	ecx, DWORD PTR ?GlobalConfig@@3PAVConfigFile@@A ; GlobalConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+164], eax

; 536  :     if (encoderSkipThreshold < 1)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+164], 1
	jae	SHORT $LN83@Start

; 537  :         encoderSkipThreshold = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+164], 1
$LN83@Start:

; 538  : 
; 539  :     //------------------------------------------------------------------
; 540  : 
; 541  :     Log(TEXT("  Base resolution: %ux%u"), baseCX, baseCY);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+860]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	push	ecx
	push	OFFSET $SG4294795222
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 12					; 0000000cH

; 542  :     Log(TEXT("  Output resolution: %ux%u"), outputCX, outputCY);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+876]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+872]
	push	edx
	push	OFFSET $SG4294795221
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 12					; 0000000cH

; 543  :     Log(TEXT("------------------------------------------"));

	push	OFFSET $SG4294795220
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 4

; 544  : 
; 545  :     //------------------------------------------------------------------
; 546  : 	//directx
; 547  :     GS = new D3D10System;

	push	436					; 000001b4H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T17[ebp], eax
	cmp	DWORD PTR $T17[ebp], 0
	je	SHORT $LN145@Start
	mov	ecx, DWORD PTR $T17[ebp]
	call	??0D3D10System@@QAE@XZ			; D3D10System::D3D10System
	mov	DWORD PTR tv591[ebp], eax
	jmp	SHORT $LN146@Start
$LN145@Start:
	mov	DWORD PTR tv591[ebp], 0
$LN146@Start:
	mov	eax, DWORD PTR __imp_?GS@@3PAVGraphicsSystem@@A
	mov	ecx, DWORD PTR tv591[ebp]
	mov	DWORD PTR [eax], ecx

; 548  :     GS->Init();

	mov	edx, DWORD PTR __imp_?GS@@3PAVGraphicsSystem@@A
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR __imp_?GS@@3PAVGraphicsSystem@@A
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+16]
	call	eax
$retryHookTestV2$173:

; 549  : 
; 550  :     //Thanks to ASUS OSD hooking the goddamn user mode driver framework (!!!!), we have to re-check for dangerous
; 551  :     //hooks after initializing D3D.
; 552  : retryHookTestV2:
; 553  :     if (!alreadyWarnedAboutModules)

	movzx	ecx, BYTE PTR _alreadyWarnedAboutModules$[ebp]
	test	ecx, ecx
	jne	$LN78@Start

; 554  :     {
; 555  :         if (OSIncompatibleModulesLoaded())

	call	DWORD PTR __imp_?OSIncompatibleModulesLoaded@@YGHXZ
	test	eax, eax
	je	$LN78@Start

; 556  :         {
; 557  :             Log(TEXT("Incompatible modules (post-D3D) detected."));

	push	OFFSET $SG4294795219
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 4

; 558  :             int ret = OBSMessageBox(hwndMain, Str("IncompatibleModules"), NULL, MB_ICONERROR | MB_ABORTRETRYIGNORE);

	push	18					; 00000012H
	push	0
	push	OFFSET $SG4294795218
	mov	edx, DWORD PTR __imp_?locale@@3PAVLocaleStringLookup@@A
	mov	ecx, DWORD PTR [edx]
	call	DWORD PTR __imp_?LookupString@LocaleStringLookup@@QAEPB_WPB_W@Z
	push	eax
	mov	eax, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	eax
	call	DWORD PTR __imp_?OBSMessageBox@@YAHPAUHWND__@@PB_W1I@Z
	add	esp, 16					; 00000010H
	mov	DWORD PTR _ret$19[ebp], eax

; 559  :             if (ret == IDABORT)

	cmp	DWORD PTR _ret$19[ebp], 3
	jne	$LN80@Start

; 560  :             {
; 561  :                 //FIXME: really need a better way to abort startup than this...
; 562  :                 network.reset();

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 76					; 0000004cH
	call	?reset@?$unique_ptr@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@@std@@QAEXPAVNetworkStream@@@Z ; std::unique_ptr<NetworkStream,std::default_delete<NetworkStream> >::reset

; 563  :                 delete GS;

	mov	ecx, DWORD PTR __imp_?GS@@3PAVGraphicsSystem@@A
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T14[ebp], edx
	mov	eax, DWORD PTR $T14[ebp]
	mov	DWORD PTR $T25[ebp], eax
	cmp	DWORD PTR $T25[ebp], 0
	je	SHORT $LN147@Start
	push	1
	mov	ecx, DWORD PTR $T25[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR $T25[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	DWORD PTR tv621[ebp], eax
	jmp	SHORT $LN148@Start
$LN147@Start:
	mov	DWORD PTR tv621[ebp], 0
$LN148@Start:

; 564  : 
; 565  :                // DisableMenusWhileStreaming(false);
; 566  :                 OSLeaveMutex (hStartupShutdownMutex);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1400]
	push	edx
	call	DWORD PTR __imp_?OSLeaveMutex@@YGXPAX@Z

; 567  :                 bStartingUp = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+626], 0

; 568  :                 return;

	lea	ecx, DWORD PTR _strError$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _processPriority$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strPatchesError$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	jmp	$LN119@Start
	jmp	SHORT $LN78@Start
$LN80@Start:

; 569  :             }
; 570  :             else if (ret == IDRETRY)

	cmp	DWORD PTR _ret$19[ebp], 4
	jne	SHORT $LN78@Start

; 571  :             {
; 572  :                 goto retryHookTestV2;

	jmp	$retryHookTestV2$173
$LN78@Start:

; 573  :             }
; 574  :         }
; 575  :     }
; 576  : 
; 577  :     //-------------------------------------------------------------
; 578  : 
; 579  :     mainVertexShader    = CreateVertexShaderFromFile(TEXT("shaders/DrawTexture.vShader"));

	push	OFFSET $SG4294795217
	call	?CreateVertexShaderFromFile@@YAPAVShader@@PB_W@Z ; CreateVertexShaderFromFile
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+52], eax

; 580  :     mainPixelShader     = CreatePixelShaderFromFile(TEXT("shaders/DrawTexture.pShader"));

	push	OFFSET $SG4294795216
	call	?CreatePixelShaderFromFile@@YAPAVShader@@PB_W@Z ; CreatePixelShaderFromFile
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+56], eax

; 581  : 
; 582  :     solidVertexShader   = CreateVertexShaderFromFile(TEXT("shaders/DrawSolid.vShader"));

	push	OFFSET $SG4294795215
	call	?CreateVertexShaderFromFile@@YAPAVShader@@PB_W@Z ; CreateVertexShaderFromFile
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+68], eax

; 583  :     solidPixelShader    = CreatePixelShaderFromFile(TEXT("shaders/DrawSolid.pShader"));

	push	OFFSET $SG4294795214
	call	?CreatePixelShaderFromFile@@YAPAVShader@@PB_W@Z ; CreatePixelShaderFromFile
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+72], eax

; 584  : 
; 585  :     transitionPixelShader = CreatePixelShaderFromFile(TEXT("shaders/SceneTransition.pShader"));

	push	OFFSET $SG4294795213
	call	?CreatePixelShaderFromFile@@YAPAVShader@@PB_W@Z ; CreatePixelShaderFromFile
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+64], eax

; 586  : 
; 587  :     if(!mainVertexShader || !mainPixelShader)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+52], 0
	je	SHORT $LN76@Start
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+56], 0
	jne	SHORT $LN77@Start
$LN76@Start:

; 588  :         CrashError(TEXT("Unable to load DrawTexture shaders"));

	push	OFFSET $SG4294795212
	call	DWORD PTR __imp_?CrashError@@YAXPB_WZZ
$LN77@Start:

; 589  : 
; 590  :     if(!solidVertexShader || !solidPixelShader)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+68], 0
	je	SHORT $LN74@Start
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+72], 0
	jne	SHORT $LN75@Start
$LN74@Start:

; 591  :         CrashError(TEXT("Unable to load DrawSolid shaders"));

	push	OFFSET $SG4294795211
	call	DWORD PTR __imp_?CrashError@@YAXPB_WZZ
$LN75@Start:

; 592  : 
; 593  :     if (!transitionPixelShader)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+64], 0
	jne	SHORT $LN73@Start

; 594  :         CrashError(TEXT("Unable to load SceneTransition shader"));

	push	OFFSET $SG4294795210
	call	DWORD PTR __imp_?CrashError@@YAXPB_WZZ
$LN73@Start:

; 595  : 
; 596  :     //------------------------------------------------------------------
; 597  : 
; 598  :     CTSTR lpShader;
; 599  :     if(CloseFloat(downscale, 1.0))

	push	ecx
	movss	xmm0, DWORD PTR __real@3c23d70a
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+880]
	movss	DWORD PTR [esp], xmm0
	call	?CloseFloat@@YAHMMM@Z			; CloseFloat
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN72@Start

; 600  :         lpShader = TEXT("shaders/DrawYUVTexture.pShader");

	mov	DWORD PTR _lpShader$[ebp], OFFSET $SG4294795209
	jmp	$LN62@Start
$LN72@Start:

; 601  :     else if(downscale < 2.01)

	mov	edx, DWORD PTR _this$[ebp]
	cvtss2sd xmm0, DWORD PTR [edx+880]
	movsd	xmm1, QWORD PTR __real@4000147ae147ae14
	comisd	xmm1, xmm0
	jbe	SHORT $LN70@Start

; 602  :     {
; 603  :         switch(downscaleType)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+884]
	mov	DWORD PTR tv664[ebp], ecx
	cmp	DWORD PTR tv664[ebp], 0
	je	SHORT $LN67@Start
	cmp	DWORD PTR tv664[ebp], 1
	je	SHORT $LN66@Start
	cmp	DWORD PTR tv664[ebp], 2
	je	SHORT $LN65@Start
	jmp	SHORT $LN68@Start
$LN67@Start:

; 604  :         {
; 605  :             case 0: lpShader = TEXT("shaders/DownscaleBilinear1YUV.pShader"); break;

	mov	DWORD PTR _lpShader$[ebp], OFFSET $SG4294795208
	jmp	SHORT $LN68@Start
$LN66@Start:

; 606  :             case 1: lpShader = TEXT("shaders/DownscaleBicubicYUV.pShader"); break;

	mov	DWORD PTR _lpShader$[ebp], OFFSET $SG4294795207
	jmp	SHORT $LN68@Start
$LN65@Start:

; 607  :             case 2: lpShader = TEXT("shaders/DownscaleLanczos6tapYUV.pShader"); break;

	mov	DWORD PTR _lpShader$[ebp], OFFSET $SG4294795206
$LN68@Start:

; 608  :         }
; 609  :     }
; 610  :     else if(downscale < 3.01)

	jmp	SHORT $LN62@Start
$LN70@Start:
	mov	edx, DWORD PTR _this$[ebp]
	cvtss2sd xmm0, DWORD PTR [edx+880]
	movsd	xmm1, QWORD PTR __real@4008147ae147ae14
	comisd	xmm1, xmm0
	jbe	SHORT $LN63@Start

; 611  :         lpShader = TEXT("shaders/DownscaleBilinear9YUV.pShader");

	mov	DWORD PTR _lpShader$[ebp], OFFSET $SG4294795205

; 612  :     else

	jmp	SHORT $LN62@Start
$LN63@Start:

; 613  :         CrashError(TEXT("Invalid downscale value (must be either 1.0, 1.5, 2.0, 2.25, or 3.0)"));

	push	OFFSET $SG4294795204
	call	DWORD PTR __imp_?CrashError@@YAXPB_WZZ
$LN62@Start:

; 614  : 
; 615  :     yuvScalePixelShader = CreatePixelShaderFromFile(lpShader);

	mov	eax, DWORD PTR _lpShader$[ebp]
	push	eax
	call	?CreatePixelShaderFromFile@@YAPAVShader@@PB_W@Z ; CreatePixelShaderFromFile
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+60], eax

; 616  :     if (!yuvScalePixelShader)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+60], 0
	jne	SHORT $LN61@Start

; 617  :         CrashError(TEXT("Unable to create shader from file %s"), lpShader);

	mov	eax, DWORD PTR _lpShader$[ebp]
	push	eax
	push	OFFSET $SG4294795203
	call	DWORD PTR __imp_?CrashError@@YAXPB_WZZ
$LN61@Start:

; 618  : 
; 619  :     //-------------------------------------------------------------
; 620  : 
; 621  :     for(UINT i=0; i<NUM_RENDER_BUFFERS; i++)

	mov	DWORD PTR _i$30[ebp], 0
	jmp	SHORT $LN60@Start
$LN59@Start:
	mov	ecx, DWORD PTR _i$30[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$30[ebp], ecx
$LN60@Start:
	cmp	DWORD PTR _i$30[ebp], 2
	jae	SHORT $LN58@Start

; 622  :     {
; 623  :         mainRenderTextures[i] = CreateRenderTarget(baseCX, baseCY, GS_BGRA, FALSE);

	push	0
	push	6
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+860]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+856]
	push	edx
	call	?CreateRenderTarget@@YAPAVTexture@@IIW4GSColorFormat@@H@Z ; CreateRenderTarget
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _i$30[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx*4+20], eax

; 624  :         yuvRenderTextures[i]  = CreateRenderTarget(outputCX, outputCY, GS_BGRA, FALSE);

	push	0
	push	6
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+876]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+872]
	push	eax
	call	?CreateRenderTarget@@YAPAVTexture@@IIW4GSColorFormat@@H@Z ; CreateRenderTarget
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _i$30[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx*4+28], eax

; 625  :     }

	jmp	SHORT $LN59@Start
$LN58@Start:

; 626  : 
; 627  :     transitionTexture = CreateRenderTarget(baseCX, baseCY, GS_BGRA, FALSE); 

	push	0
	push	6
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+860]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+856]
	push	eax
	call	?CreateRenderTarget@@YAPAVTexture@@IIW4GSColorFormat@@H@Z ; CreateRenderTarget
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+40], eax

; 628  : 
; 629  :     //-------------------------------------------------------------
; 630  : 
; 631  :     D3D10_TEXTURE2D_DESC td;
; 632  :     zero(&td, sizeof(td));

	push	44					; 0000002cH
	lea	edx, DWORD PTR _td$[ebp]
	push	edx
	call	?zero@@YGXPAXI@Z			; zero

; 633  :     td.Width            = outputCX;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+872]
	mov	DWORD PTR _td$[ebp], ecx

; 634  :     td.Height           = outputCY;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+876]
	mov	DWORD PTR _td$[ebp+4], eax

; 635  :     td.Format           = DXGI_FORMAT_B8G8R8A8_UNORM;

	mov	DWORD PTR _td$[ebp+16], 87		; 00000057H

; 636  :     td.MipLevels        = 1;

	mov	DWORD PTR _td$[ebp+8], 1

; 637  :     td.ArraySize        = 1;

	mov	DWORD PTR _td$[ebp+12], 1

; 638  :     td.SampleDesc.Count = 1;

	mov	DWORD PTR _td$[ebp+20], 1

; 639  :     td.ArraySize        = 1;

	mov	DWORD PTR _td$[ebp+12], 1

; 640  :     td.Usage            = D3D10_USAGE_STAGING;

	mov	DWORD PTR _td$[ebp+28], 3

; 641  :     td.CPUAccessFlags   = D3D10_CPU_ACCESS_READ;

	mov	DWORD PTR _td$[ebp+36], 131072		; 00020000H

; 642  : 
; 643  :     for(UINT i=0; i<NUM_RENDER_BUFFERS; i++)

	mov	DWORD PTR _i$27[ebp], 0
	jmp	SHORT $LN57@Start
$LN56@Start:
	mov	ecx, DWORD PTR _i$27[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$27[ebp], ecx
$LN57@Start:
	cmp	DWORD PTR _i$27[ebp], 2
	jae	SHORT $LN55@Start

; 644  :     {
; 645  : 		//2d
; 646  :         HRESULT err = GetD3D()->CreateTexture2D(&td, NULL, &copyTextures[i]);

	call	?GetD3D@@YAPAUID3D10Device@@XZ		; GetD3D
	mov	DWORD PTR tv749[ebp], eax
	mov	edx, DWORD PTR _i$27[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4+12]
	push	ecx
	push	0
	lea	edx, DWORD PTR _td$[ebp]
	push	edx
	mov	eax, DWORD PTR tv749[ebp]
	push	eax
	mov	ecx, DWORD PTR tv749[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+292]
	call	eax
	mov	DWORD PTR _err$9[ebp], eax

; 647  :         if(FAILED(err))

	cmp	DWORD PTR _err$9[ebp], 0
	jge	SHORT $LN54@Start

; 648  :         {
; 649  :             CrashError(TEXT("Unable to create copy texture"));

	push	OFFSET $SG4294795202
	call	DWORD PTR __imp_?CrashError@@YAXPB_WZZ
$LN54@Start:

; 650  :             //todo - better error handling
; 651  :         }
; 652  :     }

	jmp	SHORT $LN56@Start
$LN55@Start:

; 653  : 
; 654  :     //------------------------------------------------------------------
; 655  : 
; 656  :     String strEncoder = AppConfig->GetString(TEXT("Audio Encoding"), TEXT("Codec"), TEXT("AAC"));

	push	OFFSET $SG4294795201
	push	OFFSET $SG4294795200
	push	OFFSET $SG4294795199
	lea	ecx, DWORD PTR _strEncoder$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetString@ConfigFile@@QAE?AVString@@PB_W00@Z

; 657  :     BOOL isAAC = strEncoder.CompareI(TEXT("AAC"));

	push	OFFSET $SG4294795198
	lea	ecx, DWORD PTR _strEncoder$[ebp]
	call	DWORD PTR __imp_?CompareI@String@@QBEHPB_W@Z
	mov	DWORD PTR _isAAC$[ebp], eax

; 658  : 
; 659  :     UINT format = AppConfig->GetInt(L"Audio Encoding", L"Format", 1);

	push	1
	push	OFFSET $SG4294795197
	push	OFFSET $SG4294795196
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	mov	DWORD PTR _format$[ebp], eax

; 660  : 
; 661  :     if (!isAAC)

	cmp	DWORD PTR _isAAC$[ebp], 0
	jne	SHORT $LN53@Start

; 662  :         format = 0;

	mov	DWORD PTR _format$[ebp], 0
$LN53@Start:

; 663  : 
; 664  :     switch (format) {

	mov	edx, DWORD PTR _format$[ebp]
	mov	DWORD PTR tv809[ebp], edx
	cmp	DWORD PTR tv809[ebp], 0
	je	SHORT $LN50@Start
	jmp	SHORT $LN49@Start
$LN50@Start:

; 665  :     case 0: sampleRateHz = 44100; break;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+128], 44100		; 0000ac44H
	jmp	SHORT $LN51@Start
$LN49@Start:

; 666  :     default:
; 667  :     case 1: sampleRateHz = 48000; break;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+128], 48000		; 0000bb80H
$LN51@Start:

; 668  :     }
; 669  : 
; 670  :     Log(L"------------------------------------------");

	push	OFFSET $SG4294795195
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 4

; 671  :     Log(L"Audio Format: %u Hz", sampleRateHz);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+128]
	push	eax
	push	OFFSET $SG4294795194
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 8

; 672  : 
; 673  :     //------------------------------------------------------------------
; 674  : 
; 675  :     BOOL isStereo = AppConfig->GetInt(L"Audio Encoding", L"isStereo", 1);

	push	1
	push	OFFSET $SG4294795193
	push	OFFSET $SG4294795192
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	mov	DWORD PTR _isStereo$[ebp], eax

; 676  : 
; 677  :     switch (isStereo) {

	mov	ecx, DWORD PTR _isStereo$[ebp]
	mov	DWORD PTR tv822[ebp], ecx
	cmp	DWORD PTR tv822[ebp], 0
	je	SHORT $LN46@Start
	jmp	SHORT $LN45@Start
$LN46@Start:

; 678  :     case 0: audioChannels = 1; break;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+132], 1
	jmp	SHORT $LN47@Start
$LN45@Start:

; 679  :     default:
; 680  :     case 1: audioChannels = 2; break;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+132], 2
$LN47@Start:

; 681  :     }
; 682  : 
; 683  :     Log(L"------------------------------------------");

	push	OFFSET $SG4294795191
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 4

; 684  :     Log(L"Audio Channels: %u Ch", audioChannels);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+132]
	push	edx
	push	OFFSET $SG4294795190
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 8

; 685  : 
; 686  :     //------------------------------------------------------------------
; 687  : 
; 688  :     AudioDeviceList playbackDevices;

	lea	ecx, DWORD PTR _playbackDevices$[ebp]
	call	??0AudioDeviceList@@QAE@XZ

; 689  :     bool useInputDevices = AppConfig->GetInt(L"Audio", L"InputDevicesForDesktopSound", false) != 0;

	push	0
	push	OFFSET $SG4294795189
	push	OFFSET $SG4294795188
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	test	eax, eax
	je	SHORT $LN149@Start
	mov	DWORD PTR tv839[ebp], 1
	jmp	SHORT $LN150@Start
$LN149@Start:
	mov	DWORD PTR tv839[ebp], 0
$LN150@Start:
	mov	al, BYTE PTR tv839[ebp]
	mov	BYTE PTR _useInputDevices$[ebp], al

; 690  :     GetAudioDevices(playbackDevices, useInputDevices ? ADT_RECORDING : ADT_PLAYBACK);

	movzx	ecx, BYTE PTR _useInputDevices$[ebp]
	test	ecx, ecx
	je	SHORT $LN151@Start
	mov	DWORD PTR tv845[ebp], 1
	jmp	SHORT $LN152@Start
$LN151@Start:
	mov	DWORD PTR tv845[ebp], 0
$LN152@Start:
	push	0
	push	0
	mov	edx, DWORD PTR tv845[ebp]
	push	edx
	lea	eax, DWORD PTR _playbackDevices$[ebp]
	push	eax
	call	?GetAudioDevices@@YAXAAUAudioDeviceList@@W4AudioDeviceType@@_N2@Z ; GetAudioDevices
	add	esp, 16					; 00000010H

; 691  : 
; 692  :     String strPlaybackDevice = AppConfig->GetString(TEXT("Audio"), TEXT("PlaybackDevice"), TEXT("Default"));

	push	OFFSET $SG4294795187
	push	OFFSET $SG4294795186
	push	OFFSET $SG4294795185
	lea	ecx, DWORD PTR _strPlaybackDevice$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetString@ConfigFile@@QAE?AVString@@PB_W00@Z

; 693  :     if(strPlaybackDevice.IsEmpty() || !playbackDevices.HasID(strPlaybackDevice))

	lea	ecx, DWORD PTR _strPlaybackDevice$[ebp]
	call	DWORD PTR __imp_?IsEmpty@String@@QBEHXZ
	test	eax, eax
	jne	SHORT $LN43@Start
	lea	ecx, DWORD PTR _strPlaybackDevice$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	lea	ecx, DWORD PTR _playbackDevices$[ebp]
	call	?HasID@AudioDeviceList@@QBE_NPB_W@Z	; AudioDeviceList::HasID
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN44@Start
$LN43@Start:

; 694  :     {
; 695  :       
; 696  :         strPlaybackDevice = TEXT("Default");

	push	OFFSET $SG4294795184
	lea	ecx, DWORD PTR _strPlaybackDevice$[ebp]
	call	DWORD PTR __imp_??4String@@QAEAAV0@PB_W@Z
$LN44@Start:

; 697  :     }
; 698  : 
; 699  :     Log(TEXT("Playback device %s"), strPlaybackDevice.Array());

	lea	ecx, DWORD PTR _strPlaybackDevice$[ebp]
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	push	OFFSET $SG4294795183
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 8

; 700  :     playbackDevices.FreeData();

	lea	ecx, DWORD PTR _playbackDevices$[ebp]
	call	?FreeData@AudioDeviceList@@QAEXXZ	; AudioDeviceList::FreeData

; 701  : 
; 702  :     desktopAudio = CreateAudioSource(false, strPlaybackDevice);

	lea	ecx, DWORD PTR _strPlaybackDevice$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	push	0
	call	?CreateAudioSource@@YAPAVAudioSource@@_NPB_W@Z ; CreateAudioSource
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+112], eax

; 703  : 
; 704  :     if(!desktopAudio) {

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+112], 0
	jne	SHORT $LN42@Start

; 705  :         CrashError(TEXT("Cannot initialize desktop audio sound, more info in the log file."));

	push	OFFSET $SG4294795182
	call	DWORD PTR __imp_?CrashError@@YAXPB_WZZ
$LN42@Start:

; 706  :     }
; 707  : 
; 708  :     if (useInputDevices)

	movzx	eax, BYTE PTR _useInputDevices$[ebp]
	test	eax, eax
	je	SHORT $LN41@Start

; 709  :         Log(L"Use Input Devices enabled, not recording standard desktop audio");

	push	OFFSET $SG4294795181
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 4
$LN41@Start:

; 710  : 
; 711  :     AudioDeviceList audioDevices;

	lea	ecx, DWORD PTR _audioDevices$[ebp]
	call	??0AudioDeviceList@@QAE@XZ

; 712  :     GetAudioDevices(audioDevices, ADT_RECORDING, false, true);

	push	1
	push	0
	push	1
	lea	ecx, DWORD PTR _audioDevices$[ebp]
	push	ecx
	call	?GetAudioDevices@@YAXAAUAudioDeviceList@@W4AudioDeviceType@@_N2@Z ; GetAudioDevices
	add	esp, 16					; 00000010H

; 713  : 
; 714  :     String strDevice = AppConfig->GetString(TEXT("Audio"), TEXT("Device"), NULL);

	push	0
	push	OFFSET $SG4294795180
	push	OFFSET $SG4294795179
	lea	edx, DWORD PTR _strDevice$[ebp]
	push	edx
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetString@ConfigFile@@QAE?AVString@@PB_W00@Z

; 715  :     if(strDevice.IsEmpty() || !audioDevices.HasID(strDevice))

	lea	ecx, DWORD PTR _strDevice$[ebp]
	call	DWORD PTR __imp_?IsEmpty@String@@QBEHXZ
	test	eax, eax
	jne	SHORT $LN39@Start
	lea	ecx, DWORD PTR _strDevice$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	lea	ecx, DWORD PTR _audioDevices$[ebp]
	call	?HasID@AudioDeviceList@@QBE_NPB_W@Z	; AudioDeviceList::HasID
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN40@Start
$LN39@Start:

; 716  :     {
; 717  : 	  strDevice = TEXT("Disable");

	push	OFFSET $SG4294795178
	lea	ecx, DWORD PTR _strDevice$[ebp]
	call	DWORD PTR __imp_??4String@@QAEAAV0@PB_W@Z
$LN40@Start:

; 718  :     }
; 719  : 
; 720  :     audioDevices.FreeData();

	lea	ecx, DWORD PTR _audioDevices$[ebp]
	call	?FreeData@AudioDeviceList@@QAEXXZ	; AudioDeviceList::FreeData

; 721  : 
; 722  :     String strDefaultMic;

	lea	ecx, DWORD PTR _strDefaultMic$[ebp]
	call	DWORD PTR __imp_??0String@@QAE@XZ

; 723  :     bool bHasDefault = GetDefaultMicID(strDefaultMic);

	lea	ecx, DWORD PTR _strDefaultMic$[ebp]
	push	ecx
	call	?GetDefaultMicID@@YA_NAAVString@@@Z	; GetDefaultMicID
	add	esp, 4
	mov	BYTE PTR _bHasDefault$[ebp], al

; 724  : 
; 725  :     if(strDevice.CompareI(TEXT("Disable")))

	push	OFFSET $SG4294795177
	lea	ecx, DWORD PTR _strDevice$[ebp]
	call	DWORD PTR __imp_?CompareI@String@@QBEHPB_W@Z
	test	eax, eax
	je	SHORT $LN38@Start

; 726  :         EnableWindow(GetDlgItem(hwndMain, ID_MICVOLUME), FALSE);

	push	0
	push	5007					; 0000138fH
	mov	edx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	edx
	call	DWORD PTR __imp__GetDlgItem@8
	push	eax
	call	DWORD PTR __imp__EnableWindow@8

; 727  :     else

	jmp	$LN31@Start
$LN38@Start:

; 728  :     {
; 729  :         bool bUseDefault = strDevice.CompareI(TEXT("Default")) != 0;

	push	OFFSET $SG4294795176
	lea	ecx, DWORD PTR _strDevice$[ebp]
	call	DWORD PTR __imp_?CompareI@String@@QBEHPB_W@Z
	test	eax, eax
	je	SHORT $LN153@Start
	mov	DWORD PTR tv961[ebp], 1
	jmp	SHORT $LN154@Start
$LN153@Start:
	mov	DWORD PTR tv961[ebp], 0
$LN154@Start:
	mov	al, BYTE PTR tv961[ebp]
	mov	BYTE PTR _bUseDefault$35[ebp], al

; 730  :         if(!bUseDefault || bHasDefault)

	movzx	ecx, BYTE PTR _bUseDefault$35[ebp]
	test	ecx, ecx
	je	SHORT $LN35@Start
	movzx	edx, BYTE PTR _bHasDefault$[ebp]
	test	edx, edx
	je	$LN36@Start
$LN35@Start:

; 731  :         {
; 732  :             if(bUseDefault)

	movzx	eax, BYTE PTR _bUseDefault$35[ebp]
	test	eax, eax
	je	SHORT $LN34@Start

; 733  :                 strDevice = strDefaultMic;

	lea	ecx, DWORD PTR _strDefaultMic$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strDevice$[ebp]
	call	DWORD PTR __imp_??4String@@QAEAAV0@ABV0@@Z
$LN34@Start:

; 734  : 
; 735  :             micAudio = CreateAudioSource(true, strDevice);

	lea	ecx, DWORD PTR _strDevice$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	push	1
	call	?CreateAudioSource@@YAPAVAudioSource@@_NPB_W@Z ; CreateAudioSource
	add	esp, 8
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+116], eax

; 736  : 
; 737  :             if(!micAudio)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+116], 0
	jne	SHORT $LN33@Start

; 738  :                 OBSMessageBox(hwndMain, Str("MicrophoneFailure"), NULL, 0);

	push	0
	push	0
	push	OFFSET $SG4294795175
	mov	ecx, DWORD PTR __imp_?locale@@3PAVLocaleStringLookup@@A
	mov	ecx, DWORD PTR [ecx]
	call	DWORD PTR __imp_?LookupString@LocaleStringLookup@@QAEPB_WPB_W@Z
	push	eax
	mov	edx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	edx
	call	DWORD PTR __imp_?OBSMessageBox@@YAHPAUHWND__@@PB_W1I@Z
	add	esp, 16					; 00000010H

; 739  :             else

	jmp	SHORT $LN32@Start
$LN33@Start:

; 740  :             {
; 741  :                 int offset = AppConfig->GetInt(TEXT("Audio"), TEXT("MicTimeOffset"), 0);

	push	0
	push	OFFSET $SG4294795174
	push	OFFSET $SG4294795173
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	mov	DWORD PTR _offset$18[ebp], eax

; 742  :                 Log(L"Mic time offset: %d", offset);

	mov	eax, DWORD PTR _offset$18[ebp]
	push	eax
	push	OFFSET $SG4294795172
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 8

; 743  :                 micAudio->SetTimeOffset(offset);

	mov	ecx, DWORD PTR _offset$18[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+116]
	call	DWORD PTR __imp_?SetTimeOffset@AudioSource@@QAEXH@Z
$LN32@Start:

; 744  :             }
; 745  : 
; 746  :             EnableWindow(GetDlgItem(hwndMain, ID_MICVOLUME), micAudio != NULL);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+116], 0
	je	SHORT $LN155@Start
	mov	DWORD PTR tv999[ebp], 1
	jmp	SHORT $LN156@Start
$LN155@Start:
	mov	DWORD PTR tv999[ebp], 0
$LN156@Start:
	mov	ecx, DWORD PTR tv999[ebp]
	push	ecx
	push	5007					; 0000138fH
	mov	edx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	edx
	call	DWORD PTR __imp__GetDlgItem@8
	push	eax
	call	DWORD PTR __imp__EnableWindow@8

; 747  :         }
; 748  :         else

	jmp	SHORT $LN31@Start
$LN36@Start:

; 749  :             EnableWindow(GetDlgItem(hwndMain, ID_MICVOLUME), FALSE);

	push	0
	push	5007					; 0000138fH
	mov	eax, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	eax
	call	DWORD PTR __imp__GetDlgItem@8
	push	eax
	call	DWORD PTR __imp__EnableWindow@8
$LN31@Start:

; 750  :     }
; 751  : 
; 752  :     //-------------------------------------------------------------
; 753  : 
; 754  :     bool bDisableEncoding = false;

	mov	BYTE PTR _bDisableEncoding$[ebp], 0

; 755  : 
; 756  :     if (bTestStream)

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+620]
	test	edx, edx
	je	SHORT $LN30@Start

; 757  :         bDisableEncoding = GlobalConfig->GetInt(TEXT("General"), TEXT("DisablePreviewEncoding"), false) != 0;

	push	0
	push	OFFSET $SG4294795171
	push	OFFSET $SG4294795170
	mov	ecx, DWORD PTR ?GlobalConfig@@3PAVConfigFile@@A ; GlobalConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	test	eax, eax
	je	SHORT $LN157@Start
	mov	DWORD PTR tv1018[ebp], 1
	jmp	SHORT $LN158@Start
$LN157@Start:
	mov	DWORD PTR tv1018[ebp], 0
$LN158@Start:
	mov	al, BYTE PTR tv1018[ebp]
	mov	BYTE PTR _bDisableEncoding$[ebp], al
$LN30@Start:

; 758  : 
; 759  :     //-------------------------------------------------------------
; 760  : 
; 761  :     UINT bitRate = (UINT)AppConfig->GetInt(TEXT("Audio Encoding"), TEXT("Bitrate"), 96);

	push	96					; 00000060H
	push	OFFSET $SG4294795169
	push	OFFSET $SG4294795168
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	mov	DWORD PTR _bitRate$[ebp], eax

; 762  : 
; 763  :     if (bDisableEncoding)

	movzx	ecx, BYTE PTR _bDisableEncoding$[ebp]
	test	ecx, ecx
	je	SHORT $LN29@Start

; 764  :         audioEncoder = CreateNullAudioEncoder();

	call	?CreateNullAudioEncoder@@YAPAVAudioEncoder@@XZ ; CreateNullAudioEncoder
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+140], eax

; 765  :     else

	jmp	SHORT $LN26@Start
$LN29@Start:

; 766  : #ifdef USE_AAC
; 767  :     if(isAAC) // && OSGetVersion() >= 7)

	cmp	DWORD PTR _isAAC$[ebp], 0
	je	SHORT $LN27@Start

; 768  :         audioEncoder = CreateAACEncoder(bitRate);

	mov	eax, DWORD PTR _bitRate$[ebp]
	push	eax
	call	?CreateAACEncoder@@YAPAVAudioEncoder@@I@Z ; CreateAACEncoder
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+140], eax

; 769  :     else

	jmp	SHORT $LN26@Start
$LN27@Start:

; 770  : #endif
; 771  :         audioEncoder = CreateMP3Encoder(bitRate);

	mov	edx, DWORD PTR _bitRate$[ebp]
	push	edx
	call	?CreateMP3Encoder@@YAPAVAudioEncoder@@I@Z ; CreateMP3Encoder
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+140], eax
$LN26@Start:

; 772  : 
; 773  :     //-------------------------------------------------------------
; 774  : 
; 775  :     desktopVol = AppConfig->GetFloat(TEXT("Audio"), TEXT("DesktopVolume"), 1.0f);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG4294795167
	push	OFFSET $SG4294795166
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetFloat@ConfigFile@@QAEMPB_W0M@Z
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+1168]

; 776  :     micVol     = AppConfig->GetFloat(TEXT("Audio"), TEXT("MicVolume"),     1.0f);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG4294795165
	push	OFFSET $SG4294795164
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetFloat@ConfigFile@@QAEMPB_W0M@Z
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+1172]

; 777  : 
; 778  :     //-------------------------------------------------------------
; 779  : 
; 780  :     bRunning = true;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+622], 1

; 781  : 
; 782  :     if(sceneElement)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+212], 0
	je	$LN16@Start

; 783  :     {
; 784  :         scene = CreateScene(sceneElement->GetString(TEXT("class")), sceneElement->GetElement(TEXT("data")));

	push	OFFSET $SG4294795163
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+212]
	call	DWORD PTR __imp_?GetElement@XElement@@QBEPAV1@PB_W@Z
	push	eax
	push	0
	push	OFFSET $SG4294795162
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+212]
	call	DWORD PTR __imp_?GetString@XElement@@QBEPB_WPB_WPA_W@Z
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CreateScene@OBS@@AAEPAVScene@@PB_WPAVXElement@@@Z ; OBS::CreateScene
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+144], eax

; 785  :         XElement *sources = sceneElement->GetElement(TEXT("sources"));

	push	OFFSET $SG4294795161
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+212]
	call	DWORD PTR __imp_?GetElement@XElement@@QBEPAV1@PB_W@Z
	mov	DWORD PTR _sources$24[ebp], eax

; 786  :         if(sources)

	cmp	DWORD PTR _sources$24[ebp], 0
	je	$LN21@Start

; 787  :         {
; 788  :             UINT numSources = sources->NumElements();

	push	0
	mov	ecx, DWORD PTR _sources$24[ebp]
	call	DWORD PTR __imp_?NumElements@XElement@@QAEKPB_W@Z
	mov	DWORD PTR _numSources$13[ebp], eax

; 789  :             for(UINT i=0; i<numSources; i++)

	mov	DWORD PTR _i$32[ebp], 0
	jmp	SHORT $LN23@Start
$LN22@Start:
	mov	ecx, DWORD PTR _i$32[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$32[ebp], ecx
$LN23@Start:
	mov	edx, DWORD PTR _i$32[ebp]
	cmp	edx, DWORD PTR _numSources$13[ebp]
	jae	SHORT $LN21@Start

; 790  :             {
; 791  :                 SceneItem *item = scene->AddImageSource(sources->GetElementByID(i));

	mov	eax, DWORD PTR _i$32[ebp]
	push	eax
	mov	ecx, DWORD PTR _sources$24[ebp]
	call	DWORD PTR __imp_?GetElementByID@XElement@@QBEPAV1@K@Z
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+144]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+144]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	DWORD PTR _item$23[ebp], eax

; 792  :                 if(item)

	cmp	DWORD PTR _item$23[ebp], 0
	je	SHORT $LN19@Start

; 793  :                 {
; 794  :                     if(ListView_GetItemState(GetDlgItem(hwndMain, ID_SOURCES), i, LVIS_SELECTED) > 0)

	push	2
	mov	ecx, DWORD PTR _i$32[ebp]
	push	ecx
	push	4140					; 0000102cH
	push	5013					; 00001395H
	mov	edx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	edx
	call	DWORD PTR __imp__GetDlgItem@8
	push	eax
	call	DWORD PTR __imp__SendMessageW@16
	test	eax, eax
	jbe	SHORT $LN19@Start

; 795  :                         item->Select(true);

	push	1
	mov	ecx, DWORD PTR _item$23[ebp]
	call	DWORD PTR __imp_?Select@SceneItem@@QAEX_N@Z
$LN19@Start:

; 796  :                 }
; 797  :             }

	jmp	$LN22@Start
$LN21@Start:

; 798  :         }
; 799  : 		// every souce invoke beginScene
; 800  :         scene->BeginScene();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+144]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+144]
	mov	edx, DWORD PTR [eax+36]
	call	edx

; 801  :         unsigned int numSources = scene->sceneItems.Num();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+144]
	add	ecx, 8
	call	?Num@?$List@PAVSceneItem@@@@QBEIXZ	; List<SceneItem *>::Num
	mov	DWORD PTR _numSources$11[ebp], eax

; 802  :         for(UINT i=0; i<numSources; i++)

	mov	DWORD PTR _i$31[ebp], 0
	jmp	SHORT $LN18@Start
$LN17@Start:
	mov	ecx, DWORD PTR _i$31[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$31[ebp], ecx
$LN18@Start:
	mov	edx, DWORD PTR _i$31[ebp]
	cmp	edx, DWORD PTR _numSources$11[ebp]
	jae	$LN16@Start

; 803  :         {
; 804  :             XElement *source = scene->sceneItems[i]->GetElement();

	mov	eax, DWORD PTR _i$31[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+144]
	add	ecx, 8
	call	??A?$List@PAVSceneItem@@@@QAEAAPAVSceneItem@@I@Z ; List<SceneItem *>::operator[]
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR __imp_?GetElement@SceneItem@@QBEPAVXElement@@XZ
	mov	DWORD PTR _source$22[ebp], eax

; 805  : 
; 806  :             String className = source->GetString(TEXT("class"));

	push	0
	push	OFFSET $SG4294795160
	mov	ecx, DWORD PTR _source$22[ebp]
	call	DWORD PTR __imp_?GetString@XElement@@QBEPB_WPB_WPA_W@Z
	push	eax
	lea	ecx, DWORD PTR _className$6[ebp]
	call	DWORD PTR __imp_??0String@@QAE@PB_W@Z

; 807  :             if(scene->sceneItems[i]->bRender && className == "GlobalSource") {

	mov	edx, DWORD PTR _i$31[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+144]
	add	ecx, 8
	call	??A?$List@PAVSceneItem@@@@QAEAAPAVSceneItem@@I@Z ; List<SceneItem *>::operator[]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx+65]
	test	edx, edx
	je	SHORT $LN159@Start
	push	OFFSET $SG4294795159
	lea	ecx, DWORD PTR $T7[ebp]
	call	DWORD PTR __imp_??0String@@QAE@PBD@Z
	or	DWORD PTR $T29[ebp], 1
	lea	eax, DWORD PTR $T7[ebp]
	push	eax
	lea	ecx, DWORD PTR _className$6[ebp]
	call	DWORD PTR __imp_??8String@@QBEHABV0@@Z
	test	eax, eax
	je	SHORT $LN159@Start
	mov	DWORD PTR tv1175[ebp], 1
	jmp	SHORT $LN160@Start
$LN159@Start:
	mov	DWORD PTR tv1175[ebp], 0
$LN160@Start:
	mov	cl, BYTE PTR tv1175[ebp]
	mov	BYTE PTR $T33[ebp], cl
	mov	edx, DWORD PTR $T29[ebp]
	and	edx, 1
	je	SHORT $LN171@Start
	and	DWORD PTR $T29[ebp], -2			; fffffffeH
	lea	ecx, DWORD PTR $T7[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
$LN171@Start:
	movzx	eax, BYTE PTR $T33[ebp]
	test	eax, eax
	je	$LN15@Start

; 808  :                 XElement *globalSourceData = source->GetElement(TEXT("data"));

	push	OFFSET $SG4294795158
	mov	ecx, DWORD PTR _source$22[ebp]
	call	DWORD PTR __imp_?GetElement@XElement@@QBEPAV1@PB_W@Z
	mov	DWORD PTR _globalSourceData$16[ebp], eax

; 809  :                 String globalSourceName = globalSourceData->GetString(TEXT("name"));

	push	0
	push	OFFSET $SG4294795157
	mov	ecx, DWORD PTR _globalSourceData$16[ebp]
	call	DWORD PTR __imp_?GetString@XElement@@QBEPB_WPB_WPA_W@Z
	push	eax
	lea	ecx, DWORD PTR _globalSourceName$15[ebp]
	call	DWORD PTR __imp_??0String@@QAE@PB_W@Z

; 810  :                 if(App->GetGlobalSource(globalSourceName) != NULL) {

	lea	ecx, DWORD PTR _globalSourceName$15[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	call	?GetGlobalSource@OBS@@AAEPAVImageSource@@PB_W@Z ; OBS::GetGlobalSource
	test	eax, eax
	je	SHORT $LN14@Start

; 811  :                     App->GetGlobalSource(globalSourceName)->GlobalSourceEnterScene();

	lea	ecx, DWORD PTR _globalSourceName$15[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	call	?GetGlobalSource@OBS@@AAEPAVImageSource@@PB_W@Z ; OBS::GetGlobalSource
	mov	DWORD PTR tv1202[ebp], eax
	mov	ecx, DWORD PTR tv1202[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv1202[ebp]
	mov	eax, DWORD PTR [edx+36]
	call	eax
$LN14@Start:

; 812  :                 }
; 813  :             }

	lea	ecx, DWORD PTR _globalSourceName$15[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
$LN15@Start:

; 814  :         }

	lea	ecx, DWORD PTR _className$6[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	jmp	$LN17@Start
$LN16@Start:

; 815  :     }
; 816  : 
; 817  :     if(scene && scene->HasMissingSources())

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+144], 0
	je	SHORT $LN13@Start
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+144]
	call	DWORD PTR __imp_?HasMissingSources@Scene@@QBE_NXZ
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN13@Start

; 818  :         OBSMessageBox(hwndMain, Str("Scene.MissingSources"), NULL, 0);

	push	0
	push	0
	push	OFFSET $SG4294795156
	mov	ecx, DWORD PTR __imp_?locale@@3PAVLocaleStringLookup@@A
	mov	ecx, DWORD PTR [ecx]
	call	DWORD PTR __imp_?LookupString@LocaleStringLookup@@QAEPB_WPB_W@Z
	push	eax
	mov	edx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	edx
	call	DWORD PTR __imp_?OBSMessageBox@@YAHPAUHWND__@@PB_W1I@Z
	add	esp, 16					; 00000010H
$LN13@Start:

; 819  : 
; 820  :     //-------------------------------------------------------------
; 821  : 
; 822  :     int maxBitRate = AppConfig->GetInt   (TEXT("Video Encoding"), TEXT("MaxBitrate"), 1000);

	push	1000					; 000003e8H
	push	OFFSET $SG4294795155
	push	OFFSET $SG4294795154
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	mov	DWORD PTR _maxBitRate$[ebp], eax

; 823  :     int bufferSize = maxBitRate;

	mov	eax, DWORD PTR _maxBitRate$[ebp]
	mov	DWORD PTR _bufferSize$[ebp], eax

; 824  :     if (AppConfig->GetInt(L"Video Encoding", L"UseBufferSize", 0) != 0)

	push	0
	push	OFFSET $SG4294795153
	push	OFFSET $SG4294795152
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	test	eax, eax
	je	SHORT $LN12@Start

; 825  :         bufferSize = AppConfig->GetInt   (TEXT("Video Encoding"), TEXT("BufferSize"), 1000);

	push	1000					; 000003e8H
	push	OFFSET $SG4294795151
	push	OFFSET $SG4294795150
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	mov	DWORD PTR _bufferSize$[ebp], eax
$LN12@Start:

; 826  :     int quality    = AppConfig->GetInt   (TEXT("Video Encoding"), TEXT("Quality"),    8);

	push	8
	push	OFFSET $SG4294795149
	push	OFFSET $SG4294795148
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	mov	DWORD PTR _quality$[ebp], eax

; 827  :     String preset  = AppConfig->GetString(TEXT("Video Encoding"), TEXT("Preset"),     TEXT("veryfast"));

	push	OFFSET $SG4294795147
	push	OFFSET $SG4294795146
	push	OFFSET $SG4294795145
	lea	ecx, DWORD PTR _preset$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetString@ConfigFile@@QAE?AVString@@PB_W00@Z

; 828  :     bUsing444      = false;//AppConfig->GetInt   (TEXT("Video Encoding"), TEXT("Use444"),     0) != 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+896], 0

; 829  :     bUseCFR        = AppConfig->GetInt(TEXT("Video Encoding"), TEXT("UseCFR"), 1) != 0;

	push	1
	push	OFFSET $SG4294795144
	push	OFFSET $SG4294795143
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	test	eax, eax
	je	SHORT $LN161@Start
	mov	DWORD PTR tv1287[ebp], 1
	jmp	SHORT $LN162@Start
$LN161@Start:
	mov	DWORD PTR tv1287[ebp], 0
$LN162@Start:
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR tv1287[ebp]
	mov	BYTE PTR [eax+1024], cl

; 830  : 
; 831  :     //-------------------------------------------------------------
; 832  : 
; 833  :     bufferingTime = GlobalConfig->GetInt(TEXT("General"), TEXT("SceneBufferingTime"), 700);

	push	700					; 000002bcH
	push	OFFSET $SG4294795142
	push	OFFSET $SG4294795141
	mov	ecx, DWORD PTR ?GlobalConfig@@3PAVConfigFile@@A ; GlobalConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+944], eax

; 834  :     Log(TEXT("Scene buffering time set to %u"), bufferingTime);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+944]
	push	ecx
	push	OFFSET $SG4294795140
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 8

; 835  : 
; 836  :     //-------------------------------------------------------------
; 837  : 
; 838  :     bForceMicMono = AppConfig->GetInt(TEXT("Audio"), TEXT("ForceMicMono")) != 0;

	push	0
	push	OFFSET $SG4294795139
	push	OFFSET $SG4294795138
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	test	eax, eax
	je	SHORT $LN163@Start
	mov	DWORD PTR tv1305[ebp], 1
	jmp	SHORT $LN164@Start
$LN163@Start:
	mov	DWORD PTR tv1305[ebp], 0
$LN164@Start:
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR tv1305[ebp]
	mov	BYTE PTR [edx+1216], al

; 839  :     bRecievedFirstAudioFrame = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+988], 0

; 840  : 
; 841  :     //hRequestAudioEvent = CreateSemaphore(NULL, 0, 0x7FFFFFFFL, NULL);
; 842  :     hSoundDataMutex = OSCreateMutex();

	call	DWORD PTR __imp_?OSCreateMutex@@YGPAXXZ
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1152], eax

; 843  :     hSoundThread = OSCreateThread((XTHREAD)OBS::MainAudioThread, NULL);

	push	0
	push	OFFSET ?MainAudioThread@OBS@@CGKPAX@Z	; OBS::MainAudioThread
	call	DWORD PTR __imp_?OSCreateThread@@YGPAXP6GKPAX@Z0@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1148], eax

; 844  : 
; 845  :     //-------------------------------------------------------------
; 846  : 
; 847  :     //if (!useInputDevices)
; 848  :     //    StartBlankSoundPlayback(strPlaybackDevice);
; 849  : 
; 850  :     //-------------------------------------------------------------
; 851  : 
; 852  :     colorDesc.fullRange = AppConfig->GetInt(L"Video", L"FullRange") != 0;

	push	0
	push	OFFSET $SG4294795137
	push	OFFSET $SG4294795136
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	test	eax, eax
	je	SHORT $LN165@Start
	mov	DWORD PTR tv1322[ebp], 1
	jmp	SHORT $LN166@Start
$LN165@Start:
	mov	DWORD PTR tv1322[ebp], 0
$LN166@Start:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR tv1322[ebp]
	mov	DWORD PTR [edx+900], eax

; 853  :     colorDesc.primaries = ColorPrimaries_BT709;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+904], 1

; 854  :     colorDesc.transfer  = ColorTransfer_IEC6196621;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+908], 13			; 0000000dH

; 855  :     colorDesc.matrix    = outputCX >= 1280 || outputCY > 576 ? ColorMatrix_BT709 : ColorMatrix_SMPTE170M;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+872], 1280		; 00000500H
	jae	SHORT $LN167@Start
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+876], 576		; 00000240H
	ja	SHORT $LN167@Start
	mov	DWORD PTR tv1333[ebp], 6
	jmp	SHORT $LN168@Start
$LN167@Start:
	mov	DWORD PTR tv1333[ebp], 1
$LN168@Start:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR tv1333[ebp]
	mov	DWORD PTR [edx+912], eax

; 856  : 
; 857  :     videoEncoder = nullptr;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+148], 0

; 858  :     String videoEncoderErrors;

	lea	ecx, DWORD PTR _videoEncoderErrors$[ebp]
	call	DWORD PTR __imp_??0String@@QAE@XZ

; 859  :     String vencoder = AppConfig->GetString(L"Video Encoding", L"Encoder");

	push	0
	push	OFFSET $SG4294795135
	push	OFFSET $SG4294795134
	lea	edx, DWORD PTR _vencoder$[ebp]
	push	edx
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetString@ConfigFile@@QAE?AVString@@PB_W00@Z

; 860  :     if (bDisableEncoding)

	movzx	eax, BYTE PTR _bDisableEncoding$[ebp]
	test	eax, eax
	je	SHORT $LN11@Start

; 861  :         videoEncoder = CreateNullVideoEncoder();

	call	?CreateNullVideoEncoder@@YAPAVVideoEncoder@@XZ ; CreateNullVideoEncoder
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+148], eax
	jmp	$LN6@Start
$LN11@Start:

; 862  :     else if(vencoder == L"QSV")

	push	OFFSET $SG4294795133
	lea	ecx, DWORD PTR _vencoder$[ebp]
	call	DWORD PTR __imp_??8String@@QBEHPB_W@Z
	test	eax, eax
	je	SHORT $LN9@Start

; 863  :         videoEncoder = CreateQSVEncoder(fps, outputCX, outputCY, quality, preset, bUsing444, colorDesc, maxBitRate, bufferSize, bUseCFR, videoEncoderErrors);

	lea	edx, DWORD PTR _videoEncoderErrors$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+1024]
	push	ecx
	mov	edx, DWORD PTR _bufferSize$[ebp]
	push	edx
	mov	eax, DWORD PTR _maxBitRate$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 900				; 00000384H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+896]
	push	eax
	lea	ecx, DWORD PTR _preset$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	mov	ecx, DWORD PTR _quality$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+876]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+872]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+892]
	push	ecx
	call	?CreateQSVEncoder@@YAPAVVideoEncoder@@HHHHPB_W_NAAUColorDescription@@HH1AAVString@@@Z ; CreateQSVEncoder
	add	esp, 44					; 0000002cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+148], eax
	jmp	$LN6@Start
$LN9@Start:

; 864  :     else if(vencoder == L"NVENC")

	push	OFFSET $SG4294795132
	lea	ecx, DWORD PTR _vencoder$[ebp]
	call	DWORD PTR __imp_??8String@@QBEHPB_W@Z
	test	eax, eax
	je	SHORT $LN7@Start

; 865  :         videoEncoder = CreateNVENCEncoder(fps, outputCX, outputCY, quality, preset, bUsing444, colorDesc, maxBitRate, bufferSize, bUseCFR, videoEncoderErrors);

	lea	eax, DWORD PTR _videoEncoderErrors$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+1024]
	push	edx
	mov	eax, DWORD PTR _bufferSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _maxBitRate$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 900				; 00000384H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+896]
	push	ecx
	lea	ecx, DWORD PTR _preset$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	mov	edx, DWORD PTR _quality$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+876]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+872]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+892]
	push	edx
	call	?CreateNVENCEncoder@@YAPAVVideoEncoder@@HHHHPB_W_NAAUColorDescription@@HH1AAVString@@@Z ; CreateNVENCEncoder
	add	esp, 44					; 0000002cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+148], eax

; 866  :     else

	jmp	SHORT $LN6@Start
$LN7@Start:

; 867  :         videoEncoder = CreateX264Encoder(fps, outputCX, outputCY, quality, preset, bUsing444, colorDesc, maxBitRate, bufferSize, bUseCFR);

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+1024]
	push	eax
	mov	ecx, DWORD PTR _bufferSize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _maxBitRate$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 900				; 00000384H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+896]
	push	edx
	lea	ecx, DWORD PTR _preset$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	mov	eax, DWORD PTR _quality$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+876]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+872]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+892]
	push	eax
	call	?CreateX264Encoder@@YAPAVVideoEncoder@@HHHHPB_W_NAAUColorDescription@@HH1@Z ; CreateX264Encoder
	add	esp, 40					; 00000028H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+148], eax
$LN6@Start:

; 868  : 
; 869  :     if (!videoEncoder)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+148], 0
	jne	$LN5@Start

; 870  :     {
; 871  :         Log(L"Couldn't initialize encoder");

	push	OFFSET $SG4294795131
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 4

; 872  :         Stop(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Stop@OBS@@AAEX_N0@Z			; OBS::Stop

; 873  : 
; 874  :         if (videoEncoderErrors.IsEmpty())

	lea	ecx, DWORD PTR _videoEncoderErrors$[ebp]
	call	DWORD PTR __imp_?IsEmpty@String@@QBEHXZ
	test	eax, eax
	je	SHORT $LN4@Start

; 875  :             videoEncoderErrors = Str("Encoder.InitFailed");

	push	OFFSET $SG4294795130
	mov	eax, DWORD PTR __imp_?locale@@3PAVLocaleStringLookup@@A
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR __imp_?LookupString@LocaleStringLookup@@QAEPB_WPB_W@Z
	push	eax
	lea	ecx, DWORD PTR _videoEncoderErrors$[ebp]
	call	DWORD PTR __imp_??4String@@QAEAAV0@PB_W@Z

; 876  :         else

	jmp	SHORT $LN3@Start
$LN4@Start:

; 877  :             videoEncoderErrors = String(Str("Encoder.InitFailedWithReason")) + videoEncoderErrors;

	lea	ecx, DWORD PTR _videoEncoderErrors$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	push	OFFSET $SG4294795129
	mov	eax, DWORD PTR __imp_?locale@@3PAVLocaleStringLookup@@A
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR __imp_?LookupString@LocaleStringLookup@@QAEPB_WPB_W@Z
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	call	DWORD PTR __imp_??0String@@QAE@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??HString@@QBE?AV0@ABV0@@Z
	push	eax
	lea	ecx, DWORD PTR _videoEncoderErrors$[ebp]
	call	DWORD PTR __imp_??4String@@QAEAAV0@ABV0@@Z
	lea	ecx, DWORD PTR $T4[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR $T3[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
$LN3@Start:

; 878  : 
; 879  :         OBSMessageBox(hwndMain, videoEncoderErrors.Array(), nullptr, MB_OK | MB_ICONERROR); //might want to defer localization until here to automatically

	push	16					; 00000010H
	push	0
	lea	ecx, DWORD PTR _videoEncoderErrors$[ebp]
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	mov	ecx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	ecx
	call	DWORD PTR __imp_?OBSMessageBox@@YAHPAUHWND__@@PB_W1I@Z
	add	esp, 16					; 00000010H

; 880  :                                                                                          //output english localization to logfile
; 881  :         return;

	lea	ecx, DWORD PTR _vencoder$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _videoEncoderErrors$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _preset$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strDefaultMic$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strDevice$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _audioDevices$[ebp]
	call	??1AudioDeviceList@@QAE@XZ		; AudioDeviceList::~AudioDeviceList
	lea	ecx, DWORD PTR _strPlaybackDevice$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _playbackDevices$[ebp]
	call	??1AudioDeviceList@@QAE@XZ		; AudioDeviceList::~AudioDeviceList
	lea	ecx, DWORD PTR _strEncoder$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strError$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _processPriority$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strPatchesError$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	jmp	$LN119@Start
$LN5@Start:

; 882  :     }
; 883  : 
; 884  :     if ((bStreaming = (!recordingOnly && !replayBufferOnly) && networkMode == 0)) ReportStartStreamingTrigger();

	movzx	edx, BYTE PTR _recordingOnly$[ebp]
	test	edx, edx
	jne	SHORT $LN169@Start
	movzx	eax, BYTE PTR _replayBufferOnly$[ebp]
	test	eax, eax
	jne	SHORT $LN169@Start
	cmp	DWORD PTR _networkMode$[ebp], 0
	jne	SHORT $LN169@Start
	mov	DWORD PTR tv1461[ebp], 1
	jmp	SHORT $LN170@Start
$LN169@Start:
	mov	DWORD PTR tv1461[ebp], 0
$LN170@Start:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR tv1461[ebp]
	mov	BYTE PTR [ecx+627], dl
	movzx	eax, BYTE PTR tv1461[ebp]
	test	eax, eax
	je	SHORT $LN2@Start
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+76]
	call	eax
$LN2@Start:

; 885  :     //-------------------------------------------------------------
; 886  : 
; 887  :     // Ensure that the render frame is properly sized
; 888  :     ResizeRenderFrame(true);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResizeRenderFrame@OBS@@AAEX_N@Z	; OBS::ResizeRenderFrame

; 889  : 
; 890  :     //-------------------------------------------------------------
; 891  : 
; 892  :     if ((!replayBufferOnly && !StartRecording(recordingOnly)) && !bStreaming)

	movzx	ecx, BYTE PTR _replayBufferOnly$[ebp]
	test	ecx, ecx
	jne	$LN1@Start
	movzx	edx, BYTE PTR _recordingOnly$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?StartRecording@OBS@@AAE_N_N@Z		; OBS::StartRecording
	movzx	eax, al
	test	eax, eax
	jne	$LN1@Start
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+627]
	test	edx, edx
	jne	$LN1@Start

; 893  :     {
; 894  :         Stop(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Stop@OBS@@AAEX_N0@Z			; OBS::Stop

; 895  :         return;

	lea	ecx, DWORD PTR _vencoder$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _videoEncoderErrors$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _preset$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strDefaultMic$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strDevice$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _audioDevices$[ebp]
	call	??1AudioDeviceList@@QAE@XZ		; AudioDeviceList::~AudioDeviceList
	lea	ecx, DWORD PTR _strPlaybackDevice$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _playbackDevices$[ebp]
	call	??1AudioDeviceList@@QAE@XZ		; AudioDeviceList::~AudioDeviceList
	lea	ecx, DWORD PTR _strEncoder$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strError$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _processPriority$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strPatchesError$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	jmp	$LN119@Start
$LN1@Start:

; 896  :     }
; 897  : 
; 898  :     //-------------------------------------------------------------
; 899  : 
; 900  :     curFramePic = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1120], 0

; 901  :     bShutdownVideoThread = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+631], 0

; 902  :     bShutdownEncodeThread = false;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+632], 0

; 903  :    
; 904  :     hEncodeThread = OSCreateThread((XTHREAD)OBS::EncodeThread, NULL);

	push	0
	push	OFFSET ?EncodeThread@OBS@@CGKPAX@Z	; OBS::EncodeThread
	call	DWORD PTR __imp_?OSCreateThread@@YGPAXP6GKPAX@Z0@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+948], eax

; 905  :     hVideoThread = OSCreateThread((XTHREAD)OBS::MainCaptureThread, NULL);

	push	0
	push	OFFSET ?MainCaptureThread@OBS@@CGKPAX@Z	; OBS::MainCaptureThread
	call	DWORD PTR __imp_?OSCreateThread@@YGPAXP6GKPAX@Z0@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+952], eax

; 906  : 
; 907  :    // EnableWindow(GetDlgItem(hwndMain, ID_SCENEEDITOR), TRUE);
; 908  : 
; 909  :     //-------------------------------------------------------------
; 910  : 
; 911  :     ReportStartStreamTrigger();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+68]
	call	eax

; 912  :     
; 913  :     SystemParametersInfo(SPI_SETSCREENSAVEACTIVE, 0, 0, 0);

	push	0
	push	0
	push	0
	push	17					; 00000011H
	call	DWORD PTR __imp__SystemParametersInfoW@16

; 914  :     SetThreadExecutionState(ES_CONTINUOUS | ES_SYSTEM_REQUIRED | ES_AWAYMODE_REQUIRED | ES_DISPLAY_REQUIRED);

	push	-2147483581				; 80000043H
	call	DWORD PTR __imp__SetThreadExecutionState@4

; 915  : 
; 916  :    // UpdateRenderViewMessage();
; 917  : 
; 918  :     //update notification icon to reflect current status
; 919  :     UpdateNotificationAreaIcon();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?UpdateNotificationAreaIcon@OBS@@QAEHXZ	; OBS::UpdateNotificationAreaIcon

; 920  : 
; 921  :     OSLeaveMutex (hStartupShutdownMutex);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1400]
	push	edx
	call	DWORD PTR __imp_?OSLeaveMutex@@YGXPAX@Z

; 922  : 
; 923  :     bStartingUp = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+626], 0

; 924  : 
; 925  :     ConfigureStreamButtons();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ConfigureStreamButtons@OBS@@AAEXXZ	; OBS::ConfigureStreamButtons

; 926  : }

	lea	ecx, DWORD PTR _vencoder$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _videoEncoderErrors$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _preset$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strDefaultMic$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strDevice$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _audioDevices$[ebp]
	call	??1AudioDeviceList@@QAE@XZ		; AudioDeviceList::~AudioDeviceList
	lea	ecx, DWORD PTR _strPlaybackDevice$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _playbackDevices$[ebp]
	call	??1AudioDeviceList@@QAE@XZ		; AudioDeviceList::~AudioDeviceList
	lea	ecx, DWORD PTR _strEncoder$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strError$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _processPriority$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strPatchesError$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
$LN119@Start:
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
?Start@OBS@@AAEX_N0@Z ENDP				; OBS::Start
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obscapture.cpp
;	COMDAT ??0<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@QAE@PAVOBS@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__This$ = 8						; size = 4
??0<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@QAE@PAVOBS@@@Z PROC ; <lambda_7c9af1b141e25bc2e890d47a77a39da9>::<lambda_7c9af1b141e25bc2e890d47a77a39da9>, COMDAT
; _this$ = ecx

; 968  :             };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __This$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@QAE@PAVOBS@@@Z ENDP ; <lambda_7c9af1b141e25bc2e890d47a77a39da9>::<lambda_7c9af1b141e25bc2e890d47a77a39da9>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obscapture.cpp
;	COMDAT ??R<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@QBEXXZ
_TEXT	SEGMENT
$T1 = -20						; size = 8
$T2 = -12						; size = 4
_stream$ = -8						; size = 4
_this$ = -4						; size = 4
??R<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@QBEXXZ PROC ; <lambda_7c9af1b141e25bc2e890d47a77a39da9>::operator(), COMDAT
; _this$ = ecx

; 944  :             {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 945  :                 videoEncoder->RequestKeyframe();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+148]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+148]
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 946  : 
; 947  :                 auto stream = move(network);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 76					; 0000004cH
	push	edx
	call	??$move@AAV?$unique_ptr@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@@std@@@std@@YA$$QAV?$unique_ptr@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@@0@AAV10@@Z ; std::move<std::unique_ptr<NetworkStream,std::default_delete<NetworkStream> > &>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR _stream$[ebp]
	call	??0?$unique_ptr@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@@std@@QAE@$$QAV01@@Z ; std::unique_ptr<NetworkStream,std::default_delete<NetworkStream> >::unique_ptr<NetworkStream,std::default_delete<NetworkStream> >

; 948  : 
; 949  :                 Log(TEXT("=====Stream End (recording continues): %s========================="), CurrentDateTimeString().Array());

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	DWORD PTR __imp_?CurrentDateTimeString@@YA?AVString@@XZ
	add	esp, 4
	mov	ecx, eax
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	push	OFFSET $SG4294795114
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 8
	lea	ecx, DWORD PTR $T1[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 950  : 
; 951  :                 bStreamFlushed = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	BYTE PTR [edx+628], 0

; 952  : 
; 953  :                 ConfigureStreamButtons();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?ConfigureStreamButtons@OBS@@AAEXXZ	; OBS::ConfigureStreamButtons

; 954  : 
; 955  :                 AddPendingStream(stream.release(), [this]()
; 956  :                 {

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0<lambda_3648d362fc95221bbf9c4c4a922d1611>@@QAE@ABQAVOBS@@@Z ; <lambda_3648d362fc95221bbf9c4c4a922d1611>::<lambda_3648d362fc95221bbf9c4c4a922d1611>
	sub	esp, 24					; 00000018H
	mov	ecx, esp
	push	eax
	call	??$?0V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@@?$function@$$A6AXXZ@std@@QAE@$$QAV<lambda_3648d362fc95221bbf9c4c4a922d1611>@@@Z ; std::function<void __cdecl(void)>::function<void __cdecl(void)><<lambda_3648d362fc95221bbf9c4c4a922d1611> >
	lea	ecx, DWORD PTR _stream$[ebp]
	call	?release@?$unique_ptr@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@@std@@QAEPAVNetworkStream@@XZ ; std::unique_ptr<NetworkStream,std::default_delete<NetworkStream> >::release
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z ; OBS::AddPendingStream

; 957  :                     bStreaming = false;
; 958  :                     bSentHeaders = false;
; 959  : 
; 960  :                     ReportStopStreamingTrigger();
; 961  : 
; 962  :                     bStreamFlushed = true;
; 963  : 
; 964  :                     ConfigureStreamButtons();
; 965  : 
; 966  :                     if (!bStreaming && !bRecordingReplayBuffer && bRunning && !bRecording) PostStopMessage(true);
; 967  :                 });
; 968  :             };

	lea	ecx, DWORD PTR _stream$[ebp]
	call	??1?$unique_ptr@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@@std@@QAE@XZ ; std::unique_ptr<NetworkStream,std::default_delete<NetworkStream> >::~unique_ptr<NetworkStream,std::default_delete<NetworkStream> >
	mov	esp, ebp
	pop	ebp
	ret	0
??R<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@QBEXXZ ENDP ; <lambda_7c9af1b141e25bc2e890d47a77a39da9>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obscapture.cpp
;	COMDAT ??0<lambda_3b020cec0f1508adac4c896f138918cf>@@QAE@PAVOBS@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__This$ = 8						; size = 4
??0<lambda_3b020cec0f1508adac4c896f138918cf>@@QAE@PAVOBS@@@Z PROC ; <lambda_3b020cec0f1508adac4c896f138918cf>::<lambda_3b020cec0f1508adac4c896f138918cf>, COMDAT
; _this$ = ecx

; 1044 :         });

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __This$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0<lambda_3b020cec0f1508adac4c896f138918cf>@@QAE@PAVOBS@@@Z ENDP ; <lambda_3b020cec0f1508adac4c896f138918cf>::<lambda_3b020cec0f1508adac4c896f138918cf>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obscapture.cpp
;	COMDAT ??R<lambda_3b020cec0f1508adac4c896f138918cf>@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??R<lambda_3b020cec0f1508adac4c896f138918cf>@@QBEXXZ PROC ; <lambda_3b020cec0f1508adac4c896f138918cf>::operator(), COMDAT
; _this$ = ecx

; 1038 :         {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1039 :             ReportStopStreamingTrigger();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR [eax+80]
	call	edx

; 1040 :             bStreaming = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	BYTE PTR [ecx+627], 0

; 1041 :             bStreamFlushed = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	BYTE PTR [eax+628], 1

; 1042 :             bTestStream = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	BYTE PTR [edx+620], 0

; 1043 :             ConfigureStreamButtons();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?ConfigureStreamButtons@OBS@@AAEXXZ	; OBS::ConfigureStreamButtons

; 1044 :         });

	mov	esp, ebp
	pop	ebp
	ret	0
??R<lambda_3b020cec0f1508adac4c896f138918cf>@@QBEXXZ ENDP ; <lambda_3b020cec0f1508adac4c896f138918cf>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obscapture.cpp
;	COMDAT ??0<lambda_3648d362fc95221bbf9c4c4a922d1611>@@QAE@ABQAVOBS@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_____this$ = 8						; size = 4
??0<lambda_3648d362fc95221bbf9c4c4a922d1611>@@QAE@ABQAVOBS@@@Z PROC ; <lambda_3648d362fc95221bbf9c4c4a922d1611>::<lambda_3648d362fc95221bbf9c4c4a922d1611>, COMDAT
; _this$ = ecx

; 956  :                 {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _____this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0<lambda_3648d362fc95221bbf9c4c4a922d1611>@@QAE@ABQAVOBS@@@Z ENDP ; <lambda_3648d362fc95221bbf9c4c4a922d1611>::<lambda_3648d362fc95221bbf9c4c4a922d1611>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obscapture.cpp
;	COMDAT ??R<lambda_3648d362fc95221bbf9c4c4a922d1611>@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??R<lambda_3648d362fc95221bbf9c4c4a922d1611>@@QBEXXZ PROC ; <lambda_3648d362fc95221bbf9c4c4a922d1611>::operator(), COMDAT
; _this$ = ecx

; 956  :                 {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 957  :                     bStreaming = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	BYTE PTR [ecx+627], 0

; 958  :                     bSentHeaders = false;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	BYTE PTR [eax+989], 0

; 959  : 
; 960  :                     ReportStopStreamingTrigger();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+80]
	call	eax

; 961  : 
; 962  :                     bStreamFlushed = true;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	BYTE PTR [edx+628], 1

; 963  : 
; 964  :                     ConfigureStreamButtons();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?ConfigureStreamButtons@OBS@@AAEXXZ	; OBS::ConfigureStreamButtons

; 965  : 
; 966  :                     if (!bStreaming && !bRecordingReplayBuffer && bRunning && !bRecording) PostStopMessage(true);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx+627]
	test	eax, eax
	jne	SHORT $LN2@operator
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx+624]
	test	eax, eax
	jne	SHORT $LN2@operator
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx+622]
	test	eax, eax
	je	SHORT $LN2@operator
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx+623]
	test	eax, eax
	jne	SHORT $LN2@operator
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?PostStopMessage@OBS@@QAEX_N@Z		; OBS::PostStopMessage
$LN2@operator:

; 967  :                 });

	mov	esp, ebp
	pop	ebp
	ret	0
??R<lambda_3648d362fc95221bbf9c4c4a922d1611>@@QBEXXZ ENDP ; <lambda_3648d362fc95221bbf9c4c4a922d1611>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obscapture.cpp
;	COMDAT ?MainAudioThread@OBS@@CGKPAX@Z
_TEXT	SEGMENT
_lpUnused$ = 8						; size = 4
?MainAudioThread@OBS@@CGKPAX@Z PROC			; OBS::MainAudioThread, COMDAT

; 1198 : {

	push	ebp
	mov	ebp, esp

; 1199 :     CoInitialize(0);

	push	0
	call	DWORD PTR __imp__CoInitialize@4

; 1200 :     App->MainAudioLoop();

	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	call	?MainAudioLoop@OBS@@AAEXXZ		; OBS::MainAudioLoop

; 1201 :     CoUninitialize();

	call	DWORD PTR __imp__CoUninitialize@0

; 1202 :     return 0;

	xor	eax, eax

; 1203 : }

	pop	ebp
	ret	4
?MainAudioThread@OBS@@CGKPAX@Z ENDP			; OBS::MainAudioThread
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obscapture.cpp
;	COMDAT ?CalculateVolumeLevels@@YAXPAMHMAAM1@Z
_TEXT	SEGMENT
$T1 = -288						; size = 16
$T2 = -272						; size = 16
_halfmaxP$3 = -256					; size = 16
$T4 = -240						; size = 16
$T5 = -224						; size = 16
$T6 = -208						; size = 16
$T7 = -192						; size = 16
_sseMulVal$8 = -176					; size = 16
_sseSquaresP$9 = -160					; size = 16
$T10 = -144						; size = 16
$T11 = -128						; size = 16
_maxs$12 = -112						; size = 16
_sseScaledVals$13 = -96					; size = 16
_halfmax$14 = -80					; size = 16
_sseSquares$15 = -64					; size = 16
_totalFloatsStore$ = -40				; size = 4
tv147 = -36						; size = 4
_val$16 = -32						; size = 4
tv159 = -28						; size = 4
_alignedFloats$17 = -24					; size = 4
_pow2Val$18 = -20					; size = 4
_i$19 = -16						; size = 4
_i$20 = -12						; size = 4
_sum$ = -8						; size = 4
_Max$ = -4						; size = 4
_buffer$ = 8						; size = 4
_totalFloats$ = 12					; size = 4
_mulVal$ = 16						; size = 4
_RMS$ = 20						; size = 4
_MAX$ = 24						; size = 4
?CalculateVolumeLevels@@YAXPAMHMAAM1@Z PROC		; CalculateVolumeLevels, COMDAT

; 1208 : {

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -16				; fffffff0H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [esp+4], ebp
	mov	ebp, esp
	sub	esp, 288				; 00000120H

; 1209 :     float sum = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _sum$[ebp], xmm0

; 1210 :     int totalFloatsStore = totalFloats;

	mov	eax, DWORD PTR _totalFloats$[ebx]
	mov	DWORD PTR _totalFloatsStore$[ebp], eax

; 1211 : 
; 1212 :     float Max = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _Max$[ebp], xmm0

; 1213 : 
; 1214 :     if((UPARAM(buffer) & 0xF) == 0)

	mov	ecx, DWORD PTR _buffer$[ebx]
	and	ecx, 15					; 0000000fH
	jne	$LN7@CalculateV

; 1215 :     {
; 1216 :         UINT alignedFloats = totalFloats & 0xFFFFFFFC;

	mov	edx, DWORD PTR _totalFloats$[ebx]
	and	edx, -4					; fffffffcH
	mov	DWORD PTR _alignedFloats$17[ebp], edx

; 1217 :         __m128 sseMulVal = _mm_set_ps1(mulVal);

	movss	xmm0, DWORD PTR _mulVal$[ebx]
	shufps	xmm0, xmm0, 0
	movaps	XMMWORD PTR $T6[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T6[ebp]
	movaps	XMMWORD PTR _sseMulVal$8[ebp], xmm0

; 1218 : 
; 1219 :         for(UINT i=0; i<alignedFloats; i += 4)

	mov	DWORD PTR _i$20[ebp], 0
	jmp	SHORT $LN6@CalculateV
$LN5@CalculateV:
	mov	eax, DWORD PTR _i$20[ebp]
	add	eax, 4
	mov	DWORD PTR _i$20[ebp], eax
$LN6@CalculateV:
	mov	ecx, DWORD PTR _i$20[ebp]
	cmp	ecx, DWORD PTR _alignedFloats$17[ebp]
	jae	$LN4@CalculateV

; 1220 :         {
; 1221 :             __m128 sseScaledVals = _mm_mul_ps(_mm_load_ps(buffer+i), sseMulVal);

	mov	edx, DWORD PTR _i$20[ebp]
	mov	eax, DWORD PTR _buffer$[ebx]
	movaps	xmm0, XMMWORD PTR [eax+edx*4]
	movaps	XMMWORD PTR $T2[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T2[ebp]
	mulps	xmm0, XMMWORD PTR _sseMulVal$8[ebp]
	movaps	XMMWORD PTR $T4[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T4[ebp]
	movaps	XMMWORD PTR _sseScaledVals$13[ebp], xmm0

; 1222 : 
; 1223 :             /*compute squares and add them to the sum*/
; 1224 :             __m128 sseSquares = _mm_mul_ps(sseScaledVals, sseScaledVals);

	movaps	xmm0, XMMWORD PTR _sseScaledVals$13[ebp]
	mulps	xmm0, XMMWORD PTR _sseScaledVals$13[ebp]
	movaps	XMMWORD PTR $T11[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T11[ebp]
	movaps	XMMWORD PTR _sseSquares$15[ebp], xmm0

; 1225 :             sum += sseSquares.m128_f32[0] + sseSquares.m128_f32[1] + sseSquares.m128_f32[2] + sseSquares.m128_f32[3];

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _sseSquares$15[ebp+edx]
	addss	xmm0, DWORD PTR _sseSquares$15[ebp+eax]
	mov	ecx, 4
	shl	ecx, 1
	addss	xmm0, DWORD PTR _sseSquares$15[ebp+ecx]
	mov	edx, 4
	imul	eax, edx, 3
	addss	xmm0, DWORD PTR _sseSquares$15[ebp+eax]
	addss	xmm0, DWORD PTR _sum$[ebp]
	movss	DWORD PTR _sum$[ebp], xmm0

; 1226 : 
; 1227 :             /* 
; 1228 :                 sse maximum of squared floats 
; 1229 :                 concept from: http://stackoverflow.com/questions/9795529/how-to-find-the-horizontal-maximum-in-a-256-bit-avx-vector
; 1230 :             */
; 1231 :             __m128 sseSquaresP = _mm_shuffle_ps(sseSquares, sseSquares, _MM_SHUFFLE(1, 0, 3, 2));

	movaps	xmm0, XMMWORD PTR _sseSquares$15[ebp]
	shufps	xmm0, XMMWORD PTR _sseSquares$15[ebp], 78 ; 0000004eH
	movaps	XMMWORD PTR $T10[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T10[ebp]
	movaps	XMMWORD PTR _sseSquaresP$9[ebp], xmm0

; 1232 :             __m128 halfmax = _mm_max_ps(sseSquares, sseSquaresP);

	movaps	xmm0, XMMWORD PTR _sseSquares$15[ebp]
	maxps	xmm0, XMMWORD PTR _sseSquaresP$9[ebp]
	movaps	XMMWORD PTR $T7[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T7[ebp]
	movaps	XMMWORD PTR _halfmax$14[ebp], xmm0

; 1233 :             __m128 halfmaxP = _mm_shuffle_ps(halfmax, halfmax, _MM_SHUFFLE(0,1,2,3));

	movaps	xmm0, XMMWORD PTR _halfmax$14[ebp]
	shufps	xmm0, XMMWORD PTR _halfmax$14[ebp], 27	; 0000001bH
	movaps	XMMWORD PTR $T5[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T5[ebp]
	movaps	XMMWORD PTR _halfmaxP$3[ebp], xmm0

; 1234 :             __m128 maxs = _mm_max_ps(halfmax, halfmaxP);

	movaps	xmm0, XMMWORD PTR _halfmax$14[ebp]
	maxps	xmm0, XMMWORD PTR _halfmaxP$3[ebp]
	movaps	XMMWORD PTR $T1[ebp], xmm0
	movaps	xmm0, XMMWORD PTR $T1[ebp]
	movaps	XMMWORD PTR _maxs$12[ebp], xmm0

; 1235 : 
; 1236 :             Max = max(Max, maxs.m128_f32[0]);

	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR _Max$[ebp]
	comiss	xmm0, DWORD PTR _maxs$12[ebp+edx]
	jbe	SHORT $LN10@CalculateV
	movss	xmm0, DWORD PTR _Max$[ebp]
	movss	DWORD PTR tv147[ebp], xmm0
	jmp	SHORT $LN11@CalculateV
$LN10@CalculateV:
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR _maxs$12[ebp+ecx]
	movss	DWORD PTR tv147[ebp], xmm0
$LN11@CalculateV:
	movss	xmm0, DWORD PTR tv147[ebp]
	movss	DWORD PTR _Max$[ebp], xmm0

; 1237 :         }

	jmp	$LN5@CalculateV
$LN4@CalculateV:

; 1238 : 
; 1239 :         buffer      += alignedFloats;

	mov	edx, DWORD PTR _alignedFloats$17[ebp]
	mov	eax, DWORD PTR _buffer$[ebx]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _buffer$[ebx], ecx

; 1240 :         totalFloats -= alignedFloats;

	mov	edx, DWORD PTR _totalFloats$[ebx]
	sub	edx, DWORD PTR _alignedFloats$17[ebp]
	mov	DWORD PTR _totalFloats$[ebx], edx
$LN7@CalculateV:

; 1241 :     }
; 1242 : 
; 1243 :     for(int i=0; i<totalFloats; i++)

	mov	DWORD PTR _i$19[ebp], 0
	jmp	SHORT $LN3@CalculateV
$LN2@CalculateV:
	mov	eax, DWORD PTR _i$19[ebp]
	add	eax, 1
	mov	DWORD PTR _i$19[ebp], eax
$LN3@CalculateV:
	mov	ecx, DWORD PTR _i$19[ebp]
	cmp	ecx, DWORD PTR _totalFloats$[ebx]
	jge	SHORT $LN1@CalculateV

; 1244 :     {
; 1245 :         float val = buffer[i] * mulVal;

	mov	edx, DWORD PTR _i$19[ebp]
	mov	eax, DWORD PTR _buffer$[ebx]
	movss	xmm0, DWORD PTR [eax+edx*4]
	mulss	xmm0, DWORD PTR _mulVal$[ebx]
	movss	DWORD PTR _val$16[ebp], xmm0

; 1246 :         float pow2Val = val * val;

	movss	xmm0, DWORD PTR _val$16[ebp]
	mulss	xmm0, DWORD PTR _val$16[ebp]
	movss	DWORD PTR _pow2Val$18[ebp], xmm0

; 1247 :         sum += pow2Val;

	movss	xmm0, DWORD PTR _sum$[ebp]
	addss	xmm0, DWORD PTR _pow2Val$18[ebp]
	movss	DWORD PTR _sum$[ebp], xmm0

; 1248 :         Max = max(Max, pow2Val);

	movss	xmm0, DWORD PTR _Max$[ebp]
	comiss	xmm0, DWORD PTR _pow2Val$18[ebp]
	jbe	SHORT $LN12@CalculateV
	movss	xmm0, DWORD PTR _Max$[ebp]
	movss	DWORD PTR tv159[ebp], xmm0
	jmp	SHORT $LN13@CalculateV
$LN12@CalculateV:
	movss	xmm0, DWORD PTR _pow2Val$18[ebp]
	movss	DWORD PTR tv159[ebp], xmm0
$LN13@CalculateV:
	movss	xmm0, DWORD PTR tv159[ebp]
	movss	DWORD PTR _Max$[ebp], xmm0

; 1249 :     }

	jmp	SHORT $LN2@CalculateV
$LN1@CalculateV:

; 1250 : 
; 1251 :     RMS = sqrt(sum / totalFloatsStore);

	cvtsi2ss xmm0, DWORD PTR _totalFloatsStore$[ebp]
	movss	xmm1, DWORD PTR _sum$[ebp]
	divss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	mov	ecx, DWORD PTR _RMS$[ebx]
	fstp	DWORD PTR [ecx]

; 1252 :     MAX = sqrt(Max);

	push	ecx
	movss	xmm0, DWORD PTR _Max$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4
	mov	edx, DWORD PTR _MAX$[ebx]
	fstp	DWORD PTR [edx]

; 1253 : }

	mov	esp, ebp
	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	0
?CalculateVolumeLevels@@YAXPAMHMAAM1@Z ENDP		; CalculateVolumeLevels
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obscapture.cpp
;	COMDAT ?toDB@@YAMM@Z
_TEXT	SEGMENT
tv76 = -8						; size = 4
_db$ = -4						; size = 4
_RMS$ = 8						; size = 4
?toDB@@YAMM@Z PROC					; toDB, COMDAT

; 1256 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1257 :     float db = 20.0f * log10(RMS);

	push	ecx
	movss	xmm0, DWORD PTR _RMS$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?log10@@YAMM@Z				; log10
	add	esp, 4
	fstp	DWORD PTR tv76[ebp]
	movss	xmm0, DWORD PTR tv76[ebp]
	mulss	xmm0, DWORD PTR __real@41a00000
	movss	DWORD PTR _db$[ebp], xmm0

; 1258 :     if(!_finite(db))

	cvtss2sd xmm0, DWORD PTR _db$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	__finite
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN1@toDB

; 1259 :         return VOL_MIN;

	fld	DWORD PTR __real@c2c00000
	jmp	SHORT $LN2@toDB
$LN1@toDB:

; 1260 :     return db;

	fld	DWORD PTR _db$[ebp]
$LN2@toDB:

; 1261 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?toDB@@YAMM@Z ENDP					; toDB
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obscapture.cpp
;	COMDAT ?QueryAudioBuffers@OBS@@AAE_N_N@Z
_TEXT	SEGMENT
_latestDesktopTimestamp$1 = -32				; size = 8
tv186 = -24						; size = 8
tv164 = -16						; size = 4
_i$2 = -12						; size = 4
_this$ = -8						; size = 4
_bGotSomeAudio$ = -1					; size = 1
_bQueriedDesktopDebugParam$ = 8				; size = 1
?QueryAudioBuffers@OBS@@AAE_N_N@Z PROC			; OBS::QueryAudioBuffers, COMDAT
; _this$ = ecx

; 1264 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 1265 :     bool bGotSomeAudio = false;

	mov	BYTE PTR _bGotSomeAudio$[ebp], 0

; 1266 : 
; 1267 :     if (!latestAudioTime) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv164[ebp], eax
	mov	ecx, DWORD PTR tv164[ebp]
	mov	edx, DWORD PTR tv164[ebp]
	mov	eax, DWORD PTR [ecx+1160]
	or	eax, DWORD PTR [edx+1164]
	jne	SHORT $LN10@QueryAudio

; 1268 :         desktopAudio->GetEarliestTimestamp(latestAudioTime); //will always return true

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1160				; 00000488H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+112]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+112]
	mov	eax, DWORD PTR [edx+20]
	call	eax

; 1269 :     } else {

	jmp	SHORT $LN9@QueryAudio
$LN10@QueryAudio:

; 1270 :         QWORD latestDesktopTimestamp;
; 1271 :         if (desktopAudio->GetLatestTimestamp(latestDesktopTimestamp)) {

	lea	ecx, DWORD PTR _latestDesktopTimestamp$1[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+112]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+112]
	mov	eax, DWORD PTR [edx+44]
	call	eax
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN7@QueryAudio

; 1272 :             if ((latestAudioTime+10) > latestDesktopTimestamp)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1160]
	add	eax, 10					; 0000000aH
	mov	ecx, DWORD PTR [edx+1164]
	adc	ecx, 0
	mov	DWORD PTR tv186[ebp], eax
	mov	DWORD PTR tv186[ebp+4], ecx
	mov	edx, DWORD PTR tv186[ebp+4]
	cmp	edx, DWORD PTR _latestDesktopTimestamp$1[ebp+4]
	jb	SHORT $LN7@QueryAudio
	ja	SHORT $LN13@QueryAudio
	mov	eax, DWORD PTR tv186[ebp]
	cmp	eax, DWORD PTR _latestDesktopTimestamp$1[ebp]
	jbe	SHORT $LN7@QueryAudio
$LN13@QueryAudio:

; 1273 :                 return false;

	xor	al, al
	jmp	$LN11@QueryAudio
$LN7@QueryAudio:

; 1274 :         }
; 1275 :         latestAudioTime += 10;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1160]
	add	edx, 10					; 0000000aH
	mov	eax, DWORD PTR [ecx+1164]
	adc	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1160], edx
	mov	DWORD PTR [ecx+1164], eax
$LN9@QueryAudio:

; 1276 :     }
; 1277 : 
; 1278 :     bufferedAudioTimes << latestAudioTime;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1160				; 00000488H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1128				; 00000468H
	call	??6?$CircularList@_K@@QAEAAV0@AB_K@Z	; CircularList<unsigned __int64>::operator<<

; 1279 : 
; 1280 :     OSEnterMutex(hAuxAudioMutex);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1228]
	push	ecx
	call	DWORD PTR __imp_?OSEnterMutex@@YGXPAX@Z

; 1281 :     for(UINT i=0; i<auxAudioSources.Num(); i++)

	mov	DWORD PTR _i$2[ebp], 0
	jmp	SHORT $LN6@QueryAudio
$LN5@QueryAudio:
	mov	edx, DWORD PTR _i$2[ebp]
	add	edx, 1
	mov	DWORD PTR _i$2[ebp], edx
$LN6@QueryAudio:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 120				; 00000078H
	call	?Num@?$List@PAVAudioSource@@@@QBEIXZ	; List<AudioSource *>::Num
	cmp	DWORD PTR _i$2[ebp], eax
	jae	SHORT $LN4@QueryAudio

; 1282 :     {
; 1283 :         if (auxAudioSources[i]->QueryAudio2(auxAudioSources[i]->GetVolume(), true) != NoAudioAvailable)

	push	1
	mov	eax, DWORD PTR _i$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 120				; 00000078H
	call	??A?$List@PAVAudioSource@@@@QAEAAPAVAudioSource@@I@Z ; List<AudioSource *>::operator[]
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR __imp_?GetVolume@AudioSource@@QBEMXZ
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _i$2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 120				; 00000078H
	call	??A?$List@PAVAudioSource@@@@QAEAAPAVAudioSource@@I@Z ; List<AudioSource *>::operator[]
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR __imp_?QueryAudio2@AudioSource@@QAEIM_N@Z
	test	eax, eax
	je	SHORT $LN3@QueryAudio

; 1284 :             bGotSomeAudio = true;

	mov	BYTE PTR _bGotSomeAudio$[ebp], 1
$LN3@QueryAudio:

; 1285 :     }

	jmp	SHORT $LN5@QueryAudio
$LN4@QueryAudio:

; 1286 : 
; 1287 :     OSLeaveMutex(hAuxAudioMutex);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1228]
	push	eax
	call	DWORD PTR __imp_?OSLeaveMutex@@YGXPAX@Z

; 1288 : 
; 1289 :     if(micAudio != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+116], 0
	je	SHORT $LN1@QueryAudio

; 1290 :     {
; 1291 :         if (micAudio->QueryAudio2(curMicVol, true) != NoAudioAvailable)

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+1176]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+116]
	call	DWORD PTR __imp_?QueryAudio2@AudioSource@@QAEIM_N@Z
	test	eax, eax
	je	SHORT $LN1@QueryAudio

; 1292 :             bGotSomeAudio = true;

	mov	BYTE PTR _bGotSomeAudio$[ebp], 1
$LN1@QueryAudio:

; 1293 :     }
; 1294 : 
; 1295 :     return bGotSomeAudio;

	mov	al, BYTE PTR _bGotSomeAudio$[ebp]
$LN11@QueryAudio:

; 1296 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?QueryAudioBuffers@OBS@@AAE_N_N@Z ENDP			; OBS::QueryAudioBuffers
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obscapture.cpp
;	COMDAT ?QueryNewAudio@OBS@@AAE_NXZ
_TEXT	SEGMENT
tv309 = -64						; size = 8
tv306 = -56						; size = 8
tv276 = -48						; size = 8
tv273 = -40						; size = 8
_timestamp$1 = -32					; size = 8
tv198 = -24						; size = 4
tv155 = -20						; size = 4
_burst$2 = -16						; size = 4
_i$3 = -12						; size = 4
_this$ = -8						; size = 4
_bGotAudio$4 = -2					; size = 1
_bAudioBufferFilled$ = -1				; size = 1
?QueryNewAudio@OBS@@AAE_NXZ PROC			; OBS::QueryNewAudio, COMDAT
; _this$ = ecx

; 1299 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1300 :     bool bAudioBufferFilled = false;

	mov	BYTE PTR _bAudioBufferFilled$[ebp], 0
$LN21@QueryNewAu:

; 1301 : 
; 1302 :     while (!bAudioBufferFilled) {

	movzx	eax, BYTE PTR _bAudioBufferFilled$[ebp]
	test	eax, eax
	jne	$LN20@QueryNewAu

; 1303 :         bool bGotAudio = false;

	mov	BYTE PTR _bGotAudio$4[ebp], 0

; 1304 : 
; 1305 :         //don't let the audio get backed up too far, as this breaks things
; 1306 :         if (desktopAudio->GetBufferedTime() > App->bufferingTime * 1.5)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+112]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+112]
	mov	eax, DWORD PTR [edx+32]
	call	eax
	mov	ecx, eax
	call	__ultod3
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	cvtsi2sd xmm1, DWORD PTR [ecx+944]
	mulsd	xmm1, QWORD PTR __real@3ff8000000000000
	comisd	xmm0, xmm1
	jbe	SHORT $LN19@QueryNewAu

; 1307 :         {
; 1308 :             if (!audioWarningId)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+996], 0
	jne	SHORT $LN18@QueryNewAu

; 1309 :                 audioWarningId = App->AddStreamInfo(TEXT("Audio is processing too slow. Free up CPU, reduce the number of audio sources or avoid resampling."), StreamInfoPriority_Critical);

	push	3
	push	OFFSET $SG4294795113
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	call	?AddStreamInfo@OBS@@QAEIPB_WW4StreamInfoPriority@@@Z ; OBS::AddStreamInfo
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+996], eax
$LN18@QueryNewAu:

; 1310 : 
; 1311 :             bAudioBufferFilled = true;

	mov	BYTE PTR _bAudioBufferFilled$[ebp], 1

; 1312 :         }
; 1313 :         else

	jmp	$LN17@QueryNewAu
$LN19@QueryNewAu:

; 1314 :         {
; 1315 :             if (audioWarningId && desktopAudio->GetBufferedTime() <= App->bufferingTime)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+996], 0
	je	SHORT $LN16@QueryNewAu
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+112]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+112]
	mov	edx, DWORD PTR [eax+32]
	call	edx
	mov	ecx, eax
	mov	esi, edx
	mov	edx, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	eax, DWORD PTR [edx+944]
	cdq
	mov	DWORD PTR tv273[ebp], ecx
	mov	DWORD PTR tv273[ebp+4], esi
	mov	DWORD PTR tv276[ebp], eax
	mov	DWORD PTR tv276[ebp+4], edx
	mov	eax, DWORD PTR tv273[ebp+4]
	cmp	eax, DWORD PTR tv276[ebp+4]
	ja	SHORT $LN16@QueryNewAu
	jb	SHORT $LN26@QueryNewAu
	mov	ecx, DWORD PTR tv273[ebp]
	cmp	ecx, DWORD PTR tv276[ebp]
	ja	SHORT $LN16@QueryNewAu
$LN26@QueryNewAu:

; 1316 :             {
; 1317 :                 App->RemoveStreamInfo(audioWarningId);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+996]
	push	eax
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	call	?RemoveStreamInfo@OBS@@QAEXI@Z		; OBS::RemoveStreamInfo

; 1318 :                 audioWarningId = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+996], 0
$LN16@QueryNewAu:

; 1319 :             }
; 1320 : 
; 1321 :             if ((desktopAudio->QueryAudio2(curDesktopVol)) != NoAudioAvailable) {

	push	0
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+1180]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+112]
	call	DWORD PTR __imp_?QueryAudio2@AudioSource@@QAEIM_N@Z
	test	eax, eax
	je	SHORT $LN15@QueryNewAu

; 1322 :                 QueryAudioBuffers(true);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?QueryAudioBuffers@OBS@@AAE_N_N@Z	; OBS::QueryAudioBuffers

; 1323 :                 bGotAudio = true;

	mov	BYTE PTR _bGotAudio$4[ebp], 1
$LN15@QueryNewAu:

; 1324 :             }
; 1325 : 
; 1326 :             bAudioBufferFilled = desktopAudio->GetBufferedTime() >= App->bufferingTime;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+112]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+112]
	mov	eax, DWORD PTR [edx+32]
	call	eax
	mov	ecx, eax
	mov	esi, edx
	mov	edx, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	eax, DWORD PTR [edx+944]
	cdq
	mov	DWORD PTR tv306[ebp], ecx
	mov	DWORD PTR tv306[ebp+4], esi
	mov	DWORD PTR tv309[ebp], eax
	mov	DWORD PTR tv309[ebp+4], edx
	mov	eax, DWORD PTR tv306[ebp+4]
	cmp	eax, DWORD PTR tv309[ebp+4]
	jb	SHORT $LN24@QueryNewAu
	ja	SHORT $LN27@QueryNewAu
	mov	ecx, DWORD PTR tv306[ebp]
	cmp	ecx, DWORD PTR tv309[ebp]
	jb	SHORT $LN24@QueryNewAu
$LN27@QueryNewAu:
	mov	DWORD PTR tv155[ebp], 1
	jmp	SHORT $LN25@QueryNewAu
$LN24@QueryNewAu:
	mov	DWORD PTR tv155[ebp], 0
$LN25@QueryNewAu:
	mov	dl, BYTE PTR tv155[ebp]
	mov	BYTE PTR _bAudioBufferFilled$[ebp], dl
$LN17@QueryNewAu:

; 1327 :         }
; 1328 : 
; 1329 :         if (!bGotAudio && bAudioBufferFilled)

	movzx	eax, BYTE PTR _bGotAudio$4[ebp]
	test	eax, eax
	jne	SHORT $LN14@QueryNewAu
	movzx	ecx, BYTE PTR _bAudioBufferFilled$[ebp]
	test	ecx, ecx
	je	SHORT $LN14@QueryNewAu

; 1330 :             QueryAudioBuffers(false);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?QueryAudioBuffers@OBS@@AAE_N_N@Z	; OBS::QueryAudioBuffers
$LN14@QueryNewAu:

; 1331 : 
; 1332 :         if (bAudioBufferFilled || !bGotAudio)

	movzx	edx, BYTE PTR _bAudioBufferFilled$[ebp]
	test	edx, edx
	jne	SHORT $LN12@QueryNewAu
	movzx	eax, BYTE PTR _bGotAudio$4[ebp]
	test	eax, eax
	jne	SHORT $LN13@QueryNewAu
$LN12@QueryNewAu:

; 1333 :             break;

	jmp	SHORT $LN20@QueryNewAu
$LN13@QueryNewAu:

; 1334 :     }

	jmp	$LN21@QueryNewAu
$LN20@QueryNewAu:

; 1335 : 
; 1336 :     /* wait until buffers are completely filled before accounting for burst */
; 1337 :     if (!bAudioBufferFilled)

	movzx	ecx, BYTE PTR _bAudioBufferFilled$[ebp]
	test	ecx, ecx
	jne	$LN1@QueryNewAu

; 1338 :     {
; 1339 :         QWORD timestamp;
; 1340 :         int burst = 0;

	mov	DWORD PTR _burst$2[ebp], 0

; 1341 : 
; 1342 :         // No more desktop data, drain auxilary/mic buffers until they're dry to prevent burst data
; 1343 :         OSEnterMutex(hAuxAudioMutex);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1228]
	push	eax
	call	DWORD PTR __imp_?OSEnterMutex@@YGXPAX@Z

; 1344 :         for(UINT i=0; i<auxAudioSources.Num(); i++)

	mov	DWORD PTR _i$3[ebp], 0
	jmp	SHORT $LN10@QueryNewAu
$LN9@QueryNewAu:
	mov	ecx, DWORD PTR _i$3[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$3[ebp], ecx
$LN10@QueryNewAu:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 120				; 00000078H
	call	?Num@?$List@PAVAudioSource@@@@QBEIXZ	; List<AudioSource *>::Num
	cmp	DWORD PTR _i$3[ebp], eax
	jae	$LN8@QueryNewAu
$LN7@QueryNewAu:

; 1345 :         {
; 1346 :             while (auxAudioSources[i]->QueryAudio2(auxAudioSources[i]->GetVolume(), true) != NoAudioAvailable)

	push	1
	mov	edx, DWORD PTR _i$3[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 120				; 00000078H
	call	??A?$List@PAVAudioSource@@@@QAEAAPAVAudioSource@@I@Z ; List<AudioSource *>::operator[]
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR __imp_?GetVolume@AudioSource@@QBEMXZ
	push	ecx
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _i$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 120				; 00000078H
	call	??A?$List@PAVAudioSource@@@@QAEAAPAVAudioSource@@I@Z ; List<AudioSource *>::operator[]
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR __imp_?QueryAudio2@AudioSource@@QAEIM_N@Z
	test	eax, eax
	je	SHORT $LN6@QueryNewAu

; 1347 :                 burst++;

	mov	ecx, DWORD PTR _burst$2[ebp]
	add	ecx, 1
	mov	DWORD PTR _burst$2[ebp], ecx
	jmp	SHORT $LN7@QueryNewAu
$LN6@QueryNewAu:

; 1348 : 
; 1349 :             if (auxAudioSources[i]->GetLatestTimestamp(timestamp))

	mov	edx, DWORD PTR _i$3[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 120				; 00000078H
	call	??A?$List@PAVAudioSource@@@@QAEAAPAVAudioSource@@I@Z ; List<AudioSource *>::operator[]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR tv198[ebp], eax
	lea	ecx, DWORD PTR _timestamp$1[ebp]
	push	ecx
	mov	edx, DWORD PTR tv198[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv198[ebp]
	mov	edx, DWORD PTR [eax+44]
	call	edx
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@QueryNewAu

; 1350 :                 auxAudioSources[i]->SortAudio(timestamp);

	mov	ecx, DWORD PTR _timestamp$1[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _timestamp$1[ebp]
	push	edx
	mov	eax, DWORD PTR _i$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 120				; 00000078H
	call	??A?$List@PAVAudioSource@@@@QAEAAPAVAudioSource@@I@Z ; List<AudioSource *>::operator[]
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR __imp_?SortAudio@AudioSource@@QAEX_K@Z
$LN5@QueryNewAu:

; 1351 : 
; 1352 :             /*if (burst > 10)
; 1353 :                 Log(L"Burst happened for %s", auxAudioSources[i]->GetDeviceName2());*/
; 1354 :         }

	jmp	$LN9@QueryNewAu
$LN8@QueryNewAu:

; 1355 : 
; 1356 :         OSLeaveMutex(hAuxAudioMutex);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1228]
	push	edx
	call	DWORD PTR __imp_?OSLeaveMutex@@YGXPAX@Z

; 1357 : 
; 1358 :         burst = 0;

	mov	DWORD PTR _burst$2[ebp], 0

; 1359 : 
; 1360 :         if (micAudio)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+116], 0
	je	SHORT $LN1@QueryNewAu
$LN3@QueryNewAu:

; 1361 :         {
; 1362 :             while (micAudio->QueryAudio2(curMicVol, true) != NoAudioAvailable)

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+1176]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+116]
	call	DWORD PTR __imp_?QueryAudio2@AudioSource@@QAEIM_N@Z
	test	eax, eax
	je	SHORT $LN2@QueryNewAu

; 1363 :                 burst++;

	mov	eax, DWORD PTR _burst$2[ebp]
	add	eax, 1
	mov	DWORD PTR _burst$2[ebp], eax
	jmp	SHORT $LN3@QueryNewAu
$LN2@QueryNewAu:

; 1364 : 
; 1365 :             /*if (burst > 10)
; 1366 :                 Log(L"Burst happened for %s", micAudio->GetDeviceName2());*/
; 1367 : 
; 1368 :             if (micAudio->GetLatestTimestamp(timestamp))

	lea	ecx, DWORD PTR _timestamp$1[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+116]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+116]
	mov	eax, DWORD PTR [edx+44]
	call	eax
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@QueryNewAu

; 1369 :                 micAudio->SortAudio(timestamp);

	mov	edx, DWORD PTR _timestamp$1[ebp+4]
	push	edx
	mov	eax, DWORD PTR _timestamp$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+116]
	call	DWORD PTR __imp_?SortAudio@AudioSource@@QAEX_K@Z
$LN1@QueryNewAu:

; 1370 :         }
; 1371 :     }
; 1372 : 
; 1373 :     return bAudioBufferFilled;

	mov	al, BYTE PTR _bAudioBufferFilled$[ebp]

; 1374 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?QueryNewAudio@OBS@@AAE_NXZ ENDP			; OBS::QueryNewAudio
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obscapture.cpp
;	COMDAT ?EncodeAudioSegment@OBS@@AAEXPAMI_K@Z
_TEXT	SEGMENT
_packet$ = -16						; size = 8
_frameAudio$1 = -8					; size = 4
_this$ = -4						; size = 4
_buffer$ = 8						; size = 4
_numFrames$ = 12					; size = 4
_timestamp$ = 16					; size = 8
?EncodeAudioSegment@OBS@@AAEXPAMI_K@Z PROC		; OBS::EncodeAudioSegment, COMDAT
; _this$ = ecx

; 1377 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1378 :     DataPacket packet;
; 1379 :     if(audioEncoder->Encode(buffer, numFrames, packet, timestamp))

	lea	eax, DWORD PTR _timestamp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _packet$[ebp]
	push	ecx
	mov	edx, DWORD PTR _numFrames$[ebp]
	push	edx
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+140]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+140]
	mov	eax, DWORD PTR [edx]
	call	eax
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@EncodeAudi

; 1380 :     {
; 1381 :         OSEnterMutex(hSoundDataMutex);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1152]
	push	eax
	call	DWORD PTR __imp_?OSEnterMutex@@YGXPAX@Z

; 1382 : 
; 1383 :         FrameAudio *frameAudio = pendingAudioFrames.CreateNew();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1208				; 000004b8H
	call	?CreateNew@?$List@UFrameAudio@@@@QAEPAUFrameAudio@@XZ ; List<FrameAudio>::CreateNew
	mov	DWORD PTR _frameAudio$1[ebp], eax

; 1384 :         frameAudio->audioData.CopyArray(packet.lpPacket, packet.size);

	mov	ecx, DWORD PTR _packet$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _packet$[ebp]
	push	edx
	mov	ecx, DWORD PTR _frameAudio$1[ebp]
	call	?CopyArray@?$List@E@@QAEXPBEI@Z		; List<unsigned char>::CopyArray

; 1385 :         frameAudio->timestamp = timestamp;

	mov	eax, DWORD PTR _frameAudio$1[ebp]
	mov	ecx, DWORD PTR _timestamp$[ebp]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _timestamp$[ebp+4]
	mov	DWORD PTR [eax+12], edx

; 1386 : 
; 1387 :         OSLeaveMutex(hSoundDataMutex);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1152]
	push	ecx
	call	DWORD PTR __imp_?OSLeaveMutex@@YGXPAX@Z
$LN2@EncodeAudi:

; 1388 :     }
; 1389 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?EncodeAudioSegment@OBS@@AAEXPAMI_K@Z ENDP		; OBS::EncodeAudioSegment
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obscapture.cpp
;	COMDAT ?MainAudioLoop@OBS@@AAEXXZ
_TEXT	SEGMENT
_hTask$ = -148						; size = 4
_taskID$ = -144						; size = 4
_auxBuffer$1 = -140					; size = 4
_latestAuxBuffer$2 = -136				; size = 4
tv151 = -132						; size = 4
tv241 = -128						; size = 4
tv147 = -124						; size = 4
tv138 = -120						; size = 4
tv266 = -116						; size = 4
_peakMeterDelayFrames$3 = -112				; size = 4
_audioSamplesPerSec$ = -108				; size = 4
_levelsBuffer$ = -104					; size = 8
_desktopBuffer$4 = -96					; size = 4
_mixBuffer$ = -92					; size = 8
_bDesktopMuted$5 = -81					; size = 1
_latestMicBuffer$6 = -80				; size = 4
_micBuffer$7 = -76					; size = 4
_i$8 = -72						; size = 4
_i$9 = -68						; size = 4
_audioFramesSinceMeterUpdate$ = -64			; size = 4
_maxAlpha$10 = -60					; size = 4
_rmsAlpha$11 = -56					; size = 4
_audioFramesSinceMicMaxUpdate$ = -52			; size = 4
_micRMS$12 = -48					; size = 4
_latestDesktopBuffer$13 = -44				; size = 4
_desktopRMS$14 = -40					; size = 4
_timestamp$15 = -36					; size = 8
_audioFramesSinceDesktopMaxUpdate$ = -28		; size = 4
_i$16 = -24						; size = 4
_desktopMx$17 = -20					; size = 4
_micMx$18 = -16						; size = 4
_bMicEnabled$19 = -9					; size = 1
_audioSampleSize$ = -8					; size = 4
_this$ = -4						; size = 4
?MainAudioLoop@OBS@@AAEXXZ PROC				; OBS::MainAudioLoop, COMDAT
; _this$ = ecx

; 1392 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 148				; 00000094H
	mov	DWORD PTR _this$[ebp], ecx

; 1393 :     const unsigned int audioSamplesPerSec = App->GetSampleRateHz();

	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	call	?GetSampleRateHz@OBS@@QBEIXZ		; OBS::GetSampleRateHz
	mov	DWORD PTR _audioSamplesPerSec$[ebp], eax

; 1394 :     const unsigned int audioSampleSize = audioSamplesPerSec/100;

	mov	eax, DWORD PTR _audioSamplesPerSec$[ebp]
	xor	edx, edx
	mov	ecx, 100				; 00000064H
	div	ecx
	mov	DWORD PTR _audioSampleSize$[ebp], eax

; 1395 : 
; 1396 :     DWORD taskID = 0;

	mov	DWORD PTR _taskID$[ebp], 0

; 1397 :     HANDLE hTask = AvSetMmThreadCharacteristics(TEXT("Pro Audio"), &taskID);

	lea	edx, DWORD PTR _taskID$[ebp]
	push	edx
	push	OFFSET $SG4294795112
	call	DWORD PTR __imp__AvSetMmThreadCharacteristicsW@8
	mov	DWORD PTR _hTask$[ebp], eax

; 1398 : 
; 1399 :     bufferedAudioTimes.Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1128				; 00000468H
	call	?Clear@?$CircularList@_K@@QAEXXZ	; CircularList<unsigned __int64>::Clear

; 1400 : 
; 1401 :     bPushToTalkOn = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+1245], 0

; 1402 : 
; 1403 :     micMax = desktopMax = VOL_MIN;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@c2c00000
	movss	DWORD PTR [ecx+1192], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@c2c00000
	movss	DWORD PTR [edx+1196], xmm0

; 1404 :     micPeak = desktopPeak = VOL_MIN;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@c2c00000
	movss	DWORD PTR [eax+1184], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@c2c00000
	movss	DWORD PTR [ecx+1188], xmm0

; 1405 : 
; 1406 :     UINT audioFramesSinceMeterUpdate = 0;

	mov	DWORD PTR _audioFramesSinceMeterUpdate$[ebp], 0

; 1407 :     UINT audioFramesSinceMicMaxUpdate = 0;

	mov	DWORD PTR _audioFramesSinceMicMaxUpdate$[ebp], 0

; 1408 :     UINT audioFramesSinceDesktopMaxUpdate = 0;

	mov	DWORD PTR _audioFramesSinceDesktopMaxUpdate$[ebp], 0

; 1409 : 
; 1410 :     List<float> mixBuffer, levelsBuffer;

	lea	ecx, DWORD PTR _mixBuffer$[ebp]
	call	??0?$List@M@@QAE@XZ			; List<float>::List<float>
	lea	ecx, DWORD PTR _levelsBuffer$[ebp]
	call	??0?$List@M@@QAE@XZ			; List<float>::List<float>

; 1411 :     mixBuffer.SetSize(audioSampleSize*2);

	mov	edx, DWORD PTR _audioSampleSize$[ebp]
	shl	edx, 1
	push	edx
	lea	ecx, DWORD PTR _mixBuffer$[ebp]
	call	?SetSize@?$List@M@@QAEHI@Z		; List<float>::SetSize

; 1412 :     levelsBuffer.SetSize(audioSampleSize*2);

	mov	eax, DWORD PTR _audioSampleSize$[ebp]
	shl	eax, 1
	push	eax
	lea	ecx, DWORD PTR _levelsBuffer$[ebp]
	call	?SetSize@?$List@M@@QAEHI@Z		; List<float>::SetSize

; 1413 : 
; 1414 :     latestAudioTime = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1160], 0
	mov	DWORD PTR [ecx+1164], 0
$LN36@MainAudioL:

; 1415 : 
; 1416 :     //---------------------------------------------
; 1417 :     // the audio loop of doom
; 1418 : 
; 1419 :     while (true) {

	mov	edx, 1
	test	edx, edx
	je	$LN35@MainAudioL

; 1420 :         
; 1421 :         if (!bRunning)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+622]
	test	ecx, ecx
	jne	SHORT $LN34@MainAudioL

; 1422 :             break;

	jmp	$LN35@MainAudioL
$LN34@MainAudioL:

; 1423 : 
; 1424 :         //-----------------------------------------------
; 1425 : 
; 1426 :         float *desktopBuffer = nullptr, *micBuffer = nullptr;

	mov	DWORD PTR _desktopBuffer$4[ebp], 0
	mov	DWORD PTR _micBuffer$7[ebp], 0

; 1427 : 
; 1428 :         curDesktopVol = desktopVol * desktopBoost;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1168]
	mulss	xmm0, DWORD PTR [eax+1220]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+1180], xmm0

; 1429 : 
; 1430 :         if (bUsingPushToTalk)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+1244]
	test	eax, eax
	je	SHORT $LN33@MainAudioL

; 1431 :             curMicVol = bPushToTalkOn ? micVol : 0.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+1245]
	test	edx, edx
	je	SHORT $LN39@MainAudioL
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1172]
	movss	DWORD PTR tv138[ebp], xmm0
	jmp	SHORT $LN40@MainAudioL
$LN39@MainAudioL:
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR tv138[ebp], xmm0
$LN40@MainAudioL:
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR tv138[ebp]
	movss	DWORD PTR [ecx+1176], xmm0

; 1432 :         else

	jmp	SHORT $LN32@MainAudioL
$LN33@MainAudioL:

; 1433 :             curMicVol = micVol;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1172]
	mov	DWORD PTR [edx+1176], ecx
$LN32@MainAudioL:

; 1434 : 
; 1435 :         curMicVol *= micBoost;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+1176]
	mulss	xmm0, DWORD PTR [eax+1224]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+1176], xmm0

; 1436 : 
; 1437 :         bool bDesktopMuted = (curDesktopVol < VOLN_MUTELEVEL);

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@3d4ccccd
	comiss	xmm0, DWORD PTR [edx+1180]
	jbe	SHORT $LN41@MainAudioL
	mov	DWORD PTR tv147[ebp], 1
	jmp	SHORT $LN42@MainAudioL
$LN41@MainAudioL:
	mov	DWORD PTR tv147[ebp], 0
$LN42@MainAudioL:
	mov	al, BYTE PTR tv147[ebp]
	mov	BYTE PTR _bDesktopMuted$5[ebp], al

; 1438 :         bool bMicEnabled   = (micAudio != NULL);

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+116], 0
	je	SHORT $LN43@MainAudioL
	mov	DWORD PTR tv151[ebp], 1
	jmp	SHORT $LN44@MainAudioL
$LN43@MainAudioL:
	mov	DWORD PTR tv151[ebp], 0
$LN44@MainAudioL:
	mov	dl, BYTE PTR tv151[ebp]
	mov	BYTE PTR _bMicEnabled$19[ebp], dl

; 1439 : 
; 1440 :         if (QueryNewAudio()) {

	mov	ecx, DWORD PTR _this$[ebp]
	call	?QueryNewAudio@OBS@@AAE_NXZ		; OBS::QueryNewAudio
	movzx	eax, al
	test	eax, eax
	je	$LN31@MainAudioL

; 1441 :             QWORD timestamp = bufferedAudioTimes[0];

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1128				; 00000468H
	call	??A?$CircularList@_K@@QAEAA_KI@Z	; CircularList<unsigned __int64>::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _timestamp$15[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _timestamp$15[ebp+4], edx

; 1442 :             bufferedAudioTimes.Remove(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1128				; 00000468H
	call	?Remove@?$CircularList@_K@@QAEXI@Z	; CircularList<unsigned __int64>::Remove

; 1443 : 
; 1444 :             zero(mixBuffer.Array(),    audioSampleSize*2*sizeof(float));

	mov	eax, DWORD PTR _audioSampleSize$[ebp]
	shl	eax, 1
	shl	eax, 2
	push	eax
	lea	ecx, DWORD PTR _mixBuffer$[ebp]
	call	?Array@?$List@M@@QBEPAMXZ		; List<float>::Array
	push	eax
	call	?zero@@YGXPAXI@Z			; zero

; 1445 :             zero(levelsBuffer.Array(), audioSampleSize*2*sizeof(float));

	mov	ecx, DWORD PTR _audioSampleSize$[ebp]
	shl	ecx, 1
	shl	ecx, 2
	push	ecx
	lea	ecx, DWORD PTR _levelsBuffer$[ebp]
	call	?Array@?$List@M@@QBEPAMXZ		; List<float>::Array
	push	eax
	call	?zero@@YGXPAXI@Z			; zero

; 1446 : 
; 1447 :             //----------------------------------------------------------------------------
; 1448 :             // get latest sample for calculating the volume levels
; 1449 : 
; 1450 :             float *latestDesktopBuffer = NULL, *latestMicBuffer = NULL;

	mov	DWORD PTR _latestDesktopBuffer$13[ebp], 0
	mov	DWORD PTR _latestMicBuffer$6[ebp], 0

; 1451 : 
; 1452 :             desktopAudio->GetBuffer(&desktopBuffer, timestamp);

	mov	edx, DWORD PTR _timestamp$15[ebp+4]
	push	edx
	mov	eax, DWORD PTR _timestamp$15[ebp]
	push	eax
	lea	ecx, DWORD PTR _desktopBuffer$4[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+112]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+112]
	mov	eax, DWORD PTR [edx+24]
	call	eax

; 1453 :             desktopAudio->GetNewestFrame(&latestDesktopBuffer);

	lea	ecx, DWORD PTR _latestDesktopBuffer$13[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+112]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+112]
	mov	eax, DWORD PTR [edx+28]
	call	eax

; 1454 : 
; 1455 :             if (micAudio != NULL) {

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+116], 0
	je	SHORT $LN30@MainAudioL

; 1456 :                 micAudio->GetBuffer(&micBuffer, timestamp);

	mov	edx, DWORD PTR _timestamp$15[ebp+4]
	push	edx
	mov	eax, DWORD PTR _timestamp$15[ebp]
	push	eax
	lea	ecx, DWORD PTR _micBuffer$7[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+116]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+116]
	mov	eax, DWORD PTR [edx+24]
	call	eax

; 1457 :                 micAudio->GetNewestFrame(&latestMicBuffer);

	lea	ecx, DWORD PTR _latestMicBuffer$6[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+116]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+116]
	mov	eax, DWORD PTR [edx+28]
	call	eax
$LN30@MainAudioL:

; 1458 :             }
; 1459 : 
; 1460 :             //----------------------------------------------------------------------------
; 1461 :             // mix desktop samples
; 1462 : 
; 1463 :             if (desktopBuffer)

	cmp	DWORD PTR _desktopBuffer$4[ebp], 0
	je	SHORT $LN29@MainAudioL

; 1464 :                 MixAudio(mixBuffer.Array(), desktopBuffer, audioSampleSize*2, false);

	push	0
	mov	ecx, DWORD PTR _audioSampleSize$[ebp]
	shl	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _desktopBuffer$4[ebp]
	push	edx
	lea	ecx, DWORD PTR _mixBuffer$[ebp]
	call	?Array@?$List@M@@QBEPAMXZ		; List<float>::Array
	push	eax
	call	DWORD PTR __imp_?MixAudio@@YAXPAM0I_N@Z
	add	esp, 16					; 00000010H
$LN29@MainAudioL:

; 1465 : 
; 1466 :             if (latestDesktopBuffer)

	cmp	DWORD PTR _latestDesktopBuffer$13[ebp], 0
	je	SHORT $LN28@MainAudioL

; 1467 :                 MixAudio(levelsBuffer.Array(), latestDesktopBuffer, audioSampleSize*2, false);

	push	0
	mov	eax, DWORD PTR _audioSampleSize$[ebp]
	shl	eax, 1
	push	eax
	mov	ecx, DWORD PTR _latestDesktopBuffer$13[ebp]
	push	ecx
	lea	ecx, DWORD PTR _levelsBuffer$[ebp]
	call	?Array@?$List@M@@QBEPAMXZ		; List<float>::Array
	push	eax
	call	DWORD PTR __imp_?MixAudio@@YAXPAM0I_N@Z
	add	esp, 16					; 00000010H
$LN28@MainAudioL:

; 1468 : 
; 1469 :             //----------------------------------------------------------------------------
; 1470 :             // get latest aux volume level samples and mix
; 1471 : 
; 1472 :             OSEnterMutex(hAuxAudioMutex);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1228]
	push	eax
	call	DWORD PTR __imp_?OSEnterMutex@@YGXPAX@Z

; 1473 : 
; 1474 :             for (UINT i=0; i<auxAudioSources.Num(); i++) {

	mov	DWORD PTR _i$8[ebp], 0
	jmp	SHORT $LN27@MainAudioL
$LN26@MainAudioL:
	mov	ecx, DWORD PTR _i$8[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$8[ebp], ecx
$LN27@MainAudioL:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 120				; 00000078H
	call	?Num@?$List@PAVAudioSource@@@@QBEIXZ	; List<AudioSource *>::Num
	cmp	DWORD PTR _i$8[ebp], eax
	jae	SHORT $LN25@MainAudioL

; 1475 :                 float *latestAuxBuffer;
; 1476 : 
; 1477 :                 if(auxAudioSources[i]->GetNewestFrame(&latestAuxBuffer))

	mov	edx, DWORD PTR _i$8[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 120				; 00000078H
	call	??A?$List@PAVAudioSource@@@@QAEAAPAVAudioSource@@I@Z ; List<AudioSource *>::operator[]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR tv241[ebp], eax
	lea	ecx, DWORD PTR _latestAuxBuffer$2[ebp]
	push	ecx
	mov	edx, DWORD PTR tv241[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv241[ebp]
	mov	edx, DWORD PTR [eax+28]
	call	edx
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN24@MainAudioL

; 1478 :                     MixAudio(levelsBuffer.Array(), latestAuxBuffer, audioSampleSize*2, false);

	push	0
	mov	ecx, DWORD PTR _audioSampleSize$[ebp]
	shl	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _latestAuxBuffer$2[ebp]
	push	edx
	lea	ecx, DWORD PTR _levelsBuffer$[ebp]
	call	?Array@?$List@M@@QBEPAMXZ		; List<float>::Array
	push	eax
	call	DWORD PTR __imp_?MixAudio@@YAXPAM0I_N@Z
	add	esp, 16					; 00000010H
$LN24@MainAudioL:

; 1479 :             }

	jmp	SHORT $LN26@MainAudioL
$LN25@MainAudioL:

; 1480 : 
; 1481 :             //----------------------------------------------------------------------------
; 1482 :             // mix output aux sound samples with the desktop
; 1483 : 
; 1484 :             for (UINT i=0; i<auxAudioSources.Num(); i++) {

	mov	DWORD PTR _i$9[ebp], 0
	jmp	SHORT $LN23@MainAudioL
$LN22@MainAudioL:
	mov	eax, DWORD PTR _i$9[ebp]
	add	eax, 1
	mov	DWORD PTR _i$9[ebp], eax
$LN23@MainAudioL:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 120				; 00000078H
	call	?Num@?$List@PAVAudioSource@@@@QBEIXZ	; List<AudioSource *>::Num
	cmp	DWORD PTR _i$9[ebp], eax
	jae	SHORT $LN21@MainAudioL

; 1485 :                 float *auxBuffer;
; 1486 : 
; 1487 :                 if(auxAudioSources[i]->GetBuffer(&auxBuffer, timestamp))

	mov	ecx, DWORD PTR _i$9[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 120				; 00000078H
	call	??A?$List@PAVAudioSource@@@@QAEAAPAVAudioSource@@I@Z ; List<AudioSource *>::operator[]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR tv266[ebp], edx
	mov	eax, DWORD PTR _timestamp$15[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _timestamp$15[ebp]
	push	ecx
	lea	edx, DWORD PTR _auxBuffer$1[ebp]
	push	edx
	mov	eax, DWORD PTR tv266[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv266[ebp]
	mov	eax, DWORD PTR [edx+24]
	call	eax
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN20@MainAudioL

; 1488 :                     MixAudio(mixBuffer.Array(), auxBuffer, audioSampleSize*2, false);

	push	0
	mov	edx, DWORD PTR _audioSampleSize$[ebp]
	shl	edx, 1
	push	edx
	mov	eax, DWORD PTR _auxBuffer$1[ebp]
	push	eax
	lea	ecx, DWORD PTR _mixBuffer$[ebp]
	call	?Array@?$List@M@@QBEPAMXZ		; List<float>::Array
	push	eax
	call	DWORD PTR __imp_?MixAudio@@YAXPAM0I_N@Z
	add	esp, 16					; 00000010H
$LN20@MainAudioL:

; 1489 :             }

	jmp	SHORT $LN22@MainAudioL
$LN21@MainAudioL:

; 1490 : 
; 1491 :             OSLeaveMutex(hAuxAudioMutex);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1228]
	push	edx
	call	DWORD PTR __imp_?OSLeaveMutex@@YGXPAX@Z

; 1492 : 
; 1493 :             //----------------------------------------------------------------------------
; 1494 :             // multiply samples by volume and compute RMS and max of samples
; 1495 :             // Use 1.0f instead of curDesktopVol, since aux audio sources already have their volume set, and shouldn't be boosted anyway.
; 1496 : 
; 1497 :             float desktopRMS = 0, micRMS = 0, desktopMx = 0, micMx = 0;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _desktopRMS$14[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _micRMS$12[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _desktopMx$17[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _micMx$18[ebp], xmm0

; 1498 :             if (latestDesktopBuffer)

	cmp	DWORD PTR _latestDesktopBuffer$13[ebp], 0
	je	SHORT $LN19@MainAudioL

; 1499 :                 CalculateVolumeLevels(levelsBuffer.Array(), audioSampleSize*2, 1.0f, desktopRMS, desktopMx);

	lea	eax, DWORD PTR _desktopMx$17[ebp]
	push	eax
	lea	ecx, DWORD PTR _desktopRMS$14[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _audioSampleSize$[ebp]
	shl	edx, 1
	push	edx
	lea	ecx, DWORD PTR _levelsBuffer$[ebp]
	call	?Array@?$List@M@@QBEPAMXZ		; List<float>::Array
	push	eax
	call	?CalculateVolumeLevels@@YAXPAMHMAAM1@Z	; CalculateVolumeLevels
	add	esp, 20					; 00000014H
$LN19@MainAudioL:

; 1500 :             if (bMicEnabled && latestMicBuffer)

	movzx	eax, BYTE PTR _bMicEnabled$19[ebp]
	test	eax, eax
	je	SHORT $LN18@MainAudioL
	cmp	DWORD PTR _latestMicBuffer$6[ebp], 0
	je	SHORT $LN18@MainAudioL

; 1501 :                 CalculateVolumeLevels(latestMicBuffer, audioSampleSize*2, curMicVol, micRMS, micMx);

	lea	ecx, DWORD PTR _micMx$18[ebp]
	push	ecx
	lea	edx, DWORD PTR _micRMS$12[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+1176]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _audioSampleSize$[ebp]
	shl	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _latestMicBuffer$6[ebp]
	push	edx
	call	?CalculateVolumeLevels@@YAXPAMHMAAM1@Z	; CalculateVolumeLevels
	add	esp, 20					; 00000014H
$LN18@MainAudioL:

; 1502 : 
; 1503 :             //----------------------------------------------------------------------------
; 1504 :             // convert RMS and Max of samples to dB 
; 1505 : 
; 1506 :             desktopRMS = toDB(desktopRMS);

	push	ecx
	movss	xmm0, DWORD PTR _desktopRMS$14[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?toDB@@YAMM@Z				; toDB
	add	esp, 4
	fstp	DWORD PTR _desktopRMS$14[ebp]

; 1507 :             micRMS = toDB(micRMS);

	push	ecx
	movss	xmm0, DWORD PTR _micRMS$12[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?toDB@@YAMM@Z				; toDB
	add	esp, 4
	fstp	DWORD PTR _micRMS$12[ebp]

; 1508 :             desktopMx = toDB(desktopMx);

	push	ecx
	movss	xmm0, DWORD PTR _desktopMx$17[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?toDB@@YAMM@Z				; toDB
	add	esp, 4
	fstp	DWORD PTR _desktopMx$17[ebp]

; 1509 :             micMx = toDB(micMx);

	push	ecx
	movss	xmm0, DWORD PTR _micMx$18[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?toDB@@YAMM@Z				; toDB
	add	esp, 4
	fstp	DWORD PTR _micMx$18[ebp]

; 1510 : 
; 1511 :             //----------------------------------------------------------------------------
; 1512 :             // update max if sample max is greater or after 1 second
; 1513 : 
; 1514 :             float maxAlpha = 0.15f;

	movss	xmm0, DWORD PTR __real@3e19999a
	movss	DWORD PTR _maxAlpha$10[ebp], xmm0

; 1515 :             UINT peakMeterDelayFrames = audioSamplesPerSec * 3;

	imul	eax, DWORD PTR _audioSamplesPerSec$[ebp], 3
	mov	DWORD PTR _peakMeterDelayFrames$3[ebp], eax

; 1516 : 
; 1517 :             if (micMx > micMax)

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _micMx$18[ebp]
	comiss	xmm0, DWORD PTR [ecx+1196]
	jbe	SHORT $LN17@MainAudioL

; 1518 :                 micMax = micMx;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _micMx$18[ebp]
	movss	DWORD PTR [edx+1196], xmm0

; 1519 :             else

	jmp	SHORT $LN16@MainAudioL
$LN17@MainAudioL:

; 1520 :                 micMax = maxAlpha * micMx + (1.0f - maxAlpha) * micMax;

	movss	xmm0, DWORD PTR _maxAlpha$10[ebp]
	mulss	xmm0, DWORD PTR _micMx$18[ebp]
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, DWORD PTR _maxAlpha$10[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mulss	xmm1, DWORD PTR [eax+1196]
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+1196], xmm0
$LN16@MainAudioL:

; 1521 : 
; 1522 :             if(desktopMx > desktopMax)

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _desktopMx$17[ebp]
	comiss	xmm0, DWORD PTR [edx+1192]
	jbe	SHORT $LN15@MainAudioL

; 1523 :                 desktopMax = desktopMx;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _desktopMx$17[ebp]
	movss	DWORD PTR [eax+1192], xmm0

; 1524 :             else

	jmp	SHORT $LN14@MainAudioL
$LN15@MainAudioL:

; 1525 :                 desktopMax = maxAlpha * desktopMx + (1.0f - maxAlpha) * desktopMax;

	movss	xmm0, DWORD PTR _maxAlpha$10[ebp]
	mulss	xmm0, DWORD PTR _desktopMx$17[ebp]
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, DWORD PTR _maxAlpha$10[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mulss	xmm1, DWORD PTR [ecx+1192]
	addss	xmm0, xmm1
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+1192], xmm0
$LN14@MainAudioL:

; 1526 : 
; 1527 :             //----------------------------------------------------------------------------
; 1528 :             // update delayed peak meter
; 1529 : 
; 1530 :             if (micMax > micPeak || audioFramesSinceMicMaxUpdate > peakMeterDelayFrames) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+1196]
	comiss	xmm0, DWORD PTR [ecx+1188]
	ja	SHORT $LN12@MainAudioL
	mov	edx, DWORD PTR _audioFramesSinceMicMaxUpdate$[ebp]
	cmp	edx, DWORD PTR _peakMeterDelayFrames$3[ebp]
	jbe	SHORT $LN13@MainAudioL
$LN12@MainAudioL:

; 1531 :                 micPeak = micMax;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1196]
	mov	DWORD PTR [eax+1188], edx

; 1532 :                 audioFramesSinceMicMaxUpdate = 0;

	mov	DWORD PTR _audioFramesSinceMicMaxUpdate$[ebp], 0

; 1533 :             } else {

	jmp	SHORT $LN11@MainAudioL
$LN13@MainAudioL:

; 1534 :                 audioFramesSinceMicMaxUpdate += audioSampleSize;

	mov	eax, DWORD PTR _audioFramesSinceMicMaxUpdate$[ebp]
	add	eax, DWORD PTR _audioSampleSize$[ebp]
	mov	DWORD PTR _audioFramesSinceMicMaxUpdate$[ebp], eax
$LN11@MainAudioL:

; 1535 :             }
; 1536 : 
; 1537 :             if (desktopMax > desktopPeak || audioFramesSinceDesktopMaxUpdate > peakMeterDelayFrames) {

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+1192]
	comiss	xmm0, DWORD PTR [edx+1184]
	ja	SHORT $LN9@MainAudioL
	mov	eax, DWORD PTR _audioFramesSinceDesktopMaxUpdate$[ebp]
	cmp	eax, DWORD PTR _peakMeterDelayFrames$3[ebp]
	jbe	SHORT $LN10@MainAudioL
$LN9@MainAudioL:

; 1538 :                 desktopPeak = desktopMax;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1192]
	mov	DWORD PTR [ecx+1184], eax

; 1539 :                 audioFramesSinceDesktopMaxUpdate = 0;

	mov	DWORD PTR _audioFramesSinceDesktopMaxUpdate$[ebp], 0

; 1540 :             } else {

	jmp	SHORT $LN8@MainAudioL
$LN10@MainAudioL:

; 1541 :                 audioFramesSinceDesktopMaxUpdate += audioSampleSize;

	mov	ecx, DWORD PTR _audioFramesSinceDesktopMaxUpdate$[ebp]
	add	ecx, DWORD PTR _audioSampleSize$[ebp]
	mov	DWORD PTR _audioFramesSinceDesktopMaxUpdate$[ebp], ecx
$LN8@MainAudioL:

; 1542 :             }
; 1543 : 
; 1544 :             //----------------------------------------------------------------------------
; 1545 :             // low pass the level sampling
; 1546 : 
; 1547 :             float rmsAlpha = 0.15f;

	movss	xmm0, DWORD PTR __real@3e19999a
	movss	DWORD PTR _rmsAlpha$11[ebp], xmm0

; 1548 :             desktopMag = rmsAlpha * desktopRMS + desktopMag * (1.0f - rmsAlpha);

	movss	xmm0, DWORD PTR _rmsAlpha$11[ebp]
	mulss	xmm0, DWORD PTR _desktopRMS$14[ebp]
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, DWORD PTR _rmsAlpha$11[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mulss	xmm1, DWORD PTR [edx+1200]
	addss	xmm0, xmm1
	mov	eax, DWORD PTR _this$[ebp]
	movss	DWORD PTR [eax+1200], xmm0

; 1549 :             micMag = rmsAlpha * micRMS + micMag * (1.0f - rmsAlpha);

	movss	xmm0, DWORD PTR _rmsAlpha$11[ebp]
	mulss	xmm0, DWORD PTR _micRMS$12[ebp]
	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, DWORD PTR _rmsAlpha$11[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mulss	xmm1, DWORD PTR [ecx+1204]
	addss	xmm0, xmm1
	mov	edx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [edx+1204], xmm0

; 1550 : 
; 1551 :             //----------------------------------------------------------------------------
; 1552 :             // update the meter about every 50ms
; 1553 : 
; 1554 :             audioFramesSinceMeterUpdate += audioSampleSize;

	mov	eax, DWORD PTR _audioFramesSinceMeterUpdate$[ebp]
	add	eax, DWORD PTR _audioSampleSize$[ebp]
	mov	DWORD PTR _audioFramesSinceMeterUpdate$[ebp], eax

; 1555 :             if (audioFramesSinceMeterUpdate >= (audioSampleSize*5)) {

	imul	ecx, DWORD PTR _audioSampleSize$[ebp], 5
	cmp	DWORD PTR _audioFramesSinceMeterUpdate$[ebp], ecx
	jb	SHORT $LN7@MainAudioL

; 1556 :                 PostMessage(hwndMain, WM_COMMAND, MAKEWPARAM(ID_MICVOLUMEMETER, VOLN_METERED), 0);

	push	0
	push	50467729				; 03021391H
	push	273					; 00000111H
	mov	edx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	edx
	call	DWORD PTR __imp__PostMessageW@16

; 1557 :                 audioFramesSinceMeterUpdate = 0;

	mov	DWORD PTR _audioFramesSinceMeterUpdate$[ebp], 0
$LN7@MainAudioL:

; 1558 :             }
; 1559 : 
; 1560 :             //----------------------------------------------------------------------------
; 1561 :             // mix mic and desktop sound
; 1562 :             // also, it's perfectly fine to just mix into the returned buffer
; 1563 : 
; 1564 :             if (bMicEnabled && micBuffer)

	movzx	eax, BYTE PTR _bMicEnabled$19[ebp]
	test	eax, eax
	je	SHORT $LN6@MainAudioL
	cmp	DWORD PTR _micBuffer$7[ebp], 0
	je	SHORT $LN6@MainAudioL

; 1565 :                 MixAudio(mixBuffer.Array(), micBuffer, audioSampleSize*2, bForceMicMono);

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+1216]
	push	edx
	mov	eax, DWORD PTR _audioSampleSize$[ebp]
	shl	eax, 1
	push	eax
	mov	ecx, DWORD PTR _micBuffer$7[ebp]
	push	ecx
	lea	ecx, DWORD PTR _mixBuffer$[ebp]
	call	?Array@?$List@M@@QBEPAMXZ		; List<float>::Array
	push	eax
	call	DWORD PTR __imp_?MixAudio@@YAXPAM0I_N@Z
	add	esp, 16					; 00000010H
$LN6@MainAudioL:

; 1566 : 
; 1567 :             EncodeAudioSegment(mixBuffer.Array(), audioSampleSize, timestamp);

	mov	edx, DWORD PTR _timestamp$15[ebp+4]
	push	edx
	mov	eax, DWORD PTR _timestamp$15[ebp]
	push	eax
	mov	ecx, DWORD PTR _audioSampleSize$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _mixBuffer$[ebp]
	call	?Array@?$List@M@@QBEPAMXZ		; List<float>::Array
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EncodeAudioSegment@OBS@@AAEXPAMI_K@Z	; OBS::EncodeAudioSegment

; 1568 :         }
; 1569 :         else

	jmp	SHORT $LN5@MainAudioL
$LN31@MainAudioL:

; 1570 :         {
; 1571 :             OSSleep(5); //screw it, just run it every 5ms

	push	5
	call	DWORD PTR __imp_?OSSleep@@YGXK@Z
$LN5@MainAudioL:

; 1572 :         }
; 1573 : 
; 1574 :         //-----------------------------------------------
; 1575 : 
; 1576 :         if (!bRecievedFirstAudioFrame && pendingAudioFrames.Num())

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+988]
	test	eax, eax
	jne	SHORT $LN4@MainAudioL
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1208				; 000004b8H
	call	?Num@?$List@UFrameAudio@@@@QBEIXZ	; List<FrameAudio>::Num
	test	eax, eax
	je	SHORT $LN4@MainAudioL

; 1577 :             bRecievedFirstAudioFrame = true;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+988], 1
$LN4@MainAudioL:

; 1578 :     }

	jmp	$LN36@MainAudioL
$LN35@MainAudioL:

; 1579 : 
; 1580 :     desktopMag = desktopMax = desktopPeak = VOL_MIN;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@c2c00000
	movss	DWORD PTR [edx+1184], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@c2c00000
	movss	DWORD PTR [eax+1192], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@c2c00000
	movss	DWORD PTR [ecx+1200], xmm0

; 1581 :     micMag = micMax = micPeak = VOL_MIN;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@c2c00000
	movss	DWORD PTR [edx+1188], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@c2c00000
	movss	DWORD PTR [eax+1196], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@c2c00000
	movss	DWORD PTR [ecx+1204], xmm0

; 1582 : 
; 1583 :     PostMessage(hwndMain, WM_COMMAND, MAKEWPARAM(ID_MICVOLUMEMETER, VOLN_METERED), 0);

	push	0
	push	50467729				; 03021391H
	push	273					; 00000111H
	mov	edx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	edx
	call	DWORD PTR __imp__PostMessageW@16

; 1584 : 
; 1585 :     for (UINT i=0; i<pendingAudioFrames.Num(); i++)

	mov	DWORD PTR _i$16[ebp], 0
	jmp	SHORT $LN3@MainAudioL
$LN2@MainAudioL:
	mov	eax, DWORD PTR _i$16[ebp]
	add	eax, 1
	mov	DWORD PTR _i$16[ebp], eax
$LN3@MainAudioL:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1208				; 000004b8H
	call	?Num@?$List@UFrameAudio@@@@QBEIXZ	; List<FrameAudio>::Num
	cmp	DWORD PTR _i$16[ebp], eax
	jae	SHORT $LN1@MainAudioL

; 1586 :         pendingAudioFrames[i].audioData.Clear();

	mov	ecx, DWORD PTR _i$16[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1208				; 000004b8H
	call	??A?$List@UFrameAudio@@@@QAEAAUFrameAudio@@I@Z ; List<FrameAudio>::operator[]
	mov	ecx, eax
	call	?Clear@?$List@E@@QAEXXZ			; List<unsigned char>::Clear
	jmp	SHORT $LN2@MainAudioL
$LN1@MainAudioL:

; 1587 : 
; 1588 :     AvRevertMmThreadCharacteristics(hTask);

	mov	edx, DWORD PTR _hTask$[ebp]
	push	edx
	call	DWORD PTR __imp__AvRevertMmThreadCharacteristics@4

; 1589 : }

	lea	ecx, DWORD PTR _levelsBuffer$[ebp]
	call	??1?$List@M@@QAE@XZ			; List<float>::~List<float>
	lea	ecx, DWORD PTR _mixBuffer$[ebp]
	call	??1?$List@M@@QAE@XZ			; List<float>::~List<float>
	mov	esp, ebp
	pop	ebp
	ret	0
?MainAudioLoop@OBS@@AAEXXZ ENDP				; OBS::MainAudioLoop
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obscapture.cpp
;	COMDAT ?RequestKeyframe@OBS@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_waitTime$ = 8						; size = 4
?RequestKeyframe@OBS@@QAEXH@Z PROC			; OBS::RequestKeyframe, COMDAT
; _this$ = ecx

; 1592 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1593 :     if(bRequestKeyframe && waitTime > keyframeWait)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+1104]
	test	ecx, ecx
	je	SHORT $LN1@RequestKey
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _waitTime$[ebp]
	cmp	eax, DWORD PTR [edx+1108]
	jle	SHORT $LN1@RequestKey

; 1594 :         return;

	jmp	SHORT $LN2@RequestKey
$LN1@RequestKey:

; 1595 : 
; 1596 :     bRequestKeyframe = true;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+1104], 1

; 1597 :     keyframeWait = waitTime;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _waitTime$[ebp]
	mov	DWORD PTR [edx+1108], eax
$LN2@RequestKey:

; 1598 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?RequestKeyframe@OBS@@QAEXH@Z ENDP			; OBS::RequestKeyframe
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obscapture.cpp
;	COMDAT ?AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z
_TEXT	SEGMENT
_l$ = -24						; size = 8
$T1 = -16						; size = 4
_args$ = -12						; size = 4
_this$ = -8						; size = 4
$T2 = -1						; size = 1
_stream$ = 8						; size = 4
_finishedCallback$ = 12					; size = 24
?AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z PROC ; OBS::AddPendingStream, COMDAT
; _this$ = ecx

; 1601 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 1602 :     using namespace std;
; 1603 :     struct args_t
; 1604 :     {
; 1605 :         using stream_t = remove_pointer_t<decltype(stream)>;
; 1606 :         unique_ptr<stream_t> stream;
; 1607 :         decltype(finishedCallback) finishedCallback;
; 1608 :         args_t(stream_t *stream, decltype(finishedCallback) finishedCallback) : stream(stream), finishedCallback(move(finishedCallback)) {}
; 1609 :     };
; 1610 : 
; 1611 :     auto args = make_unique<args_t>(stream, move(finishedCallback));

	lea	eax, DWORD PTR _finishedCallback$[ebp]
	push	eax
	call	??$move@AAV?$function@$$A6AXXZ@std@@@std@@YA$$QAV?$function@$$A6AXXZ@0@AAV10@@Z ; std::move<std::function<void __cdecl(void)> &>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR _stream$[ebp]
	push	ecx
	lea	edx, DWORD PTR _args$[ebp]
	push	edx
	call	??$make_unique@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@AAPAU4@V56@@std@@YA?AV?$unique_ptr@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@U?$default_delete@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@6@@0@AAPAUClosableStream@@$$QAV?$function@$$A6AXXZ@0@@Z ; std::make_unique<`OBS::AddPendingStream'::`2'::args_t,ClosableStream * &,std::function<void __cdecl(void)> >
	add	esp, 12					; 0000000cH

; 1612 : 
; 1613 :     ScopedLock l(pendingStreams.mutex);

	push	1
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1424				; 00000590H
	push	eax
	lea	ecx, DWORD PTR _l$[ebp]
	call	??0ScopedLock@@QAE@ABV?$unique_ptr@XUMutexDeleter@@@std@@_N1@Z ; ScopedLock::ScopedLock

; 1614 :     pendingStreams.streams.emplace_back(OSCreateThread([](void *arg) -> DWORD
; 1615 :     {
; 1616 :         unique_ptr<args_t> args(static_cast<args_t*>(arg));
; 1617 :         args->stream.reset();
; 1618 :         if (args->finishedCallback)
; 1619 :             args->finishedCallback();
; 1620 :         return 0;
; 1621 :     }, args.release()));

	lea	ecx, DWORD PTR _args$[ebp]
	call	?release@?$unique_ptr@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@U?$default_delete@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@6@@std@@QAEPAUargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@2@@Z@XZ ; std::unique_ptr<`OBS::AddPendingStream'::`2'::args_t,std::default_delete<`OBS::AddPendingStream'::`2'::args_t> >::release
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	call	??B<lambda_0949a521542c6fafab37c8b897d7d49e>@@QBEP6GKPAX@ZXZ ; <lambda_0949a521542c6fafab37c8b897d7d49e>::operator unsigned long (__stdcall*)(void *)
	push	eax
	call	DWORD PTR __imp_?OSCreateThread@@YGPAXP6GKPAX@Z0@Z
	mov	DWORD PTR $T1[ebp], eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1416				; 00000588H
	call	??$emplace_back@PAX@?$list@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAEX$$QAPAX@Z ; std::list<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >::emplace_back<void *>

; 1622 : }

	lea	ecx, DWORD PTR _l$[ebp]
	call	??1ScopedLock@@QAE@XZ			; ScopedLock::~ScopedLock
	lea	ecx, DWORD PTR _args$[ebp]
	call	??1?$unique_ptr@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@U?$default_delete@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@6@@std@@QAE@XZ ; std::unique_ptr<`OBS::AddPendingStream'::`2'::args_t,std::default_delete<`OBS::AddPendingStream'::`2'::args_t> >::~unique_ptr<`OBS::AddPendingStream'::`2'::args_t,std::default_delete<`OBS::AddPendingStream'::`2'::args_t> >
	lea	ecx, DWORD PTR _finishedCallback$[ebp]
	call	??1?$function@$$A6AXXZ@std@@QAE@XZ	; std::function<void __cdecl(void)>::~function<void __cdecl(void)>
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
?AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z ENDP ; OBS::AddPendingStream
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obscapture.cpp
;	COMDAT ??0args_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@QAE@01@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_stream$ = 8						; size = 4
_finishedCallback$ = 12					; size = 24
??0args_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@QAE@01@Z PROC ; `OBS::AddPendingStream'::`2'::args_t::args_t, COMDAT
; _this$ = ecx

; 1608 :         args_t(stream_t *stream, decltype(finishedCallback) finishedCallback) : stream(stream), finishedCallback(move(finishedCallback)) {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _stream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$unique_ptr@UClosableStream@@U?$default_delete@UClosableStream@@@std@@@std@@QAE@PAUClosableStream@@@Z ; std::unique_ptr<ClosableStream,std::default_delete<ClosableStream> >::unique_ptr<ClosableStream,std::default_delete<ClosableStream> >
	lea	ecx, DWORD PTR _finishedCallback$[ebp]
	push	ecx
	call	??$move@AAV?$function@$$A6AXXZ@std@@@std@@YA$$QAV?$function@$$A6AXXZ@0@AAV10@@Z ; std::move<std::function<void __cdecl(void)> &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$function@$$A6AXXZ@std@@QAE@$$QAV01@@Z ; std::function<void __cdecl(void)>::function<void __cdecl(void)>
	lea	ecx, DWORD PTR _finishedCallback$[ebp]
	call	??1?$function@$$A6AXXZ@std@@QAE@XZ	; std::function<void __cdecl(void)>::~function<void __cdecl(void)>
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
??0args_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@QAE@01@Z ENDP ; `OBS::AddPendingStream'::`2'::args_t::args_t
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obscapture.cpp
;	COMDAT ?<helper_func_cdecl>@<lambda_0949a521542c6fafab37c8b897d7d49e>@@CAKPAX@Z
_TEXT	SEGMENT
$T1 = -8						; size = 4
_args$ = -4						; size = 4
_arg$ = 8						; size = 4
?<helper_func_cdecl>@<lambda_0949a521542c6fafab37c8b897d7d49e>@@CAKPAX@Z PROC ; <lambda_0949a521542c6fafab37c8b897d7d49e>::<helper_func_cdecl>, COMDAT

; 1615 :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1616 :         unique_ptr<args_t> args(static_cast<args_t*>(arg));

	mov	eax, DWORD PTR _arg$[ebp]
	push	eax
	lea	ecx, DWORD PTR _args$[ebp]
	call	??0?$unique_ptr@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@U?$default_delete@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@6@@std@@QAE@PAUargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@1@@Z@@Z ; std::unique_ptr<`OBS::AddPendingStream'::`2'::args_t,std::default_delete<`OBS::AddPendingStream'::`2'::args_t> >::unique_ptr<`OBS::AddPendingStream'::`2'::args_t,std::default_delete<`OBS::AddPendingStream'::`2'::args_t> >

; 1617 :         args->stream.reset();

	push	0
	lea	ecx, DWORD PTR _args$[ebp]
	call	??C?$unique_ptr@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@U?$default_delete@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@6@@std@@QBEPAUargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@1@@Z@XZ ; std::unique_ptr<`OBS::AddPendingStream'::`2'::args_t,std::default_delete<`OBS::AddPendingStream'::`2'::args_t> >::operator->
	mov	ecx, eax
	call	?reset@?$unique_ptr@UClosableStream@@U?$default_delete@UClosableStream@@@std@@@std@@QAEXPAUClosableStream@@@Z ; std::unique_ptr<ClosableStream,std::default_delete<ClosableStream> >::reset

; 1618 :         if (args->finishedCallback)

	lea	ecx, DWORD PTR _args$[ebp]
	call	??C?$unique_ptr@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@U?$default_delete@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@6@@std@@QBEPAUargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@1@@Z@XZ ; std::unique_ptr<`OBS::AddPendingStream'::`2'::args_t,std::default_delete<`OBS::AddPendingStream'::`2'::args_t> >::operator->
	add	eax, 8
	mov	ecx, eax
	call	??B?$function@$$A6AXXZ@std@@QBE_NXZ	; std::function<void __cdecl(void)>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@

; 1619 :             args->finishedCallback();

	lea	ecx, DWORD PTR _args$[ebp]
	call	??C?$unique_ptr@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@U?$default_delete@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@6@@std@@QBEPAUargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@1@@Z@XZ ; std::unique_ptr<`OBS::AddPendingStream'::`2'::args_t,std::default_delete<`OBS::AddPendingStream'::`2'::args_t> >::operator->
	add	eax, 8
	mov	ecx, eax
	call	??R?$_Func_class@X$$$V@std@@QBEXXZ	; std::_Func_class<void>::operator()
$LN1@:

; 1620 :         return 0;

	mov	DWORD PTR $T1[ebp], 0
	lea	ecx, DWORD PTR _args$[ebp]
	call	??1?$unique_ptr@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@U?$default_delete@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@6@@std@@QAE@XZ ; std::unique_ptr<`OBS::AddPendingStream'::`2'::args_t,std::default_delete<`OBS::AddPendingStream'::`2'::args_t> >::~unique_ptr<`OBS::AddPendingStream'::`2'::args_t,std::default_delete<`OBS::AddPendingStream'::`2'::args_t> >
	mov	eax, DWORD PTR $T1[ebp]

; 1621 :     }, args.release()));

	mov	esp, ebp
	pop	ebp
	ret	0
?<helper_func_cdecl>@<lambda_0949a521542c6fafab37c8b897d7d49e>@@CAKPAX@Z ENDP ; <lambda_0949a521542c6fafab37c8b897d7d49e>::<helper_func_cdecl>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obscapture.cpp
;	COMDAT ?<helper_func_stdcall>@<lambda_0949a521542c6fafab37c8b897d7d49e>@@CGKPAX@Z
_TEXT	SEGMENT
$T1 = -8						; size = 4
_args$ = -4						; size = 4
_arg$ = 8						; size = 4
?<helper_func_stdcall>@<lambda_0949a521542c6fafab37c8b897d7d49e>@@CGKPAX@Z PROC ; <lambda_0949a521542c6fafab37c8b897d7d49e>::<helper_func_stdcall>, COMDAT

; 1615 :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1616 :         unique_ptr<args_t> args(static_cast<args_t*>(arg));

	mov	eax, DWORD PTR _arg$[ebp]
	push	eax
	lea	ecx, DWORD PTR _args$[ebp]
	call	??0?$unique_ptr@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@U?$default_delete@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@6@@std@@QAE@PAUargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@1@@Z@@Z ; std::unique_ptr<`OBS::AddPendingStream'::`2'::args_t,std::default_delete<`OBS::AddPendingStream'::`2'::args_t> >::unique_ptr<`OBS::AddPendingStream'::`2'::args_t,std::default_delete<`OBS::AddPendingStream'::`2'::args_t> >

; 1617 :         args->stream.reset();

	push	0
	lea	ecx, DWORD PTR _args$[ebp]
	call	??C?$unique_ptr@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@U?$default_delete@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@6@@std@@QBEPAUargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@1@@Z@XZ ; std::unique_ptr<`OBS::AddPendingStream'::`2'::args_t,std::default_delete<`OBS::AddPendingStream'::`2'::args_t> >::operator->
	mov	ecx, eax
	call	?reset@?$unique_ptr@UClosableStream@@U?$default_delete@UClosableStream@@@std@@@std@@QAEXPAUClosableStream@@@Z ; std::unique_ptr<ClosableStream,std::default_delete<ClosableStream> >::reset

; 1618 :         if (args->finishedCallback)

	lea	ecx, DWORD PTR _args$[ebp]
	call	??C?$unique_ptr@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@U?$default_delete@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@6@@std@@QBEPAUargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@1@@Z@XZ ; std::unique_ptr<`OBS::AddPendingStream'::`2'::args_t,std::default_delete<`OBS::AddPendingStream'::`2'::args_t> >::operator->
	add	eax, 8
	mov	ecx, eax
	call	??B?$function@$$A6AXXZ@std@@QBE_NXZ	; std::function<void __cdecl(void)>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@

; 1619 :             args->finishedCallback();

	lea	ecx, DWORD PTR _args$[ebp]
	call	??C?$unique_ptr@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@U?$default_delete@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@6@@std@@QBEPAUargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@1@@Z@XZ ; std::unique_ptr<`OBS::AddPendingStream'::`2'::args_t,std::default_delete<`OBS::AddPendingStream'::`2'::args_t> >::operator->
	add	eax, 8
	mov	ecx, eax
	call	??R?$_Func_class@X$$$V@std@@QBEXXZ	; std::_Func_class<void>::operator()
$LN1@:

; 1620 :         return 0;

	mov	DWORD PTR $T1[ebp], 0
	lea	ecx, DWORD PTR _args$[ebp]
	call	??1?$unique_ptr@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@U?$default_delete@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@6@@std@@QAE@XZ ; std::unique_ptr<`OBS::AddPendingStream'::`2'::args_t,std::default_delete<`OBS::AddPendingStream'::`2'::args_t> >::~unique_ptr<`OBS::AddPendingStream'::`2'::args_t,std::default_delete<`OBS::AddPendingStream'::`2'::args_t> >
	mov	eax, DWORD PTR $T1[ebp]

; 1621 :     }, args.release()));

	mov	esp, ebp
	pop	ebp
	ret	4
?<helper_func_stdcall>@<lambda_0949a521542c6fafab37c8b897d7d49e>@@CGKPAX@Z ENDP ; <lambda_0949a521542c6fafab37c8b897d7d49e>::<helper_func_stdcall>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obscapture.cpp
;	COMDAT ??B<lambda_0949a521542c6fafab37c8b897d7d49e>@@QBEP6GKPAX@ZXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??B<lambda_0949a521542c6fafab37c8b897d7d49e>@@QBEP6GKPAX@ZXZ PROC ; <lambda_0949a521542c6fafab37c8b897d7d49e>::operator unsigned long (__stdcall*)(void *), COMDAT
; _this$ = ecx

; 1621 :     }, args.release()));

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET ?<helper_func_stdcall>@<lambda_0949a521542c6fafab37c8b897d7d49e>@@CGKPAX@Z ; <lambda_0949a521542c6fafab37c8b897d7d49e>::<helper_func_stdcall>
	mov	esp, ebp
	pop	ebp
	ret	0
??B<lambda_0949a521542c6fafab37c8b897d7d49e>@@QBEP6GKPAX@ZXZ ENDP ; <lambda_0949a521542c6fafab37c8b897d7d49e>::operator unsigned long (__stdcall*)(void *)
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obscapture.cpp
;	COMDAT ?<helper_func_fastcall>@<lambda_0949a521542c6fafab37c8b897d7d49e>@@CIKPAX@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
_arg$ = -8						; size = 4
_args$ = -4						; size = 4
?<helper_func_fastcall>@<lambda_0949a521542c6fafab37c8b897d7d49e>@@CIKPAX@Z PROC ; <lambda_0949a521542c6fafab37c8b897d7d49e>::<helper_func_fastcall>, COMDAT
; _arg$ = ecx

; 1615 :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _arg$[ebp], ecx

; 1616 :         unique_ptr<args_t> args(static_cast<args_t*>(arg));

	mov	eax, DWORD PTR _arg$[ebp]
	push	eax
	lea	ecx, DWORD PTR _args$[ebp]
	call	??0?$unique_ptr@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@U?$default_delete@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@6@@std@@QAE@PAUargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@1@@Z@@Z ; std::unique_ptr<`OBS::AddPendingStream'::`2'::args_t,std::default_delete<`OBS::AddPendingStream'::`2'::args_t> >::unique_ptr<`OBS::AddPendingStream'::`2'::args_t,std::default_delete<`OBS::AddPendingStream'::`2'::args_t> >

; 1617 :         args->stream.reset();

	push	0
	lea	ecx, DWORD PTR _args$[ebp]
	call	??C?$unique_ptr@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@U?$default_delete@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@6@@std@@QBEPAUargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@1@@Z@XZ ; std::unique_ptr<`OBS::AddPendingStream'::`2'::args_t,std::default_delete<`OBS::AddPendingStream'::`2'::args_t> >::operator->
	mov	ecx, eax
	call	?reset@?$unique_ptr@UClosableStream@@U?$default_delete@UClosableStream@@@std@@@std@@QAEXPAUClosableStream@@@Z ; std::unique_ptr<ClosableStream,std::default_delete<ClosableStream> >::reset

; 1618 :         if (args->finishedCallback)

	lea	ecx, DWORD PTR _args$[ebp]
	call	??C?$unique_ptr@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@U?$default_delete@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@6@@std@@QBEPAUargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@1@@Z@XZ ; std::unique_ptr<`OBS::AddPendingStream'::`2'::args_t,std::default_delete<`OBS::AddPendingStream'::`2'::args_t> >::operator->
	add	eax, 8
	mov	ecx, eax
	call	??B?$function@$$A6AXXZ@std@@QBE_NXZ	; std::function<void __cdecl(void)>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@

; 1619 :             args->finishedCallback();

	lea	ecx, DWORD PTR _args$[ebp]
	call	??C?$unique_ptr@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@U?$default_delete@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@6@@std@@QBEPAUargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@1@@Z@XZ ; std::unique_ptr<`OBS::AddPendingStream'::`2'::args_t,std::default_delete<`OBS::AddPendingStream'::`2'::args_t> >::operator->
	add	eax, 8
	mov	ecx, eax
	call	??R?$_Func_class@X$$$V@std@@QBEXXZ	; std::_Func_class<void>::operator()
$LN1@:

; 1620 :         return 0;

	mov	DWORD PTR $T1[ebp], 0
	lea	ecx, DWORD PTR _args$[ebp]
	call	??1?$unique_ptr@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@U?$default_delete@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@6@@std@@QAE@XZ ; std::unique_ptr<`OBS::AddPendingStream'::`2'::args_t,std::default_delete<`OBS::AddPendingStream'::`2'::args_t> >::~unique_ptr<`OBS::AddPendingStream'::`2'::args_t,std::default_delete<`OBS::AddPendingStream'::`2'::args_t> >
	mov	eax, DWORD PTR $T1[ebp]

; 1621 :     }, args.release()));

	mov	esp, ebp
	pop	ebp
	ret	0
?<helper_func_fastcall>@<lambda_0949a521542c6fafab37c8b897d7d49e>@@CIKPAX@Z ENDP ; <lambda_0949a521542c6fafab37c8b897d7d49e>::<helper_func_fastcall>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obscapture.cpp
;	COMDAT ?<helper_func_vectorcall>@<lambda_0949a521542c6fafab37c8b897d7d49e>@@CQKPAX@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
_arg$ = -8						; size = 4
_args$ = -4						; size = 4
?<helper_func_vectorcall>@<lambda_0949a521542c6fafab37c8b897d7d49e>@@CQKPAX@Z PROC ; <lambda_0949a521542c6fafab37c8b897d7d49e>::<helper_func_vectorcall>, COMDAT
; _arg$ = ecx

; 1615 :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _arg$[ebp], ecx

; 1616 :         unique_ptr<args_t> args(static_cast<args_t*>(arg));

	mov	eax, DWORD PTR _arg$[ebp]
	push	eax
	lea	ecx, DWORD PTR _args$[ebp]
	call	??0?$unique_ptr@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@U?$default_delete@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@6@@std@@QAE@PAUargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@1@@Z@@Z ; std::unique_ptr<`OBS::AddPendingStream'::`2'::args_t,std::default_delete<`OBS::AddPendingStream'::`2'::args_t> >::unique_ptr<`OBS::AddPendingStream'::`2'::args_t,std::default_delete<`OBS::AddPendingStream'::`2'::args_t> >

; 1617 :         args->stream.reset();

	push	0
	lea	ecx, DWORD PTR _args$[ebp]
	call	??C?$unique_ptr@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@U?$default_delete@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@6@@std@@QBEPAUargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@1@@Z@XZ ; std::unique_ptr<`OBS::AddPendingStream'::`2'::args_t,std::default_delete<`OBS::AddPendingStream'::`2'::args_t> >::operator->
	mov	ecx, eax
	call	?reset@?$unique_ptr@UClosableStream@@U?$default_delete@UClosableStream@@@std@@@std@@QAEXPAUClosableStream@@@Z ; std::unique_ptr<ClosableStream,std::default_delete<ClosableStream> >::reset

; 1618 :         if (args->finishedCallback)

	lea	ecx, DWORD PTR _args$[ebp]
	call	??C?$unique_ptr@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@U?$default_delete@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@6@@std@@QBEPAUargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@1@@Z@XZ ; std::unique_ptr<`OBS::AddPendingStream'::`2'::args_t,std::default_delete<`OBS::AddPendingStream'::`2'::args_t> >::operator->
	add	eax, 8
	mov	ecx, eax
	call	??B?$function@$$A6AXXZ@std@@QBE_NXZ	; std::function<void __cdecl(void)>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@

; 1619 :             args->finishedCallback();

	lea	ecx, DWORD PTR _args$[ebp]
	call	??C?$unique_ptr@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@U?$default_delete@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@6@@std@@QBEPAUargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@1@@Z@XZ ; std::unique_ptr<`OBS::AddPendingStream'::`2'::args_t,std::default_delete<`OBS::AddPendingStream'::`2'::args_t> >::operator->
	add	eax, 8
	mov	ecx, eax
	call	??R?$_Func_class@X$$$V@std@@QBEXXZ	; std::_Func_class<void>::operator()
$LN1@:

; 1620 :         return 0;

	mov	DWORD PTR $T1[ebp], 0
	lea	ecx, DWORD PTR _args$[ebp]
	call	??1?$unique_ptr@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@U?$default_delete@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@6@@std@@QAE@XZ ; std::unique_ptr<`OBS::AddPendingStream'::`2'::args_t,std::default_delete<`OBS::AddPendingStream'::`2'::args_t> >::~unique_ptr<`OBS::AddPendingStream'::`2'::args_t,std::default_delete<`OBS::AddPendingStream'::`2'::args_t> >
	mov	eax, DWORD PTR $T1[ebp]

; 1621 :     }, args.release()));

	mov	esp, ebp
	pop	ebp
	ret	0
?<helper_func_vectorcall>@<lambda_0949a521542c6fafab37c8b897d7d49e>@@CQKPAX@Z ENDP ; <lambda_0949a521542c6fafab37c8b897d7d49e>::<helper_func_vectorcall>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ??0?$function@$$A6AXXZ@std@@QAE@$$T@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$function@$$A6AXXZ@std@@QAE@$$T@Z PROC		; std::function<void __cdecl(void)>::function<void __cdecl(void)>, COMDAT
; _this$ = ecx

; 561  : 	function(nullptr_t) _NOEXCEPT

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Func_class@X$$$V@std@@QAE@XZ	; std::_Func_class<void>::_Func_class<void>

; 562  : 		{	// construct empty function wrapper from null pointer
; 563  : 		this->_Reset();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Reset@?$_Func_class@X$$$V@std@@IAEXXZ	; std::_Func_class<void>::_Reset

; 564  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$function@$$A6AXXZ@std@@QAE@$$T@Z ENDP		; std::function<void __cdecl(void)>::function<void __cdecl(void)>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ??0?$function@$$A6AXXZ@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??0?$function@$$A6AXXZ@std@@QAE@$$QAV01@@Z PROC		; std::function<void __cdecl(void)>::function<void __cdecl(void)>, COMDAT
; _this$ = ecx

; 657  : 	function(_Myt&& _Right)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Func_class@X$$$V@std@@QAE@XZ	; std::_Func_class<void>::_Func_class<void>

; 658  : 		{	// construct holding moved copy of _Right
; 659  : 		this->_Resetm(_STD forward<_Myt>(_Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	call	??$forward@V?$function@$$A6AXXZ@std@@@std@@YA$$QAV?$function@$$A6AXXZ@0@AAV10@@Z ; std::forward<std::function<void __cdecl(void)> >
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Resetm@?$_Func_class@X$$$V@std@@IAEX$$QAV12@@Z ; std::_Func_class<void>::_Resetm

; 660  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$function@$$A6AXXZ@std@@QAE@$$QAV01@@Z ENDP		; std::function<void __cdecl(void)>::function<void __cdecl(void)>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ??B?$function@$$A6AXXZ@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv72 = -4						; size = 4
??B?$function@$$A6AXXZ@std@@QBE_NXZ PROC		; std::function<void __cdecl(void)>::operator bool, COMDAT
; _this$ = ecx

; 729  : 		{	// test if wrapper holds null function pointer

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 730  : 		return (!this->_Empty());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Empty@?$_Func_class@X$$$V@std@@QBE_NXZ ; std::_Func_class<void>::_Empty
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv72[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv72[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv72[ebp]

; 731  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??B?$function@$$A6AXXZ@std@@QBE_NXZ ENDP		; std::function<void __cdecl(void)>::operator bool
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ??R?$_Func_class@X$$$V@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??R?$_Func_class@X$$$V@std@@QBEXXZ PROC			; std::_Func_class<void>::operator(), COMDAT
; _this$ = ecx

; 312  : 		{	// call through stored object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 313  : 		if (_Impl == 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+16], 0
	jne	SHORT $LN1@operator

; 314  : 			_Xbad_function_call();

	call	?_Xbad_function_call@std@@YAXXZ		; std::_Xbad_function_call
$LN1@operator:

; 315  : 		return (_Impl->_Do_call(_STD forward<_Types>(_Args)...));

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR [edx+8]
	call	eax
$LN3@operator:

; 316  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??R?$_Func_class@X$$$V@std@@QBEXXZ ENDP			; std::_Func_class<void>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\memory
;	COMDAT ??0?$unique_ptr@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??0?$unique_ptr@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@@std@@QAE@$$QAV01@@Z PROC ; std::unique_ptr<NetworkStream,std::default_delete<NetworkStream> >::unique_ptr<NetworkStream,std::default_delete<NetworkStream> >, COMDAT
; _this$ = ecx

; 1388 : 		{	// construct by moving _Right

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?get_deleter@?$_Unique_ptr_base@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@$00@std@@QAEAAU?$default_delete@VNetworkStream@@@2@XZ ; std::_Unique_ptr_base<NetworkStream,std::default_delete<NetworkStream>,1>::get_deleter
	push	eax
	call	??$forward@U?$default_delete@VNetworkStream@@@std@@@std@@YA$$QAU?$default_delete@VNetworkStream@@@0@AAU10@@Z ; std::forward<std::default_delete<NetworkStream> >
	add	esp, 4
	mov	al, BYTE PTR [eax]
	movzx	ecx, al
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?release@?$unique_ptr@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@@std@@QAEPAVNetworkStream@@XZ ; std::unique_ptr<NetworkStream,std::default_delete<NetworkStream> >::release
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Unique_ptr_base@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@$00@std@@QAE@PAVNetworkStream@@U?$default_delete@VNetworkStream@@@1@@Z ; std::_Unique_ptr_base<NetworkStream,std::default_delete<NetworkStream>,1>::_Unique_ptr_base<NetworkStream,std::default_delete<NetworkStream>,1>

; 1389 : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$unique_ptr@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@@std@@QAE@$$QAV01@@Z ENDP ; std::unique_ptr<NetworkStream,std::default_delete<NetworkStream> >::unique_ptr<NetworkStream,std::default_delete<NetworkStream> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\memory
;	COMDAT ?release@?$unique_ptr@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@@std@@QAEPAVNetworkStream@@XZ
_TEXT	SEGMENT
__Ans$ = -8						; size = 4
_this$ = -4						; size = 4
?release@?$unique_ptr@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@@std@@QAEPAVNetworkStream@@XZ PROC ; std::unique_ptr<NetworkStream,std::default_delete<NetworkStream> >::release, COMDAT
; _this$ = ecx

; 1472 : 		{	// yield ownership of pointer

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1473 : 		pointer _Ans = this->_Myptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Ans$[ebp], ecx

; 1474 : 		this->_Myptr = pointer();

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], 0

; 1475 : 		return (_Ans);

	mov	eax, DWORD PTR __Ans$[ebp]

; 1476 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?release@?$unique_ptr@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@@std@@QAEPAVNetworkStream@@XZ ENDP ; std::unique_ptr<NetworkStream,std::default_delete<NetworkStream> >::release
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\memory
;	COMDAT ??0?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??0?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@QAE@$$QAV01@@Z PROC ; std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> >::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> >, COMDAT
; _this$ = ecx

; 1388 : 		{	// construct by moving _Right

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?get_deleter@?$_Unique_ptr_base@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@$00@std@@QAEAAU?$default_delete@VVideoFileStream@@@2@XZ ; std::_Unique_ptr_base<VideoFileStream,std::default_delete<VideoFileStream>,1>::get_deleter
	push	eax
	call	??$forward@U?$default_delete@VVideoFileStream@@@std@@@std@@YA$$QAU?$default_delete@VVideoFileStream@@@0@AAU10@@Z ; std::forward<std::default_delete<VideoFileStream> >
	add	esp, 4
	mov	al, BYTE PTR [eax]
	movzx	ecx, al
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?release@?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@QAEPAVVideoFileStream@@XZ ; std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> >::release
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Unique_ptr_base@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@$00@std@@QAE@PAVVideoFileStream@@U?$default_delete@VVideoFileStream@@@1@@Z ; std::_Unique_ptr_base<VideoFileStream,std::default_delete<VideoFileStream>,1>::_Unique_ptr_base<VideoFileStream,std::default_delete<VideoFileStream>,1>

; 1389 : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@QAE@$$QAV01@@Z ENDP ; std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> >::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\memory
;	COMDAT ?release@?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@QAEPAVVideoFileStream@@XZ
_TEXT	SEGMENT
__Ans$ = -8						; size = 4
_this$ = -4						; size = 4
?release@?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@QAEPAVVideoFileStream@@XZ PROC ; std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> >::release, COMDAT
; _this$ = ecx

; 1472 : 		{	// yield ownership of pointer

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1473 : 		pointer _Ans = this->_Myptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Ans$[ebp], ecx

; 1474 : 		this->_Myptr = pointer();

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], 0

; 1475 : 		return (_Ans);

	mov	eax, DWORD PTR __Ans$[ebp]

; 1476 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?release@?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@QAEPAVVideoFileStream@@XZ ENDP ; std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> >::release
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Remove@?$CircularList@_K@@QAEXI@Z
_TEXT	SEGMENT
_count$1 = -24						; size = 4
_count$2 = -20						; size = 4
tv94 = -16						; size = 4
tv80 = -12						; size = 4
_realID$ = -8						; size = 4
_this$ = -4						; size = 4
_index$ = 8						; size = 4
?Remove@?$CircularList@_K@@QAEXI@Z PROC			; CircularList<unsigned __int64>::Remove, COMDAT
; _this$ = ecx

; 860  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 861  :         unsigned int realID = GetRealIndex(index);

	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetRealIndex@?$CircularList@_K@@AAEII@Z ; CircularList<unsigned __int64>::GetRealIndex
	mov	DWORD PTR _realID$[ebp], eax

; 862  : 
; 863  :         if (realID == endID) {

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _realID$[ebp]
	cmp	edx, DWORD PTR [ecx+12]
	jne	SHORT $LN8@Remove

; 864  :             endID = (endID == 0) ? num-1 : endID-1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN11@Remove
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	sub	edx, 1
	mov	DWORD PTR tv80[ebp], edx
	jmp	SHORT $LN12@Remove
$LN11@Remove:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	sub	ecx, 1
	mov	DWORD PTR tv80[ebp], ecx
$LN12@Remove:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR tv80[ebp]
	mov	DWORD PTR [edx+12], eax
	jmp	$LN7@Remove
$LN8@Remove:

; 865  :         } else if (realID == startID) {

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _realID$[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN6@Remove

; 866  :             startID = (startID == num-1) ? 0 : startID+1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+8], ecx
	jne	SHORT $LN13@Remove
	mov	DWORD PTR tv94[ebp], 0
	jmp	SHORT $LN14@Remove
$LN13@Remove:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, 1
	mov	DWORD PTR tv94[ebp], ecx
$LN14@Remove:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR tv94[ebp]
	mov	DWORD PTR [edx+8], eax
	jmp	$LN7@Remove
$LN6@Remove:

; 867  :         } else if (realID < endID) {

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _realID$[ebp]
	cmp	edx, DWORD PTR [ecx+12]
	jae	SHORT $LN4@Remove

; 868  :             unsigned int count = endID-realID;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	sub	ecx, DWORD PTR _realID$[ebp]
	mov	DWORD PTR _count$2[ebp], ecx

; 869  :             mcpy(array+realID, array+realID+1, count*sizeof(T));

	mov	edx, DWORD PTR _count$2[ebp]
	shl	edx, 3
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _realID$[ebp]
	lea	eax, DWORD PTR [ecx+edx*8+8]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _realID$[ebp]
	lea	ecx, DWORD PTR [edx+eax*8]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 870  :             --endID;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	sub	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax
	jmp	SHORT $LN7@Remove
$LN4@Remove:

; 871  :         } else if (realID > startID) {

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _realID$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jbe	SHORT $LN7@Remove

; 872  :             unsigned int count = realID-startID;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _realID$[ebp]
	sub	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _count$1[ebp], edx

; 873  :             mcpyrev(array+startID+1, array+startID, count*sizeof(T));

	mov	eax, DWORD PTR _count$1[ebp]
	shl	eax, 3
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	lea	edx, DWORD PTR [ecx+edx*8]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+ecx*8+8]
	push	ecx
	call	?mcpyrev@@YGXPAXPBXI@Z			; mcpyrev

; 874  :             ++startID;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax
$LN7@Remove:

; 875  :         }
; 876  : 
; 877  :         --storedNum;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 878  : 
; 879  :         if (!storedNum)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+16], 0
	jne	SHORT $LN9@Remove

; 880  :             startID = endID = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
$LN9@Remove:

; 881  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?Remove@?$CircularList@_K@@QAEXI@Z ENDP			; CircularList<unsigned __int64>::Remove
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Clear@?$CircularList@_K@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Clear@?$CircularList@_K@@QAEXXZ PROC			; CircularList<unsigned __int64>::Clear, COMDAT
; _this$ = ecx

; 913  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 914  :         storedNum = startID = endID = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0

; 915  :         List::Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$List@_K@@QAEXXZ		; List<unsigned __int64>::Clear

; 916  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?Clear@?$CircularList@_K@@QAEXXZ ENDP			; CircularList<unsigned __int64>::Clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??6?$CircularList@_K@@QAEAAV0@AB_K@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_val$ = 8						; size = 4
??6?$CircularList@_K@@QAEAAV0@AB_K@Z PROC		; CircularList<unsigned __int64>::operator<<, COMDAT
; _this$ = ecx

; 937  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 938  :         Add(val);

	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Add@?$CircularList@_K@@QAEIAB_K@Z	; CircularList<unsigned __int64>::Add

; 939  :         return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 940  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
??6?$CircularList@_K@@QAEAAV0@AB_K@Z ENDP		; CircularList<unsigned __int64>::operator<<
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??A?$CircularList@_K@@QAEAA_KI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
??A?$CircularList@_K@@QAEAA_KI@Z PROC			; CircularList<unsigned __int64>::operator[], COMDAT
; _this$ = ecx

; 949  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 950  :         if (index >= storedNum) DumpError(TEXT("Out of range!  CircularList::operator[](%d)"), index);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN1@operator
	mov	edx, DWORD PTR _index$[ebp]
	push	edx
	push	OFFSET ??_C@_1FI@OMPFMOGB@?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CB?$AA?5?$AA?5?$AAC?$AAi?$AAr?$AAc?$AAu?$AAl?$AAa?$AAr?$AAL?$AAi?$AAs?$AAt?$AA?3?$AA?3?$AAo?$AAp?$AAe@
	call	DWORD PTR __imp_?DumpError@@YAXPB_WZZ
$LN1@operator:

; 951  :         return array[GetRealIndex(index)];

	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetRealIndex@?$CircularList@_K@@AAEII@Z ; CircularList<unsigned __int64>::GetRealIndex
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+eax*8]
$LN3@operator:

; 952  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CircularList@_K@@QAEAA_KI@Z ENDP			; CircularList<unsigned __int64>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Num@?$List@UFrameAudio@@@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Num@?$List@UFrameAudio@@@@QBEIXZ PROC			; List<FrameAudio>::Num, COMDAT
; _this$ = ecx

; 42   :     inline unsigned int Num() const     {return num;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	esp, ebp
	pop	ebp
	ret	0
?Num@?$List@UFrameAudio@@@@QBEIXZ ENDP			; List<FrameAudio>::Num
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?CreateNew@?$List@UFrameAudio@@@@QAEPAUFrameAudio@@XZ
_TEXT	SEGMENT
_value$ = -8						; size = 4
_this$ = -4						; size = 4
?CreateNew@?$List@UFrameAudio@@@@QAEPAUFrameAudio@@XZ PROC ; List<FrameAudio>::CreateNew, COMDAT
; _this$ = ecx

; 346  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 347  :         SetSize(num+1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSize@?$List@UFrameAudio@@@@QAEHI@Z	; List<FrameAudio>::SetSize

; 348  : 
; 349  :         T *value = &array[num-1];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR _value$[ebp], eax

; 350  : 
; 351  :         return value;

	mov	eax, DWORD PTR _value$[ebp]

; 352  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?CreateNew@?$List@UFrameAudio@@@@QAEPAUFrameAudio@@XZ ENDP ; List<FrameAudio>::CreateNew
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??A?$List@UFrameAudio@@@@QAEAAUFrameAudio@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
??A?$List@UFrameAudio@@@@QAEAAUFrameAudio@@I@Z PROC	; List<FrameAudio>::operator[], COMDAT
; _this$ = ecx

; 379  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 380  :         assert(index < num);
; 381  :         if(index >= num) {DumpError(TEXT("Out of range!  List<%S>::operator[](%d)"), typeid(T).name(), index); return array[0];}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN1@operator
	mov	edx, DWORD PTR _index$[ebp]
	push	edx
	push	OFFSET ?__type_info_root_node@@3U__type_info_node@@A ; __type_info_root_node
	mov	ecx, OFFSET ??_R0?AUFrameAudio@@@8
	call	?name@type_info@@QBEPBDPAU__type_info_node@@@Z ; type_info::name
	push	eax
	push	OFFSET ??_C@_1FA@KCLJOBNL@?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CB?$AA?5?$AA?5?$AAL?$AAi?$AAs?$AAt?$AA?$DM?$AA?$CF?$AAS?$AA?$DO?$AA?3?$AA?3?$AAo?$AAp?$AAe?$AAr?$AAa?$AAt?$AAo@
	call	DWORD PTR __imp_?DumpError@@YAXPB_WZZ
	mov	eax, 16					; 00000010H
	imul	eax, eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN3@operator
$LN1@operator:

; 382  :         return array[index];

	mov	eax, DWORD PTR _index$[ebp]
	shl	eax, 4
	mov	edx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [edx]
$LN3@operator:

; 383  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$List@UFrameAudio@@@@QAEAAUFrameAudio@@I@Z ENDP	; List<FrameAudio>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\list
;	COMDAT ?begin@?$list@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$list@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@@2@XZ PROC ; std::list<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >::begin, COMDAT
; _this$ = ecx

; 1115 : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1116 : 		return (iterator(this->_Nextnode(this->_Myhead), this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	?_Nextnode@?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@SAAAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@PAU32@@Z ; std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > >::_Nextnode
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@1@@Z ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > > >::_List_iterator<std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1117 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$list@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@@2@XZ ENDP ; std::list<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >::begin
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\list
;	COMDAT ?end@?$list@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$list@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@@2@XZ PROC ; std::list<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >::end, COMDAT
; _this$ = ecx

; 1125 : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1126 : 		return (iterator(this->_Myhead, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@1@@Z ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > > >::_List_iterator<std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1127 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$list@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@@2@XZ ENDP ; std::list<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >::end
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\list
;	COMDAT ?empty@?$list@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv70 = -4						; size = 4
?empty@?$list@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QBE_NXZ PROC ; std::list<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >::empty, COMDAT
; _this$ = ecx

; 1245 : 		{	// test if sequence is empty

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1246 : 		return (this->_Mysize == 0);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN3@empty
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN4@empty
$LN3@empty:
	mov	DWORD PTR tv70[ebp], 0
$LN4@empty:
	mov	al, BYTE PTR tv70[ebp]

; 1247 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?empty@?$list@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QBE_NXZ ENDP ; std::list<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >::empty
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\memory
;	COMDAT ??0?$unique_ptr@UClosableStream@@U?$default_delete@UClosableStream@@@std@@@std@@QAE@PAUClosableStream@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??0?$unique_ptr@UClosableStream@@U?$default_delete@UClosableStream@@@std@@@std@@QAE@PAUClosableStream@@@Z PROC ; std::unique_ptr<ClosableStream,std::default_delete<ClosableStream> >::unique_ptr<ClosableStream,std::default_delete<ClosableStream> >, COMDAT
; _this$ = ecx

; 1365 : 		{	// construct with pointer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Unique_ptr_base@UClosableStream@@U?$default_delete@UClosableStream@@@std@@$00@std@@QAE@PAUClosableStream@@@Z ; std::_Unique_ptr_base<ClosableStream,std::default_delete<ClosableStream>,1>::_Unique_ptr_base<ClosableStream,std::default_delete<ClosableStream>,1>

; 1366 : 		static_assert(!is_pointer<_Dx>::value,
; 1367 : 			"unique_ptr constructed with null deleter pointer");
; 1368 : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$unique_ptr@UClosableStream@@U?$default_delete@UClosableStream@@@std@@@std@@QAE@PAUClosableStream@@@Z ENDP ; std::unique_ptr<ClosableStream,std::default_delete<ClosableStream> >::unique_ptr<ClosableStream,std::default_delete<ClosableStream> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\memory
;	COMDAT ??1?$unique_ptr@UClosableStream@@U?$default_delete@UClosableStream@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$unique_ptr@UClosableStream@@U?$default_delete@UClosableStream@@@std@@@std@@QAE@XZ PROC ; std::unique_ptr<ClosableStream,std::default_delete<ClosableStream> >::~unique_ptr<ClosableStream,std::default_delete<ClosableStream> >, COMDAT
; _this$ = ecx

; 1446 : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1447 : 		if (this->_Myptr != pointer())

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@unique_ptr

; 1448 : 			this->get_deleter()(this->_Myptr);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?get_deleter@?$_Unique_ptr_base@UClosableStream@@U?$default_delete@UClosableStream@@@std@@$00@std@@QAEAAU?$default_delete@UClosableStream@@@2@XZ ; std::_Unique_ptr_base<ClosableStream,std::default_delete<ClosableStream>,1>::get_deleter
	mov	ecx, eax
	call	??R?$default_delete@UClosableStream@@@std@@QBEXPAUClosableStream@@@Z ; std::default_delete<ClosableStream>::operator()
$LN2@unique_ptr:

; 1449 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$unique_ptr@UClosableStream@@U?$default_delete@UClosableStream@@@std@@@std@@QAE@XZ ENDP ; std::unique_ptr<ClosableStream,std::default_delete<ClosableStream> >::~unique_ptr<ClosableStream,std::default_delete<ClosableStream> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\memory
;	COMDAT ?reset@?$unique_ptr@UClosableStream@@U?$default_delete@UClosableStream@@@std@@@std@@QAEXPAUClosableStream@@@Z
_TEXT	SEGMENT
__Old$ = -8						; size = 4
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?reset@?$unique_ptr@UClosableStream@@U?$default_delete@UClosableStream@@@std@@@std@@QAEXPAUClosableStream@@@Z PROC ; std::unique_ptr<ClosableStream,std::default_delete<ClosableStream> >::reset, COMDAT
; _this$ = ecx

; 1479 : 		{	// establish new pointer

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1480 : 		pointer _Old = this->_Myptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Old$[ebp], ecx

; 1481 : 		this->_Myptr = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [edx], eax

; 1482 : 		if (_Old != pointer())

	cmp	DWORD PTR __Old$[ebp], 0
	je	SHORT $LN2@reset

; 1483 : 			this->get_deleter()(_Old);

	mov	ecx, DWORD PTR __Old$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?get_deleter@?$_Unique_ptr_base@UClosableStream@@U?$default_delete@UClosableStream@@@std@@$00@std@@QAEAAU?$default_delete@UClosableStream@@@2@XZ ; std::_Unique_ptr_base<ClosableStream,std::default_delete<ClosableStream>,1>::get_deleter
	mov	ecx, eax
	call	??R?$default_delete@UClosableStream@@@std@@QBEXPAUClosableStream@@@Z ; std::default_delete<ClosableStream>::operator()
$LN2@reset:

; 1484 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?reset@?$unique_ptr@UClosableStream@@U?$default_delete@UClosableStream@@@std@@@std@@QAEXPAUClosableStream@@@Z ENDP ; std::unique_ptr<ClosableStream,std::default_delete<ClosableStream> >::reset
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\memory
;	COMDAT ??0?$unique_ptr@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@U?$default_delete@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@6@@std@@QAE@PAUargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@1@@Z@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??0?$unique_ptr@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@U?$default_delete@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@6@@std@@QAE@PAUargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@1@@Z@@Z PROC ; std::unique_ptr<`OBS::AddPendingStream'::`2'::args_t,std::default_delete<`OBS::AddPendingStream'::`2'::args_t> >::unique_ptr<`OBS::AddPendingStream'::`2'::args_t,std::default_delete<`OBS::AddPendingStream'::`2'::args_t> >, COMDAT
; _this$ = ecx

; 1365 : 		{	// construct with pointer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Unique_ptr_base@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@U?$default_delete@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@6@$00@std@@QAE@PAUargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@1@@Z@@Z ; std::_Unique_ptr_base<`OBS::AddPendingStream'::`2'::args_t,std::default_delete<`OBS::AddPendingStream'::`2'::args_t>,1>::_Unique_ptr_base<`OBS::AddPendingStream'::`2'::args_t,std::default_delete<`OBS::AddPendingStream'::`2'::args_t>,1>

; 1366 : 		static_assert(!is_pointer<_Dx>::value,
; 1367 : 			"unique_ptr constructed with null deleter pointer");
; 1368 : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$unique_ptr@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@U?$default_delete@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@6@@std@@QAE@PAUargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@1@@Z@@Z ENDP ; std::unique_ptr<`OBS::AddPendingStream'::`2'::args_t,std::default_delete<`OBS::AddPendingStream'::`2'::args_t> >::unique_ptr<`OBS::AddPendingStream'::`2'::args_t,std::default_delete<`OBS::AddPendingStream'::`2'::args_t> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\memory
;	COMDAT ??1?$unique_ptr@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@U?$default_delete@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@6@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$unique_ptr@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@U?$default_delete@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@6@@std@@QAE@XZ PROC ; std::unique_ptr<`OBS::AddPendingStream'::`2'::args_t,std::default_delete<`OBS::AddPendingStream'::`2'::args_t> >::~unique_ptr<`OBS::AddPendingStream'::`2'::args_t,std::default_delete<`OBS::AddPendingStream'::`2'::args_t> >, COMDAT
; _this$ = ecx

; 1446 : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1447 : 		if (this->_Myptr != pointer())

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@unique_ptr

; 1448 : 			this->get_deleter()(this->_Myptr);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?get_deleter@?$_Unique_ptr_base@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@U?$default_delete@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@6@$00@std@@QAEAAU?$default_delete@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@2@XZ ; std::_Unique_ptr_base<`OBS::AddPendingStream'::`2'::args_t,std::default_delete<`OBS::AddPendingStream'::`2'::args_t>,1>::get_deleter
	mov	ecx, eax
	call	??R?$default_delete@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@std@@QBEXPAUargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@1@@Z@@Z ; std::default_delete<`OBS::AddPendingStream'::`2'::args_t>::operator()
$LN2@unique_ptr:

; 1449 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$unique_ptr@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@U?$default_delete@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@6@@std@@QAE@XZ ENDP ; std::unique_ptr<`OBS::AddPendingStream'::`2'::args_t,std::default_delete<`OBS::AddPendingStream'::`2'::args_t> >::~unique_ptr<`OBS::AddPendingStream'::`2'::args_t,std::default_delete<`OBS::AddPendingStream'::`2'::args_t> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\memory
;	COMDAT ??C?$unique_ptr@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@U?$default_delete@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@6@@std@@QBEPAUargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@1@@Z@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??C?$unique_ptr@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@U?$default_delete@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@6@@std@@QBEPAUargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@1@@Z@XZ PROC ; std::unique_ptr<`OBS::AddPendingStream'::`2'::args_t,std::default_delete<`OBS::AddPendingStream'::`2'::args_t> >::operator->, COMDAT
; _this$ = ecx

; 1457 : 		{	// return pointer to class object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1458 : 		return (_STD pointer_traits<pointer>::pointer_to(**this));

	mov	ecx, DWORD PTR _this$[ebp]
	call	??D?$unique_ptr@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@U?$default_delete@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@6@@std@@QBEAAUargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@1@@Z@XZ ; std::unique_ptr<`OBS::AddPendingStream'::`2'::args_t,std::default_delete<`OBS::AddPendingStream'::`2'::args_t> >::operator*
	push	eax
	call	?pointer_to@?$pointer_traits@PAUargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@std@@SAPAUargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@2@@Z@AAU3?1??45@QAEX01@Z@@Z ; std::pointer_traits<`OBS::AddPendingStream'::`2'::args_t *>::pointer_to
	add	esp, 4

; 1459 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??C?$unique_ptr@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@U?$default_delete@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@6@@std@@QBEPAUargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@1@@Z@XZ ENDP ; std::unique_ptr<`OBS::AddPendingStream'::`2'::args_t,std::default_delete<`OBS::AddPendingStream'::`2'::args_t> >::operator->
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\memory
;	COMDAT ?release@?$unique_ptr@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@U?$default_delete@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@6@@std@@QAEPAUargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@2@@Z@XZ
_TEXT	SEGMENT
__Ans$ = -8						; size = 4
_this$ = -4						; size = 4
?release@?$unique_ptr@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@U?$default_delete@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@6@@std@@QAEPAUargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@2@@Z@XZ PROC ; std::unique_ptr<`OBS::AddPendingStream'::`2'::args_t,std::default_delete<`OBS::AddPendingStream'::`2'::args_t> >::release, COMDAT
; _this$ = ecx

; 1472 : 		{	// yield ownership of pointer

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1473 : 		pointer _Ans = this->_Myptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Ans$[ebp], ecx

; 1474 : 		this->_Myptr = pointer();

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], 0

; 1475 : 		return (_Ans);

	mov	eax, DWORD PTR __Ans$[ebp]

; 1476 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?release@?$unique_ptr@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@U?$default_delete@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@6@@std@@QAEPAUargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@2@@Z@XZ ENDP ; std::unique_ptr<`OBS::AddPendingStream'::`2'::args_t,std::default_delete<`OBS::AddPendingStream'::`2'::args_t> >::release
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\vector
;	COMDAT ?push_back@?$vector@PAXV?$allocator@PAX@std@@@std@@QAEX$$QAPAX@Z
_TEXT	SEGMENT
__Idx$1 = -12						; size = 4
_this$ = -8						; size = 4
$T2 = -2						; size = 1
$T3 = -1						; size = 1
__Val$ = 8						; size = 4
?push_back@?$vector@PAXV?$allocator@PAX@std@@@std@@QAEX$$QAPAX@Z PROC ; std::vector<void *,std::allocator<void *> >::push_back, COMDAT
; _this$ = ecx

; 865  : 		{	// insert by moving into element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 866  : 		if (_Inside(_STD addressof(_Val)))

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	??$addressof@PAX@std@@YAPAPAXAAPAX@Z	; std::addressof<void *>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inside@?$vector@PAXV?$allocator@PAX@std@@@std@@IBE_NPBQAX@Z ; std::vector<void *,std::allocator<void *> >::_Inside
	movzx	ecx, al
	test	ecx, ecx
	je	$LN4@push_back

; 867  : 			{	// push back an element
; 868  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	call	??$addressof@PAX@std@@YAPAPAXAAPAX@Z	; std::addressof<void *>
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2
	mov	DWORD PTR __Idx$1[ebp], eax

; 869  : 			if (this->_Mylast == this->_Myend)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $LN3@push_back

; 870  : 				_Reserve(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Reserve@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXI@Z ; std::vector<void *,std::allocator<void *> >::_Reserve
$LN3@push_back:

; 871  : 			_Orphan_range(this->_Mylast, this->_Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_range@?$vector@PAXV?$allocator@PAX@std@@@std@@IBEXPAPAX0@Z ; std::vector<void *,std::allocator<void *> >::_Orphan_range

; 872  : 			this->_Getal().construct(this->_Mylast,
; 873  : 				_STD forward<value_type>(this->_Myfirst[_Idx]));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Idx$1[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	push	eax
	call	??$forward@PAX@std@@YA$$QAPAXAAPAX@Z	; std::forward<void *>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAX@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<void *,std::allocator<void *> > >::_Getal
	mov	ecx, eax
	call	??$construct@PAXPAX@?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@QAEXPAPAX$$QAPAX@Z ; std::_Wrap_alloc<std::allocator<void *> >::construct<void *,void *>

; 874  : 			++this->_Mylast;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], edx

; 875  : 			}
; 876  : 		else

	jmp	SHORT $LN5@push_back
$LN4@push_back:

; 877  : 			{	// push back a non-element
; 878  : 			if (this->_Mylast == this->_Myend)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN1@push_back

; 879  : 				_Reserve(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Reserve@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXI@Z ; std::vector<void *,std::allocator<void *> >::_Reserve
$LN1@push_back:

; 880  : 			_Orphan_range(this->_Mylast, this->_Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_range@?$vector@PAXV?$allocator@PAX@std@@@std@@IBEXPAPAX0@Z ; std::vector<void *,std::allocator<void *> >::_Orphan_range

; 881  : 			this->_Getal().construct(this->_Mylast,
; 882  : 				_STD forward<value_type>(_Val));

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	call	??$forward@PAX@std@@YA$$QAPAXAAPAX@Z	; std::forward<void *>
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAXV?$allocator@PAX@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAX@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<void *,std::allocator<void *> > >::_Getal
	mov	ecx, eax
	call	??$construct@PAXPAX@?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@QAEXPAPAX$$QAPAX@Z ; std::_Wrap_alloc<std::allocator<void *> >::construct<void *,void *>

; 883  : 			++this->_Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx
$LN5@push_back:

; 884  : 			}
; 885  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@PAXV?$allocator@PAX@std@@@std@@QAEX$$QAPAX@Z ENDP ; std::vector<void *,std::allocator<void *> >::push_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\vector
;	COMDAT ?data@?$vector@PAXV?$allocator@PAX@std@@@std@@QAEPAPAXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?data@?$vector@PAXV?$allocator@PAX@std@@@std@@QAEPAPAXXZ PROC ; std::vector<void *,std::allocator<void *> >::data, COMDAT
; _this$ = ecx

; 1213 : 		{	// return address of first element

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1214 : 		return (this->_Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 1215 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?data@?$vector@PAXV?$allocator@PAX@std@@@std@@QAEPAPAXXZ ENDP ; std::vector<void *,std::allocator<void *> >::data
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\list
;	COMDAT ??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@@std@@QBEAAV?$unique_ptr@XU?$ThreadTerminator@$0A@@@@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@@std@@QBEAAV?$unique_ptr@XU?$ThreadTerminator@$0A@@@@1@XZ PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > > >::operator*, COMDAT
; _this$ = ecx

; 362  : 		{	// return designated value

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 363  : 		return ((reference)**(_Mybase *)this);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@@std@@QBEABV?$unique_ptr@XU?$ThreadTerminator@$0A@@@@1@XZ ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > > >::operator*

; 364  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@@std@@QBEAAV?$unique_ptr@XU?$ThreadTerminator@$0A@@@@1@XZ ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\list
;	COMDAT ??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > > >::operator++, COMDAT
; _this$ = ecx

; 372  : 		{	// preincrement

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 373  : 		++(*(_Mybase *)this);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > > >::operator++

; 374  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 375  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\list
;	COMDAT ??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv69 = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > > >::operator!=, COMDAT
; _this$ = ecx

; 302  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 303  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > > >::operator==
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv69[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv69[ebp]

; 304  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > > >::operator!=
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\memory
;	COMDAT ?get@?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@QBEPAXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@QBEPAXXZ PROC ; std::unique_ptr<void,ThreadTerminator<0> >::get, COMDAT
; _this$ = ecx

; 1462 : 		{	// return pointer to object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1463 : 		return (this->_Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 1464 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?get@?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@QBEPAXXZ ENDP ; std::unique_ptr<void,ThreadTerminator<0> >::get
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ?_Empty@?$_Func_class@X$$$V@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv66 = -4						; size = 4
?_Empty@?$_Func_class@X$$$V@std@@QBE_NXZ PROC		; std::_Func_class<void>::_Empty, COMDAT
; _this$ = ecx

; 319  : 		{	// return true if no stored object

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 320  : 		return (_Impl == 0);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+16], 0
	jne	SHORT $LN3@Empty
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN4@Empty
$LN3@Empty:
	mov	DWORD PTR tv66[ebp], 0
$LN4@Empty:
	mov	al, BYTE PTR tv66[ebp]

; 321  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Empty@?$_Func_class@X$$$V@std@@QBE_NXZ ENDP		; std::_Func_class<void>::_Empty
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ?_Resetm@?$_Func_class@X$$$V@std@@IAEX$$QAV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
?_Resetm@?$_Func_class@X$$$V@std@@IAEX$$QAV12@@Z PROC	; std::_Func_class<void>::_Resetm, COMDAT
; _this$ = ecx

; 345  : 		{	// move _Right's stored object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 346  : 		if (_Right._Impl == 0)

	mov	eax, DWORD PTR __Right$[ebp]
	cmp	DWORD PTR [eax+16], 0
	jne	SHORT $LN4@Resetm

; 347  : 			_Set(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set@?$_Func_class@X$$$V@std@@AAEXPAV?$_Func_base@X$$$V@2@@Z ; std::_Func_class<void>::_Set
	jmp	SHORT $LN5@Resetm
$LN4@Resetm:

; 348  : 		else if (_Right._Local())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Local@?$_Func_class@X$$$V@std@@ABE_NXZ ; std::_Func_class<void>::_Local
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@Resetm

; 349  : 			{	// move and tidy
; 350  : 			_Set(_Right._Impl->_Move((void *)&_Space));

	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+16]
	mov	edx, DWORD PTR [eax+4]
	call	edx
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set@?$_Func_class@X$$$V@std@@AAEXPAV?$_Func_base@X$$$V@2@@Z ; std::_Func_class<void>::_Set

; 351  : 			_Right._Tidy();

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Tidy@?$_Func_class@X$$$V@std@@IAEXXZ	; std::_Func_class<void>::_Tidy

; 352  : 			}
; 353  : 		else

	jmp	SHORT $LN5@Resetm
$LN2@Resetm:

; 354  : 			{	// steal from _Right
; 355  : 			_Set(_Right._Impl);

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set@?$_Func_class@X$$$V@std@@AAEXPAV?$_Func_base@X$$$V@2@@Z ; std::_Func_class<void>::_Set

; 356  : 			_Right._Set(0);

	push	0
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Set@?$_Func_class@X$$$V@std@@AAEXPAV?$_Func_base@X$$$V@2@@Z ; std::_Func_class<void>::_Set
$LN5@Resetm:

; 357  : 			}
; 358  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Resetm@?$_Func_class@X$$$V@std@@IAEX$$QAV12@@Z ENDP	; std::_Func_class<void>::_Resetm
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\memory
;	COMDAT ??0?$_Unique_ptr_base@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@$00@std@@QAE@PAVNetworkStream@@U?$default_delete@VNetworkStream@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Dt$ = 12						; size = 1
??0?$_Unique_ptr_base@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@$00@std@@QAE@PAVNetworkStream@@U?$default_delete@VNetworkStream@@@1@@Z PROC ; std::_Unique_ptr_base<NetworkStream,std::default_delete<NetworkStream>,1>::_Unique_ptr_base<NetworkStream,std::default_delete<NetworkStream>,1>, COMDAT
; _this$ = ecx

; 1290 : 		{	// construct with pointer and deleter

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [eax], ecx

; 1291 : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Unique_ptr_base@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@$00@std@@QAE@PAVNetworkStream@@U?$default_delete@VNetworkStream@@@1@@Z ENDP ; std::_Unique_ptr_base<NetworkStream,std::default_delete<NetworkStream>,1>::_Unique_ptr_base<NetworkStream,std::default_delete<NetworkStream>,1>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\memory
;	COMDAT ??0?$_Unique_ptr_base@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@$00@std@@QAE@PAVVideoFileStream@@U?$default_delete@VVideoFileStream@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Dt$ = 12						; size = 1
??0?$_Unique_ptr_base@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@$00@std@@QAE@PAVVideoFileStream@@U?$default_delete@VVideoFileStream@@@1@@Z PROC ; std::_Unique_ptr_base<VideoFileStream,std::default_delete<VideoFileStream>,1>::_Unique_ptr_base<VideoFileStream,std::default_delete<VideoFileStream>,1>, COMDAT
; _this$ = ecx

; 1290 : 		{	// construct with pointer and deleter

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [eax], ecx

; 1291 : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Unique_ptr_base@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@$00@std@@QAE@PAVVideoFileStream@@U?$default_delete@VVideoFileStream@@@1@@Z ENDP ; std::_Unique_ptr_base<VideoFileStream,std::default_delete<VideoFileStream>,1>::_Unique_ptr_base<VideoFileStream,std::default_delete<VideoFileStream>,1>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?GetRealIndex@?$CircularList@_K@@AAEII@Z
_TEXT	SEGMENT
_newIndex$1 = -8					; size = 4
_this$ = -4						; size = 4
_index$ = 8						; size = 4
?GetRealIndex@?$CircularList@_K@@AAEII@Z PROC		; CircularList<unsigned __int64>::GetRealIndex, COMDAT
; _this$ = ecx

; 771  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 772  :         if (startID == 0) {

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN3@GetRealInd

; 773  :             return index;

	mov	eax, DWORD PTR _index$[ebp]
	jmp	SHORT $LN4@GetRealInd

; 774  :         } else {

	jmp	SHORT $LN4@GetRealInd
$LN3@GetRealInd:

; 775  :             unsigned int newIndex = startID + index;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	add	edx, DWORD PTR _index$[ebp]
	mov	DWORD PTR _newIndex$1[ebp], edx

; 776  :             if (newIndex >= num)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newIndex$1[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN1@GetRealInd

; 777  :                 newIndex -= num;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _newIndex$1[ebp]
	sub	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _newIndex$1[ebp], eax
$LN1@GetRealInd:

; 778  : 
; 779  :             return newIndex;

	mov	eax, DWORD PTR _newIndex$1[ebp]
$LN4@GetRealInd:

; 780  :         }
; 781  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetRealIndex@?$CircularList@_K@@AAEII@Z ENDP		; CircularList<unsigned __int64>::GetRealIndex
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Add@?$CircularList@_K@@QAEIAB_K@Z
_TEXT	SEGMENT
tv198 = -12						; size = 4
tv180 = -8						; size = 4
_this$ = -4						; size = 4
_val$ = 8						; size = 4
?Add@?$CircularList@_K@@QAEIAB_K@Z PROC			; CircularList<unsigned __int64>::Add, COMDAT
; _this$ = ecx

; 787  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 788  :         if (storedNum == num) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+16]
	cmp	edx, DWORD PTR [ecx+4]
	jne	$LN6@Add

; 789  :             if (startID == 0) {

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN5@Add

; 790  :                 List::Add(val);

	mov	ecx, DWORD PTR _val$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Add@?$List@_K@@QAEIAB_K@Z		; List<unsigned __int64>::Add

; 791  : 
; 792  :                 if (storedNum != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+16], 0
	je	SHORT $LN4@Add

; 793  :                     ++endID;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], ecx
$LN4@Add:

; 794  :             } else {

	jmp	SHORT $LN3@Add
$LN5@Add:

; 795  :                 List::SetSize(storedNum+1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSize@?$List@_K@@QAEHI@Z		; List<unsigned __int64>::SetSize

; 796  :                 mcpyrev(array+startID+1, array+startID, (storedNum-startID)*sizeof(T));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+16]
	sub	ecx, DWORD PTR [eax+8]
	shl	ecx, 3
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+eax*8]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	lea	edx, DWORD PTR [ecx+edx*8+8]
	push	edx
	call	?mcpyrev@@YGXPAXPBXI@Z			; mcpyrev

; 797  :                 mcpy(array+startID, &val, sizeof(T));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR _val$[ebp]
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax+ecx*8], esi
	mov	edx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+ecx*8+4], edx

; 798  :                 ++startID;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 799  :                 ++endID;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], ecx
$LN3@Add:

; 800  :             }
; 801  :         } else {

	jmp	SHORT $LN2@Add
$LN6@Add:

; 802  :             if (storedNum > 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+16], 0
	jbe	SHORT $LN1@Add

; 803  :                 endID = (endID == num-1) ? 0 : endID+1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	sub	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], edx
	jne	SHORT $LN9@Add
	mov	DWORD PTR tv180[ebp], 0
	jmp	SHORT $LN10@Add
$LN9@Add:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	add	edx, 1
	mov	DWORD PTR tv180[ebp], edx
$LN10@Add:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR tv180[ebp]
	mov	DWORD PTR [eax+12], ecx
$LN1@Add:

; 804  :             mcpy(array+endID, &val, sizeof(T));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _val$[ebp]
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [edx+eax*8], esi
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+eax*8+4], ecx
$LN2@Add:

; 805  :         }
; 806  : 
; 807  :         return storedNum++;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR tv198[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR tv198[ebp]

; 808  :     }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?Add@?$CircularList@_K@@QAEIAB_K@Z ENDP			; CircularList<unsigned __int64>::Add
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?SetSize@?$List@UFrameAudio@@@@QAEHI@Z
_TEXT	SEGMENT
_bClear$ = -16						; size = 4
_oldNum$ = -12						; size = 4
tv70 = -8						; size = 4
_this$ = -4						; size = 4
_n$ = 8							; size = 4
?SetSize@?$List@UFrameAudio@@@@QAEHI@Z PROC		; List<FrameAudio>::SetSize, COMDAT
; _this$ = ecx

; 205  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 206  :         if(num == n)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _n$[ebp]
	jne	SHORT $LN4@SetSize

; 207  :             return FALSE;

	xor	eax, eax
	jmp	$LN5@SetSize
	jmp	SHORT $LN3@SetSize
$LN4@SetSize:

; 208  :         else if(!n)

	cmp	DWORD PTR _n$[ebp], 0
	jne	SHORT $LN3@SetSize

; 209  :         {
; 210  :             Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$List@UFrameAudio@@@@QAEXXZ	; List<FrameAudio>::Clear

; 211  :             return TRUE;

	mov	eax, 1
	jmp	$LN5@SetSize
$LN3@SetSize:

; 212  :         }
; 213  : 
; 214  :         BOOL bClear=(n>num);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _n$[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jbe	SHORT $LN7@SetSize
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN8@SetSize
$LN7@SetSize:
	mov	DWORD PTR tv70[ebp], 0
$LN8@SetSize:
	mov	ecx, DWORD PTR tv70[ebp]
	mov	DWORD PTR _bClear$[ebp], ecx

; 215  :         UINT oldNum=num;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _oldNum$[ebp], eax

; 216  : 
; 217  :         num = n;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _n$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 218  :         array = (T*)ReAllocate(array, sizeof(T)*num);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 4
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 219  : 
; 220  :         if(bClear)

	cmp	DWORD PTR _bClear$[ebp], 0
	je	SHORT $LN1@SetSize

; 221  :             zero(&array[oldNum], sizeof(T)*(num-oldNum));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, DWORD PTR _oldNum$[ebp]
	shl	eax, 4
	push	eax
	mov	ecx, DWORD PTR _oldNum$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx]
	push	ecx
	call	?zero@@YGXPAXI@Z			; zero
$LN1@SetSize:

; 222  : 
; 223  :         return TRUE;

	mov	eax, 1
$LN5@SetSize:

; 224  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetSize@?$List@UFrameAudio@@@@QAEHI@Z ENDP		; List<FrameAudio>::SetSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\memory
;	COMDAT ??R?$default_delete@UClosableStream@@@std@@QBEXPAUClosableStream@@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv70 = -12						; size = 4
$T1 = -8						; size = 4
$T2 = -4						; size = 4
__Ptr$ = 8						; size = 4
??R?$default_delete@UClosableStream@@@std@@QBEXPAUClosableStream@@@Z PROC ; std::default_delete<ClosableStream>::operator(), COMDAT
; _this$ = ecx

; 1197 : 		{	// delete a pointer

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1198 : 		static_assert(0 < sizeof (_Ty),
; 1199 : 			"can't delete an incomplete type");
; 1200 : 		delete _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR $T2[ebp], ecx
	cmp	DWORD PTR $T2[ebp], 0
	je	SHORT $LN3@operator
	push	1
	mov	edx, DWORD PTR $T2[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR $T2[ebp]
	mov	edx, DWORD PTR [eax]
	call	edx
	mov	DWORD PTR tv70[ebp], eax
	jmp	SHORT $LN1@operator
$LN3@operator:
	mov	DWORD PTR tv70[ebp], 0
$LN1@operator:

; 1201 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??R?$default_delete@UClosableStream@@@std@@QBEXPAUClosableStream@@@Z ENDP ; std::default_delete<ClosableStream>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\memory
;	COMDAT ??0?$_Unique_ptr_base@UClosableStream@@U?$default_delete@UClosableStream@@@std@@$00@std@@QAE@PAUClosableStream@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??0?$_Unique_ptr_base@UClosableStream@@U?$default_delete@UClosableStream@@@std@@$00@std@@QAE@PAUClosableStream@@@Z PROC ; std::_Unique_ptr_base<ClosableStream,std::default_delete<ClosableStream>,1>::_Unique_ptr_base<ClosableStream,std::default_delete<ClosableStream>,1>, COMDAT
; _this$ = ecx

; 1295 : 		{	// construct with pointer and deleter

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$default_delete@UClosableStream@@@std@@QAE@XZ ; std::default_delete<ClosableStream>::default_delete<ClosableStream>
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [eax], ecx

; 1296 : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Unique_ptr_base@UClosableStream@@U?$default_delete@UClosableStream@@@std@@$00@std@@QAE@PAUClosableStream@@@Z ENDP ; std::_Unique_ptr_base<ClosableStream,std::default_delete<ClosableStream>,1>::_Unique_ptr_base<ClosableStream,std::default_delete<ClosableStream>,1>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\memory
;	COMDAT ?get_deleter@?$_Unique_ptr_base@UClosableStream@@U?$default_delete@UClosableStream@@@std@@$00@std@@QAEAAU?$default_delete@UClosableStream@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get_deleter@?$_Unique_ptr_base@UClosableStream@@U?$default_delete@UClosableStream@@@std@@$00@std@@QAEAAU?$default_delete@UClosableStream@@@2@XZ PROC ; std::_Unique_ptr_base<ClosableStream,std::default_delete<ClosableStream>,1>::get_deleter, COMDAT
; _this$ = ecx

; 1312 : 		{	// return reference to deleter

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1313 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 1314 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?get_deleter@?$_Unique_ptr_base@UClosableStream@@U?$default_delete@UClosableStream@@@std@@$00@std@@QAEAAU?$default_delete@UClosableStream@@@2@XZ ENDP ; std::_Unique_ptr_base<ClosableStream,std::default_delete<ClosableStream>,1>::get_deleter
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\memory
;	COMDAT ??D?$unique_ptr@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@U?$default_delete@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@6@@std@@QBEAAUargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@1@@Z@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$unique_ptr@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@U?$default_delete@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@6@@std@@QBEAAUargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@1@@Z@XZ PROC ; std::unique_ptr<`OBS::AddPendingStream'::`2'::args_t,std::default_delete<`OBS::AddPendingStream'::`2'::args_t> >::operator*, COMDAT
; _this$ = ecx

; 1452 : 		{	// return reference to object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1453 : 		return (*this->_Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 1454 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??D?$unique_ptr@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@U?$default_delete@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@6@@std@@QBEAAUargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@1@@Z@XZ ENDP ; std::unique_ptr<`OBS::AddPendingStream'::`2'::args_t,std::default_delete<`OBS::AddPendingStream'::`2'::args_t> >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\memory
;	COMDAT ??R?$default_delete@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@std@@QBEXPAUargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@1@@Z@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv68 = -12						; size = 4
$T1 = -8						; size = 4
$T2 = -4						; size = 4
__Ptr$ = 8						; size = 4
??R?$default_delete@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@std@@QBEXPAUargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@1@@Z@@Z PROC ; std::default_delete<`OBS::AddPendingStream'::`2'::args_t>::operator(), COMDAT
; _this$ = ecx

; 1197 : 		{	// delete a pointer

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1198 : 		static_assert(0 < sizeof (_Ty),
; 1199 : 			"can't delete an incomplete type");
; 1200 : 		delete _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR $T2[ebp], ecx
	cmp	DWORD PTR $T2[ebp], 0
	je	SHORT $LN3@operator
	push	1
	mov	ecx, DWORD PTR $T2[ebp]
	call	??_Gargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@QAEPAXI@Z
	mov	DWORD PTR tv68[ebp], eax
	jmp	SHORT $LN1@operator
$LN3@operator:
	mov	DWORD PTR tv68[ebp], 0
$LN1@operator:

; 1201 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??R?$default_delete@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@std@@QBEXPAUargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@1@@Z@@Z ENDP ; std::default_delete<`OBS::AddPendingStream'::`2'::args_t>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\memory
;	COMDAT ??0?$_Unique_ptr_base@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@U?$default_delete@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@6@$00@std@@QAE@PAUargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@1@@Z@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??0?$_Unique_ptr_base@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@U?$default_delete@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@6@$00@std@@QAE@PAUargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@1@@Z@@Z PROC ; std::_Unique_ptr_base<`OBS::AddPendingStream'::`2'::args_t,std::default_delete<`OBS::AddPendingStream'::`2'::args_t>,1>::_Unique_ptr_base<`OBS::AddPendingStream'::`2'::args_t,std::default_delete<`OBS::AddPendingStream'::`2'::args_t>,1>, COMDAT
; _this$ = ecx

; 1295 : 		{	// construct with pointer and deleter

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$default_delete@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@std@@QAE@XZ ; std::default_delete<`OBS::AddPendingStream'::`2'::args_t>::default_delete<`OBS::AddPendingStream'::`2'::args_t>
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [eax], ecx

; 1296 : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Unique_ptr_base@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@U?$default_delete@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@6@$00@std@@QAE@PAUargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@1@@Z@@Z ENDP ; std::_Unique_ptr_base<`OBS::AddPendingStream'::`2'::args_t,std::default_delete<`OBS::AddPendingStream'::`2'::args_t>,1>::_Unique_ptr_base<`OBS::AddPendingStream'::`2'::args_t,std::default_delete<`OBS::AddPendingStream'::`2'::args_t>,1>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\memory
;	COMDAT ?get_deleter@?$_Unique_ptr_base@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@U?$default_delete@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@6@$00@std@@QAEAAU?$default_delete@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get_deleter@?$_Unique_ptr_base@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@U?$default_delete@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@6@$00@std@@QAEAAU?$default_delete@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@2@XZ PROC ; std::_Unique_ptr_base<`OBS::AddPendingStream'::`2'::args_t,std::default_delete<`OBS::AddPendingStream'::`2'::args_t>,1>::get_deleter, COMDAT
; _this$ = ecx

; 1312 : 		{	// return reference to deleter

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1313 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 1314 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?get_deleter@?$_Unique_ptr_base@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@U?$default_delete@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@6@$00@std@@QAEAAU?$default_delete@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@2@XZ ENDP ; std::_Unique_ptr_base<`OBS::AddPendingStream'::`2'::args_t,std::default_delete<`OBS::AddPendingStream'::`2'::args_t>,1>::get_deleter
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\list
;	COMDAT ??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@1@@Z PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > > >::_List_iterator<std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > > >, COMDAT
; _this$ = ecx

; 345  : 		{	// construct with node pointer _Pnode

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Plist$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@1@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > > >::_List_const_iterator<std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > > >

; 346  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@1@@Z ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > > >::_List_iterator<std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\list
;	COMDAT ??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@@std@@QBEABV?$unique_ptr@XU?$ThreadTerminator@$0A@@@@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@@std@@QBEABV?$unique_ptr@XU?$ThreadTerminator@$0A@@@@1@XZ PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > > >::operator*, COMDAT
; _this$ = ecx

; 204  : 		{	// return designated value

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 205  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 206  : 		if (this->_Getcont() == 0
; 207  : 			|| this->_Ptr == 0
; 208  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 209  : 			{	// report error
; 210  : 			_DEBUG_ERROR("list iterator not dereferencable");
; 211  : 			_SCL_SECURE_OUT_OF_RANGE;
; 212  : 			}
; 213  : 
; 214  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 215  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 216  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 217  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 218  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 219  : 
; 220  : 		return (_Mylist::_Myval(this->_Ptr));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Myval@?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@SAAAV?$unique_ptr@XU?$ThreadTerminator@$0A@@@@2@PAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@@Z ; std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > >::_Myval
	add	esp, 4

; 221  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@@std@@QBEABV?$unique_ptr@XU?$ThreadTerminator@$0A@@@@1@XZ ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\list
;	COMDAT ??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > > >::operator++, COMDAT
; _this$ = ecx

; 224  : 		{	// preincrement

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 225  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 226  : 		if (this->_Getcont() == 0
; 227  : 			|| this->_Ptr == 0
; 228  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 229  : 			{	// report error
; 230  : 			_DEBUG_ERROR("list iterator not incrementable");
; 231  : 			_SCL_SECURE_OUT_OF_RANGE;
; 232  : 			}
; 233  : 
; 234  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 235  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 236  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 237  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 238  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 239  : 
; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Nextnode@?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@SAAAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@PAU32@@Z ; std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > >::_Nextnode
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 241  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 242  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\list
;	COMDAT ??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv75 = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > > >::operator==, COMDAT
; _this$ = ecx

; 284  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 285  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 286  : 		if (this->_Getcont() == 0
; 287  : 			|| this->_Getcont() != _Right._Getcont())
; 288  : 			{	// report error
; 289  : 			_DEBUG_ERROR("list iterators incompatible");
; 290  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 291  : 			}
; 292  : 
; 293  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 294  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 295  : 			&& this->_Getcont() == _Right._Getcont());
; 296  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 297  : 
; 298  : 		return (this->_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv75[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv75[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv75[ebp]

; 299  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > > >::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ??1?$_Func_base@X$$$V@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Func_base@X$$$V@std@@UAE@XZ PROC			; std::_Func_base<void>::~_Func_base<void>, COMDAT
; _this$ = ecx

; 151  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7?$_Func_base@X$$$V@std@@6B@

; 152  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Func_base@X$$$V@std@@UAE@XZ ENDP			; std::_Func_base<void>::~_Func_base<void>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ?pointer_to@?$pointer_traits@PAUargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@std@@SAPAUargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@2@@Z@AAU3?1??45@QAEX01@Z@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?pointer_to@?$pointer_traits@PAUargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@std@@SAPAUargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@2@@Z@AAU3?1??45@QAEX01@Z@@Z PROC ; std::pointer_traits<`OBS::AddPendingStream'::`2'::args_t *>::pointer_to, COMDAT

; 233  : 		{	// convert raw reference to pointer

	push	ebp
	mov	ebp, esp

; 234  : 		return (_STD addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	??$addressof@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@std@@YAPAUargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@0@@Z@AAU1?1??23@QAEX01@Z@@Z ; std::addressof<`OBS::AddPendingStream'::`2'::args_t>
	add	esp, 4

; 235  : 		}

	pop	ebp
	ret	0
?pointer_to@?$pointer_traits@PAUargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@std@@SAPAUargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@2@@Z@AAU3?1??45@QAEX01@Z@@Z ENDP ; std::pointer_traits<`OBS::AddPendingStream'::`2'::args_t *>::pointer_to
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@QAEPAXI@Z PROC ; `OBS::AddPendingStream'::`2'::args_t::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1args_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@QAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@QAEPAXI@Z ENDP ; `OBS::AddPendingStream'::`2'::args_t::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G?$_Func_base@X$$$V@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$_Func_base@X$$$V@std@@UAEPAXI@Z PROC		; std::_Func_base<void>::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Func_base@X$$$V@std@@UAE@XZ	; std::_Func_base<void>::~_Func_base<void>
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G?$_Func_base@X$$$V@std@@UAEPAXI@Z ENDP		; std::_Func_base<void>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1args_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1args_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@QAE@XZ PROC ; `OBS::AddPendingStream'::`2'::args_t::~args_t, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??1?$function@$$A6AXXZ@std@@QAE@XZ	; std::function<void __cdecl(void)>::~function<void __cdecl(void)>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$unique_ptr@UClosableStream@@U?$default_delete@UClosableStream@@@std@@@std@@QAE@XZ ; std::unique_ptr<ClosableStream,std::default_delete<ClosableStream> >::~unique_ptr<ClosableStream,std::default_delete<ClosableStream> >
	mov	esp, ebp
	pop	ebp
	ret	0
??1args_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@QAE@XZ ENDP ; `OBS::AddPendingStream'::`2'::args_t::~args_t
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?SetSize@?$List@_K@@QAEHI@Z
_TEXT	SEGMENT
_bClear$ = -16						; size = 4
_oldNum$ = -12						; size = 4
tv70 = -8						; size = 4
_this$ = -4						; size = 4
_n$ = 8							; size = 4
?SetSize@?$List@_K@@QAEHI@Z PROC			; List<unsigned __int64>::SetSize, COMDAT
; _this$ = ecx

; 205  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 206  :         if(num == n)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _n$[ebp]
	jne	SHORT $LN4@SetSize

; 207  :             return FALSE;

	xor	eax, eax
	jmp	$LN5@SetSize
	jmp	SHORT $LN3@SetSize
$LN4@SetSize:

; 208  :         else if(!n)

	cmp	DWORD PTR _n$[ebp], 0
	jne	SHORT $LN3@SetSize

; 209  :         {
; 210  :             Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$List@_K@@QAEXXZ		; List<unsigned __int64>::Clear

; 211  :             return TRUE;

	mov	eax, 1
	jmp	$LN5@SetSize
$LN3@SetSize:

; 212  :         }
; 213  : 
; 214  :         BOOL bClear=(n>num);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _n$[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jbe	SHORT $LN7@SetSize
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN8@SetSize
$LN7@SetSize:
	mov	DWORD PTR tv70[ebp], 0
$LN8@SetSize:
	mov	ecx, DWORD PTR tv70[ebp]
	mov	DWORD PTR _bClear$[ebp], ecx

; 215  :         UINT oldNum=num;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _oldNum$[ebp], eax

; 216  : 
; 217  :         num = n;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _n$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 218  :         array = (T*)ReAllocate(array, sizeof(T)*num);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 3
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 219  : 
; 220  :         if(bClear)

	cmp	DWORD PTR _bClear$[ebp], 0
	je	SHORT $LN1@SetSize

; 221  :             zero(&array[oldNum], sizeof(T)*(num-oldNum));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, DWORD PTR _oldNum$[ebp]
	shl	eax, 3
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _oldNum$[ebp]
	lea	ecx, DWORD PTR [edx+eax*8]
	push	ecx
	call	?zero@@YGXPAXI@Z			; zero
$LN1@SetSize:

; 222  : 
; 223  :         return TRUE;

	mov	eax, 1
$LN5@SetSize:

; 224  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetSize@?$List@_K@@QAEHI@Z ENDP			; List<unsigned __int64>::SetSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\memory
;	COMDAT ??0?$default_delete@UClosableStream@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$default_delete@UClosableStream@@@std@@QAE@XZ PROC	; std::default_delete<ClosableStream>::default_delete<ClosableStream>, COMDAT
; _this$ = ecx

; 1185 : 	default_delete() _NOEXCEPT

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1186 : 		{	// default construct
; 1187 : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$default_delete@UClosableStream@@@std@@QAE@XZ ENDP	; std::default_delete<ClosableStream>::default_delete<ClosableStream>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\memory
;	COMDAT ??0?$default_delete@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$default_delete@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@std@@QAE@XZ PROC ; std::default_delete<`OBS::AddPendingStream'::`2'::args_t>::default_delete<`OBS::AddPendingStream'::`2'::args_t>, COMDAT
; _this$ = ecx

; 1185 : 	default_delete() _NOEXCEPT

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1186 : 		{	// default construct
; 1187 : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$default_delete@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@std@@QAE@XZ ENDP ; std::default_delete<`OBS::AddPendingStream'::`2'::args_t>::default_delete<`OBS::AddPendingStream'::`2'::args_t>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\list
;	COMDAT ??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@1@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > > >::_List_const_iterator<std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > > >, COMDAT
; _this$ = ecx

; 187  : 		{	// construct with node pointer _Pnode

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Plist$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > >,std::_Iterator_base0>

; 188  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@1@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > > >::_List_const_iterator<std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\list
;	COMDAT ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@1@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 44   : 		{	// construct with node pointer _Pnode

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 45   : 		this->_Adopt(_Plist);

	mov	edx, DWORD PTR __Plist$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z	; std::_Iterator_base0::_Adopt

; 46   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@1@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\tuple
;	COMDAT ??$tie@PAUReplayBuffer@@V?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@std@@YA?AV?$tuple@AAPAUReplayBuffer@@AAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@0@AAPAUReplayBuffer@@AAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_<_Args_0>$ = 12					; size = 4
_<_Args_1>$ = 16					; size = 4
??$tie@PAUReplayBuffer@@V?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@std@@YA?AV?$tuple@AAPAUReplayBuffer@@AAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@0@AAPAUReplayBuffer@@AAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@0@@Z PROC ; std::tie<ReplayBuffer *,std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > >, COMDAT

; 617  : 	{	// make tuple from elements

	push	ebp
	mov	ebp, esp

; 618  : 	typedef tuple<_Types&...> _Ttype;
; 619  : 	return (_Ttype(_Args...));

	mov	eax, DWORD PTR _<_Args_1>$[ebp]
	push	eax
	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$tuple@AAPAUReplayBuffer@@AAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@std@@QAE@AAPAUReplayBuffer@@AAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@1@@Z ; std::tuple<ReplayBuffer * &,std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > &>::tuple<ReplayBuffer * &,std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > &>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 620  : 	}

	pop	ebp
	ret	0
??$tie@PAUReplayBuffer@@V?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@std@@YA?AV?$tuple@AAPAUReplayBuffer@@AAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@0@AAPAUReplayBuffer@@AAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@0@@Z ENDP ; std::tie<ReplayBuffer *,std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\tuple
;	COMDAT ??$?4PAUReplayBuffer@@V?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@?$tuple@AAPAUReplayBuffer@@AAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@std@@QAEAAV01@$$QAU?$pair@PAUReplayBuffer@@V?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??$?4PAUReplayBuffer@@V?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@?$tuple@AAPAUReplayBuffer@@AAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@std@@QAEAAV01@$$QAU?$pair@PAUReplayBuffer@@V?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@1@@Z PROC ; std::tuple<ReplayBuffer * &,std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > &>::operator=<ReplayBuffer *,std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > >, COMDAT
; _this$ = ecx

; 423  : 		_Myt& operator=(pair<_First, _Second>&& _Right)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 424  : 		_NOEXCEPT_OP(
; 425  : 			_NOEXCEPT_OP(_Myfirst._Val = _STD forward<_First>(_Right.first))
; 426  : 			&& _NOEXCEPT_OP((_Mybase&)*this =
; 427  : 				tuple<_Second>(_STD forward<_Second>(_Right.second))))
; 428  : 		{	// assign by moving pair
; 429  : 		static_assert(_Mysize == 2,
; 430  : 			"assigning to tuple from object with different size");
; 431  : 		_Myfirst._Val = _STD forward<_First>(_Right.first);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	call	??$forward@PAUReplayBuffer@@@std@@YA$$QAPAUReplayBuffer@@AAPAU1@@Z ; std::forward<ReplayBuffer *>
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 432  : 		(_Mybase&)*this =
; 433  : 			tuple<_Second>(_STD forward<_Second>(_Right.second));

	mov	ecx, DWORD PTR __Right$[ebp]
	add	ecx, 4
	push	ecx
	call	??$forward@V?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@std@@YA$$QAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@0@AAV10@@Z ; std::forward<std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > >
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	call	??$?0V?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@$$$VPAPAX@?$tuple@V?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@std@@QAE@$$QAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@1@@Z ; std::tuple<std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > >::tuple<std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > ><std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> >,void * *>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$?4V?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@?$tuple@AAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@std@@QAEAAV01@$$QAV?$tuple@V?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@1@@Z ; std::tuple<std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > &>::operator=<std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > >
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1?$tuple@V?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@std@@QAE@XZ

; 434  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 435  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$?4PAUReplayBuffer@@V?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@?$tuple@AAPAUReplayBuffer@@AAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@std@@QAEAAV01@$$QAU?$pair@PAUReplayBuffer@@V?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@1@@Z ENDP ; std::tuple<ReplayBuffer * &,std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > &>::operator=<ReplayBuffer *,std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\type_traits
;	COMDAT ??$move@AAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@std@@YA$$QAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@std@@YA$$QAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@0@AAV10@@Z PROC ; std::move<std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > &>, COMDAT

; 1519 : 	{	// forward _Arg as movable

	push	ebp
	mov	ebp, esp

; 1520 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

	mov	eax, DWORD PTR __Arg$[ebp]

; 1521 : 	}

	pop	ebp
	ret	0
??$move@AAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@std@@YA$$QAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@0@AAV10@@Z ENDP ; std::move<std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ??$?4AAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@@?$function@$$A6AXXZ@std@@QAEAAV01@AAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Func$ = 8						; size = 4
??$?4AAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@@?$function@$$A6AXXZ@std@@QAEAAV01@AAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@@Z PROC ; std::function<void __cdecl(void)>::operator=<<lambda_582637cdd8d6a2f689bc987be9ec55df> &>, COMDAT
; _this$ = ecx

; 685  : 		_Myt& operator=(_Fx&& _Func)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 686  : 		{	// move function object _Func
; 687  : 		this->_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$_Func_class@X$$$V@std@@IAEXXZ	; std::_Func_class<void>::_Tidy

; 688  : 		this->_Reset(_STD forward<_Fx>(_Func));

	mov	eax, DWORD PTR __Func$[ebp]
	push	eax
	call	??$forward@AAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@@std@@YAAAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@AAV1@@Z ; std::forward<<lambda_582637cdd8d6a2f689bc987be9ec55df> &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Reset@AAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@@?$_Func_class@X$$$V@std@@IAEXAAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@@Z ; std::_Func_class<void>::_Reset<<lambda_582637cdd8d6a2f689bc987be9ec55df> &>

; 689  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 690  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$?4AAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@@?$function@$$A6AXXZ@std@@QAEAAV01@AAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@@Z ENDP ; std::function<void __cdecl(void)>::operator=<<lambda_582637cdd8d6a2f689bc987be9ec55df> &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ??$?4AAV<lambda_e856d28dddb7588070dd099cfda6c634>@@@?$function@$$A6AXXZ@std@@QAEAAV01@AAV<lambda_e856d28dddb7588070dd099cfda6c634>@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Func$ = 8						; size = 4
??$?4AAV<lambda_e856d28dddb7588070dd099cfda6c634>@@@?$function@$$A6AXXZ@std@@QAEAAV01@AAV<lambda_e856d28dddb7588070dd099cfda6c634>@@@Z PROC ; std::function<void __cdecl(void)>::operator=<<lambda_e856d28dddb7588070dd099cfda6c634> &>, COMDAT
; _this$ = ecx

; 685  : 		_Myt& operator=(_Fx&& _Func)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 686  : 		{	// move function object _Func
; 687  : 		this->_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$_Func_class@X$$$V@std@@IAEXXZ	; std::_Func_class<void>::_Tidy

; 688  : 		this->_Reset(_STD forward<_Fx>(_Func));

	mov	eax, DWORD PTR __Func$[ebp]
	push	eax
	call	??$forward@AAV<lambda_e856d28dddb7588070dd099cfda6c634>@@@std@@YAAAV<lambda_e856d28dddb7588070dd099cfda6c634>@@AAV1@@Z ; std::forward<<lambda_e856d28dddb7588070dd099cfda6c634> &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Reset@AAV<lambda_e856d28dddb7588070dd099cfda6c634>@@@?$_Func_class@X$$$V@std@@IAEXAAV<lambda_e856d28dddb7588070dd099cfda6c634>@@@Z ; std::_Func_class<void>::_Reset<<lambda_e856d28dddb7588070dd099cfda6c634> &>

; 689  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 690  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$?4AAV<lambda_e856d28dddb7588070dd099cfda6c634>@@@?$function@$$A6AXXZ@std@@QAEAAV01@AAV<lambda_e856d28dddb7588070dd099cfda6c634>@@@Z ENDP ; std::function<void __cdecl(void)>::operator=<<lambda_e856d28dddb7588070dd099cfda6c634> &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\type_traits
;	COMDAT ??$move@AAV?$unique_ptr@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@@std@@@std@@YA$$QAV?$unique_ptr@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$unique_ptr@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@@std@@@std@@YA$$QAV?$unique_ptr@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@@0@AAV10@@Z PROC ; std::move<std::unique_ptr<NetworkStream,std::default_delete<NetworkStream> > &>, COMDAT

; 1519 : 	{	// forward _Arg as movable

	push	ebp
	mov	ebp, esp

; 1520 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

	mov	eax, DWORD PTR __Arg$[ebp]

; 1521 : 	}

	pop	ebp
	ret	0
??$move@AAV?$unique_ptr@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@@std@@@std@@YA$$QAV?$unique_ptr@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@@0@AAV10@@Z ENDP ; std::move<std::unique_ptr<NetworkStream,std::default_delete<NetworkStream> > &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ??$?4V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@@?$function@$$A6AXXZ@std@@QAEAAV01@$$QAV<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Func$ = 8						; size = 4
??$?4V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@@?$function@$$A6AXXZ@std@@QAEAAV01@$$QAV<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@@Z PROC ; std::function<void __cdecl(void)>::operator=<<lambda_7c9af1b141e25bc2e890d47a77a39da9> >, COMDAT
; _this$ = ecx

; 685  : 		_Myt& operator=(_Fx&& _Func)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 686  : 		{	// move function object _Func
; 687  : 		this->_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$_Func_class@X$$$V@std@@IAEXXZ	; std::_Func_class<void>::_Tidy

; 688  : 		this->_Reset(_STD forward<_Fx>(_Func));

	mov	eax, DWORD PTR __Func$[ebp]
	push	eax
	call	??$forward@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@@std@@YA$$QAV<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@AAV1@@Z ; std::forward<<lambda_7c9af1b141e25bc2e890d47a77a39da9> >
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Reset@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@@?$_Func_class@X$$$V@std@@IAEX$$QAV<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@@Z ; std::_Func_class<void>::_Reset<<lambda_7c9af1b141e25bc2e890d47a77a39da9> >

; 689  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 690  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$?4V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@@?$function@$$A6AXXZ@std@@QAEAAV01@$$QAV<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@@Z ENDP ; std::function<void __cdecl(void)>::operator=<<lambda_7c9af1b141e25bc2e890d47a77a39da9> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ??$?0V<lambda_3b020cec0f1508adac4c896f138918cf>@@@?$function@$$A6AXXZ@std@@QAE@$$QAV<lambda_3b020cec0f1508adac4c896f138918cf>@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Func$ = 8						; size = 4
??$?0V<lambda_3b020cec0f1508adac4c896f138918cf>@@@?$function@$$A6AXXZ@std@@QAE@$$QAV<lambda_3b020cec0f1508adac4c896f138918cf>@@@Z PROC ; std::function<void __cdecl(void)>::function<void __cdecl(void)><<lambda_3b020cec0f1508adac4c896f138918cf> >, COMDAT
; _this$ = ecx

; 669  : 		function(_Fx&& _Func)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Func_class@X$$$V@std@@QAE@XZ	; std::_Func_class<void>::_Func_class<void>

; 670  : 		{	// construct wrapper holding moved _Func
; 671  : 		this->_Reset(_STD forward<_Fx>(_Func));

	mov	eax, DWORD PTR __Func$[ebp]
	push	eax
	call	??$forward@V<lambda_3b020cec0f1508adac4c896f138918cf>@@@std@@YA$$QAV<lambda_3b020cec0f1508adac4c896f138918cf>@@AAV1@@Z ; std::forward<<lambda_3b020cec0f1508adac4c896f138918cf> >
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Reset@V<lambda_3b020cec0f1508adac4c896f138918cf>@@@?$_Func_class@X$$$V@std@@IAEX$$QAV<lambda_3b020cec0f1508adac4c896f138918cf>@@@Z ; std::_Func_class<void>::_Reset<<lambda_3b020cec0f1508adac4c896f138918cf> >

; 672  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0V<lambda_3b020cec0f1508adac4c896f138918cf>@@@?$function@$$A6AXXZ@std@@QAE@$$QAV<lambda_3b020cec0f1508adac4c896f138918cf>@@@Z ENDP ; std::function<void __cdecl(void)>::function<void __cdecl(void)><<lambda_3b020cec0f1508adac4c896f138918cf> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ??$?0V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@@?$function@$$A6AXXZ@std@@QAE@$$QAV<lambda_3648d362fc95221bbf9c4c4a922d1611>@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Func$ = 8						; size = 4
??$?0V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@@?$function@$$A6AXXZ@std@@QAE@$$QAV<lambda_3648d362fc95221bbf9c4c4a922d1611>@@@Z PROC ; std::function<void __cdecl(void)>::function<void __cdecl(void)><<lambda_3648d362fc95221bbf9c4c4a922d1611> >, COMDAT
; _this$ = ecx

; 669  : 		function(_Fx&& _Func)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Func_class@X$$$V@std@@QAE@XZ	; std::_Func_class<void>::_Func_class<void>

; 670  : 		{	// construct wrapper holding moved _Func
; 671  : 		this->_Reset(_STD forward<_Fx>(_Func));

	mov	eax, DWORD PTR __Func$[ebp]
	push	eax
	call	??$forward@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@@std@@YA$$QAV<lambda_3648d362fc95221bbf9c4c4a922d1611>@@AAV1@@Z ; std::forward<<lambda_3648d362fc95221bbf9c4c4a922d1611> >
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Reset@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@@?$_Func_class@X$$$V@std@@IAEX$$QAV<lambda_3648d362fc95221bbf9c4c4a922d1611>@@@Z ; std::_Func_class<void>::_Reset<<lambda_3648d362fc95221bbf9c4c4a922d1611> >

; 672  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@@?$function@$$A6AXXZ@std@@QAE@$$QAV<lambda_3648d362fc95221bbf9c4c4a922d1611>@@@Z ENDP ; std::function<void __cdecl(void)>::function<void __cdecl(void)><<lambda_3648d362fc95221bbf9c4c4a922d1611> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\type_traits
;	COMDAT ??$move@AAV?$function@$$A6AXXZ@std@@@std@@YA$$QAV?$function@$$A6AXXZ@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$function@$$A6AXXZ@std@@@std@@YA$$QAV?$function@$$A6AXXZ@0@AAV10@@Z PROC ; std::move<std::function<void __cdecl(void)> &>, COMDAT

; 1519 : 	{	// forward _Arg as movable

	push	ebp
	mov	ebp, esp

; 1520 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

	mov	eax, DWORD PTR __Arg$[ebp]

; 1521 : 	}

	pop	ebp
	ret	0
??$move@AAV?$function@$$A6AXXZ@std@@@std@@YA$$QAV?$function@$$A6AXXZ@0@AAV10@@Z ENDP ; std::move<std::function<void __cdecl(void)> &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\memory
;	COMDAT ??$make_unique@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@AAPAU4@V56@@std@@YA?AV?$unique_ptr@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@U?$default_delete@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@6@@0@AAPAUClosableStream@@$$QAV?$function@$$A6AXXZ@0@@Z
_TEXT	SEGMENT
tv88 = -8						; size = 4
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_<_Args_0>$ = 12					; size = 4
_<_Args_1>$ = 16					; size = 4
??$make_unique@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@AAPAU4@V56@@std@@YA?AV?$unique_ptr@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@U?$default_delete@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@6@@0@AAPAUClosableStream@@$$QAV?$function@$$A6AXXZ@0@@Z PROC ; std::make_unique<`OBS::AddPendingStream'::`2'::args_t,ClosableStream * &,std::function<void __cdecl(void)> >, COMDAT

; 1638 : 	{	// make a unique_ptr

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1639 : 	return (unique_ptr<_Ty>(new _Ty(_STD forward<_Types>(_Args)...)));

	push	32					; 00000020H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 0
	je	SHORT $LN3@make_uniqu
	mov	eax, DWORD PTR _<_Args_1>$[ebp]
	push	eax
	call	??$forward@V?$function@$$A6AXXZ@std@@@std@@YA$$QAV?$function@$$A6AXXZ@0@AAV10@@Z ; std::forward<std::function<void __cdecl(void)> >
	add	esp, -20				; ffffffecH
	mov	ecx, esp
	push	eax
	call	??0?$function@$$A6AXXZ@std@@QAE@$$QAV01@@Z ; std::function<void __cdecl(void)>::function<void __cdecl(void)>
	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	push	ecx
	call	??$forward@AAPAUClosableStream@@@std@@YAAAPAUClosableStream@@AAPAU1@@Z ; std::forward<ClosableStream * &>
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR $T1[ebp]
	call	??0args_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@QAE@01@Z ; `OBS::AddPendingStream'::`2'::args_t::args_t
	mov	DWORD PTR tv88[ebp], eax
	jmp	SHORT $LN4@make_uniqu
$LN3@make_uniqu:
	mov	DWORD PTR tv88[ebp], 0
$LN4@make_uniqu:
	mov	eax, DWORD PTR tv88[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$unique_ptr@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@U?$default_delete@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@6@@std@@QAE@PAUargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@1@@Z@@Z ; std::unique_ptr<`OBS::AddPendingStream'::`2'::args_t,std::default_delete<`OBS::AddPendingStream'::`2'::args_t> >::unique_ptr<`OBS::AddPendingStream'::`2'::args_t,std::default_delete<`OBS::AddPendingStream'::`2'::args_t> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1640 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$make_unique@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@AAPAU4@V56@@std@@YA?AV?$unique_ptr@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@U?$default_delete@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@6@@0@AAPAUClosableStream@@$$QAV?$function@$$A6AXXZ@0@@Z ENDP ; std::make_unique<`OBS::AddPendingStream'::`2'::args_t,ClosableStream * &,std::function<void __cdecl(void)> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\list
;	COMDAT ??$emplace_back@PAX@?$list@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAEX$$QAPAX@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$emplace_back@PAX@?$list@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAEX$$QAPAX@Z PROC ; std::list<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >::emplace_back<void *>, COMDAT
; _this$ = ecx

; 1038 : 		void emplace_back(_Valty&&... _Val)

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1039 : 		{	// insert element at end
; 1040 : 		_Insert(_Unchecked_end(), _STD forward<_Valty>(_Val)...);

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Unchecked_end@?$list@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@@2@XZ ; std::list<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >::_Unchecked_end
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR _<_Val_0>$[ebp]
	push	edx
	call	??$forward@PAX@std@@YA$$QAPAXAAPAX@Z	; std::forward<void *>
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Insert@PAX@?$list@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@U_Iterator_base0@2@@1@$$QAPAX@Z ; std::list<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >::_Insert<void *>

; 1041 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$emplace_back@PAX@?$list@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAEX$$QAPAX@Z ENDP ; std::list<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >::emplace_back<void *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\list
;	COMDAT ??$emplace_back@AAPAX@?$list@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAEXAAPAX@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$emplace_back@AAPAX@?$list@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAEXAAPAX@Z PROC ; std::list<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >::emplace_back<void * &>, COMDAT
; _this$ = ecx

; 1038 : 		void emplace_back(_Valty&&... _Val)

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1039 : 		{	// insert element at end
; 1040 : 		_Insert(_Unchecked_end(), _STD forward<_Valty>(_Val)...);

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Unchecked_end@?$list@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@@2@XZ ; std::list<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >::_Unchecked_end
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR _<_Val_0>$[ebp]
	push	edx
	call	??$forward@AAPAX@std@@YAAAPAXAAPAX@Z	; std::forward<void * &>
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Insert@AAPAX@?$list@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@U_Iterator_base0@2@@1@AAPAX@Z ; std::list<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >::_Insert<void * &>

; 1041 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$emplace_back@AAPAX@?$list@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAEXAAPAX@Z ENDP ; std::list<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >::emplace_back<void * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\type_traits
;	COMDAT ??$forward@V?$function@$$A6AXXZ@std@@@std@@YA$$QAV?$function@$$A6AXXZ@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$function@$$A6AXXZ@std@@@std@@YA$$QAV?$function@$$A6AXXZ@0@AAV10@@Z PROC ; std::forward<std::function<void __cdecl(void)> >, COMDAT

; 1504 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

	pop	ebp
	ret	0
??$forward@V?$function@$$A6AXXZ@std@@@std@@YA$$QAV?$function@$$A6AXXZ@0@AAV10@@Z ENDP ; std::forward<std::function<void __cdecl(void)> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\type_traits
;	COMDAT ??$forward@U?$default_delete@VNetworkStream@@@std@@@std@@YA$$QAU?$default_delete@VNetworkStream@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U?$default_delete@VNetworkStream@@@std@@@std@@YA$$QAU?$default_delete@VNetworkStream@@@0@AAU10@@Z PROC ; std::forward<std::default_delete<NetworkStream> >, COMDAT

; 1504 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

	pop	ebp
	ret	0
??$forward@U?$default_delete@VNetworkStream@@@std@@@std@@YA$$QAU?$default_delete@VNetworkStream@@@0@AAU10@@Z ENDP ; std::forward<std::default_delete<NetworkStream> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\type_traits
;	COMDAT ??$forward@U?$default_delete@VVideoFileStream@@@std@@@std@@YA$$QAU?$default_delete@VVideoFileStream@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U?$default_delete@VVideoFileStream@@@std@@@std@@YA$$QAU?$default_delete@VVideoFileStream@@@0@AAU10@@Z PROC ; std::forward<std::default_delete<VideoFileStream> >, COMDAT

; 1504 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

	pop	ebp
	ret	0
??$forward@U?$default_delete@VVideoFileStream@@@std@@@std@@YA$$QAU?$default_delete@VVideoFileStream@@@0@AAU10@@Z ENDP ; std::forward<std::default_delete<VideoFileStream> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xstddef
;	COMDAT ??$addressof@PAX@std@@YAPAPAXAAPAX@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PAX@std@@YAPAPAXAAPAX@Z PROC		; std::addressof<void *>, COMDAT

; 92   : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR __Val$[ebp]

; 96   : 	}

	pop	ebp
	ret	0
??$addressof@PAX@std@@YAPAPAXAAPAX@Z ENDP		; std::addressof<void *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\type_traits
;	COMDAT ??$forward@PAX@std@@YA$$QAPAXAAPAX@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@PAX@std@@YA$$QAPAXAAPAX@Z PROC		; std::forward<void *>, COMDAT

; 1504 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

	pop	ebp
	ret	0
??$forward@PAX@std@@YA$$QAPAXAAPAX@Z ENDP		; std::forward<void *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$construct@PAXPAX@?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@QAEXPAPAX$$QAPAX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAXPAX@?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@QAEXPAPAX$$QAPAX@Z PROC ; std::_Wrap_alloc<std::allocator<void *> >::construct<void *,void *>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	eax
	call	??$forward@PAX@std@@YA$$QAPAXAAPAX@Z	; std::forward<void *>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@PAXPAX@?$allocator_traits@V?$allocator@PAX@std@@@std@@SAXAAV?$allocator@PAX@1@PAPAX$$QAPAX@Z ; std::allocator_traits<std::allocator<void *> >::construct<void *,void *>
	add	esp, 12					; 0000000cH

; 873  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@PAXPAX@?$_Wrap_alloc@V?$allocator@PAX@std@@@std@@QAEXPAPAX$$QAPAX@Z ENDP ; std::_Wrap_alloc<std::allocator<void *> >::construct<void *,void *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xstddef
;	COMDAT ??$addressof@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@std@@YAPAUargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@0@@Z@AAU1?1??23@QAEX01@Z@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@std@@YAPAUargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@0@@Z@AAU1?1??23@QAEX01@Z@@Z PROC ; std::addressof<`OBS::AddPendingStream'::`2'::args_t>, COMDAT

; 92   : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR __Val$[ebp]

; 96   : 	}

	pop	ebp
	ret	0
??$addressof@Uargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@std@@@Z@@std@@YAPAUargs_t@?1??AddPendingStream@OBS@@QAEXPAUClosableStream@@V?$function@$$A6AXXZ@0@@Z@AAU1?1??23@QAEX01@Z@@Z ENDP ; std::addressof<`OBS::AddPendingStream'::`2'::args_t>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$tuple@V?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$tuple@V?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@std@@QAE@XZ PROC ; std::tuple<std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > >::~tuple<std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Tuple_val@V?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@std@@QAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$tuple@V?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@std@@QAE@XZ ENDP ; std::tuple<std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > >::~tuple<std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$_Tuple_val@V?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Tuple_val@V?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Tuple_val<std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > >::~_Tuple_val<std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@QAE@XZ ; std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> >::~unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> >
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Tuple_val@V?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tuple_val<std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > >::~_Tuple_val<std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\list
;	COMDAT ?_Unchecked_end@?$list@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Unchecked_end@?$list@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@@2@XZ PROC ; std::list<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >::_Unchecked_end, COMDAT
; _this$ = ecx

; 1147 : 		{	// return unchecked iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1148 : 		return (_Unchecked_iterator(this->_Myhead, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@1@@Z ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1149 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Unchecked_end@?$list@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@@2@XZ ENDP ; std::list<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\tuple
;	COMDAT ??0?$tuple@AAPAUReplayBuffer@@AAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@std@@QAE@AAPAUReplayBuffer@@AAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__This_arg$ = 8						; size = 4
_<_Rest_arg_0>$ = 12					; size = 4
??0?$tuple@AAPAUReplayBuffer@@AAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@std@@QAE@AAPAUReplayBuffer@@AAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@1@@Z PROC ; std::tuple<ReplayBuffer * &,std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > &>::tuple<ReplayBuffer * &,std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > &>, COMDAT
; _this$ = ecx

; 215  : 		{	// construct from one or more copied elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _<_Rest_arg_0>$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$tuple@AAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@std@@QAE@AAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@1@@Z ; std::tuple<std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > &>::tuple<std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > &>
	mov	ecx, DWORD PTR __This_arg$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0AAPAUReplayBuffer@@@?$_Tuple_val@AAPAUReplayBuffer@@@std@@QAE@AAPAUReplayBuffer@@@Z ; std::_Tuple_val<ReplayBuffer * &>::_Tuple_val<ReplayBuffer * &><ReplayBuffer * &>

; 216  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$tuple@AAPAUReplayBuffer@@AAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@std@@QAE@AAPAUReplayBuffer@@AAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@1@@Z ENDP ; std::tuple<ReplayBuffer * &,std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > &>::tuple<ReplayBuffer * &,std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\tuple
;	COMDAT ??0?$tuple@AAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@std@@QAE@AAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__This_arg$ = 8						; size = 4
??0?$tuple@AAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@std@@QAE@AAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@1@@Z PROC ; std::tuple<std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > &>::tuple<std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > &>, COMDAT
; _this$ = ecx

; 215  : 		{	// construct from one or more copied elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$tuple@$$$V@std@@QAE@XZ		; std::tuple<>::tuple<>
	mov	eax, DWORD PTR __This_arg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$?0AAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@?$_Tuple_val@AAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@std@@QAE@AAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@1@@Z ; std::_Tuple_val<std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > &>::_Tuple_val<std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > &><std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > &>

; 216  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$tuple@AAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@std@@QAE@AAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@1@@Z ENDP ; std::tuple<std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > &>::tuple<std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\list
;	COMDAT ??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@1@@Z PROC ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > > >, COMDAT
; _this$ = ecx

; 124  : 		{	// construct with node pointer _Pnode

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Plist$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > >,std::_Iterator_base0>

; 125  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@1@@Z ENDP ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\type_traits
;	COMDAT ??$forward@V?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@std@@YA$$QAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@std@@YA$$QAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@0@AAV10@@Z PROC ; std::forward<std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > >, COMDAT

; 1504 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

	pop	ebp
	ret	0
??$forward@V?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@std@@YA$$QAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\tuple
;	COMDAT ??$?0V?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@$$$VPAPAX@?$tuple@V?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@std@@QAE@$$QAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__This_arg$ = 8						; size = 4
??$?0V?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@$$$VPAPAX@?$tuple@V?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@std@@QAE@$$QAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@1@@Z PROC ; std::tuple<std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > >::tuple<std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > ><std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> >,void * *>, COMDAT
; _this$ = ecx

; 233  : 		{	// construct from one or more moved elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$tuple@$$$V@std@@QAE@XZ		; std::tuple<>::tuple<>
	mov	eax, DWORD PTR __This_arg$[ebp]
	push	eax
	call	??$forward@V?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@std@@YA$$QAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@0@AAV10@@Z ; std::forward<std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > >
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$?0V?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@?$_Tuple_val@V?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@std@@QAE@$$QAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@1@@Z ; std::_Tuple_val<std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > >::_Tuple_val<std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > ><std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > >

; 234  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0V?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@$$$VPAPAX@?$tuple@V?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@std@@QAE@$$QAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@1@@Z ENDP ; std::tuple<std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > >::tuple<std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > ><std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> >,void * *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\tuple
;	COMDAT ??$?4V?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@?$tuple@AAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@std@@QAEAAV01@$$QAV?$tuple@V?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??$?4V?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@?$tuple@AAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@std@@QAEAAV01@$$QAV?$tuple@V?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@1@@Z PROC ; std::tuple<std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > &>::operator=<std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > >, COMDAT
; _this$ = ecx

; 285  : 		_Myt& operator=(tuple<_Other...>&& _Right)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 286  : 		{	// assign by moving same size tuple
; 287  : 		_Myfirst._Val = _STD forward<typename tuple<_Other...>::_This_type>
; 288  : 			(_Right._Myfirst._Val);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	call	??$forward@V?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@std@@YA$$QAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@0@AAV10@@Z ; std::forward<std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > >
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	??4?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@QAEAAV01@$$QAV01@@Z ; std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> >::operator=

; 289  : 		(_Mybase&)*this = _STD forward<typename tuple<_Other...>::_Mybase>
; 290  : 			(_Right._Get_rest());

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Get_rest@?$tuple@V?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@std@@QAEAAV?$tuple@$$$V@2@XZ ; std::tuple<std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > >::_Get_rest
	push	eax
	call	??$forward@V?$tuple@$$$V@std@@@std@@YA$$QAV?$tuple@$$$V@0@AAV10@@Z ; std::forward<std::tuple<> >
	add	esp, 4

; 291  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 292  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$?4V?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@?$tuple@AAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@std@@QAEAAV01@$$QAV?$tuple@V?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@1@@Z ENDP ; std::tuple<std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > &>::operator=<std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\type_traits
;	COMDAT ??$forward@AAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@@std@@YAAAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@AAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@@std@@YAAAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@AAV1@@Z PROC ; std::forward<<lambda_582637cdd8d6a2f689bc987be9ec55df> &>, COMDAT

; 1504 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

	pop	ebp
	ret	0
??$forward@AAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@@std@@YAAAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@AAV1@@Z ENDP ; std::forward<<lambda_582637cdd8d6a2f689bc987be9ec55df> &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ??$_Reset@AAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@@?$_Func_class@X$$$V@std@@IAEXAAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
??$_Reset@AAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@@?$_Func_class@X$$$V@std@@IAEXAAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@@Z PROC ; std::_Func_class<void>::_Reset<<lambda_582637cdd8d6a2f689bc987be9ec55df> &>, COMDAT
; _this$ = ecx

; 383  : 		void _Reset(_Fty&& _Val)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 384  : 		{	// store copy of _Val
; 385  : 		_Reset_alloc(_STD forward<_Fty>(_Val), allocator<_Myt>());

	push	ecx
	mov	ecx, esp
	call	??0?$allocator@V?$_Func_class@X$$$V@std@@@std@@QAE@XZ ; std::allocator<std::_Func_class<void> >::allocator<std::_Func_class<void> >
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	??$forward@AAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@@std@@YAAAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@AAV1@@Z ; std::forward<<lambda_582637cdd8d6a2f689bc987be9ec55df> &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Reset_alloc@AAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@V?$allocator@V?$_Func_class@X$$$V@std@@@std@@@?$_Func_class@X$$$V@std@@IAEXAAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@V?$allocator@V?$_Func_class@X$$$V@std@@@1@@Z ; std::_Func_class<void>::_Reset_alloc<<lambda_582637cdd8d6a2f689bc987be9ec55df> &,std::allocator<std::_Func_class<void> > >

; 386  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$_Reset@AAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@@?$_Func_class@X$$$V@std@@IAEXAAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@@Z ENDP ; std::_Func_class<void>::_Reset<<lambda_582637cdd8d6a2f689bc987be9ec55df> &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\type_traits
;	COMDAT ??$forward@AAV<lambda_e856d28dddb7588070dd099cfda6c634>@@@std@@YAAAV<lambda_e856d28dddb7588070dd099cfda6c634>@@AAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAV<lambda_e856d28dddb7588070dd099cfda6c634>@@@std@@YAAAV<lambda_e856d28dddb7588070dd099cfda6c634>@@AAV1@@Z PROC ; std::forward<<lambda_e856d28dddb7588070dd099cfda6c634> &>, COMDAT

; 1504 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

	pop	ebp
	ret	0
??$forward@AAV<lambda_e856d28dddb7588070dd099cfda6c634>@@@std@@YAAAV<lambda_e856d28dddb7588070dd099cfda6c634>@@AAV1@@Z ENDP ; std::forward<<lambda_e856d28dddb7588070dd099cfda6c634> &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ??$_Reset@AAV<lambda_e856d28dddb7588070dd099cfda6c634>@@@?$_Func_class@X$$$V@std@@IAEXAAV<lambda_e856d28dddb7588070dd099cfda6c634>@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
??$_Reset@AAV<lambda_e856d28dddb7588070dd099cfda6c634>@@@?$_Func_class@X$$$V@std@@IAEXAAV<lambda_e856d28dddb7588070dd099cfda6c634>@@@Z PROC ; std::_Func_class<void>::_Reset<<lambda_e856d28dddb7588070dd099cfda6c634> &>, COMDAT
; _this$ = ecx

; 383  : 		void _Reset(_Fty&& _Val)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 384  : 		{	// store copy of _Val
; 385  : 		_Reset_alloc(_STD forward<_Fty>(_Val), allocator<_Myt>());

	push	ecx
	mov	ecx, esp
	call	??0?$allocator@V?$_Func_class@X$$$V@std@@@std@@QAE@XZ ; std::allocator<std::_Func_class<void> >::allocator<std::_Func_class<void> >
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	??$forward@AAV<lambda_e856d28dddb7588070dd099cfda6c634>@@@std@@YAAAV<lambda_e856d28dddb7588070dd099cfda6c634>@@AAV1@@Z ; std::forward<<lambda_e856d28dddb7588070dd099cfda6c634> &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Reset_alloc@AAV<lambda_e856d28dddb7588070dd099cfda6c634>@@V?$allocator@V?$_Func_class@X$$$V@std@@@std@@@?$_Func_class@X$$$V@std@@IAEXAAV<lambda_e856d28dddb7588070dd099cfda6c634>@@V?$allocator@V?$_Func_class@X$$$V@std@@@1@@Z ; std::_Func_class<void>::_Reset_alloc<<lambda_e856d28dddb7588070dd099cfda6c634> &,std::allocator<std::_Func_class<void> > >

; 386  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$_Reset@AAV<lambda_e856d28dddb7588070dd099cfda6c634>@@@?$_Func_class@X$$$V@std@@IAEXAAV<lambda_e856d28dddb7588070dd099cfda6c634>@@@Z ENDP ; std::_Func_class<void>::_Reset<<lambda_e856d28dddb7588070dd099cfda6c634> &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\type_traits
;	COMDAT ??$forward@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@@std@@YA$$QAV<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@AAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@@std@@YA$$QAV<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@AAV1@@Z PROC ; std::forward<<lambda_7c9af1b141e25bc2e890d47a77a39da9> >, COMDAT

; 1504 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

	pop	ebp
	ret	0
??$forward@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@@std@@YA$$QAV<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@AAV1@@Z ENDP ; std::forward<<lambda_7c9af1b141e25bc2e890d47a77a39da9> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ??$_Reset@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@@?$_Func_class@X$$$V@std@@IAEX$$QAV<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
??$_Reset@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@@?$_Func_class@X$$$V@std@@IAEX$$QAV<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@@Z PROC ; std::_Func_class<void>::_Reset<<lambda_7c9af1b141e25bc2e890d47a77a39da9> >, COMDAT
; _this$ = ecx

; 383  : 		void _Reset(_Fty&& _Val)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 384  : 		{	// store copy of _Val
; 385  : 		_Reset_alloc(_STD forward<_Fty>(_Val), allocator<_Myt>());

	push	ecx
	mov	ecx, esp
	call	??0?$allocator@V?$_Func_class@X$$$V@std@@@std@@QAE@XZ ; std::allocator<std::_Func_class<void> >::allocator<std::_Func_class<void> >
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	??$forward@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@@std@@YA$$QAV<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@AAV1@@Z ; std::forward<<lambda_7c9af1b141e25bc2e890d47a77a39da9> >
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Reset_alloc@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@V?$allocator@V?$_Func_class@X$$$V@std@@@std@@@?$_Func_class@X$$$V@std@@IAEX$$QAV<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@V?$allocator@V?$_Func_class@X$$$V@std@@@1@@Z ; std::_Func_class<void>::_Reset_alloc<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,std::allocator<std::_Func_class<void> > >

; 386  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$_Reset@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@@?$_Func_class@X$$$V@std@@IAEX$$QAV<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@@Z ENDP ; std::_Func_class<void>::_Reset<<lambda_7c9af1b141e25bc2e890d47a77a39da9> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\type_traits
;	COMDAT ??$forward@V<lambda_3b020cec0f1508adac4c896f138918cf>@@@std@@YA$$QAV<lambda_3b020cec0f1508adac4c896f138918cf>@@AAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V<lambda_3b020cec0f1508adac4c896f138918cf>@@@std@@YA$$QAV<lambda_3b020cec0f1508adac4c896f138918cf>@@AAV1@@Z PROC ; std::forward<<lambda_3b020cec0f1508adac4c896f138918cf> >, COMDAT

; 1504 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

	pop	ebp
	ret	0
??$forward@V<lambda_3b020cec0f1508adac4c896f138918cf>@@@std@@YA$$QAV<lambda_3b020cec0f1508adac4c896f138918cf>@@AAV1@@Z ENDP ; std::forward<<lambda_3b020cec0f1508adac4c896f138918cf> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ??$_Reset@V<lambda_3b020cec0f1508adac4c896f138918cf>@@@?$_Func_class@X$$$V@std@@IAEX$$QAV<lambda_3b020cec0f1508adac4c896f138918cf>@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
??$_Reset@V<lambda_3b020cec0f1508adac4c896f138918cf>@@@?$_Func_class@X$$$V@std@@IAEX$$QAV<lambda_3b020cec0f1508adac4c896f138918cf>@@@Z PROC ; std::_Func_class<void>::_Reset<<lambda_3b020cec0f1508adac4c896f138918cf> >, COMDAT
; _this$ = ecx

; 383  : 		void _Reset(_Fty&& _Val)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 384  : 		{	// store copy of _Val
; 385  : 		_Reset_alloc(_STD forward<_Fty>(_Val), allocator<_Myt>());

	push	ecx
	mov	ecx, esp
	call	??0?$allocator@V?$_Func_class@X$$$V@std@@@std@@QAE@XZ ; std::allocator<std::_Func_class<void> >::allocator<std::_Func_class<void> >
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	??$forward@V<lambda_3b020cec0f1508adac4c896f138918cf>@@@std@@YA$$QAV<lambda_3b020cec0f1508adac4c896f138918cf>@@AAV1@@Z ; std::forward<<lambda_3b020cec0f1508adac4c896f138918cf> >
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Reset_alloc@V<lambda_3b020cec0f1508adac4c896f138918cf>@@V?$allocator@V?$_Func_class@X$$$V@std@@@std@@@?$_Func_class@X$$$V@std@@IAEX$$QAV<lambda_3b020cec0f1508adac4c896f138918cf>@@V?$allocator@V?$_Func_class@X$$$V@std@@@1@@Z ; std::_Func_class<void>::_Reset_alloc<<lambda_3b020cec0f1508adac4c896f138918cf>,std::allocator<std::_Func_class<void> > >

; 386  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$_Reset@V<lambda_3b020cec0f1508adac4c896f138918cf>@@@?$_Func_class@X$$$V@std@@IAEX$$QAV<lambda_3b020cec0f1508adac4c896f138918cf>@@@Z ENDP ; std::_Func_class<void>::_Reset<<lambda_3b020cec0f1508adac4c896f138918cf> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\type_traits
;	COMDAT ??$forward@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@@std@@YA$$QAV<lambda_3648d362fc95221bbf9c4c4a922d1611>@@AAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@@std@@YA$$QAV<lambda_3648d362fc95221bbf9c4c4a922d1611>@@AAV1@@Z PROC ; std::forward<<lambda_3648d362fc95221bbf9c4c4a922d1611> >, COMDAT

; 1504 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

	pop	ebp
	ret	0
??$forward@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@@std@@YA$$QAV<lambda_3648d362fc95221bbf9c4c4a922d1611>@@AAV1@@Z ENDP ; std::forward<<lambda_3648d362fc95221bbf9c4c4a922d1611> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ??$_Reset@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@@?$_Func_class@X$$$V@std@@IAEX$$QAV<lambda_3648d362fc95221bbf9c4c4a922d1611>@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
??$_Reset@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@@?$_Func_class@X$$$V@std@@IAEX$$QAV<lambda_3648d362fc95221bbf9c4c4a922d1611>@@@Z PROC ; std::_Func_class<void>::_Reset<<lambda_3648d362fc95221bbf9c4c4a922d1611> >, COMDAT
; _this$ = ecx

; 383  : 		void _Reset(_Fty&& _Val)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 384  : 		{	// store copy of _Val
; 385  : 		_Reset_alloc(_STD forward<_Fty>(_Val), allocator<_Myt>());

	push	ecx
	mov	ecx, esp
	call	??0?$allocator@V?$_Func_class@X$$$V@std@@@std@@QAE@XZ ; std::allocator<std::_Func_class<void> >::allocator<std::_Func_class<void> >
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	??$forward@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@@std@@YA$$QAV<lambda_3648d362fc95221bbf9c4c4a922d1611>@@AAV1@@Z ; std::forward<<lambda_3648d362fc95221bbf9c4c4a922d1611> >
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Reset_alloc@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@V?$allocator@V?$_Func_class@X$$$V@std@@@std@@@?$_Func_class@X$$$V@std@@IAEX$$QAV<lambda_3648d362fc95221bbf9c4c4a922d1611>@@V?$allocator@V?$_Func_class@X$$$V@std@@@1@@Z ; std::_Func_class<void>::_Reset_alloc<<lambda_3648d362fc95221bbf9c4c4a922d1611>,std::allocator<std::_Func_class<void> > >

; 386  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$_Reset@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@@?$_Func_class@X$$$V@std@@IAEX$$QAV<lambda_3648d362fc95221bbf9c4c4a922d1611>@@@Z ENDP ; std::_Func_class<void>::_Reset<<lambda_3648d362fc95221bbf9c4c4a922d1611> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\type_traits
;	COMDAT ??$forward@AAPAUClosableStream@@@std@@YAAAPAUClosableStream@@AAPAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAUClosableStream@@@std@@YAAAPAUClosableStream@@AAPAU1@@Z PROC ; std::forward<ClosableStream * &>, COMDAT

; 1504 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

	pop	ebp
	ret	0
??$forward@AAPAUClosableStream@@@std@@YAAAPAUClosableStream@@AAPAU1@@Z ENDP ; std::forward<ClosableStream * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\list
;	COMDAT ??$_Insert@PAX@?$list@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@U_Iterator_base0@2@@1@$$QAPAX@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Newnode$ = -8						; size = 4
__Pnode$ = -4						; size = 4
__Where$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Insert@PAX@?$list@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@U_Iterator_base0@2@@1@$$QAPAX@Z PROC ; std::list<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >::_Insert<void *>, COMDAT
; _this$ = ecx

; 1056 : 		void _Insert(_Unchecked_const_iterator _Where,

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1057 : 		_Valty&&... _Val)
; 1058 : 		{	// insert element at _Where
; 1059 : 		_Nodeptr _Pnode = _Where._Mynode();

	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > >,std::_Iterator_base0>::_Mynode
	mov	DWORD PTR __Pnode$[ebp], eax

; 1060 : 		_Nodeptr _Newnode =
; 1061 : 			this->_Buynode(_Pnode, this->_Prevnode(_Pnode),
; 1062 : 				_STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR _<_Val_0>$[ebp]
	push	eax
	call	??$forward@PAX@std@@YA$$QAPAXAAPAX@Z	; std::forward<void *>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Prevnode@?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@SAAAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@PAU32@@Z ; std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > >::_Prevnode
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Buynode@PAX@?$_List_buy@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAEPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@PAU21@0$$QAPAX@Z ; std::_List_buy<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >::_Buynode<void *>
	mov	DWORD PTR __Newnode$[ebp], eax

; 1063 : 		_Incsize(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Incsize@?$list@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAEXI@Z ; std::list<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >::_Incsize

; 1064 : 		this->_Prevnode(_Pnode) = _Newnode;

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Prevnode@?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@SAAAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@PAU32@@Z ; std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > >::_Prevnode
	add	esp, 4
	mov	edx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], edx

; 1065 : 		this->_Nextnode(this->_Prevnode(_Newnode)) = _Newnode;

	mov	eax, DWORD PTR __Newnode$[ebp]
	push	eax
	call	?_Prevnode@?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@SAAAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@PAU32@@Z ; std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > >::_Prevnode
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Nextnode@?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@SAAAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@PAU32@@Z ; std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > >::_Nextnode
	add	esp, 4
	mov	edx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], edx

; 1066 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??$_Insert@PAX@?$list@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@U_Iterator_base0@2@@1@$$QAPAX@Z ENDP ; std::list<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >::_Insert<void *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\list
;	COMDAT ??$_Insert@AAPAX@?$list@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@U_Iterator_base0@2@@1@AAPAX@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Newnode$ = -8						; size = 4
__Pnode$ = -4						; size = 4
__Where$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Insert@AAPAX@?$list@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@U_Iterator_base0@2@@1@AAPAX@Z PROC ; std::list<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >::_Insert<void * &>, COMDAT
; _this$ = ecx

; 1056 : 		void _Insert(_Unchecked_const_iterator _Where,

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1057 : 		_Valty&&... _Val)
; 1058 : 		{	// insert element at _Where
; 1059 : 		_Nodeptr _Pnode = _Where._Mynode();

	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > >,std::_Iterator_base0>::_Mynode
	mov	DWORD PTR __Pnode$[ebp], eax

; 1060 : 		_Nodeptr _Newnode =
; 1061 : 			this->_Buynode(_Pnode, this->_Prevnode(_Pnode),
; 1062 : 				_STD forward<_Valty>(_Val)...);

	mov	eax, DWORD PTR _<_Val_0>$[ebp]
	push	eax
	call	??$forward@AAPAX@std@@YAAAPAXAAPAX@Z	; std::forward<void * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Prevnode@?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@SAAAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@PAU32@@Z ; std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > >::_Prevnode
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Buynode@AAPAX@?$_List_buy@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAEPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@PAU21@0AAPAX@Z ; std::_List_buy<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >::_Buynode<void * &>
	mov	DWORD PTR __Newnode$[ebp], eax

; 1063 : 		_Incsize(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Incsize@?$list@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAEXI@Z ; std::list<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >::_Incsize

; 1064 : 		this->_Prevnode(_Pnode) = _Newnode;

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Prevnode@?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@SAAAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@PAU32@@Z ; std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > >::_Prevnode
	add	esp, 4
	mov	edx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], edx

; 1065 : 		this->_Nextnode(this->_Prevnode(_Newnode)) = _Newnode;

	mov	eax, DWORD PTR __Newnode$[ebp]
	push	eax
	call	?_Prevnode@?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@SAAAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@PAU32@@Z ; std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > >::_Prevnode
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Nextnode@?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@SAAAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@PAU32@@Z ; std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > >::_Nextnode
	add	esp, 4
	mov	edx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], edx

; 1066 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??$_Insert@AAPAX@?$list@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@U_Iterator_base0@2@@1@AAPAX@Z ENDP ; std::list<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >::_Insert<void * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$construct@PAXPAX@?$allocator_traits@V?$allocator@PAX@std@@@std@@SAXAAV?$allocator@PAX@1@PAPAX$$QAPAX@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PAXPAX@?$allocator_traits@V?$allocator@PAX@std@@@std@@SAXAAV?$allocator@PAX@1@PAPAX$$QAPAX@Z PROC ; std::allocator_traits<std::allocator<void *> >::construct<void *,void *>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

	push	ebp
	mov	ebp, esp

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	eax
	call	??$forward@PAX@std@@YA$$QAPAXAAPAX@Z	; std::forward<void *>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@PAXPAX@?$allocator@PAX@std@@QAEXPAPAX$$QAPAX@Z ; std::allocator<void *>::construct<void *,void *>

; 724  : 		}

	pop	ebp
	ret	0
??$construct@PAXPAX@?$allocator_traits@V?$allocator@PAX@std@@@std@@SAXAAV?$allocator@PAX@1@PAPAX$$QAPAX@Z ENDP ; std::allocator_traits<std::allocator<void *> >::construct<void *,void *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\tuple
;	COMDAT ??$?0AAPAUReplayBuffer@@@?$_Tuple_val@AAPAUReplayBuffer@@@std@@QAE@AAPAUReplayBuffer@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Arg$ = 8						; size = 4
??$?0AAPAUReplayBuffer@@@?$_Tuple_val@AAPAUReplayBuffer@@@std@@QAE@AAPAUReplayBuffer@@@Z PROC ; std::_Tuple_val<ReplayBuffer * &>::_Tuple_val<ReplayBuffer * &><ReplayBuffer * &>, COMDAT
; _this$ = ecx

; 80   : 		{	// construct with argument

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Arg$[ebp]
	push	eax
	call	??$forward@AAPAUReplayBuffer@@@std@@YAAAPAUReplayBuffer@@AAPAU1@@Z ; std::forward<ReplayBuffer * &>
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 81   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0AAPAUReplayBuffer@@@?$_Tuple_val@AAPAUReplayBuffer@@@std@@QAE@AAPAUReplayBuffer@@@Z ENDP ; std::_Tuple_val<ReplayBuffer * &>::_Tuple_val<ReplayBuffer * &><ReplayBuffer * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\tuple
;	COMDAT ??$?0AAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@?$_Tuple_val@AAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@std@@QAE@AAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Arg$ = 8						; size = 4
??$?0AAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@?$_Tuple_val@AAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@std@@QAE@AAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@1@@Z PROC ; std::_Tuple_val<std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > &>::_Tuple_val<std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > &><std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > &>, COMDAT
; _this$ = ecx

; 80   : 		{	// construct with argument

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Arg$[ebp]
	push	eax
	call	??$forward@AAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@std@@YAAAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@0@AAV10@@Z ; std::forward<std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > &>
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 81   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0AAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@?$_Tuple_val@AAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@std@@QAE@AAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@1@@Z ENDP ; std::_Tuple_val<std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > &>::_Tuple_val<std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > &><std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\memory
;	COMDAT ??4?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@QAEAAV01@$$QAV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??4?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@QAEAAV01@$$QAV01@@Z PROC ; std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> >::operator=, COMDAT
; _this$ = ecx

; 1429 : 		{	// assign by moving _Right

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1430 : 		if (this != &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	SHORT $LN1@operator

; 1431 : 			{	// different, do the move
; 1432 : 			reset(_Right.release());

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?release@?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@QAEPAVVideoFileStream@@XZ ; std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> >::release
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?reset@?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@QAEXPAVVideoFileStream@@@Z ; std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> >::reset

; 1433 : 			this->get_deleter() = _STD forward<_Dx>(_Right.get_deleter());

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?get_deleter@?$_Unique_ptr_base@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@$00@std@@QAEAAU?$default_delete@VVideoFileStream@@@2@XZ ; std::_Unique_ptr_base<VideoFileStream,std::default_delete<VideoFileStream>,1>::get_deleter
	push	eax
	call	??$forward@U?$default_delete@VVideoFileStream@@@std@@@std@@YA$$QAU?$default_delete@VVideoFileStream@@@0@AAU10@@Z ; std::forward<std::default_delete<VideoFileStream> >
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?get_deleter@?$_Unique_ptr_base@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@$00@std@@QAEAAU?$default_delete@VVideoFileStream@@@2@XZ ; std::_Unique_ptr_base<VideoFileStream,std::default_delete<VideoFileStream>,1>::get_deleter
$LN1@operator:

; 1434 : 			}
; 1435 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 1436 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??4?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@QAEAAV01@$$QAV01@@Z ENDP ; std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> >::operator=
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\list
;	COMDAT ?_Incsize@?$list@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Incsize@?$list@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAEXI@Z PROC ; std::list<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >::_Incsize, COMDAT
; _this$ = ecx

; 1905 : 		{	// alter element count, with checking

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1906 : 		if (max_size() - this->_Mysize - 1 < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$list@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QBEIXZ ; std::list<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >::max_size
	mov	ecx, DWORD PTR _this$[ebp]
	sub	eax, DWORD PTR [ecx+4]
	sub	eax, 1
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $LN1@Incsize

; 1907 : 			_Xlength_error("list<T> too long");

	push	OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN1@Incsize:

; 1908 : 		this->_Mysize += _Count;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax
$LN3@Incsize:

; 1909 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Incsize@?$list@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAEXI@Z ENDP ; std::list<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >::_Incsize
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\list
;	COMDAT ?_Mynode@?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Mynode@?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > >,std::_Iterator_base0>::_Mynode, COMDAT
; _this$ = ecx

; 95   : 		{	// return node pointer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 96   : 		return (_Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 97   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Mynode@?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > >,std::_Iterator_base0>::_Mynode
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\tuple
;	COMDAT ?_Get_rest@?$tuple@V?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@std@@QAEAAV?$tuple@$$$V@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_rest@?$tuple@V?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@std@@QAEAAV?$tuple@$$$V@2@XZ PROC ; std::tuple<std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > >::_Get_rest, COMDAT
; _this$ = ecx

; 438  : 		{	// get reference to rest of elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 439  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 440  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Get_rest@?$tuple@V?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@std@@QAEAAV?$tuple@$$$V@2@XZ ENDP ; std::tuple<std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > >::_Get_rest
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??0?$allocator@V?$_Func_class@X$$$V@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@V?$_Func_class@X$$$V@std@@@std@@QAE@XZ PROC ; std::allocator<std::_Func_class<void> >::allocator<std::_Func_class<void> >, COMDAT
; _this$ = ecx

; 552  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@V?$_Func_class@X$$$V@std@@@std@@QAE@XZ ENDP ; std::allocator<std::_Func_class<void> >::allocator<std::_Func_class<void> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\list
;	COMDAT ?max_size@?$list@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
?max_size@?$list@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QBEIXZ PROC ; std::list<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >::max_size, COMDAT
; _this$ = ecx

; 1240 : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1241 : 		return (this->_Getal().max_size());

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_List_alloc@$0A@U?$_List_base_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@2@XZ ; std::_List_alloc<0,std::_List_base_types<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > > >::_Getal
	mov	ecx, eax
	call	?max_size@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> > >::max_size

; 1242 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$list@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QBEIXZ ENDP ; std::list<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> > >::max_size, COMDAT
; _this$ = ecx

; 883  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 884  : 		return (_Mytraits::max_size(*this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?max_size@?$allocator_traits@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@2@@Z ; std::allocator_traits<std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> > >::max_size
	add	esp, 4

; 885  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@2@@Z PROC ; std::allocator_traits<std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> > >::max_size, COMDAT

; 734  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp

; 735  : 		return (_Al.max_size());

	mov	ecx, DWORD PTR __Al$[ebp]
	call	?max_size@?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@QBEIXZ ; std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> >::max_size

; 736  : 		}

	pop	ebp
	ret	0
?max_size@?$allocator_traits@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@2@@Z ENDP ; std::allocator_traits<std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@QBEIXZ PROC ; std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> >::max_size, COMDAT
; _this$ = ecx

; 611  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 612  : 		return ((size_t)(-1) / sizeof (_Ty));

	mov	eax, 357913941				; 15555555H

; 613  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@QBEIXZ ENDP ; std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\tuple
;	COMDAT ??$?0V?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@?$_Tuple_val@V?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@std@@QAE@$$QAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Arg$ = 8						; size = 4
??$?0V?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@?$_Tuple_val@V?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@std@@QAE@$$QAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@1@@Z PROC ; std::_Tuple_val<std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > >::_Tuple_val<std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > ><std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > >, COMDAT
; _this$ = ecx

; 80   : 		{	// construct with argument

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Arg$[ebp]
	push	eax
	call	??$forward@V?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@std@@YA$$QAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@0@AAV10@@Z ; std::forward<std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > >
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@QAE@$$QAV01@@Z ; std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> >::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> >

; 81   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0V?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@?$_Tuple_val@V?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@std@@QAE@$$QAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@1@@Z ENDP ; std::_Tuple_val<std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > >::_Tuple_val<std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > ><std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\type_traits
;	COMDAT ??$forward@V?$tuple@$$$V@std@@@std@@YA$$QAV?$tuple@$$$V@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$tuple@$$$V@std@@@std@@YA$$QAV?$tuple@$$$V@0@AAV10@@Z PROC ; std::forward<std::tuple<> >, COMDAT

; 1504 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

	pop	ebp
	ret	0
??$forward@V?$tuple@$$$V@std@@@std@@YA$$QAV?$tuple@$$$V@0@AAV10@@Z ENDP ; std::forward<std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ??$_Reset_alloc@AAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@V?$allocator@V?$_Func_class@X$$$V@std@@@std@@@?$_Func_class@X$$$V@std@@IAEXAAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@V?$allocator@V?$_Func_class@X$$$V@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
__Ax$ = 12						; size = 1
??$_Reset_alloc@AAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@V?$allocator@V?$_Func_class@X$$$V@std@@@std@@@?$_Func_class@X$$$V@std@@IAEXAAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@V?$allocator@V?$_Func_class@X$$$V@std@@@1@@Z PROC ; std::_Func_class<void>::_Reset_alloc<<lambda_582637cdd8d6a2f689bc987be9ec55df> &,std::allocator<std::_Func_class<void> > >, COMDAT
; _this$ = ecx

; 390  : 		void _Reset_alloc(_Fty&& _Val, _Alloc _Ax)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 391  : 		{	// store copy of _Val with allocator
; 392  : 		typedef _Callable_obj<typename decay<_Fty>::type>
; 393  : 			_MyWrapper;
; 394  : 		typedef _Func_impl<_MyWrapper, _Alloc, _Ret, _Types...> _Myimpl;
; 395  : 
; 396  : 		_Do_alloc<_Myimpl>(_STD forward<_Fty>(_Val), _Ax);

	push	ecx
	mov	ecx, esp
	lea	eax, DWORD PTR __Ax$[ebp]
	push	eax
	call	??0?$allocator@V?$_Func_class@X$$$V@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::_Func_class<void> >::allocator<std::_Func_class<void> >
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	call	??$forward@AAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@@std@@YAAAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@AAV1@@Z ; std::forward<<lambda_582637cdd8d6a2f689bc987be9ec55df> &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Do_alloc@V?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@AAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@@?$_Func_class@X$$$V@std@@AAEXAAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@V?$allocator@V?$_Func_class@X$$$V@std@@@1@@Z ; std::_Func_class<void>::_Do_alloc<std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void>,<lambda_582637cdd8d6a2f689bc987be9ec55df> &,std::allocator<std::_Func_class<void> > >

; 397  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??$_Reset_alloc@AAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@V?$allocator@V?$_Func_class@X$$$V@std@@@std@@@?$_Func_class@X$$$V@std@@IAEXAAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@V?$allocator@V?$_Func_class@X$$$V@std@@@1@@Z ENDP ; std::_Func_class<void>::_Reset_alloc<<lambda_582637cdd8d6a2f689bc987be9ec55df> &,std::allocator<std::_Func_class<void> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ??$_Reset_alloc@AAV<lambda_e856d28dddb7588070dd099cfda6c634>@@V?$allocator@V?$_Func_class@X$$$V@std@@@std@@@?$_Func_class@X$$$V@std@@IAEXAAV<lambda_e856d28dddb7588070dd099cfda6c634>@@V?$allocator@V?$_Func_class@X$$$V@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
__Ax$ = 12						; size = 1
??$_Reset_alloc@AAV<lambda_e856d28dddb7588070dd099cfda6c634>@@V?$allocator@V?$_Func_class@X$$$V@std@@@std@@@?$_Func_class@X$$$V@std@@IAEXAAV<lambda_e856d28dddb7588070dd099cfda6c634>@@V?$allocator@V?$_Func_class@X$$$V@std@@@1@@Z PROC ; std::_Func_class<void>::_Reset_alloc<<lambda_e856d28dddb7588070dd099cfda6c634> &,std::allocator<std::_Func_class<void> > >, COMDAT
; _this$ = ecx

; 390  : 		void _Reset_alloc(_Fty&& _Val, _Alloc _Ax)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 391  : 		{	// store copy of _Val with allocator
; 392  : 		typedef _Callable_obj<typename decay<_Fty>::type>
; 393  : 			_MyWrapper;
; 394  : 		typedef _Func_impl<_MyWrapper, _Alloc, _Ret, _Types...> _Myimpl;
; 395  : 
; 396  : 		_Do_alloc<_Myimpl>(_STD forward<_Fty>(_Val), _Ax);

	push	ecx
	mov	ecx, esp
	lea	eax, DWORD PTR __Ax$[ebp]
	push	eax
	call	??0?$allocator@V?$_Func_class@X$$$V@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::_Func_class<void> >::allocator<std::_Func_class<void> >
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	call	??$forward@AAV<lambda_e856d28dddb7588070dd099cfda6c634>@@@std@@YAAAV<lambda_e856d28dddb7588070dd099cfda6c634>@@AAV1@@Z ; std::forward<<lambda_e856d28dddb7588070dd099cfda6c634> &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Do_alloc@V?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@AAV<lambda_e856d28dddb7588070dd099cfda6c634>@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@@?$_Func_class@X$$$V@std@@AAEXAAV<lambda_e856d28dddb7588070dd099cfda6c634>@@V?$allocator@V?$_Func_class@X$$$V@std@@@1@@Z ; std::_Func_class<void>::_Do_alloc<std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void>,<lambda_e856d28dddb7588070dd099cfda6c634> &,std::allocator<std::_Func_class<void> > >

; 397  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??$_Reset_alloc@AAV<lambda_e856d28dddb7588070dd099cfda6c634>@@V?$allocator@V?$_Func_class@X$$$V@std@@@std@@@?$_Func_class@X$$$V@std@@IAEXAAV<lambda_e856d28dddb7588070dd099cfda6c634>@@V?$allocator@V?$_Func_class@X$$$V@std@@@1@@Z ENDP ; std::_Func_class<void>::_Reset_alloc<<lambda_e856d28dddb7588070dd099cfda6c634> &,std::allocator<std::_Func_class<void> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ??$_Reset_alloc@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@V?$allocator@V?$_Func_class@X$$$V@std@@@std@@@?$_Func_class@X$$$V@std@@IAEX$$QAV<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@V?$allocator@V?$_Func_class@X$$$V@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
__Ax$ = 12						; size = 1
??$_Reset_alloc@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@V?$allocator@V?$_Func_class@X$$$V@std@@@std@@@?$_Func_class@X$$$V@std@@IAEX$$QAV<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@V?$allocator@V?$_Func_class@X$$$V@std@@@1@@Z PROC ; std::_Func_class<void>::_Reset_alloc<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,std::allocator<std::_Func_class<void> > >, COMDAT
; _this$ = ecx

; 390  : 		void _Reset_alloc(_Fty&& _Val, _Alloc _Ax)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 391  : 		{	// store copy of _Val with allocator
; 392  : 		typedef _Callable_obj<typename decay<_Fty>::type>
; 393  : 			_MyWrapper;
; 394  : 		typedef _Func_impl<_MyWrapper, _Alloc, _Ret, _Types...> _Myimpl;
; 395  : 
; 396  : 		_Do_alloc<_Myimpl>(_STD forward<_Fty>(_Val), _Ax);

	push	ecx
	mov	ecx, esp
	lea	eax, DWORD PTR __Ax$[ebp]
	push	eax
	call	??0?$allocator@V?$_Func_class@X$$$V@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::_Func_class<void> >::allocator<std::_Func_class<void> >
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	call	??$forward@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@@std@@YA$$QAV<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@AAV1@@Z ; std::forward<<lambda_7c9af1b141e25bc2e890d47a77a39da9> >
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Do_alloc@V?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@@?$_Func_class@X$$$V@std@@AAEX$$QAV<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@V?$allocator@V?$_Func_class@X$$$V@std@@@1@@Z ; std::_Func_class<void>::_Do_alloc<std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void>,<lambda_7c9af1b141e25bc2e890d47a77a39da9>,std::allocator<std::_Func_class<void> > >

; 397  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??$_Reset_alloc@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@V?$allocator@V?$_Func_class@X$$$V@std@@@std@@@?$_Func_class@X$$$V@std@@IAEX$$QAV<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@V?$allocator@V?$_Func_class@X$$$V@std@@@1@@Z ENDP ; std::_Func_class<void>::_Reset_alloc<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,std::allocator<std::_Func_class<void> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ??$_Reset_alloc@V<lambda_3b020cec0f1508adac4c896f138918cf>@@V?$allocator@V?$_Func_class@X$$$V@std@@@std@@@?$_Func_class@X$$$V@std@@IAEX$$QAV<lambda_3b020cec0f1508adac4c896f138918cf>@@V?$allocator@V?$_Func_class@X$$$V@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
__Ax$ = 12						; size = 1
??$_Reset_alloc@V<lambda_3b020cec0f1508adac4c896f138918cf>@@V?$allocator@V?$_Func_class@X$$$V@std@@@std@@@?$_Func_class@X$$$V@std@@IAEX$$QAV<lambda_3b020cec0f1508adac4c896f138918cf>@@V?$allocator@V?$_Func_class@X$$$V@std@@@1@@Z PROC ; std::_Func_class<void>::_Reset_alloc<<lambda_3b020cec0f1508adac4c896f138918cf>,std::allocator<std::_Func_class<void> > >, COMDAT
; _this$ = ecx

; 390  : 		void _Reset_alloc(_Fty&& _Val, _Alloc _Ax)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 391  : 		{	// store copy of _Val with allocator
; 392  : 		typedef _Callable_obj<typename decay<_Fty>::type>
; 393  : 			_MyWrapper;
; 394  : 		typedef _Func_impl<_MyWrapper, _Alloc, _Ret, _Types...> _Myimpl;
; 395  : 
; 396  : 		_Do_alloc<_Myimpl>(_STD forward<_Fty>(_Val), _Ax);

	push	ecx
	mov	ecx, esp
	lea	eax, DWORD PTR __Ax$[ebp]
	push	eax
	call	??0?$allocator@V?$_Func_class@X$$$V@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::_Func_class<void> >::allocator<std::_Func_class<void> >
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	call	??$forward@V<lambda_3b020cec0f1508adac4c896f138918cf>@@@std@@YA$$QAV<lambda_3b020cec0f1508adac4c896f138918cf>@@AAV1@@Z ; std::forward<<lambda_3b020cec0f1508adac4c896f138918cf> >
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Do_alloc@V?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@V<lambda_3b020cec0f1508adac4c896f138918cf>@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@@?$_Func_class@X$$$V@std@@AAEX$$QAV<lambda_3b020cec0f1508adac4c896f138918cf>@@V?$allocator@V?$_Func_class@X$$$V@std@@@1@@Z ; std::_Func_class<void>::_Do_alloc<std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void>,<lambda_3b020cec0f1508adac4c896f138918cf>,std::allocator<std::_Func_class<void> > >

; 397  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??$_Reset_alloc@V<lambda_3b020cec0f1508adac4c896f138918cf>@@V?$allocator@V?$_Func_class@X$$$V@std@@@std@@@?$_Func_class@X$$$V@std@@IAEX$$QAV<lambda_3b020cec0f1508adac4c896f138918cf>@@V?$allocator@V?$_Func_class@X$$$V@std@@@1@@Z ENDP ; std::_Func_class<void>::_Reset_alloc<<lambda_3b020cec0f1508adac4c896f138918cf>,std::allocator<std::_Func_class<void> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ??$_Reset_alloc@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@V?$allocator@V?$_Func_class@X$$$V@std@@@std@@@?$_Func_class@X$$$V@std@@IAEX$$QAV<lambda_3648d362fc95221bbf9c4c4a922d1611>@@V?$allocator@V?$_Func_class@X$$$V@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
__Ax$ = 12						; size = 1
??$_Reset_alloc@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@V?$allocator@V?$_Func_class@X$$$V@std@@@std@@@?$_Func_class@X$$$V@std@@IAEX$$QAV<lambda_3648d362fc95221bbf9c4c4a922d1611>@@V?$allocator@V?$_Func_class@X$$$V@std@@@1@@Z PROC ; std::_Func_class<void>::_Reset_alloc<<lambda_3648d362fc95221bbf9c4c4a922d1611>,std::allocator<std::_Func_class<void> > >, COMDAT
; _this$ = ecx

; 390  : 		void _Reset_alloc(_Fty&& _Val, _Alloc _Ax)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 391  : 		{	// store copy of _Val with allocator
; 392  : 		typedef _Callable_obj<typename decay<_Fty>::type>
; 393  : 			_MyWrapper;
; 394  : 		typedef _Func_impl<_MyWrapper, _Alloc, _Ret, _Types...> _Myimpl;
; 395  : 
; 396  : 		_Do_alloc<_Myimpl>(_STD forward<_Fty>(_Val), _Ax);

	push	ecx
	mov	ecx, esp
	lea	eax, DWORD PTR __Ax$[ebp]
	push	eax
	call	??0?$allocator@V?$_Func_class@X$$$V@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::_Func_class<void> >::allocator<std::_Func_class<void> >
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	call	??$forward@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@@std@@YA$$QAV<lambda_3648d362fc95221bbf9c4c4a922d1611>@@AAV1@@Z ; std::forward<<lambda_3648d362fc95221bbf9c4c4a922d1611> >
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Do_alloc@V?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@@?$_Func_class@X$$$V@std@@AAEX$$QAV<lambda_3648d362fc95221bbf9c4c4a922d1611>@@V?$allocator@V?$_Func_class@X$$$V@std@@@1@@Z ; std::_Func_class<void>::_Do_alloc<std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void>,<lambda_3648d362fc95221bbf9c4c4a922d1611>,std::allocator<std::_Func_class<void> > >

; 397  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??$_Reset_alloc@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@V?$allocator@V?$_Func_class@X$$$V@std@@@std@@@?$_Func_class@X$$$V@std@@IAEX$$QAV<lambda_3648d362fc95221bbf9c4c4a922d1611>@@V?$allocator@V?$_Func_class@X$$$V@std@@@1@@Z ENDP ; std::_Func_class<void>::_Reset_alloc<<lambda_3648d362fc95221bbf9c4c4a922d1611>,std::allocator<std::_Func_class<void> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\list
;	COMDAT ??$_Buynode@PAX@?$_List_buy@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAEPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@PAU21@0$$QAPAX@Z
_TEXT	SEGMENT
__Pnode$ = -28						; size = 4
_this$ = -24						; size = 4
$T2 = -18						; size = 1
$T3 = -17						; size = 1
__$EHRec$ = -16						; size = 16
__Next$ = 8						; size = 4
__Prev$ = 12						; size = 4
_<_Val_0>$ = 16						; size = 4
??$_Buynode@PAX@?$_List_buy@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAEPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@PAU21@0$$QAPAX@Z PROC ; std::_List_buy<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >::_Buynode<void *>, COMDAT
; _this$ = ecx

; 827  : 		_Nodeptr _Buynode(_Nodeptr _Next, _Nodeptr _Prev,

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Buynode@PAX@?$_List_buy@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAEPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@PAU21@0$$QAPAX@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 828  : 			_Valty&&... _Val)
; 829  : 		{	// allocate a node and set links and value
; 830  : 		_Nodeptr _Pnode = this->_Buynode0(_Next, _Prev);

	mov	eax, DWORD PTR __Prev$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Next$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@@std@@QAEPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@PAU32@0@Z ; std::_List_alloc<0,std::_List_base_types<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > > >::_Buynode0
	mov	DWORD PTR __Pnode$[ebp], eax

; 831  : 
; 832  : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 833  : 		this->_Getal().construct(
; 834  : 			_STD addressof(this->_Myval(_Pnode)),
; 835  : 				_STD forward<_Valty>(_Val)...);

	mov	edx, DWORD PTR _<_Val_0>$[ebp]
	push	edx
	call	??$forward@PAX@std@@YA$$QAPAXAAPAX@Z	; std::forward<void *>
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Myval@?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@SAAAV?$unique_ptr@XU?$ThreadTerminator@$0A@@@@2@PAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@@Z ; std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > >::_Myval
	add	esp, 4
	push	eax
	call	??$addressof@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@YAPAV?$unique_ptr@XU?$ThreadTerminator@$0A@@@@0@AAV10@@Z ; std::addressof<std::unique_ptr<void,ThreadTerminator<0> > >
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_List_alloc@$0A@U?$_List_base_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@2@XZ ; std::_List_alloc<0,std::_List_base_types<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > > >::_Getal
	mov	ecx, eax
	call	??$construct@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@QAEXPAV?$unique_ptr@XU?$ThreadTerminator@$0A@@@@1@$$QAPAX@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> > >::construct<std::unique_ptr<void,ThreadTerminator<0> >,void *>
	jmp	SHORT $LN4@Buynode
__catch$??$_Buynode@PAX@?$_List_buy@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAEPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@PAU21@0$$QAPAX@Z$0:

; 836  : 		_CATCH_ALL
; 837  : 		this->_Getal().deallocate(_Pnode, 1);

	push	1
	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_List_alloc@$0A@U?$_List_base_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@2@XZ ; std::_List_alloc<0,std::_List_base_types<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> > >::deallocate

; 838  : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 839  : 		_CATCH_END

	mov	eax, $LN7@Buynode
	ret	0
$LN4@Buynode:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT __tryend$??$_Buynode@PAX@?$_List_buy@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAEPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@PAU21@0$$QAPAX@Z$1
$LN7@Buynode:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Buynode@PAX@?$_List_buy@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAEPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@PAU21@0$$QAPAX@Z$1:

; 840  : 
; 841  : 		return (_Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]
$LN3@Buynode:

; 842  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Buynode@PAX@?$_List_buy@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAEPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@PAU21@0$$QAPAX@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-32]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Buynode@PAX@?$_List_buy@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAEPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@PAU21@0$$QAPAX@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Buynode@PAX@?$_List_buy@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAEPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@PAU21@0$$QAPAX@Z ENDP ; std::_List_buy<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >::_Buynode<void *>
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\list
;	COMDAT ??$_Buynode@AAPAX@?$_List_buy@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAEPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@PAU21@0AAPAX@Z
_TEXT	SEGMENT
__Pnode$ = -28						; size = 4
_this$ = -24						; size = 4
$T2 = -18						; size = 1
$T3 = -17						; size = 1
__$EHRec$ = -16						; size = 16
__Next$ = 8						; size = 4
__Prev$ = 12						; size = 4
_<_Val_0>$ = 16						; size = 4
??$_Buynode@AAPAX@?$_List_buy@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAEPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@PAU21@0AAPAX@Z PROC ; std::_List_buy<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >::_Buynode<void * &>, COMDAT
; _this$ = ecx

; 827  : 		_Nodeptr _Buynode(_Nodeptr _Next, _Nodeptr _Prev,

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Buynode@AAPAX@?$_List_buy@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAEPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@PAU21@0AAPAX@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 828  : 			_Valty&&... _Val)
; 829  : 		{	// allocate a node and set links and value
; 830  : 		_Nodeptr _Pnode = this->_Buynode0(_Next, _Prev);

	mov	eax, DWORD PTR __Prev$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Next$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@@std@@QAEPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@PAU32@0@Z ; std::_List_alloc<0,std::_List_base_types<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > > >::_Buynode0
	mov	DWORD PTR __Pnode$[ebp], eax

; 831  : 
; 832  : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 833  : 		this->_Getal().construct(
; 834  : 			_STD addressof(this->_Myval(_Pnode)),
; 835  : 				_STD forward<_Valty>(_Val)...);

	mov	edx, DWORD PTR _<_Val_0>$[ebp]
	push	edx
	call	??$forward@AAPAX@std@@YAAAPAXAAPAX@Z	; std::forward<void * &>
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Myval@?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@SAAAV?$unique_ptr@XU?$ThreadTerminator@$0A@@@@2@PAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@@Z ; std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > >::_Myval
	add	esp, 4
	push	eax
	call	??$addressof@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@YAPAV?$unique_ptr@XU?$ThreadTerminator@$0A@@@@0@AAV10@@Z ; std::addressof<std::unique_ptr<void,ThreadTerminator<0> > >
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_List_alloc@$0A@U?$_List_base_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@2@XZ ; std::_List_alloc<0,std::_List_base_types<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > > >::_Getal
	mov	ecx, eax
	call	??$construct@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@AAPAX@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@QAEXPAV?$unique_ptr@XU?$ThreadTerminator@$0A@@@@1@AAPAX@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> > >::construct<std::unique_ptr<void,ThreadTerminator<0> >,void * &>
	jmp	SHORT $LN4@Buynode
__catch$??$_Buynode@AAPAX@?$_List_buy@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAEPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@PAU21@0AAPAX@Z$0:

; 836  : 		_CATCH_ALL
; 837  : 		this->_Getal().deallocate(_Pnode, 1);

	push	1
	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_List_alloc@$0A@U?$_List_base_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@2@XZ ; std::_List_alloc<0,std::_List_base_types<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> > >::deallocate

; 838  : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 839  : 		_CATCH_END

	mov	eax, $LN7@Buynode
	ret	0
$LN4@Buynode:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT __tryend$??$_Buynode@AAPAX@?$_List_buy@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAEPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@PAU21@0AAPAX@Z$1
$LN7@Buynode:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Buynode@AAPAX@?$_List_buy@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAEPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@PAU21@0AAPAX@Z$1:

; 840  : 
; 841  : 		return (_Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]
$LN3@Buynode:

; 842  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Buynode@AAPAX@?$_List_buy@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAEPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@PAU21@0AAPAX@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-32]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Buynode@AAPAX@?$_List_buy@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAEPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@PAU21@0AAPAX@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Buynode@AAPAX@?$_List_buy@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAEPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@PAU21@0AAPAX@Z ENDP ; std::_List_buy<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >::_Buynode<void * &>
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$construct@PAXPAX@?$allocator@PAX@std@@QAEXPAPAX$$QAPAX@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
tv70 = -8						; size = 4
$T1 = -4						; size = 4
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAXPAX@?$allocator@PAX@std@@QAEXPAPAX$$QAPAX@Z PROC ; std::allocator<void *>::construct<void *,void *>, COMDAT
; _this$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	push	ecx
	call	??$forward@PAX@std@@YA$$QAPAXAAPAX@Z	; std::forward<void *>
	add	esp, 4
	mov	edx, DWORD PTR $T1[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR tv70[ebp], ecx
	jmp	SHORT $LN1@construct
$LN3@construct:
	mov	DWORD PTR tv70[ebp], 0
$LN1@construct:

; 601  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@PAXPAX@?$allocator@PAX@std@@QAEXPAPAX$$QAPAX@Z ENDP ; std::allocator<void *>::construct<void *,void *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\type_traits
;	COMDAT ??$forward@AAPAUReplayBuffer@@@std@@YAAAPAUReplayBuffer@@AAPAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAUReplayBuffer@@@std@@YAAAPAUReplayBuffer@@AAPAU1@@Z PROC ; std::forward<ReplayBuffer * &>, COMDAT

; 1504 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

	pop	ebp
	ret	0
??$forward@AAPAUReplayBuffer@@@std@@YAAAPAUReplayBuffer@@AAPAU1@@Z ENDP ; std::forward<ReplayBuffer * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\type_traits
;	COMDAT ??$forward@AAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@std@@YAAAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@std@@YAAAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@0@AAV10@@Z PROC ; std::forward<std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > &>, COMDAT

; 1504 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

	pop	ebp
	ret	0
??$forward@AAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@@std@@YAAAV?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> > &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??0?$allocator@V?$_Func_class@X$$$V@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@V?$_Func_class@X$$$V@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::_Func_class<void> >::allocator<std::_Func_class<void> >, COMDAT
; _this$ = ecx

; 556  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 557  : 		{	// construct by copying (do nothing)
; 558  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@V?$_Func_class@X$$$V@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::_Func_class<void> >::allocator<std::_Func_class<void> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ??$_Do_alloc@V?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@AAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@@?$_Func_class@X$$$V@std@@AAEXAAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@V?$allocator@V?$_Func_class@X$$$V@std@@@1@@Z
_TEXT	SEGMENT
tv132 = -32						; size = 4
$T1 = -28						; size = 4
tv84 = -24						; size = 4
$T2 = -20						; size = 4
_this$ = -16						; size = 4
__Ptr$ = -12						; size = 4
__Vptr$ = -8						; size = 4
$T3 = -2						; size = 1
__Al$4 = -1						; size = 1
__Val$ = 8						; size = 4
__Ax$ = 12						; size = 1
??$_Do_alloc@V?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@AAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@@?$_Func_class@X$$$V@std@@AAEXAAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@V?$allocator@V?$_Func_class@X$$$V@std@@@1@@Z PROC ; std::_Func_class<void>::_Do_alloc<std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void>,<lambda_582637cdd8d6a2f689bc987be9ec55df> &,std::allocator<std::_Func_class<void> > >, COMDAT
; _this$ = ecx

; 485  : 		void _Do_alloc(_Fty&& _Val,

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 486  : 			_Alloc _Ax)
; 487  : 		{	// store copy of _Val with allocator
; 488  : 		if (!_Test_callable(_Val))

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	??$_Test_callable@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@@std@@YA_NAAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@@Z ; std::_Test_callable<<lambda_582637cdd8d6a2f689bc987be9ec55df> >
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@Do_alloc

; 489  : 			{	// null member pointer/function pointer/std::function
; 490  : 			_Set(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set@?$_Func_class@X$$$V@std@@AAEXPAV?$_Func_base@X$$$V@2@@Z ; std::_Func_class<void>::_Set

; 491  : 			return;

	jmp	$LN4@Do_alloc
$LN3@Do_alloc:

; 492  : 			}
; 493  : 		void *_Vptr = 0;

	mov	DWORD PTR __Vptr$[ebp], 0

; 494  : 		_Myimpl *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 495  : 		if (sizeof (_Myimpl) <= sizeof (_Space))

	mov	edx, 1
	test	edx, edx
	je	SHORT $LN2@Do_alloc

; 496  : 			{	// small enough, allocate locally
; 497  : 			_Vptr = &_Space;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __Vptr$[ebp], eax

; 498  : 			_Ptr = ::new (_Vptr) _Myimpl(_STD forward<_Fty>(_Val));

	mov	ecx, DWORD PTR __Vptr$[ebp]
	push	ecx
	push	12					; 0000000cH
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T2[ebp], eax
	cmp	DWORD PTR $T2[ebp], 0
	je	SHORT $LN6@Do_alloc
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@XZ ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void> >::allocator<std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void> >
	push	eax
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	call	??$forward@AAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@@std@@YAAAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@AAV1@@Z ; std::forward<<lambda_582637cdd8d6a2f689bc987be9ec55df> &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR $T2[ebp]
	call	??$?0AAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@@?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@QAE@AAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@ABV?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@1@@Z ; std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void>::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void><<lambda_582637cdd8d6a2f689bc987be9ec55df> &>
	mov	DWORD PTR tv84[ebp], eax
	jmp	SHORT $LN7@Do_alloc
$LN6@Do_alloc:
	mov	DWORD PTR tv84[ebp], 0
$LN7@Do_alloc:
	mov	eax, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Ptr$[ebp], eax

; 499  : 			}
; 500  : 		else

	jmp	SHORT $LN1@Do_alloc
$LN2@Do_alloc:

; 501  : 			{	// use allocator
; 502  : 			typename _Alloc::template rebind<_Myimpl>::other _Al = _Ax;

	lea	ecx, DWORD PTR __Ax$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Al$4[ebp]
	call	??$?0V?$_Func_class@X$$$V@std@@@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@ABV?$allocator@V?$_Func_class@X$$$V@std@@@1@@Z ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void> >::allocator<std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void> ><std::_Func_class<void> >

; 503  : 			_Vptr = _Al.allocate(1);

	push	1
	lea	ecx, DWORD PTR __Al$4[ebp]
	call	?allocate@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEPAV?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@2@I@Z ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void> >::allocate
	mov	DWORD PTR __Vptr$[ebp], eax

; 504  : 			_Ptr = ::new (_Vptr) _Myimpl(_STD forward<_Fty>(_Val), _Al);

	mov	edx, DWORD PTR __Vptr$[ebp]
	push	edx
	push	12					; 0000000cH
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 0
	je	SHORT $LN8@Do_alloc
	lea	eax, DWORD PTR __Al$4[ebp]
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	call	??$forward@AAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@@std@@YAAAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@AAV1@@Z ; std::forward<<lambda_582637cdd8d6a2f689bc987be9ec55df> &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR $T1[ebp]
	call	??$?0AAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@@?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@QAE@AAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@ABV?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@1@@Z ; std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void>::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void><<lambda_582637cdd8d6a2f689bc987be9ec55df> &>
	mov	DWORD PTR tv132[ebp], eax
	jmp	SHORT $LN9@Do_alloc
$LN8@Do_alloc:
	mov	DWORD PTR tv132[ebp], 0
$LN9@Do_alloc:
	mov	edx, DWORD PTR tv132[ebp]
	mov	DWORD PTR __Ptr$[ebp], edx
$LN1@Do_alloc:

; 505  : 			}
; 506  : 		_Set(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set@?$_Func_class@X$$$V@std@@AAEXPAV?$_Func_base@X$$$V@2@@Z ; std::_Func_class<void>::_Set
$LN4@Do_alloc:

; 507  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??$_Do_alloc@V?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@AAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@@?$_Func_class@X$$$V@std@@AAEXAAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@V?$allocator@V?$_Func_class@X$$$V@std@@@1@@Z ENDP ; std::_Func_class<void>::_Do_alloc<std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void>,<lambda_582637cdd8d6a2f689bc987be9ec55df> &,std::allocator<std::_Func_class<void> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ??$_Do_alloc@V?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@AAV<lambda_e856d28dddb7588070dd099cfda6c634>@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@@?$_Func_class@X$$$V@std@@AAEXAAV<lambda_e856d28dddb7588070dd099cfda6c634>@@V?$allocator@V?$_Func_class@X$$$V@std@@@1@@Z
_TEXT	SEGMENT
tv132 = -32						; size = 4
$T1 = -28						; size = 4
tv84 = -24						; size = 4
$T2 = -20						; size = 4
_this$ = -16						; size = 4
__Ptr$ = -12						; size = 4
__Vptr$ = -8						; size = 4
$T3 = -2						; size = 1
__Al$4 = -1						; size = 1
__Val$ = 8						; size = 4
__Ax$ = 12						; size = 1
??$_Do_alloc@V?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@AAV<lambda_e856d28dddb7588070dd099cfda6c634>@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@@?$_Func_class@X$$$V@std@@AAEXAAV<lambda_e856d28dddb7588070dd099cfda6c634>@@V?$allocator@V?$_Func_class@X$$$V@std@@@1@@Z PROC ; std::_Func_class<void>::_Do_alloc<std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void>,<lambda_e856d28dddb7588070dd099cfda6c634> &,std::allocator<std::_Func_class<void> > >, COMDAT
; _this$ = ecx

; 485  : 		void _Do_alloc(_Fty&& _Val,

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 486  : 			_Alloc _Ax)
; 487  : 		{	// store copy of _Val with allocator
; 488  : 		if (!_Test_callable(_Val))

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	??$_Test_callable@V<lambda_e856d28dddb7588070dd099cfda6c634>@@@std@@YA_NAAV<lambda_e856d28dddb7588070dd099cfda6c634>@@@Z ; std::_Test_callable<<lambda_e856d28dddb7588070dd099cfda6c634> >
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@Do_alloc

; 489  : 			{	// null member pointer/function pointer/std::function
; 490  : 			_Set(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set@?$_Func_class@X$$$V@std@@AAEXPAV?$_Func_base@X$$$V@2@@Z ; std::_Func_class<void>::_Set

; 491  : 			return;

	jmp	$LN4@Do_alloc
$LN3@Do_alloc:

; 492  : 			}
; 493  : 		void *_Vptr = 0;

	mov	DWORD PTR __Vptr$[ebp], 0

; 494  : 		_Myimpl *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 495  : 		if (sizeof (_Myimpl) <= sizeof (_Space))

	mov	edx, 1
	test	edx, edx
	je	SHORT $LN2@Do_alloc

; 496  : 			{	// small enough, allocate locally
; 497  : 			_Vptr = &_Space;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __Vptr$[ebp], eax

; 498  : 			_Ptr = ::new (_Vptr) _Myimpl(_STD forward<_Fty>(_Val));

	mov	ecx, DWORD PTR __Vptr$[ebp]
	push	ecx
	push	12					; 0000000cH
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T2[ebp], eax
	cmp	DWORD PTR $T2[ebp], 0
	je	SHORT $LN6@Do_alloc
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@XZ ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void> >::allocator<std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void> >
	push	eax
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	call	??$forward@AAV<lambda_e856d28dddb7588070dd099cfda6c634>@@@std@@YAAAV<lambda_e856d28dddb7588070dd099cfda6c634>@@AAV1@@Z ; std::forward<<lambda_e856d28dddb7588070dd099cfda6c634> &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR $T2[ebp]
	call	??$?0AAV<lambda_e856d28dddb7588070dd099cfda6c634>@@@?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@QAE@AAV<lambda_e856d28dddb7588070dd099cfda6c634>@@ABV?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@1@@Z ; std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void>::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void><<lambda_e856d28dddb7588070dd099cfda6c634> &>
	mov	DWORD PTR tv84[ebp], eax
	jmp	SHORT $LN7@Do_alloc
$LN6@Do_alloc:
	mov	DWORD PTR tv84[ebp], 0
$LN7@Do_alloc:
	mov	eax, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Ptr$[ebp], eax

; 499  : 			}
; 500  : 		else

	jmp	SHORT $LN1@Do_alloc
$LN2@Do_alloc:

; 501  : 			{	// use allocator
; 502  : 			typename _Alloc::template rebind<_Myimpl>::other _Al = _Ax;

	lea	ecx, DWORD PTR __Ax$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Al$4[ebp]
	call	??$?0V?$_Func_class@X$$$V@std@@@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@ABV?$allocator@V?$_Func_class@X$$$V@std@@@1@@Z ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void> >::allocator<std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void> ><std::_Func_class<void> >

; 503  : 			_Vptr = _Al.allocate(1);

	push	1
	lea	ecx, DWORD PTR __Al$4[ebp]
	call	?allocate@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEPAV?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@2@I@Z ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void> >::allocate
	mov	DWORD PTR __Vptr$[ebp], eax

; 504  : 			_Ptr = ::new (_Vptr) _Myimpl(_STD forward<_Fty>(_Val), _Al);

	mov	edx, DWORD PTR __Vptr$[ebp]
	push	edx
	push	12					; 0000000cH
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 0
	je	SHORT $LN8@Do_alloc
	lea	eax, DWORD PTR __Al$4[ebp]
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	call	??$forward@AAV<lambda_e856d28dddb7588070dd099cfda6c634>@@@std@@YAAAV<lambda_e856d28dddb7588070dd099cfda6c634>@@AAV1@@Z ; std::forward<<lambda_e856d28dddb7588070dd099cfda6c634> &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR $T1[ebp]
	call	??$?0AAV<lambda_e856d28dddb7588070dd099cfda6c634>@@@?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@QAE@AAV<lambda_e856d28dddb7588070dd099cfda6c634>@@ABV?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@1@@Z ; std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void>::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void><<lambda_e856d28dddb7588070dd099cfda6c634> &>
	mov	DWORD PTR tv132[ebp], eax
	jmp	SHORT $LN9@Do_alloc
$LN8@Do_alloc:
	mov	DWORD PTR tv132[ebp], 0
$LN9@Do_alloc:
	mov	edx, DWORD PTR tv132[ebp]
	mov	DWORD PTR __Ptr$[ebp], edx
$LN1@Do_alloc:

; 505  : 			}
; 506  : 		_Set(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set@?$_Func_class@X$$$V@std@@AAEXPAV?$_Func_base@X$$$V@2@@Z ; std::_Func_class<void>::_Set
$LN4@Do_alloc:

; 507  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??$_Do_alloc@V?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@AAV<lambda_e856d28dddb7588070dd099cfda6c634>@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@@?$_Func_class@X$$$V@std@@AAEXAAV<lambda_e856d28dddb7588070dd099cfda6c634>@@V?$allocator@V?$_Func_class@X$$$V@std@@@1@@Z ENDP ; std::_Func_class<void>::_Do_alloc<std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void>,<lambda_e856d28dddb7588070dd099cfda6c634> &,std::allocator<std::_Func_class<void> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ??$_Do_alloc@V?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@@?$_Func_class@X$$$V@std@@AAEX$$QAV<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@V?$allocator@V?$_Func_class@X$$$V@std@@@1@@Z
_TEXT	SEGMENT
tv132 = -32						; size = 4
$T1 = -28						; size = 4
tv84 = -24						; size = 4
$T2 = -20						; size = 4
_this$ = -16						; size = 4
__Ptr$ = -12						; size = 4
__Vptr$ = -8						; size = 4
$T3 = -2						; size = 1
__Al$4 = -1						; size = 1
__Val$ = 8						; size = 4
__Ax$ = 12						; size = 1
??$_Do_alloc@V?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@@?$_Func_class@X$$$V@std@@AAEX$$QAV<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@V?$allocator@V?$_Func_class@X$$$V@std@@@1@@Z PROC ; std::_Func_class<void>::_Do_alloc<std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void>,<lambda_7c9af1b141e25bc2e890d47a77a39da9>,std::allocator<std::_Func_class<void> > >, COMDAT
; _this$ = ecx

; 485  : 		void _Do_alloc(_Fty&& _Val,

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 486  : 			_Alloc _Ax)
; 487  : 		{	// store copy of _Val with allocator
; 488  : 		if (!_Test_callable(_Val))

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	??$_Test_callable@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@@std@@YA_NAAV<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@@Z ; std::_Test_callable<<lambda_7c9af1b141e25bc2e890d47a77a39da9> >
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@Do_alloc

; 489  : 			{	// null member pointer/function pointer/std::function
; 490  : 			_Set(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set@?$_Func_class@X$$$V@std@@AAEXPAV?$_Func_base@X$$$V@2@@Z ; std::_Func_class<void>::_Set

; 491  : 			return;

	jmp	$LN4@Do_alloc
$LN3@Do_alloc:

; 492  : 			}
; 493  : 		void *_Vptr = 0;

	mov	DWORD PTR __Vptr$[ebp], 0

; 494  : 		_Myimpl *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 495  : 		if (sizeof (_Myimpl) <= sizeof (_Space))

	mov	edx, 1
	test	edx, edx
	je	SHORT $LN2@Do_alloc

; 496  : 			{	// small enough, allocate locally
; 497  : 			_Vptr = &_Space;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __Vptr$[ebp], eax

; 498  : 			_Ptr = ::new (_Vptr) _Myimpl(_STD forward<_Fty>(_Val));

	mov	ecx, DWORD PTR __Vptr$[ebp]
	push	ecx
	push	12					; 0000000cH
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T2[ebp], eax
	cmp	DWORD PTR $T2[ebp], 0
	je	SHORT $LN6@Do_alloc
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@XZ ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void> >::allocator<std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void> >
	push	eax
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	call	??$forward@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@@std@@YA$$QAV<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@AAV1@@Z ; std::forward<<lambda_7c9af1b141e25bc2e890d47a77a39da9> >
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR $T2[ebp]
	call	??0?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@QAE@$$QAV<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@ABV?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@1@@Z ; std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void>::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void>
	mov	DWORD PTR tv84[ebp], eax
	jmp	SHORT $LN7@Do_alloc
$LN6@Do_alloc:
	mov	DWORD PTR tv84[ebp], 0
$LN7@Do_alloc:
	mov	eax, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Ptr$[ebp], eax

; 499  : 			}
; 500  : 		else

	jmp	SHORT $LN1@Do_alloc
$LN2@Do_alloc:

; 501  : 			{	// use allocator
; 502  : 			typename _Alloc::template rebind<_Myimpl>::other _Al = _Ax;

	lea	ecx, DWORD PTR __Ax$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Al$4[ebp]
	call	??$?0V?$_Func_class@X$$$V@std@@@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@ABV?$allocator@V?$_Func_class@X$$$V@std@@@1@@Z ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void> >::allocator<std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void> ><std::_Func_class<void> >

; 503  : 			_Vptr = _Al.allocate(1);

	push	1
	lea	ecx, DWORD PTR __Al$4[ebp]
	call	?allocate@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEPAV?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@2@I@Z ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void> >::allocate
	mov	DWORD PTR __Vptr$[ebp], eax

; 504  : 			_Ptr = ::new (_Vptr) _Myimpl(_STD forward<_Fty>(_Val), _Al);

	mov	edx, DWORD PTR __Vptr$[ebp]
	push	edx
	push	12					; 0000000cH
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 0
	je	SHORT $LN8@Do_alloc
	lea	eax, DWORD PTR __Al$4[ebp]
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	call	??$forward@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@@std@@YA$$QAV<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@AAV1@@Z ; std::forward<<lambda_7c9af1b141e25bc2e890d47a77a39da9> >
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR $T1[ebp]
	call	??0?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@QAE@$$QAV<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@ABV?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@1@@Z ; std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void>::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void>
	mov	DWORD PTR tv132[ebp], eax
	jmp	SHORT $LN9@Do_alloc
$LN8@Do_alloc:
	mov	DWORD PTR tv132[ebp], 0
$LN9@Do_alloc:
	mov	edx, DWORD PTR tv132[ebp]
	mov	DWORD PTR __Ptr$[ebp], edx
$LN1@Do_alloc:

; 505  : 			}
; 506  : 		_Set(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set@?$_Func_class@X$$$V@std@@AAEXPAV?$_Func_base@X$$$V@2@@Z ; std::_Func_class<void>::_Set
$LN4@Do_alloc:

; 507  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??$_Do_alloc@V?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@@?$_Func_class@X$$$V@std@@AAEX$$QAV<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@V?$allocator@V?$_Func_class@X$$$V@std@@@1@@Z ENDP ; std::_Func_class<void>::_Do_alloc<std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void>,<lambda_7c9af1b141e25bc2e890d47a77a39da9>,std::allocator<std::_Func_class<void> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ??$_Do_alloc@V?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@V<lambda_3b020cec0f1508adac4c896f138918cf>@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@@?$_Func_class@X$$$V@std@@AAEX$$QAV<lambda_3b020cec0f1508adac4c896f138918cf>@@V?$allocator@V?$_Func_class@X$$$V@std@@@1@@Z
_TEXT	SEGMENT
tv132 = -32						; size = 4
$T1 = -28						; size = 4
tv84 = -24						; size = 4
$T2 = -20						; size = 4
_this$ = -16						; size = 4
__Ptr$ = -12						; size = 4
__Vptr$ = -8						; size = 4
$T3 = -2						; size = 1
__Al$4 = -1						; size = 1
__Val$ = 8						; size = 4
__Ax$ = 12						; size = 1
??$_Do_alloc@V?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@V<lambda_3b020cec0f1508adac4c896f138918cf>@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@@?$_Func_class@X$$$V@std@@AAEX$$QAV<lambda_3b020cec0f1508adac4c896f138918cf>@@V?$allocator@V?$_Func_class@X$$$V@std@@@1@@Z PROC ; std::_Func_class<void>::_Do_alloc<std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void>,<lambda_3b020cec0f1508adac4c896f138918cf>,std::allocator<std::_Func_class<void> > >, COMDAT
; _this$ = ecx

; 485  : 		void _Do_alloc(_Fty&& _Val,

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 486  : 			_Alloc _Ax)
; 487  : 		{	// store copy of _Val with allocator
; 488  : 		if (!_Test_callable(_Val))

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	??$_Test_callable@V<lambda_3b020cec0f1508adac4c896f138918cf>@@@std@@YA_NAAV<lambda_3b020cec0f1508adac4c896f138918cf>@@@Z ; std::_Test_callable<<lambda_3b020cec0f1508adac4c896f138918cf> >
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@Do_alloc

; 489  : 			{	// null member pointer/function pointer/std::function
; 490  : 			_Set(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set@?$_Func_class@X$$$V@std@@AAEXPAV?$_Func_base@X$$$V@2@@Z ; std::_Func_class<void>::_Set

; 491  : 			return;

	jmp	$LN4@Do_alloc
$LN3@Do_alloc:

; 492  : 			}
; 493  : 		void *_Vptr = 0;

	mov	DWORD PTR __Vptr$[ebp], 0

; 494  : 		_Myimpl *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 495  : 		if (sizeof (_Myimpl) <= sizeof (_Space))

	mov	edx, 1
	test	edx, edx
	je	SHORT $LN2@Do_alloc

; 496  : 			{	// small enough, allocate locally
; 497  : 			_Vptr = &_Space;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __Vptr$[ebp], eax

; 498  : 			_Ptr = ::new (_Vptr) _Myimpl(_STD forward<_Fty>(_Val));

	mov	ecx, DWORD PTR __Vptr$[ebp]
	push	ecx
	push	12					; 0000000cH
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T2[ebp], eax
	cmp	DWORD PTR $T2[ebp], 0
	je	SHORT $LN6@Do_alloc
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@XZ ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void> >::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void> >
	push	eax
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	call	??$forward@V<lambda_3b020cec0f1508adac4c896f138918cf>@@@std@@YA$$QAV<lambda_3b020cec0f1508adac4c896f138918cf>@@AAV1@@Z ; std::forward<<lambda_3b020cec0f1508adac4c896f138918cf> >
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR $T2[ebp]
	call	??0?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@QAE@$$QAV<lambda_3b020cec0f1508adac4c896f138918cf>@@ABV?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@1@@Z ; std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void>::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void>
	mov	DWORD PTR tv84[ebp], eax
	jmp	SHORT $LN7@Do_alloc
$LN6@Do_alloc:
	mov	DWORD PTR tv84[ebp], 0
$LN7@Do_alloc:
	mov	eax, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Ptr$[ebp], eax

; 499  : 			}
; 500  : 		else

	jmp	SHORT $LN1@Do_alloc
$LN2@Do_alloc:

; 501  : 			{	// use allocator
; 502  : 			typename _Alloc::template rebind<_Myimpl>::other _Al = _Ax;

	lea	ecx, DWORD PTR __Ax$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Al$4[ebp]
	call	??$?0V?$_Func_class@X$$$V@std@@@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@ABV?$allocator@V?$_Func_class@X$$$V@std@@@1@@Z ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void> >::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void> ><std::_Func_class<void> >

; 503  : 			_Vptr = _Al.allocate(1);

	push	1
	lea	ecx, DWORD PTR __Al$4[ebp]
	call	?allocate@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEPAV?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@2@I@Z ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void> >::allocate
	mov	DWORD PTR __Vptr$[ebp], eax

; 504  : 			_Ptr = ::new (_Vptr) _Myimpl(_STD forward<_Fty>(_Val), _Al);

	mov	edx, DWORD PTR __Vptr$[ebp]
	push	edx
	push	12					; 0000000cH
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 0
	je	SHORT $LN8@Do_alloc
	lea	eax, DWORD PTR __Al$4[ebp]
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	call	??$forward@V<lambda_3b020cec0f1508adac4c896f138918cf>@@@std@@YA$$QAV<lambda_3b020cec0f1508adac4c896f138918cf>@@AAV1@@Z ; std::forward<<lambda_3b020cec0f1508adac4c896f138918cf> >
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR $T1[ebp]
	call	??0?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@QAE@$$QAV<lambda_3b020cec0f1508adac4c896f138918cf>@@ABV?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@1@@Z ; std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void>::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void>
	mov	DWORD PTR tv132[ebp], eax
	jmp	SHORT $LN9@Do_alloc
$LN8@Do_alloc:
	mov	DWORD PTR tv132[ebp], 0
$LN9@Do_alloc:
	mov	edx, DWORD PTR tv132[ebp]
	mov	DWORD PTR __Ptr$[ebp], edx
$LN1@Do_alloc:

; 505  : 			}
; 506  : 		_Set(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set@?$_Func_class@X$$$V@std@@AAEXPAV?$_Func_base@X$$$V@2@@Z ; std::_Func_class<void>::_Set
$LN4@Do_alloc:

; 507  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??$_Do_alloc@V?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@V<lambda_3b020cec0f1508adac4c896f138918cf>@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@@?$_Func_class@X$$$V@std@@AAEX$$QAV<lambda_3b020cec0f1508adac4c896f138918cf>@@V?$allocator@V?$_Func_class@X$$$V@std@@@1@@Z ENDP ; std::_Func_class<void>::_Do_alloc<std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void>,<lambda_3b020cec0f1508adac4c896f138918cf>,std::allocator<std::_Func_class<void> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ??$_Do_alloc@V?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@@?$_Func_class@X$$$V@std@@AAEX$$QAV<lambda_3648d362fc95221bbf9c4c4a922d1611>@@V?$allocator@V?$_Func_class@X$$$V@std@@@1@@Z
_TEXT	SEGMENT
tv132 = -32						; size = 4
$T1 = -28						; size = 4
tv84 = -24						; size = 4
$T2 = -20						; size = 4
_this$ = -16						; size = 4
__Ptr$ = -12						; size = 4
__Vptr$ = -8						; size = 4
$T3 = -2						; size = 1
__Al$4 = -1						; size = 1
__Val$ = 8						; size = 4
__Ax$ = 12						; size = 1
??$_Do_alloc@V?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@@?$_Func_class@X$$$V@std@@AAEX$$QAV<lambda_3648d362fc95221bbf9c4c4a922d1611>@@V?$allocator@V?$_Func_class@X$$$V@std@@@1@@Z PROC ; std::_Func_class<void>::_Do_alloc<std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void>,<lambda_3648d362fc95221bbf9c4c4a922d1611>,std::allocator<std::_Func_class<void> > >, COMDAT
; _this$ = ecx

; 485  : 		void _Do_alloc(_Fty&& _Val,

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 486  : 			_Alloc _Ax)
; 487  : 		{	// store copy of _Val with allocator
; 488  : 		if (!_Test_callable(_Val))

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	??$_Test_callable@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@@std@@YA_NAAV<lambda_3648d362fc95221bbf9c4c4a922d1611>@@@Z ; std::_Test_callable<<lambda_3648d362fc95221bbf9c4c4a922d1611> >
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@Do_alloc

; 489  : 			{	// null member pointer/function pointer/std::function
; 490  : 			_Set(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set@?$_Func_class@X$$$V@std@@AAEXPAV?$_Func_base@X$$$V@2@@Z ; std::_Func_class<void>::_Set

; 491  : 			return;

	jmp	$LN4@Do_alloc
$LN3@Do_alloc:

; 492  : 			}
; 493  : 		void *_Vptr = 0;

	mov	DWORD PTR __Vptr$[ebp], 0

; 494  : 		_Myimpl *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 495  : 		if (sizeof (_Myimpl) <= sizeof (_Space))

	mov	edx, 1
	test	edx, edx
	je	SHORT $LN2@Do_alloc

; 496  : 			{	// small enough, allocate locally
; 497  : 			_Vptr = &_Space;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR __Vptr$[ebp], eax

; 498  : 			_Ptr = ::new (_Vptr) _Myimpl(_STD forward<_Fty>(_Val));

	mov	ecx, DWORD PTR __Vptr$[ebp]
	push	ecx
	push	12					; 0000000cH
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T2[ebp], eax
	cmp	DWORD PTR $T2[ebp], 0
	je	SHORT $LN6@Do_alloc
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@XZ ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void> >::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void> >
	push	eax
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	call	??$forward@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@@std@@YA$$QAV<lambda_3648d362fc95221bbf9c4c4a922d1611>@@AAV1@@Z ; std::forward<<lambda_3648d362fc95221bbf9c4c4a922d1611> >
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR $T2[ebp]
	call	??0?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@QAE@$$QAV<lambda_3648d362fc95221bbf9c4c4a922d1611>@@ABV?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@1@@Z ; std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void>::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void>
	mov	DWORD PTR tv84[ebp], eax
	jmp	SHORT $LN7@Do_alloc
$LN6@Do_alloc:
	mov	DWORD PTR tv84[ebp], 0
$LN7@Do_alloc:
	mov	eax, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Ptr$[ebp], eax

; 499  : 			}
; 500  : 		else

	jmp	SHORT $LN1@Do_alloc
$LN2@Do_alloc:

; 501  : 			{	// use allocator
; 502  : 			typename _Alloc::template rebind<_Myimpl>::other _Al = _Ax;

	lea	ecx, DWORD PTR __Ax$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Al$4[ebp]
	call	??$?0V?$_Func_class@X$$$V@std@@@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@ABV?$allocator@V?$_Func_class@X$$$V@std@@@1@@Z ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void> >::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void> ><std::_Func_class<void> >

; 503  : 			_Vptr = _Al.allocate(1);

	push	1
	lea	ecx, DWORD PTR __Al$4[ebp]
	call	?allocate@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEPAV?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@2@I@Z ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void> >::allocate
	mov	DWORD PTR __Vptr$[ebp], eax

; 504  : 			_Ptr = ::new (_Vptr) _Myimpl(_STD forward<_Fty>(_Val), _Al);

	mov	edx, DWORD PTR __Vptr$[ebp]
	push	edx
	push	12					; 0000000cH
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 0
	je	SHORT $LN8@Do_alloc
	lea	eax, DWORD PTR __Al$4[ebp]
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	call	??$forward@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@@std@@YA$$QAV<lambda_3648d362fc95221bbf9c4c4a922d1611>@@AAV1@@Z ; std::forward<<lambda_3648d362fc95221bbf9c4c4a922d1611> >
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR $T1[ebp]
	call	??0?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@QAE@$$QAV<lambda_3648d362fc95221bbf9c4c4a922d1611>@@ABV?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@1@@Z ; std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void>::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void>
	mov	DWORD PTR tv132[ebp], eax
	jmp	SHORT $LN9@Do_alloc
$LN8@Do_alloc:
	mov	DWORD PTR tv132[ebp], 0
$LN9@Do_alloc:
	mov	edx, DWORD PTR tv132[ebp]
	mov	DWORD PTR __Ptr$[ebp], edx
$LN1@Do_alloc:

; 505  : 			}
; 506  : 		_Set(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set@?$_Func_class@X$$$V@std@@AAEXPAV?$_Func_base@X$$$V@2@@Z ; std::_Func_class<void>::_Set
$LN4@Do_alloc:

; 507  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??$_Do_alloc@V?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@@?$_Func_class@X$$$V@std@@AAEX$$QAV<lambda_3648d362fc95221bbf9c4c4a922d1611>@@V?$allocator@V?$_Func_class@X$$$V@std@@@1@@Z ENDP ; std::_Func_class<void>::_Do_alloc<std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void>,<lambda_3648d362fc95221bbf9c4c4a922d1611>,std::allocator<std::_Func_class<void> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$construct@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@QAEXPAV?$unique_ptr@XU?$ThreadTerminator@$0A@@@@1@$$QAPAX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@QAEXPAV?$unique_ptr@XU?$ThreadTerminator@$0A@@@@1@$$QAPAX@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> > >::construct<std::unique_ptr<void,ThreadTerminator<0> >,void *>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	eax
	call	??$forward@PAX@std@@YA$$QAPAXAAPAX@Z	; std::forward<void *>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@?$allocator_traits@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@1@PAV?$unique_ptr@XU?$ThreadTerminator@$0A@@@@1@$$QAPAX@Z ; std::allocator_traits<std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> > >::construct<std::unique_ptr<void,ThreadTerminator<0> >,void *>
	add	esp, 12					; 0000000cH

; 873  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@QAEXPAV?$unique_ptr@XU?$ThreadTerminator@$0A@@@@1@$$QAPAX@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> > >::construct<std::unique_ptr<void,ThreadTerminator<0> >,void *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$construct@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@AAPAX@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@QAEXPAV?$unique_ptr@XU?$ThreadTerminator@$0A@@@@1@AAPAX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@AAPAX@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@QAEXPAV?$unique_ptr@XU?$ThreadTerminator@$0A@@@@1@AAPAX@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> > >::construct<std::unique_ptr<void,ThreadTerminator<0> >,void * &>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	eax
	call	??$forward@AAPAX@std@@YAAAPAXAAPAX@Z	; std::forward<void * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@AAPAX@?$allocator_traits@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@1@PAV?$unique_ptr@XU?$ThreadTerminator@$0A@@@@1@AAPAX@Z ; std::allocator_traits<std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> > >::construct<std::unique_ptr<void,ThreadTerminator<0> >,void * &>
	add	esp, 12					; 0000000cH

; 873  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@AAPAX@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@QAEXPAV?$unique_ptr@XU?$ThreadTerminator@$0A@@@@1@AAPAX@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> > >::construct<std::unique_ptr<void,ThreadTerminator<0> >,void * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ?_Copy@?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEPAV?$_Func_base@X$$$V@2@PAX@Z
_TEXT	SEGMENT
tv76 = -12						; size = 4
$T1 = -8						; size = 4
_this$ = -4						; size = 4
__Where$ = 8						; size = 4
?_Copy@?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEPAV?$_Func_base@X$$$V@2@PAX@Z PROC ; std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void>::_Copy, COMDAT
; _this$ = ecx

; 206  : 		{	// return clone of *this

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 207  : 		if (_Where == 0)

	cmp	DWORD PTR __Where$[ebp], 0
	jne	SHORT $LN1@Copy

; 208  : 			_Where = _Myal.allocate(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEPAV?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@2@I@Z ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void> >::allocate
	mov	DWORD PTR __Where$[ebp], eax
$LN1@Copy:

; 209  : 		::new (_Where) _Myt(*this);

	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	push	12					; 0000000cH
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 0
	je	SHORT $LN4@Copy
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T1[ebp]
	call	??0?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@QAE@AAV01@@Z ; std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void>::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void>
	mov	DWORD PTR tv76[ebp], eax
	jmp	SHORT $LN5@Copy
$LN4@Copy:
	mov	DWORD PTR tv76[ebp], 0
$LN5@Copy:

; 210  : 		return ((_Mybase *)_Where);

	mov	eax, DWORD PTR __Where$[ebp]

; 211  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Copy@?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEPAV?$_Func_base@X$$$V@2@PAX@Z ENDP ; std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void>::_Copy
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ?_Move@?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEPAV?$_Func_base@X$$$V@2@PAX@Z
_TEXT	SEGMENT
tv78 = -12						; size = 4
$T1 = -8						; size = 4
_this$ = -4						; size = 4
__Where$ = 8						; size = 4
?_Move@?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEPAV?$_Func_base@X$$$V@2@PAX@Z PROC ; std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void>::_Move, COMDAT
; _this$ = ecx

; 214  : 		{	// return clone of *this

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 215  : 		if (_Where == 0)

	cmp	DWORD PTR __Where$[ebp], 0
	jne	SHORT $LN1@Move

; 216  : 			_Where = _Myal.allocate(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEPAV?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@2@I@Z ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void> >::allocate
	mov	DWORD PTR __Where$[ebp], eax
$LN1@Move:

; 217  : 		::new (_Where) _Myt(_STD move(*this));

	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	push	12					; 0000000cH
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 0
	je	SHORT $LN4@Move
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$move@AAV?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@YA$$QAV?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@0@AAV10@@Z ; std::move<std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void> &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR $T1[ebp]
	call	??0?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@QAE@$$QAV01@@Z ; std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void>::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void>
	mov	DWORD PTR tv78[ebp], eax
	jmp	SHORT $LN5@Move
$LN4@Move:
	mov	DWORD PTR tv78[ebp], 0
$LN5@Move:

; 218  : 		return ((_Mybase *)_Where);

	mov	eax, DWORD PTR __Where$[ebp]

; 219  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Move@?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEPAV?$_Func_base@X$$$V@2@PAX@Z ENDP ; std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void>::_Move
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ??1?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAE@XZ PROC ; std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void>::~_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void>, COMDAT
; _this$ = ecx

; 222  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@6B@

; 223  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Func_base@X$$$V@std@@UAE@XZ	; std::_Func_base<void>::~_Func_base<void>
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAE@XZ ENDP ; std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void>::~_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ?_Do_call@?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Do_call@?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEXXZ PROC ; std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void>::_Do_call, COMDAT
; _this$ = ecx

; 226  : 		{	// call wrapped function

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 227  : 		return (_Callee.template _ApplyX<_Rx>(
; 228  : 			_STD forward<_Types>(_Args)...));

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$_ApplyX@X$$$V@?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@QAEXXZ ; std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>::_ApplyX<void>

; 229  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Do_call@?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEXXZ ENDP ; std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void>::_Do_call
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ?_Target_type@?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UBEABVtype_info@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Target_type@?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UBEABVtype_info@@XZ PROC ; std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void>::_Target_type, COMDAT
; _this$ = ecx

; 232  : 		{	// return type information for stored object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 233  : 		return (typeid(typename _Callable::_MyTy));

	mov	eax, OFFSET ??_R0?AV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@@8

; 234  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Target_type@?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UBEABVtype_info@@XZ ENDP ; std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void>::_Target_type
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ?_Get@?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@EBEPBXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get@?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@EBEPBXXZ PROC ; std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void>::_Get, COMDAT
; _this$ = ecx

; 238  : 		{	// return address of stored object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 239  : 		return (reinterpret_cast<const void*>(&_Callee._Get()));

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?_Get@?$_Callable_base@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@QBEABV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@XZ ; std::_Callable_base<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>::_Get

; 240  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Get@?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@EBEPBXXZ ENDP ; std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void>::_Get
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ?_Delete_this@?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@EAEX_N@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Al$ = -1						; size = 1
__Deallocate$ = 8					; size = 1
?_Delete_this@?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@EAEX_N@Z PROC ; std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void>::_Delete_this, COMDAT
; _this$ = ecx

; 243  : 		{	// destroy self

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 244  : 		_Myalty _Al = _Myal;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	lea	ecx, DWORD PTR __Al$[ebp]
	call	??0?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void> >::allocator<std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void> >

; 245  : 		_Al.destroy(this);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Al$[ebp]
	call	??$destroy@V?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEXPAV?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@1@@Z ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void> >::destroy<std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void> >

; 246  : 		if (_Deallocate)

	movzx	edx, BYTE PTR __Deallocate$[ebp]
	test	edx, edx
	je	SHORT $LN2@Delete_thi

; 247  : 			_Al.deallocate(this, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Al$[ebp]
	call	?deallocate@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEXPAV?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@2@I@Z ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void> >::deallocate
$LN2@Delete_thi:

; 248  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Delete_this@?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@EAEX_N@Z ENDP ; std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void>::_Delete_this
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??0?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@XZ PROC ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void> >::allocator<std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void> >, COMDAT
; _this$ = ecx

; 552  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@XZ ENDP ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void> >::allocator<std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEPAV?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEPAV?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@2@I@Z PROC ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void> >::allocate, COMDAT
; _this$ = ecx

; 577  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 578  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@V?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@YAPAV?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@0@IPAV10@@Z ; std::_Allocate<std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void> >
	add	esp, 8

; 579  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEPAV?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@2@I@Z ENDP ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ?_Copy@?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEPAV?$_Func_base@X$$$V@2@PAX@Z
_TEXT	SEGMENT
tv76 = -12						; size = 4
$T1 = -8						; size = 4
_this$ = -4						; size = 4
__Where$ = 8						; size = 4
?_Copy@?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEPAV?$_Func_base@X$$$V@2@PAX@Z PROC ; std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void>::_Copy, COMDAT
; _this$ = ecx

; 206  : 		{	// return clone of *this

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 207  : 		if (_Where == 0)

	cmp	DWORD PTR __Where$[ebp], 0
	jne	SHORT $LN1@Copy

; 208  : 			_Where = _Myal.allocate(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEPAV?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@2@I@Z ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void> >::allocate
	mov	DWORD PTR __Where$[ebp], eax
$LN1@Copy:

; 209  : 		::new (_Where) _Myt(*this);

	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	push	12					; 0000000cH
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 0
	je	SHORT $LN4@Copy
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T1[ebp]
	call	??0?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@QAE@AAV01@@Z ; std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void>::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void>
	mov	DWORD PTR tv76[ebp], eax
	jmp	SHORT $LN5@Copy
$LN4@Copy:
	mov	DWORD PTR tv76[ebp], 0
$LN5@Copy:

; 210  : 		return ((_Mybase *)_Where);

	mov	eax, DWORD PTR __Where$[ebp]

; 211  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Copy@?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEPAV?$_Func_base@X$$$V@2@PAX@Z ENDP ; std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void>::_Copy
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ?_Move@?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEPAV?$_Func_base@X$$$V@2@PAX@Z
_TEXT	SEGMENT
tv78 = -12						; size = 4
$T1 = -8						; size = 4
_this$ = -4						; size = 4
__Where$ = 8						; size = 4
?_Move@?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEPAV?$_Func_base@X$$$V@2@PAX@Z PROC ; std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void>::_Move, COMDAT
; _this$ = ecx

; 214  : 		{	// return clone of *this

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 215  : 		if (_Where == 0)

	cmp	DWORD PTR __Where$[ebp], 0
	jne	SHORT $LN1@Move

; 216  : 			_Where = _Myal.allocate(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEPAV?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@2@I@Z ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void> >::allocate
	mov	DWORD PTR __Where$[ebp], eax
$LN1@Move:

; 217  : 		::new (_Where) _Myt(_STD move(*this));

	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	push	12					; 0000000cH
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 0
	je	SHORT $LN4@Move
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$move@AAV?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@YA$$QAV?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@0@AAV10@@Z ; std::move<std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void> &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR $T1[ebp]
	call	??0?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@QAE@$$QAV01@@Z ; std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void>::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void>
	mov	DWORD PTR tv78[ebp], eax
	jmp	SHORT $LN5@Move
$LN4@Move:
	mov	DWORD PTR tv78[ebp], 0
$LN5@Move:

; 218  : 		return ((_Mybase *)_Where);

	mov	eax, DWORD PTR __Where$[ebp]

; 219  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Move@?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEPAV?$_Func_base@X$$$V@2@PAX@Z ENDP ; std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void>::_Move
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ??1?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAE@XZ PROC ; std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void>::~_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void>, COMDAT
; _this$ = ecx

; 222  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@6B@

; 223  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Func_base@X$$$V@std@@UAE@XZ	; std::_Func_base<void>::~_Func_base<void>
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAE@XZ ENDP ; std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void>::~_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ?_Do_call@?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Do_call@?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEXXZ PROC ; std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void>::_Do_call, COMDAT
; _this$ = ecx

; 226  : 		{	// call wrapped function

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 227  : 		return (_Callee.template _ApplyX<_Rx>(
; 228  : 			_STD forward<_Types>(_Args)...));

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$_ApplyX@X$$$V@?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@QAEXXZ ; std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>::_ApplyX<void>

; 229  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Do_call@?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEXXZ ENDP ; std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void>::_Do_call
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ?_Target_type@?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UBEABVtype_info@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Target_type@?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UBEABVtype_info@@XZ PROC ; std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void>::_Target_type, COMDAT
; _this$ = ecx

; 232  : 		{	// return type information for stored object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 233  : 		return (typeid(typename _Callable::_MyTy));

	mov	eax, OFFSET ??_R0?AV<lambda_e856d28dddb7588070dd099cfda6c634>@@@8

; 234  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Target_type@?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UBEABVtype_info@@XZ ENDP ; std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void>::_Target_type
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ?_Get@?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@EBEPBXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get@?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@EBEPBXXZ PROC ; std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void>::_Get, COMDAT
; _this$ = ecx

; 238  : 		{	// return address of stored object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 239  : 		return (reinterpret_cast<const void*>(&_Callee._Get()));

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?_Get@?$_Callable_base@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@QBEABV<lambda_e856d28dddb7588070dd099cfda6c634>@@XZ ; std::_Callable_base<<lambda_e856d28dddb7588070dd099cfda6c634>,0>::_Get

; 240  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Get@?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@EBEPBXXZ ENDP ; std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void>::_Get
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ?_Delete_this@?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@EAEX_N@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Al$ = -1						; size = 1
__Deallocate$ = 8					; size = 1
?_Delete_this@?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@EAEX_N@Z PROC ; std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void>::_Delete_this, COMDAT
; _this$ = ecx

; 243  : 		{	// destroy self

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 244  : 		_Myalty _Al = _Myal;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	lea	ecx, DWORD PTR __Al$[ebp]
	call	??0?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void> >::allocator<std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void> >

; 245  : 		_Al.destroy(this);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Al$[ebp]
	call	??$destroy@V?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEXPAV?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@1@@Z ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void> >::destroy<std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void> >

; 246  : 		if (_Deallocate)

	movzx	edx, BYTE PTR __Deallocate$[ebp]
	test	edx, edx
	je	SHORT $LN2@Delete_thi

; 247  : 			_Al.deallocate(this, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Al$[ebp]
	call	?deallocate@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEXPAV?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@2@I@Z ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void> >::deallocate
$LN2@Delete_thi:

; 248  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Delete_this@?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@EAEX_N@Z ENDP ; std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void>::_Delete_this
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??0?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@XZ PROC ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void> >::allocator<std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void> >, COMDAT
; _this$ = ecx

; 552  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@XZ ENDP ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void> >::allocator<std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEPAV?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEPAV?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@2@I@Z PROC ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void> >::allocate, COMDAT
; _this$ = ecx

; 577  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 578  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@V?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@YAPAV?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@0@IPAV10@@Z ; std::_Allocate<std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void> >
	add	esp, 8

; 579  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEPAV?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@2@I@Z ENDP ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ??0?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@QAE@$$QAV<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@ABV?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
__Ax$ = 12						; size = 4
??0?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@QAE@$$QAV<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@ABV?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@1@@Z PROC ; std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void>::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void>, COMDAT
; _this$ = ecx

; 192  : 		{	// construct

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Func_base@X$$$V@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@6B@
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	call	??$forward@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@@std@@YA$$QAV<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@AAV1@@Z ; std::forward<<lambda_7c9af1b141e25bc2e890d47a77a39da9> >
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@@?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@QAE@$$QAV<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@@Z ; std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0><<lambda_7c9af1b141e25bc2e890d47a77a39da9> >
	mov	edx, DWORD PTR __Ax$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void> >::allocator<std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void> >

; 193  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@QAE@$$QAV<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@ABV?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@1@@Z ENDP ; std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void>::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ?_Copy@?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEPAV?$_Func_base@X$$$V@2@PAX@Z
_TEXT	SEGMENT
tv76 = -12						; size = 4
$T1 = -8						; size = 4
_this$ = -4						; size = 4
__Where$ = 8						; size = 4
?_Copy@?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEPAV?$_Func_base@X$$$V@2@PAX@Z PROC ; std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void>::_Copy, COMDAT
; _this$ = ecx

; 206  : 		{	// return clone of *this

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 207  : 		if (_Where == 0)

	cmp	DWORD PTR __Where$[ebp], 0
	jne	SHORT $LN1@Copy

; 208  : 			_Where = _Myal.allocate(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEPAV?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@2@I@Z ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void> >::allocate
	mov	DWORD PTR __Where$[ebp], eax
$LN1@Copy:

; 209  : 		::new (_Where) _Myt(*this);

	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	push	12					; 0000000cH
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 0
	je	SHORT $LN4@Copy
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T1[ebp]
	call	??0?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@QAE@AAV01@@Z ; std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void>::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void>
	mov	DWORD PTR tv76[ebp], eax
	jmp	SHORT $LN5@Copy
$LN4@Copy:
	mov	DWORD PTR tv76[ebp], 0
$LN5@Copy:

; 210  : 		return ((_Mybase *)_Where);

	mov	eax, DWORD PTR __Where$[ebp]

; 211  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Copy@?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEPAV?$_Func_base@X$$$V@2@PAX@Z ENDP ; std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void>::_Copy
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ?_Move@?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEPAV?$_Func_base@X$$$V@2@PAX@Z
_TEXT	SEGMENT
tv78 = -12						; size = 4
$T1 = -8						; size = 4
_this$ = -4						; size = 4
__Where$ = 8						; size = 4
?_Move@?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEPAV?$_Func_base@X$$$V@2@PAX@Z PROC ; std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void>::_Move, COMDAT
; _this$ = ecx

; 214  : 		{	// return clone of *this

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 215  : 		if (_Where == 0)

	cmp	DWORD PTR __Where$[ebp], 0
	jne	SHORT $LN1@Move

; 216  : 			_Where = _Myal.allocate(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEPAV?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@2@I@Z ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void> >::allocate
	mov	DWORD PTR __Where$[ebp], eax
$LN1@Move:

; 217  : 		::new (_Where) _Myt(_STD move(*this));

	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	push	12					; 0000000cH
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 0
	je	SHORT $LN4@Move
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$move@AAV?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@YA$$QAV?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@0@AAV10@@Z ; std::move<std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void> &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR $T1[ebp]
	call	??0?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@QAE@$$QAV01@@Z ; std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void>::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void>
	mov	DWORD PTR tv78[ebp], eax
	jmp	SHORT $LN5@Move
$LN4@Move:
	mov	DWORD PTR tv78[ebp], 0
$LN5@Move:

; 218  : 		return ((_Mybase *)_Where);

	mov	eax, DWORD PTR __Where$[ebp]

; 219  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Move@?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEPAV?$_Func_base@X$$$V@2@PAX@Z ENDP ; std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void>::_Move
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ??1?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAE@XZ PROC ; std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void>::~_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void>, COMDAT
; _this$ = ecx

; 222  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@6B@

; 223  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Func_base@X$$$V@std@@UAE@XZ	; std::_Func_base<void>::~_Func_base<void>
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAE@XZ ENDP ; std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void>::~_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ?_Do_call@?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Do_call@?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEXXZ PROC ; std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void>::_Do_call, COMDAT
; _this$ = ecx

; 226  : 		{	// call wrapped function

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 227  : 		return (_Callee.template _ApplyX<_Rx>(
; 228  : 			_STD forward<_Types>(_Args)...));

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$_ApplyX@X$$$V@?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@QAEXXZ ; std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>::_ApplyX<void>

; 229  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Do_call@?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEXXZ ENDP ; std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void>::_Do_call
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ?_Target_type@?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UBEABVtype_info@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Target_type@?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UBEABVtype_info@@XZ PROC ; std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void>::_Target_type, COMDAT
; _this$ = ecx

; 232  : 		{	// return type information for stored object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 233  : 		return (typeid(typename _Callable::_MyTy));

	mov	eax, OFFSET ??_R0?AV<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@@8

; 234  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Target_type@?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UBEABVtype_info@@XZ ENDP ; std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void>::_Target_type
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ?_Get@?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@EBEPBXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get@?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@EBEPBXXZ PROC ; std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void>::_Get, COMDAT
; _this$ = ecx

; 238  : 		{	// return address of stored object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 239  : 		return (reinterpret_cast<const void*>(&_Callee._Get()));

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?_Get@?$_Callable_base@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@QBEABV<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@XZ ; std::_Callable_base<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>::_Get

; 240  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Get@?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@EBEPBXXZ ENDP ; std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void>::_Get
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ?_Delete_this@?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@EAEX_N@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Al$ = -1						; size = 1
__Deallocate$ = 8					; size = 1
?_Delete_this@?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@EAEX_N@Z PROC ; std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void>::_Delete_this, COMDAT
; _this$ = ecx

; 243  : 		{	// destroy self

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 244  : 		_Myalty _Al = _Myal;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	lea	ecx, DWORD PTR __Al$[ebp]
	call	??0?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void> >::allocator<std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void> >

; 245  : 		_Al.destroy(this);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Al$[ebp]
	call	??$destroy@V?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEXPAV?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@1@@Z ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void> >::destroy<std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void> >

; 246  : 		if (_Deallocate)

	movzx	edx, BYTE PTR __Deallocate$[ebp]
	test	edx, edx
	je	SHORT $LN2@Delete_thi

; 247  : 			_Al.deallocate(this, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Al$[ebp]
	call	?deallocate@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEXPAV?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@2@I@Z ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void> >::deallocate
$LN2@Delete_thi:

; 248  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Delete_this@?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@EAEX_N@Z ENDP ; std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void>::_Delete_this
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??0?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@XZ PROC ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void> >::allocator<std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void> >, COMDAT
; _this$ = ecx

; 552  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@XZ ENDP ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void> >::allocator<std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEPAV?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEPAV?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@2@I@Z PROC ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void> >::allocate, COMDAT
; _this$ = ecx

; 577  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 578  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@V?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@YAPAV?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@0@IPAV10@@Z ; std::_Allocate<std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void> >
	add	esp, 8

; 579  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEPAV?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@2@I@Z ENDP ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ??0?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@QAE@$$QAV<lambda_3b020cec0f1508adac4c896f138918cf>@@ABV?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
__Ax$ = 12						; size = 4
??0?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@QAE@$$QAV<lambda_3b020cec0f1508adac4c896f138918cf>@@ABV?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@1@@Z PROC ; std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void>::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void>, COMDAT
; _this$ = ecx

; 192  : 		{	// construct

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Func_base@X$$$V@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@6B@
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	call	??$forward@V<lambda_3b020cec0f1508adac4c896f138918cf>@@@std@@YA$$QAV<lambda_3b020cec0f1508adac4c896f138918cf>@@AAV1@@Z ; std::forward<<lambda_3b020cec0f1508adac4c896f138918cf> >
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0V<lambda_3b020cec0f1508adac4c896f138918cf>@@@?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@QAE@$$QAV<lambda_3b020cec0f1508adac4c896f138918cf>@@@Z ; std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0><<lambda_3b020cec0f1508adac4c896f138918cf> >
	mov	edx, DWORD PTR __Ax$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void> >::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void> >

; 193  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@QAE@$$QAV<lambda_3b020cec0f1508adac4c896f138918cf>@@ABV?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@1@@Z ENDP ; std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void>::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ?_Copy@?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEPAV?$_Func_base@X$$$V@2@PAX@Z
_TEXT	SEGMENT
tv76 = -12						; size = 4
$T1 = -8						; size = 4
_this$ = -4						; size = 4
__Where$ = 8						; size = 4
?_Copy@?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEPAV?$_Func_base@X$$$V@2@PAX@Z PROC ; std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void>::_Copy, COMDAT
; _this$ = ecx

; 206  : 		{	// return clone of *this

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 207  : 		if (_Where == 0)

	cmp	DWORD PTR __Where$[ebp], 0
	jne	SHORT $LN1@Copy

; 208  : 			_Where = _Myal.allocate(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEPAV?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@2@I@Z ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void> >::allocate
	mov	DWORD PTR __Where$[ebp], eax
$LN1@Copy:

; 209  : 		::new (_Where) _Myt(*this);

	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	push	12					; 0000000cH
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 0
	je	SHORT $LN4@Copy
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T1[ebp]
	call	??0?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@QAE@AAV01@@Z ; std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void>::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void>
	mov	DWORD PTR tv76[ebp], eax
	jmp	SHORT $LN5@Copy
$LN4@Copy:
	mov	DWORD PTR tv76[ebp], 0
$LN5@Copy:

; 210  : 		return ((_Mybase *)_Where);

	mov	eax, DWORD PTR __Where$[ebp]

; 211  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Copy@?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEPAV?$_Func_base@X$$$V@2@PAX@Z ENDP ; std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void>::_Copy
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ?_Move@?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEPAV?$_Func_base@X$$$V@2@PAX@Z
_TEXT	SEGMENT
tv78 = -12						; size = 4
$T1 = -8						; size = 4
_this$ = -4						; size = 4
__Where$ = 8						; size = 4
?_Move@?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEPAV?$_Func_base@X$$$V@2@PAX@Z PROC ; std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void>::_Move, COMDAT
; _this$ = ecx

; 214  : 		{	// return clone of *this

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 215  : 		if (_Where == 0)

	cmp	DWORD PTR __Where$[ebp], 0
	jne	SHORT $LN1@Move

; 216  : 			_Where = _Myal.allocate(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEPAV?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@2@I@Z ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void> >::allocate
	mov	DWORD PTR __Where$[ebp], eax
$LN1@Move:

; 217  : 		::new (_Where) _Myt(_STD move(*this));

	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	push	12					; 0000000cH
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 0
	je	SHORT $LN4@Move
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$move@AAV?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@YA$$QAV?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@0@AAV10@@Z ; std::move<std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void> &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR $T1[ebp]
	call	??0?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@QAE@$$QAV01@@Z ; std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void>::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void>
	mov	DWORD PTR tv78[ebp], eax
	jmp	SHORT $LN5@Move
$LN4@Move:
	mov	DWORD PTR tv78[ebp], 0
$LN5@Move:

; 218  : 		return ((_Mybase *)_Where);

	mov	eax, DWORD PTR __Where$[ebp]

; 219  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Move@?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEPAV?$_Func_base@X$$$V@2@PAX@Z ENDP ; std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void>::_Move
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ??1?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAE@XZ PROC ; std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void>::~_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void>, COMDAT
; _this$ = ecx

; 222  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@6B@

; 223  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Func_base@X$$$V@std@@UAE@XZ	; std::_Func_base<void>::~_Func_base<void>
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAE@XZ ENDP ; std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void>::~_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ?_Do_call@?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Do_call@?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEXXZ PROC ; std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void>::_Do_call, COMDAT
; _this$ = ecx

; 226  : 		{	// call wrapped function

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 227  : 		return (_Callee.template _ApplyX<_Rx>(
; 228  : 			_STD forward<_Types>(_Args)...));

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$_ApplyX@X$$$V@?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@QAEXXZ ; std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>::_ApplyX<void>

; 229  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Do_call@?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEXXZ ENDP ; std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void>::_Do_call
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ?_Target_type@?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UBEABVtype_info@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Target_type@?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UBEABVtype_info@@XZ PROC ; std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void>::_Target_type, COMDAT
; _this$ = ecx

; 232  : 		{	// return type information for stored object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 233  : 		return (typeid(typename _Callable::_MyTy));

	mov	eax, OFFSET ??_R0?AV<lambda_3b020cec0f1508adac4c896f138918cf>@@@8

; 234  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Target_type@?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UBEABVtype_info@@XZ ENDP ; std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void>::_Target_type
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ?_Get@?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@EBEPBXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get@?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@EBEPBXXZ PROC ; std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void>::_Get, COMDAT
; _this$ = ecx

; 238  : 		{	// return address of stored object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 239  : 		return (reinterpret_cast<const void*>(&_Callee._Get()));

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?_Get@?$_Callable_base@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@QBEABV<lambda_3b020cec0f1508adac4c896f138918cf>@@XZ ; std::_Callable_base<<lambda_3b020cec0f1508adac4c896f138918cf>,0>::_Get

; 240  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Get@?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@EBEPBXXZ ENDP ; std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void>::_Get
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ?_Delete_this@?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@EAEX_N@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Al$ = -1						; size = 1
__Deallocate$ = 8					; size = 1
?_Delete_this@?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@EAEX_N@Z PROC ; std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void>::_Delete_this, COMDAT
; _this$ = ecx

; 243  : 		{	// destroy self

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 244  : 		_Myalty _Al = _Myal;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	lea	ecx, DWORD PTR __Al$[ebp]
	call	??0?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void> >::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void> >

; 245  : 		_Al.destroy(this);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Al$[ebp]
	call	??$destroy@V?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEXPAV?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@1@@Z ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void> >::destroy<std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void> >

; 246  : 		if (_Deallocate)

	movzx	edx, BYTE PTR __Deallocate$[ebp]
	test	edx, edx
	je	SHORT $LN2@Delete_thi

; 247  : 			_Al.deallocate(this, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Al$[ebp]
	call	?deallocate@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEXPAV?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@2@I@Z ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void> >::deallocate
$LN2@Delete_thi:

; 248  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Delete_this@?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@EAEX_N@Z ENDP ; std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void>::_Delete_this
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??0?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@XZ PROC ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void> >::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void> >, COMDAT
; _this$ = ecx

; 552  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@XZ ENDP ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void> >::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEPAV?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEPAV?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@2@I@Z PROC ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void> >::allocate, COMDAT
; _this$ = ecx

; 577  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 578  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@V?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@YAPAV?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@0@IPAV10@@Z ; std::_Allocate<std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void> >
	add	esp, 8

; 579  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEPAV?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@2@I@Z ENDP ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ??0?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@QAE@$$QAV<lambda_3648d362fc95221bbf9c4c4a922d1611>@@ABV?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
__Ax$ = 12						; size = 4
??0?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@QAE@$$QAV<lambda_3648d362fc95221bbf9c4c4a922d1611>@@ABV?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@1@@Z PROC ; std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void>::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void>, COMDAT
; _this$ = ecx

; 192  : 		{	// construct

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Func_base@X$$$V@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@6B@
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	call	??$forward@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@@std@@YA$$QAV<lambda_3648d362fc95221bbf9c4c4a922d1611>@@AAV1@@Z ; std::forward<<lambda_3648d362fc95221bbf9c4c4a922d1611> >
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@@?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@QAE@$$QAV<lambda_3648d362fc95221bbf9c4c4a922d1611>@@@Z ; std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0><<lambda_3648d362fc95221bbf9c4c4a922d1611> >
	mov	edx, DWORD PTR __Ax$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void> >::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void> >

; 193  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@QAE@$$QAV<lambda_3648d362fc95221bbf9c4c4a922d1611>@@ABV?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@1@@Z ENDP ; std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void>::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ?_Copy@?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEPAV?$_Func_base@X$$$V@2@PAX@Z
_TEXT	SEGMENT
tv76 = -12						; size = 4
$T1 = -8						; size = 4
_this$ = -4						; size = 4
__Where$ = 8						; size = 4
?_Copy@?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEPAV?$_Func_base@X$$$V@2@PAX@Z PROC ; std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void>::_Copy, COMDAT
; _this$ = ecx

; 206  : 		{	// return clone of *this

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 207  : 		if (_Where == 0)

	cmp	DWORD PTR __Where$[ebp], 0
	jne	SHORT $LN1@Copy

; 208  : 			_Where = _Myal.allocate(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEPAV?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@2@I@Z ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void> >::allocate
	mov	DWORD PTR __Where$[ebp], eax
$LN1@Copy:

; 209  : 		::new (_Where) _Myt(*this);

	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	push	12					; 0000000cH
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 0
	je	SHORT $LN4@Copy
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T1[ebp]
	call	??0?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@QAE@AAV01@@Z ; std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void>::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void>
	mov	DWORD PTR tv76[ebp], eax
	jmp	SHORT $LN5@Copy
$LN4@Copy:
	mov	DWORD PTR tv76[ebp], 0
$LN5@Copy:

; 210  : 		return ((_Mybase *)_Where);

	mov	eax, DWORD PTR __Where$[ebp]

; 211  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Copy@?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEPAV?$_Func_base@X$$$V@2@PAX@Z ENDP ; std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void>::_Copy
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ?_Move@?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEPAV?$_Func_base@X$$$V@2@PAX@Z
_TEXT	SEGMENT
tv78 = -12						; size = 4
$T1 = -8						; size = 4
_this$ = -4						; size = 4
__Where$ = 8						; size = 4
?_Move@?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEPAV?$_Func_base@X$$$V@2@PAX@Z PROC ; std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void>::_Move, COMDAT
; _this$ = ecx

; 214  : 		{	// return clone of *this

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 215  : 		if (_Where == 0)

	cmp	DWORD PTR __Where$[ebp], 0
	jne	SHORT $LN1@Move

; 216  : 			_Where = _Myal.allocate(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEPAV?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@2@I@Z ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void> >::allocate
	mov	DWORD PTR __Where$[ebp], eax
$LN1@Move:

; 217  : 		::new (_Where) _Myt(_STD move(*this));

	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	push	12					; 0000000cH
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 0
	je	SHORT $LN4@Move
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$move@AAV?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@YA$$QAV?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@0@AAV10@@Z ; std::move<std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void> &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR $T1[ebp]
	call	??0?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@QAE@$$QAV01@@Z ; std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void>::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void>
	mov	DWORD PTR tv78[ebp], eax
	jmp	SHORT $LN5@Move
$LN4@Move:
	mov	DWORD PTR tv78[ebp], 0
$LN5@Move:

; 218  : 		return ((_Mybase *)_Where);

	mov	eax, DWORD PTR __Where$[ebp]

; 219  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Move@?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEPAV?$_Func_base@X$$$V@2@PAX@Z ENDP ; std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void>::_Move
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ??1?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAE@XZ PROC ; std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void>::~_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void>, COMDAT
; _this$ = ecx

; 222  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@6B@

; 223  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Func_base@X$$$V@std@@UAE@XZ	; std::_Func_base<void>::~_Func_base<void>
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAE@XZ ENDP ; std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void>::~_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ?_Do_call@?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Do_call@?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEXXZ PROC ; std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void>::_Do_call, COMDAT
; _this$ = ecx

; 226  : 		{	// call wrapped function

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 227  : 		return (_Callee.template _ApplyX<_Rx>(
; 228  : 			_STD forward<_Types>(_Args)...));

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$_ApplyX@X$$$V@?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@QAEXXZ ; std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>::_ApplyX<void>

; 229  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Do_call@?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEXXZ ENDP ; std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void>::_Do_call
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ?_Target_type@?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UBEABVtype_info@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Target_type@?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UBEABVtype_info@@XZ PROC ; std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void>::_Target_type, COMDAT
; _this$ = ecx

; 232  : 		{	// return type information for stored object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 233  : 		return (typeid(typename _Callable::_MyTy));

	mov	eax, OFFSET ??_R0?AV<lambda_3648d362fc95221bbf9c4c4a922d1611>@@@8

; 234  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Target_type@?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UBEABVtype_info@@XZ ENDP ; std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void>::_Target_type
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ?_Get@?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@EBEPBXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get@?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@EBEPBXXZ PROC ; std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void>::_Get, COMDAT
; _this$ = ecx

; 238  : 		{	// return address of stored object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 239  : 		return (reinterpret_cast<const void*>(&_Callee._Get()));

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?_Get@?$_Callable_base@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@QBEABV<lambda_3648d362fc95221bbf9c4c4a922d1611>@@XZ ; std::_Callable_base<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>::_Get

; 240  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Get@?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@EBEPBXXZ ENDP ; std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void>::_Get
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ?_Delete_this@?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@EAEX_N@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Al$ = -1						; size = 1
__Deallocate$ = 8					; size = 1
?_Delete_this@?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@EAEX_N@Z PROC ; std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void>::_Delete_this, COMDAT
; _this$ = ecx

; 243  : 		{	// destroy self

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 244  : 		_Myalty _Al = _Myal;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	lea	ecx, DWORD PTR __Al$[ebp]
	call	??0?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void> >::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void> >

; 245  : 		_Al.destroy(this);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Al$[ebp]
	call	??$destroy@V?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEXPAV?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@1@@Z ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void> >::destroy<std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void> >

; 246  : 		if (_Deallocate)

	movzx	edx, BYTE PTR __Deallocate$[ebp]
	test	edx, edx
	je	SHORT $LN2@Delete_thi

; 247  : 			_Al.deallocate(this, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Al$[ebp]
	call	?deallocate@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEXPAV?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@2@I@Z ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void> >::deallocate
$LN2@Delete_thi:

; 248  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Delete_this@?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@EAEX_N@Z ENDP ; std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void>::_Delete_this
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??0?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@XZ PROC ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void> >::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void> >, COMDAT
; _this$ = ecx

; 552  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@XZ ENDP ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void> >::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEPAV?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEPAV?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@2@I@Z PROC ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void> >::allocate, COMDAT
; _this$ = ecx

; 577  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 578  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@V?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@YAPAV?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@0@IPAV10@@Z ; std::_Allocate<std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void> >
	add	esp, 8

; 579  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEPAV?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@2@I@Z ENDP ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEPAXI@Z PROC ; std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void>::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAE@XZ ; std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void>::~_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void>
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEPAXI@Z ENDP ; std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEPAXI@Z PROC ; std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void>::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAE@XZ ; std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void>::~_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void>
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEPAXI@Z ENDP ; std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEPAXI@Z PROC ; std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void>::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAE@XZ ; std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void>::~_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void>
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEPAXI@Z ENDP ; std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0?$_Func_base@X$$$V@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Func_base@X$$$V@std@@QAE@XZ PROC			; std::_Func_base<void>::_Func_base<void>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7?$_Func_base@X$$$V@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Func_base@X$$$V@std@@QAE@XZ ENDP			; std::_Func_base<void>::_Func_base<void>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEPAXI@Z PROC ; std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void>::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAE@XZ ; std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void>::~_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void>
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEPAXI@Z ENDP ; std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEPAXI@Z PROC ; std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void>::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAE@XZ ; std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void>::~_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void>
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@UAEPAXI@Z ENDP ; std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ??0?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@QAE@AAV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??0?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@QAE@AAV01@@Z PROC ; std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void>::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void>, COMDAT
; _this$ = ecx

; 180  : 		{	// copy construct

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Func_base@X$$$V@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@6B@
	mov	ecx, DWORD PTR __Right$[ebp]
	add	ecx, 4
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0AAU?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@@?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@QAE@AAU01@@Z ; std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0><std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0> &>
	mov	edx, DWORD PTR __Right$[ebp]
	add	edx, 8
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void> >::allocator<std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void> >

; 181  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@QAE@AAV01@@Z ENDP ; std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void>::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ??0?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??0?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@QAE@$$QAV01@@Z PROC ; std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void>::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void>, COMDAT
; _this$ = ecx

; 186  : 		{	// move construct

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Func_base@X$$$V@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@6B@
	mov	ecx, DWORD PTR __Right$[ebp]
	add	ecx, 4
	push	ecx
	call	??$forward@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@@std@@YA$$QAU?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@0@AAU10@@Z ; std::forward<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0> >
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@@?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@QAE@$$QAU01@@Z ; std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0><std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0> >
	mov	edx, DWORD PTR __Right$[ebp]
	add	edx, 8
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void> >::allocator<std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void> >

; 187  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@QAE@$$QAV01@@Z ENDP ; std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void>::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xrefwrap
;	COMDAT ?_Get@?$_Callable_base@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@QBEABV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get@?$_Callable_base@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@QBEABV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@XZ PROC ; std::_Callable_base<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>::_Get, COMDAT
; _this$ = ecx

; 179  : 		{	// return reference to stored object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 180  : 		return (_Object);

	mov	eax, DWORD PTR _this$[ebp]

; 181  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Get@?$_Callable_base@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@QBEABV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@XZ ENDP ; std::_Callable_base<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>::_Get
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??0?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void> >::allocator<std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void> >, COMDAT
; _this$ = ecx

; 556  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 557  : 		{	// construct by copying (do nothing)
; 558  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void> >::allocator<std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEXPAV?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEXPAV?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@2@I@Z PROC ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void> >::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 573  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 574  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEXPAV?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@2@I@Z ENDP ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ??0?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@QAE@AAV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??0?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@QAE@AAV01@@Z PROC ; std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void>::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void>, COMDAT
; _this$ = ecx

; 180  : 		{	// copy construct

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Func_base@X$$$V@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@6B@
	mov	ecx, DWORD PTR __Right$[ebp]
	add	ecx, 4
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0AAU?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@@?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@QAE@AAU01@@Z ; std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0><std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0> &>
	mov	edx, DWORD PTR __Right$[ebp]
	add	edx, 8
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void> >::allocator<std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void> >

; 181  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@QAE@AAV01@@Z ENDP ; std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void>::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ??0?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??0?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@QAE@$$QAV01@@Z PROC ; std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void>::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void>, COMDAT
; _this$ = ecx

; 186  : 		{	// move construct

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Func_base@X$$$V@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@6B@
	mov	ecx, DWORD PTR __Right$[ebp]
	add	ecx, 4
	push	ecx
	call	??$forward@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@@std@@YA$$QAU?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@0@AAU10@@Z ; std::forward<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0> >
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@@?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@QAE@$$QAU01@@Z ; std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0><std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0> >
	mov	edx, DWORD PTR __Right$[ebp]
	add	edx, 8
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void> >::allocator<std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void> >

; 187  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@QAE@$$QAV01@@Z ENDP ; std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void>::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xrefwrap
;	COMDAT ?_Get@?$_Callable_base@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@QBEABV<lambda_e856d28dddb7588070dd099cfda6c634>@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get@?$_Callable_base@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@QBEABV<lambda_e856d28dddb7588070dd099cfda6c634>@@XZ PROC ; std::_Callable_base<<lambda_e856d28dddb7588070dd099cfda6c634>,0>::_Get, COMDAT
; _this$ = ecx

; 179  : 		{	// return reference to stored object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 180  : 		return (_Object);

	mov	eax, DWORD PTR _this$[ebp]

; 181  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Get@?$_Callable_base@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@QBEABV<lambda_e856d28dddb7588070dd099cfda6c634>@@XZ ENDP ; std::_Callable_base<<lambda_e856d28dddb7588070dd099cfda6c634>,0>::_Get
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??0?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void> >::allocator<std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void> >, COMDAT
; _this$ = ecx

; 556  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 557  : 		{	// construct by copying (do nothing)
; 558  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void> >::allocator<std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEXPAV?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEXPAV?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@2@I@Z PROC ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void> >::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 573  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 574  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEXPAV?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@2@I@Z ENDP ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ??0?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@QAE@AAV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??0?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@QAE@AAV01@@Z PROC ; std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void>::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void>, COMDAT
; _this$ = ecx

; 180  : 		{	// copy construct

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Func_base@X$$$V@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@6B@
	mov	ecx, DWORD PTR __Right$[ebp]
	add	ecx, 4
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0AAU?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@@?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@QAE@AAU01@@Z ; std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0><std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0> &>
	mov	edx, DWORD PTR __Right$[ebp]
	add	edx, 8
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void> >::allocator<std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void> >

; 181  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@QAE@AAV01@@Z ENDP ; std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void>::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ??0?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??0?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@QAE@$$QAV01@@Z PROC ; std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void>::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void>, COMDAT
; _this$ = ecx

; 186  : 		{	// move construct

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Func_base@X$$$V@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@6B@
	mov	ecx, DWORD PTR __Right$[ebp]
	add	ecx, 4
	push	ecx
	call	??$forward@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@@std@@YA$$QAU?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@0@AAU10@@Z ; std::forward<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0> >
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@@?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@QAE@$$QAU01@@Z ; std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0><std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0> >
	mov	edx, DWORD PTR __Right$[ebp]
	add	edx, 8
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void> >::allocator<std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void> >

; 187  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@QAE@$$QAV01@@Z ENDP ; std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void>::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xrefwrap
;	COMDAT ?_Get@?$_Callable_base@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@QBEABV<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get@?$_Callable_base@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@QBEABV<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@XZ PROC ; std::_Callable_base<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>::_Get, COMDAT
; _this$ = ecx

; 179  : 		{	// return reference to stored object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 180  : 		return (_Object);

	mov	eax, DWORD PTR _this$[ebp]

; 181  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Get@?$_Callable_base@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@QBEABV<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@XZ ENDP ; std::_Callable_base<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>::_Get
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??0?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void> >::allocator<std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void> >, COMDAT
; _this$ = ecx

; 556  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 557  : 		{	// construct by copying (do nothing)
; 558  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void> >::allocator<std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEXPAV?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEXPAV?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@2@I@Z PROC ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void> >::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 573  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 574  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEXPAV?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@2@I@Z ENDP ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ??0?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@QAE@AAV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??0?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@QAE@AAV01@@Z PROC ; std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void>::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void>, COMDAT
; _this$ = ecx

; 180  : 		{	// copy construct

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Func_base@X$$$V@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@6B@
	mov	ecx, DWORD PTR __Right$[ebp]
	add	ecx, 4
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0AAU?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@@?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@QAE@AAU01@@Z ; std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0><std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0> &>
	mov	edx, DWORD PTR __Right$[ebp]
	add	edx, 8
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void> >::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void> >

; 181  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@QAE@AAV01@@Z ENDP ; std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void>::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ??0?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??0?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@QAE@$$QAV01@@Z PROC ; std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void>::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void>, COMDAT
; _this$ = ecx

; 186  : 		{	// move construct

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Func_base@X$$$V@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@6B@
	mov	ecx, DWORD PTR __Right$[ebp]
	add	ecx, 4
	push	ecx
	call	??$forward@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@@std@@YA$$QAU?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@0@AAU10@@Z ; std::forward<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0> >
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@@?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@QAE@$$QAU01@@Z ; std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0><std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0> >
	mov	edx, DWORD PTR __Right$[ebp]
	add	edx, 8
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void> >::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void> >

; 187  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@QAE@$$QAV01@@Z ENDP ; std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void>::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xrefwrap
;	COMDAT ?_Get@?$_Callable_base@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@QBEABV<lambda_3b020cec0f1508adac4c896f138918cf>@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get@?$_Callable_base@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@QBEABV<lambda_3b020cec0f1508adac4c896f138918cf>@@XZ PROC ; std::_Callable_base<<lambda_3b020cec0f1508adac4c896f138918cf>,0>::_Get, COMDAT
; _this$ = ecx

; 179  : 		{	// return reference to stored object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 180  : 		return (_Object);

	mov	eax, DWORD PTR _this$[ebp]

; 181  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Get@?$_Callable_base@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@QBEABV<lambda_3b020cec0f1508adac4c896f138918cf>@@XZ ENDP ; std::_Callable_base<<lambda_3b020cec0f1508adac4c896f138918cf>,0>::_Get
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??0?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void> >::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void> >, COMDAT
; _this$ = ecx

; 556  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 557  : 		{	// construct by copying (do nothing)
; 558  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void> >::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEXPAV?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEXPAV?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@2@I@Z PROC ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void> >::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 573  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 574  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEXPAV?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@2@I@Z ENDP ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ??0?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@QAE@AAV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??0?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@QAE@AAV01@@Z PROC ; std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void>::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void>, COMDAT
; _this$ = ecx

; 180  : 		{	// copy construct

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Func_base@X$$$V@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@6B@
	mov	ecx, DWORD PTR __Right$[ebp]
	add	ecx, 4
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0AAU?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@@?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@QAE@AAU01@@Z ; std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0><std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0> &>
	mov	edx, DWORD PTR __Right$[ebp]
	add	edx, 8
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void> >::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void> >

; 181  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@QAE@AAV01@@Z ENDP ; std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void>::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ??0?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??0?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@QAE@$$QAV01@@Z PROC ; std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void>::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void>, COMDAT
; _this$ = ecx

; 186  : 		{	// move construct

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Func_base@X$$$V@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@6B@
	mov	ecx, DWORD PTR __Right$[ebp]
	add	ecx, 4
	push	ecx
	call	??$forward@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@@std@@YA$$QAU?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@0@AAU10@@Z ; std::forward<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0> >
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@@?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@QAE@$$QAU01@@Z ; std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0><std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0> >
	mov	edx, DWORD PTR __Right$[ebp]
	add	edx, 8
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void> >::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void> >

; 187  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@QAE@$$QAV01@@Z ENDP ; std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void>::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xrefwrap
;	COMDAT ?_Get@?$_Callable_base@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@QBEABV<lambda_3648d362fc95221bbf9c4c4a922d1611>@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get@?$_Callable_base@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@QBEABV<lambda_3648d362fc95221bbf9c4c4a922d1611>@@XZ PROC ; std::_Callable_base<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>::_Get, COMDAT
; _this$ = ecx

; 179  : 		{	// return reference to stored object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 180  : 		return (_Object);

	mov	eax, DWORD PTR _this$[ebp]

; 181  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Get@?$_Callable_base@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@QBEABV<lambda_3648d362fc95221bbf9c4c4a922d1611>@@XZ ENDP ; std::_Callable_base<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>::_Get
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??0?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void> >::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void> >, COMDAT
; _this$ = ecx

; 556  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 557  : 		{	// construct by copying (do nothing)
; 558  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void> >::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEXPAV?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEXPAV?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@2@I@Z PROC ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void> >::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 573  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 574  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEXPAV?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@2@I@Z ENDP ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ??$_Test_callable@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@@std@@YA_NAAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__Arg$ = 8						; size = 4
??$_Test_callable@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@@std@@YA_NAAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@@Z PROC ; std::_Test_callable<<lambda_582637cdd8d6a2f689bc987be9ec55df> >, COMDAT

; 291  : 	{	// determine whether std::function must store _Arg

	push	ebp
	mov	ebp, esp
	push	ecx

; 292  : 	return (_Test_callable(_Arg, _Testable_callable<_Ty>()));

	movzx	eax, BYTE PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR __Arg$[ebp]
	push	ecx
	call	??$_Test_callable@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@@std@@YA_NAAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@U?$integral_constant@_N$0A@@0@@Z ; std::_Test_callable<<lambda_582637cdd8d6a2f689bc987be9ec55df> >
	add	esp, 8

; 293  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Test_callable@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@@std@@YA_NAAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@@Z ENDP ; std::_Test_callable<<lambda_582637cdd8d6a2f689bc987be9ec55df> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ??$?0AAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@@?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@QAE@AAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@ABV?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
__Ax$ = 12						; size = 4
??$?0AAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@@?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@QAE@AAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@ABV?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@1@@Z PROC ; std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void>::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void><<lambda_582637cdd8d6a2f689bc987be9ec55df> &>, COMDAT
; _this$ = ecx

; 202  : 		{	// construct

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Func_base@X$$$V@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@6B@
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	call	??$forward@AAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@@std@@YAAAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@AAV1@@Z ; std::forward<<lambda_582637cdd8d6a2f689bc987be9ec55df> &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0AAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@@?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@QAE@AAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@@Z ; std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0><<lambda_582637cdd8d6a2f689bc987be9ec55df> &>
	mov	edx, DWORD PTR __Ax$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void> >::allocator<std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void> >

; 203  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??$?0AAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@@?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@QAE@AAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@ABV?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@1@@Z ENDP ; std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void>::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void><<lambda_582637cdd8d6a2f689bc987be9ec55df> &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$?0V?$_Func_class@X$$$V@std@@@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@ABV?$allocator@V?$_Func_class@X$$$V@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0V?$_Func_class@X$$$V@std@@@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@ABV?$allocator@V?$_Func_class@X$$$V@std@@@1@@Z PROC ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void> >::allocator<std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void> ><std::_Func_class<void> >, COMDAT
; _this$ = ecx

; 561  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 562  : 		{	// construct from a related allocator (do nothing)
; 563  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0V?$_Func_class@X$$$V@std@@@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@ABV?$allocator@V?$_Func_class@X$$$V@std@@@1@@Z ENDP ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void> >::allocator<std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void> ><std::_Func_class<void> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ??$_Test_callable@V<lambda_e856d28dddb7588070dd099cfda6c634>@@@std@@YA_NAAV<lambda_e856d28dddb7588070dd099cfda6c634>@@@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__Arg$ = 8						; size = 4
??$_Test_callable@V<lambda_e856d28dddb7588070dd099cfda6c634>@@@std@@YA_NAAV<lambda_e856d28dddb7588070dd099cfda6c634>@@@Z PROC ; std::_Test_callable<<lambda_e856d28dddb7588070dd099cfda6c634> >, COMDAT

; 291  : 	{	// determine whether std::function must store _Arg

	push	ebp
	mov	ebp, esp
	push	ecx

; 292  : 	return (_Test_callable(_Arg, _Testable_callable<_Ty>()));

	movzx	eax, BYTE PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR __Arg$[ebp]
	push	ecx
	call	??$_Test_callable@V<lambda_e856d28dddb7588070dd099cfda6c634>@@@std@@YA_NAAV<lambda_e856d28dddb7588070dd099cfda6c634>@@U?$integral_constant@_N$0A@@0@@Z ; std::_Test_callable<<lambda_e856d28dddb7588070dd099cfda6c634> >
	add	esp, 8

; 293  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Test_callable@V<lambda_e856d28dddb7588070dd099cfda6c634>@@@std@@YA_NAAV<lambda_e856d28dddb7588070dd099cfda6c634>@@@Z ENDP ; std::_Test_callable<<lambda_e856d28dddb7588070dd099cfda6c634> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ??$?0AAV<lambda_e856d28dddb7588070dd099cfda6c634>@@@?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@QAE@AAV<lambda_e856d28dddb7588070dd099cfda6c634>@@ABV?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
__Ax$ = 12						; size = 4
??$?0AAV<lambda_e856d28dddb7588070dd099cfda6c634>@@@?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@QAE@AAV<lambda_e856d28dddb7588070dd099cfda6c634>@@ABV?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@1@@Z PROC ; std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void>::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void><<lambda_e856d28dddb7588070dd099cfda6c634> &>, COMDAT
; _this$ = ecx

; 202  : 		{	// construct

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Func_base@X$$$V@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@6B@
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	call	??$forward@AAV<lambda_e856d28dddb7588070dd099cfda6c634>@@@std@@YAAAV<lambda_e856d28dddb7588070dd099cfda6c634>@@AAV1@@Z ; std::forward<<lambda_e856d28dddb7588070dd099cfda6c634> &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0AAV<lambda_e856d28dddb7588070dd099cfda6c634>@@@?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@QAE@AAV<lambda_e856d28dddb7588070dd099cfda6c634>@@@Z ; std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0><<lambda_e856d28dddb7588070dd099cfda6c634> &>
	mov	edx, DWORD PTR __Ax$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void> >::allocator<std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void> >

; 203  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??$?0AAV<lambda_e856d28dddb7588070dd099cfda6c634>@@@?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@QAE@AAV<lambda_e856d28dddb7588070dd099cfda6c634>@@ABV?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@1@@Z ENDP ; std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void>::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void><<lambda_e856d28dddb7588070dd099cfda6c634> &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$?0V?$_Func_class@X$$$V@std@@@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@ABV?$allocator@V?$_Func_class@X$$$V@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0V?$_Func_class@X$$$V@std@@@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@ABV?$allocator@V?$_Func_class@X$$$V@std@@@1@@Z PROC ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void> >::allocator<std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void> ><std::_Func_class<void> >, COMDAT
; _this$ = ecx

; 561  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 562  : 		{	// construct from a related allocator (do nothing)
; 563  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0V?$_Func_class@X$$$V@std@@@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@ABV?$allocator@V?$_Func_class@X$$$V@std@@@1@@Z ENDP ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void> >::allocator<std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void> ><std::_Func_class<void> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ??$_Test_callable@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@@std@@YA_NAAV<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__Arg$ = 8						; size = 4
??$_Test_callable@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@@std@@YA_NAAV<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@@Z PROC ; std::_Test_callable<<lambda_7c9af1b141e25bc2e890d47a77a39da9> >, COMDAT

; 291  : 	{	// determine whether std::function must store _Arg

	push	ebp
	mov	ebp, esp
	push	ecx

; 292  : 	return (_Test_callable(_Arg, _Testable_callable<_Ty>()));

	movzx	eax, BYTE PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR __Arg$[ebp]
	push	ecx
	call	??$_Test_callable@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@@std@@YA_NAAV<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@U?$integral_constant@_N$0A@@0@@Z ; std::_Test_callable<<lambda_7c9af1b141e25bc2e890d47a77a39da9> >
	add	esp, 8

; 293  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Test_callable@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@@std@@YA_NAAV<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@@Z ENDP ; std::_Test_callable<<lambda_7c9af1b141e25bc2e890d47a77a39da9> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$?0V?$_Func_class@X$$$V@std@@@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@ABV?$allocator@V?$_Func_class@X$$$V@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0V?$_Func_class@X$$$V@std@@@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@ABV?$allocator@V?$_Func_class@X$$$V@std@@@1@@Z PROC ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void> >::allocator<std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void> ><std::_Func_class<void> >, COMDAT
; _this$ = ecx

; 561  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 562  : 		{	// construct from a related allocator (do nothing)
; 563  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0V?$_Func_class@X$$$V@std@@@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@ABV?$allocator@V?$_Func_class@X$$$V@std@@@1@@Z ENDP ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void> >::allocator<std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void> ><std::_Func_class<void> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ??$_Test_callable@V<lambda_3b020cec0f1508adac4c896f138918cf>@@@std@@YA_NAAV<lambda_3b020cec0f1508adac4c896f138918cf>@@@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__Arg$ = 8						; size = 4
??$_Test_callable@V<lambda_3b020cec0f1508adac4c896f138918cf>@@@std@@YA_NAAV<lambda_3b020cec0f1508adac4c896f138918cf>@@@Z PROC ; std::_Test_callable<<lambda_3b020cec0f1508adac4c896f138918cf> >, COMDAT

; 291  : 	{	// determine whether std::function must store _Arg

	push	ebp
	mov	ebp, esp
	push	ecx

; 292  : 	return (_Test_callable(_Arg, _Testable_callable<_Ty>()));

	movzx	eax, BYTE PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR __Arg$[ebp]
	push	ecx
	call	??$_Test_callable@V<lambda_3b020cec0f1508adac4c896f138918cf>@@@std@@YA_NAAV<lambda_3b020cec0f1508adac4c896f138918cf>@@U?$integral_constant@_N$0A@@0@@Z ; std::_Test_callable<<lambda_3b020cec0f1508adac4c896f138918cf> >
	add	esp, 8

; 293  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Test_callable@V<lambda_3b020cec0f1508adac4c896f138918cf>@@@std@@YA_NAAV<lambda_3b020cec0f1508adac4c896f138918cf>@@@Z ENDP ; std::_Test_callable<<lambda_3b020cec0f1508adac4c896f138918cf> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$?0V?$_Func_class@X$$$V@std@@@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@ABV?$allocator@V?$_Func_class@X$$$V@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0V?$_Func_class@X$$$V@std@@@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@ABV?$allocator@V?$_Func_class@X$$$V@std@@@1@@Z PROC ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void> >::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void> ><std::_Func_class<void> >, COMDAT
; _this$ = ecx

; 561  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 562  : 		{	// construct from a related allocator (do nothing)
; 563  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0V?$_Func_class@X$$$V@std@@@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@ABV?$allocator@V?$_Func_class@X$$$V@std@@@1@@Z ENDP ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void> >::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void> ><std::_Func_class<void> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ??$_Test_callable@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@@std@@YA_NAAV<lambda_3648d362fc95221bbf9c4c4a922d1611>@@@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__Arg$ = 8						; size = 4
??$_Test_callable@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@@std@@YA_NAAV<lambda_3648d362fc95221bbf9c4c4a922d1611>@@@Z PROC ; std::_Test_callable<<lambda_3648d362fc95221bbf9c4c4a922d1611> >, COMDAT

; 291  : 	{	// determine whether std::function must store _Arg

	push	ebp
	mov	ebp, esp
	push	ecx

; 292  : 	return (_Test_callable(_Arg, _Testable_callable<_Ty>()));

	movzx	eax, BYTE PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR __Arg$[ebp]
	push	ecx
	call	??$_Test_callable@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@@std@@YA_NAAV<lambda_3648d362fc95221bbf9c4c4a922d1611>@@U?$integral_constant@_N$0A@@0@@Z ; std::_Test_callable<<lambda_3648d362fc95221bbf9c4c4a922d1611> >
	add	esp, 8

; 293  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Test_callable@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@@std@@YA_NAAV<lambda_3648d362fc95221bbf9c4c4a922d1611>@@@Z ENDP ; std::_Test_callable<<lambda_3648d362fc95221bbf9c4c4a922d1611> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$?0V?$_Func_class@X$$$V@std@@@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@ABV?$allocator@V?$_Func_class@X$$$V@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0V?$_Func_class@X$$$V@std@@@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@ABV?$allocator@V?$_Func_class@X$$$V@std@@@1@@Z PROC ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void> >::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void> ><std::_Func_class<void> >, COMDAT
; _this$ = ecx

; 561  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 562  : 		{	// construct from a related allocator (do nothing)
; 563  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0V?$_Func_class@X$$$V@std@@@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAE@ABV?$allocator@V?$_Func_class@X$$$V@std@@@1@@Z ENDP ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void> >::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void> ><std::_Func_class<void> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$construct@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@?$allocator_traits@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@1@PAV?$unique_ptr@XU?$ThreadTerminator@$0A@@@@1@$$QAPAX@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@?$allocator_traits@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@1@PAV?$unique_ptr@XU?$ThreadTerminator@$0A@@@@1@$$QAPAX@Z PROC ; std::allocator_traits<std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> > >::construct<std::unique_ptr<void,ThreadTerminator<0> >,void *>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

	push	ebp
	mov	ebp, esp

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	eax
	call	??$forward@PAX@std@@YA$$QAPAXAAPAX@Z	; std::forward<void *>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@QAEXPAV?$unique_ptr@XU?$ThreadTerminator@$0A@@@@1@$$QAPAX@Z ; std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> >::construct<std::unique_ptr<void,ThreadTerminator<0> >,void *>

; 724  : 		}

	pop	ebp
	ret	0
??$construct@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@?$allocator_traits@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@1@PAV?$unique_ptr@XU?$ThreadTerminator@$0A@@@@1@$$QAPAX@Z ENDP ; std::allocator_traits<std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> > >::construct<std::unique_ptr<void,ThreadTerminator<0> >,void *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$construct@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@AAPAX@?$allocator_traits@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@1@PAV?$unique_ptr@XU?$ThreadTerminator@$0A@@@@1@AAPAX@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@AAPAX@?$allocator_traits@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@1@PAV?$unique_ptr@XU?$ThreadTerminator@$0A@@@@1@AAPAX@Z PROC ; std::allocator_traits<std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> > >::construct<std::unique_ptr<void,ThreadTerminator<0> >,void * &>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

	push	ebp
	mov	ebp, esp

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	eax
	call	??$forward@AAPAX@std@@YAAAPAXAAPAX@Z	; std::forward<void * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@AAPAX@?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@QAEXPAV?$unique_ptr@XU?$ThreadTerminator@$0A@@@@1@AAPAX@Z ; std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> >::construct<std::unique_ptr<void,ThreadTerminator<0> >,void * &>

; 724  : 		}

	pop	ebp
	ret	0
??$construct@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@AAPAX@?$allocator_traits@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@1@PAV?$unique_ptr@XU?$ThreadTerminator@$0A@@@@1@AAPAX@Z ENDP ; std::allocator_traits<std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> > >::construct<std::unique_ptr<void,ThreadTerminator<0> >,void * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\type_traits
;	COMDAT ??$move@AAV?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@YA$$QAV?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@YA$$QAV?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@0@AAV10@@Z PROC ; std::move<std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void> &>, COMDAT

; 1519 : 	{	// forward _Arg as movable

	push	ebp
	mov	ebp, esp

; 1520 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

	mov	eax, DWORD PTR __Arg$[ebp]

; 1521 : 	}

	pop	ebp
	ret	0
??$move@AAV?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@YA$$QAV?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@0@AAV10@@Z ENDP ; std::move<std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void> &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xrefwrap
;	COMDAT ??$_ApplyX@X$$$V@?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$_ApplyX@X$$$V@?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@QAEXXZ PROC ; std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>::_ApplyX<void>, COMDAT
; _this$ = ecx

; 281  : 		_Ret _ApplyX(_Types&&... _Args)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 282  : 		{ // apply to UDT object
; 283  : 		return (this->_Get()(_STD forward<_Types>(_Args)...));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get@?$_Callable_base@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@QAEAAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@XZ ; std::_Callable_base<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>::_Get
	mov	ecx, eax
	call	??R<lambda_582637cdd8d6a2f689bc987be9ec55df>@@QBEXXZ ; <lambda_582637cdd8d6a2f689bc987be9ec55df>::operator()

; 284  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_ApplyX@X$$$V@?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@QAEXXZ ENDP ; std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>::_ApplyX<void>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$destroy@V?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEXPAV?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@V?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEXPAV?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@1@@Z PROC ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void> >::destroy<std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void> >, COMDAT
; _this$ = ecx

; 605  : 		void destroy(_Uty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 606  : 		{	// destroy object at _Ptr
; 607  : 		_Ptr->~_Uty();

	push	0
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	eax, DWORD PTR [edx+20]
	call	eax

; 608  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@V?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEXPAV?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@1@@Z ENDP ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void> >::destroy<std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$_Allocate@V?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@YAPAV?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@0@IPAV10@@Z
_TEXT	SEGMENT
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@V?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@YAPAV?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@0@IPAV10@@Z PROC ; std::_Allocate<std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void> >, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	push	ecx

; 23   : 	void *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

	jmp	SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	DWORD PTR __Count$[ebp], 357913941	; 15555555H
	ja	SHORT $LN1@Allocate
	imul	eax, DWORD PTR __Count$[ebp], 12
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax
	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@V?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@YAPAV?$_Func_impl@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@0@IPAV10@@Z ENDP ; std::_Allocate<std::_Func_impl<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>,std::allocator<std::_Func_class<void> >,void> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\type_traits
;	COMDAT ??$move@AAV?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@YA$$QAV?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@YA$$QAV?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@0@AAV10@@Z PROC ; std::move<std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void> &>, COMDAT

; 1519 : 	{	// forward _Arg as movable

	push	ebp
	mov	ebp, esp

; 1520 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

	mov	eax, DWORD PTR __Arg$[ebp]

; 1521 : 	}

	pop	ebp
	ret	0
??$move@AAV?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@YA$$QAV?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@0@AAV10@@Z ENDP ; std::move<std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void> &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xrefwrap
;	COMDAT ??$_ApplyX@X$$$V@?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$_ApplyX@X$$$V@?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@QAEXXZ PROC ; std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>::_ApplyX<void>, COMDAT
; _this$ = ecx

; 281  : 		_Ret _ApplyX(_Types&&... _Args)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 282  : 		{ // apply to UDT object
; 283  : 		return (this->_Get()(_STD forward<_Types>(_Args)...));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get@?$_Callable_base@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@QAEAAV<lambda_e856d28dddb7588070dd099cfda6c634>@@XZ ; std::_Callable_base<<lambda_e856d28dddb7588070dd099cfda6c634>,0>::_Get
	mov	ecx, eax
	call	??R<lambda_e856d28dddb7588070dd099cfda6c634>@@QBEXXZ ; <lambda_e856d28dddb7588070dd099cfda6c634>::operator()

; 284  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_ApplyX@X$$$V@?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@QAEXXZ ENDP ; std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>::_ApplyX<void>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$destroy@V?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEXPAV?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@V?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEXPAV?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@1@@Z PROC ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void> >::destroy<std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void> >, COMDAT
; _this$ = ecx

; 605  : 		void destroy(_Uty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 606  : 		{	// destroy object at _Ptr
; 607  : 		_Ptr->~_Uty();

	push	0
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	eax, DWORD PTR [edx+20]
	call	eax

; 608  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@V?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEXPAV?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@1@@Z ENDP ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void> >::destroy<std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$_Allocate@V?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@YAPAV?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@0@IPAV10@@Z
_TEXT	SEGMENT
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@V?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@YAPAV?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@0@IPAV10@@Z PROC ; std::_Allocate<std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void> >, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	push	ecx

; 23   : 	void *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

	jmp	SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	DWORD PTR __Count$[ebp], 357913941	; 15555555H
	ja	SHORT $LN1@Allocate
	imul	eax, DWORD PTR __Count$[ebp], 12
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax
	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@V?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@YAPAV?$_Func_impl@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@0@IPAV10@@Z ENDP ; std::_Allocate<std::_Func_impl<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>,std::allocator<std::_Func_class<void> >,void> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xrefwrap
;	COMDAT ??$?0V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@@?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@QAE@$$QAV<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
??$?0V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@@?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@QAE@$$QAV<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@@Z PROC ; std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0><<lambda_7c9af1b141e25bc2e890d47a77a39da9> >, COMDAT
; _this$ = ecx

; 269  : 		{	// construct

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	??$forward@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@@std@@YA$$QAV<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@AAV1@@Z ; std::forward<<lambda_7c9af1b141e25bc2e890d47a77a39da9> >
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Callable_base@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@QAE@ABV<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@@Z ; std::_Callable_base<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>::_Callable_base<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>

; 270  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@@?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@QAE@$$QAV<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@@Z ENDP ; std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0><<lambda_7c9af1b141e25bc2e890d47a77a39da9> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\type_traits
;	COMDAT ??$move@AAV?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@YA$$QAV?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@YA$$QAV?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@0@AAV10@@Z PROC ; std::move<std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void> &>, COMDAT

; 1519 : 	{	// forward _Arg as movable

	push	ebp
	mov	ebp, esp

; 1520 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

	mov	eax, DWORD PTR __Arg$[ebp]

; 1521 : 	}

	pop	ebp
	ret	0
??$move@AAV?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@YA$$QAV?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@0@AAV10@@Z ENDP ; std::move<std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void> &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xrefwrap
;	COMDAT ??$_ApplyX@X$$$V@?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$_ApplyX@X$$$V@?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@QAEXXZ PROC ; std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>::_ApplyX<void>, COMDAT
; _this$ = ecx

; 281  : 		_Ret _ApplyX(_Types&&... _Args)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 282  : 		{ // apply to UDT object
; 283  : 		return (this->_Get()(_STD forward<_Types>(_Args)...));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get@?$_Callable_base@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@QAEAAV<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@XZ ; std::_Callable_base<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>::_Get
	mov	ecx, eax
	call	??R<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@QBEXXZ ; <lambda_7c9af1b141e25bc2e890d47a77a39da9>::operator()

; 284  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_ApplyX@X$$$V@?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@QAEXXZ ENDP ; std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>::_ApplyX<void>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$destroy@V?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEXPAV?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@V?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEXPAV?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@1@@Z PROC ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void> >::destroy<std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void> >, COMDAT
; _this$ = ecx

; 605  : 		void destroy(_Uty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 606  : 		{	// destroy object at _Ptr
; 607  : 		_Ptr->~_Uty();

	push	0
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	eax, DWORD PTR [edx+20]
	call	eax

; 608  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@V?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEXPAV?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@1@@Z ENDP ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void> >::destroy<std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$_Allocate@V?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@YAPAV?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@0@IPAV10@@Z
_TEXT	SEGMENT
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@V?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@YAPAV?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@0@IPAV10@@Z PROC ; std::_Allocate<std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void> >, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	push	ecx

; 23   : 	void *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

	jmp	SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	DWORD PTR __Count$[ebp], 357913941	; 15555555H
	ja	SHORT $LN1@Allocate
	imul	eax, DWORD PTR __Count$[ebp], 12
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax
	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@V?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@YAPAV?$_Func_impl@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@0@IPAV10@@Z ENDP ; std::_Allocate<std::_Func_impl<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>,std::allocator<std::_Func_class<void> >,void> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xrefwrap
;	COMDAT ??$?0V<lambda_3b020cec0f1508adac4c896f138918cf>@@@?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@QAE@$$QAV<lambda_3b020cec0f1508adac4c896f138918cf>@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
??$?0V<lambda_3b020cec0f1508adac4c896f138918cf>@@@?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@QAE@$$QAV<lambda_3b020cec0f1508adac4c896f138918cf>@@@Z PROC ; std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0><<lambda_3b020cec0f1508adac4c896f138918cf> >, COMDAT
; _this$ = ecx

; 269  : 		{	// construct

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	??$forward@V<lambda_3b020cec0f1508adac4c896f138918cf>@@@std@@YA$$QAV<lambda_3b020cec0f1508adac4c896f138918cf>@@AAV1@@Z ; std::forward<<lambda_3b020cec0f1508adac4c896f138918cf> >
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Callable_base@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@QAE@ABV<lambda_3b020cec0f1508adac4c896f138918cf>@@@Z ; std::_Callable_base<<lambda_3b020cec0f1508adac4c896f138918cf>,0>::_Callable_base<<lambda_3b020cec0f1508adac4c896f138918cf>,0>

; 270  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0V<lambda_3b020cec0f1508adac4c896f138918cf>@@@?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@QAE@$$QAV<lambda_3b020cec0f1508adac4c896f138918cf>@@@Z ENDP ; std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0><<lambda_3b020cec0f1508adac4c896f138918cf> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\type_traits
;	COMDAT ??$move@AAV?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@YA$$QAV?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@YA$$QAV?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@0@AAV10@@Z PROC ; std::move<std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void> &>, COMDAT

; 1519 : 	{	// forward _Arg as movable

	push	ebp
	mov	ebp, esp

; 1520 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

	mov	eax, DWORD PTR __Arg$[ebp]

; 1521 : 	}

	pop	ebp
	ret	0
??$move@AAV?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@YA$$QAV?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@0@AAV10@@Z ENDP ; std::move<std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void> &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xrefwrap
;	COMDAT ??$_ApplyX@X$$$V@?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$_ApplyX@X$$$V@?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@QAEXXZ PROC ; std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>::_ApplyX<void>, COMDAT
; _this$ = ecx

; 281  : 		_Ret _ApplyX(_Types&&... _Args)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 282  : 		{ // apply to UDT object
; 283  : 		return (this->_Get()(_STD forward<_Types>(_Args)...));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get@?$_Callable_base@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@QAEAAV<lambda_3b020cec0f1508adac4c896f138918cf>@@XZ ; std::_Callable_base<<lambda_3b020cec0f1508adac4c896f138918cf>,0>::_Get
	mov	ecx, eax
	call	??R<lambda_3b020cec0f1508adac4c896f138918cf>@@QBEXXZ ; <lambda_3b020cec0f1508adac4c896f138918cf>::operator()

; 284  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_ApplyX@X$$$V@?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@QAEXXZ ENDP ; std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>::_ApplyX<void>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$destroy@V?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEXPAV?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@V?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEXPAV?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@1@@Z PROC ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void> >::destroy<std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void> >, COMDAT
; _this$ = ecx

; 605  : 		void destroy(_Uty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 606  : 		{	// destroy object at _Ptr
; 607  : 		_Ptr->~_Uty();

	push	0
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	eax, DWORD PTR [edx+20]
	call	eax

; 608  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@V?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEXPAV?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@1@@Z ENDP ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void> >::destroy<std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$_Allocate@V?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@YAPAV?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@0@IPAV10@@Z
_TEXT	SEGMENT
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@V?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@YAPAV?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@0@IPAV10@@Z PROC ; std::_Allocate<std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void> >, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	push	ecx

; 23   : 	void *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

	jmp	SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	DWORD PTR __Count$[ebp], 357913941	; 15555555H
	ja	SHORT $LN1@Allocate
	imul	eax, DWORD PTR __Count$[ebp], 12
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax
	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@V?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@YAPAV?$_Func_impl@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@0@IPAV10@@Z ENDP ; std::_Allocate<std::_Func_impl<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>,std::allocator<std::_Func_class<void> >,void> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xrefwrap
;	COMDAT ??$?0V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@@?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@QAE@$$QAV<lambda_3648d362fc95221bbf9c4c4a922d1611>@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
??$?0V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@@?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@QAE@$$QAV<lambda_3648d362fc95221bbf9c4c4a922d1611>@@@Z PROC ; std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0><<lambda_3648d362fc95221bbf9c4c4a922d1611> >, COMDAT
; _this$ = ecx

; 269  : 		{	// construct

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	??$forward@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@@std@@YA$$QAV<lambda_3648d362fc95221bbf9c4c4a922d1611>@@AAV1@@Z ; std::forward<<lambda_3648d362fc95221bbf9c4c4a922d1611> >
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Callable_base@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@QAE@ABV<lambda_3648d362fc95221bbf9c4c4a922d1611>@@@Z ; std::_Callable_base<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>::_Callable_base<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>

; 270  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@@?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@QAE@$$QAV<lambda_3648d362fc95221bbf9c4c4a922d1611>@@@Z ENDP ; std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0><<lambda_3648d362fc95221bbf9c4c4a922d1611> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\type_traits
;	COMDAT ??$move@AAV?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@YA$$QAV?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@YA$$QAV?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@0@AAV10@@Z PROC ; std::move<std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void> &>, COMDAT

; 1519 : 	{	// forward _Arg as movable

	push	ebp
	mov	ebp, esp

; 1520 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

	mov	eax, DWORD PTR __Arg$[ebp]

; 1521 : 	}

	pop	ebp
	ret	0
??$move@AAV?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@YA$$QAV?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@0@AAV10@@Z ENDP ; std::move<std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void> &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xrefwrap
;	COMDAT ??$_ApplyX@X$$$V@?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$_ApplyX@X$$$V@?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@QAEXXZ PROC ; std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>::_ApplyX<void>, COMDAT
; _this$ = ecx

; 281  : 		_Ret _ApplyX(_Types&&... _Args)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 282  : 		{ // apply to UDT object
; 283  : 		return (this->_Get()(_STD forward<_Types>(_Args)...));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get@?$_Callable_base@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@QAEAAV<lambda_3648d362fc95221bbf9c4c4a922d1611>@@XZ ; std::_Callable_base<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>::_Get
	mov	ecx, eax
	call	??R<lambda_3648d362fc95221bbf9c4c4a922d1611>@@QBEXXZ ; <lambda_3648d362fc95221bbf9c4c4a922d1611>::operator()

; 284  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_ApplyX@X$$$V@?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@QAEXXZ ENDP ; std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>::_ApplyX<void>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$destroy@V?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEXPAV?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@V?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEXPAV?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@1@@Z PROC ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void> >::destroy<std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void> >, COMDAT
; _this$ = ecx

; 605  : 		void destroy(_Uty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 606  : 		{	// destroy object at _Ptr
; 607  : 		_Ptr->~_Uty();

	push	0
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	eax, DWORD PTR [edx+20]
	call	eax

; 608  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@V?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@?$allocator@V?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@QAEXPAV?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@1@@Z ENDP ; std::allocator<std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void> >::destroy<std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$_Allocate@V?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@YAPAV?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@0@IPAV10@@Z
_TEXT	SEGMENT
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@V?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@YAPAV?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@0@IPAV10@@Z PROC ; std::_Allocate<std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void> >, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	push	ecx

; 23   : 	void *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

	jmp	SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	DWORD PTR __Count$[ebp], 357913941	; 15555555H
	ja	SHORT $LN1@Allocate
	imul	eax, DWORD PTR __Count$[ebp], 12
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax
	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@V?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@std@@@std@@YAPAV?$_Func_impl@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@V?$allocator@V?$_Func_class@X$$$V@std@@@2@X$$$V@0@IPAV10@@Z ENDP ; std::_Allocate<std::_Func_impl<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>,std::allocator<std::_Func_class<void> >,void> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xrefwrap
;	COMDAT ??$?0AAU?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@@?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@QAE@AAU01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
??$?0AAU?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@@?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@QAE@AAU01@@Z PROC ; std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0><std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0> &>, COMDAT
; _this$ = ecx

; 269  : 		{	// construct

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	??$forward@AAU?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@@std@@YAAAU?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@0@AAU10@@Z ; std::forward<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0> &>
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx

; 270  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0AAU?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@@?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@QAE@AAU01@@Z ENDP ; std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0><std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0> &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\type_traits
;	COMDAT ??$forward@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@@std@@YA$$QAU?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@@std@@YA$$QAU?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@0@AAU10@@Z PROC ; std::forward<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0> >, COMDAT

; 1504 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

	pop	ebp
	ret	0
??$forward@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@@std@@YA$$QAU?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@0@AAU10@@Z ENDP ; std::forward<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xrefwrap
;	COMDAT ??$?0U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@@?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@QAE@$$QAU01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
??$?0U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@@?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@QAE@$$QAU01@@Z PROC ; std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0><std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0> >, COMDAT
; _this$ = ecx

; 269  : 		{	// construct

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	??$forward@U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@@std@@YA$$QAU?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@0@AAU10@@Z ; std::forward<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0> >
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx

; 270  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0U?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@@?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@QAE@$$QAU01@@Z ENDP ; std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0><std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xrefwrap
;	COMDAT ??$?0AAU?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@@?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@QAE@AAU01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
??$?0AAU?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@@?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@QAE@AAU01@@Z PROC ; std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0><std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0> &>, COMDAT
; _this$ = ecx

; 269  : 		{	// construct

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	??$forward@AAU?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@@std@@YAAAU?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@0@AAU10@@Z ; std::forward<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0> &>
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx

; 270  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0AAU?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@@?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@QAE@AAU01@@Z ENDP ; std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0><std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0> &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\type_traits
;	COMDAT ??$forward@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@@std@@YA$$QAU?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@@std@@YA$$QAU?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@0@AAU10@@Z PROC ; std::forward<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0> >, COMDAT

; 1504 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

	pop	ebp
	ret	0
??$forward@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@@std@@YA$$QAU?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@0@AAU10@@Z ENDP ; std::forward<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xrefwrap
;	COMDAT ??$?0U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@@?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@QAE@$$QAU01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
??$?0U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@@?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@QAE@$$QAU01@@Z PROC ; std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0><std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0> >, COMDAT
; _this$ = ecx

; 269  : 		{	// construct

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	??$forward@U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@@std@@YA$$QAU?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@0@AAU10@@Z ; std::forward<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0> >
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx

; 270  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0U?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@@?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@QAE@$$QAU01@@Z ENDP ; std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0><std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xrefwrap
;	COMDAT ??$?0AAU?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@@?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@QAE@AAU01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
??$?0AAU?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@@?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@QAE@AAU01@@Z PROC ; std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0><std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0> &>, COMDAT
; _this$ = ecx

; 269  : 		{	// construct

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	??$forward@AAU?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@@std@@YAAAU?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@0@AAU10@@Z ; std::forward<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0> &>
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx

; 270  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0AAU?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@@?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@QAE@AAU01@@Z ENDP ; std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0><std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0> &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\type_traits
;	COMDAT ??$forward@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@@std@@YA$$QAU?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@@std@@YA$$QAU?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@0@AAU10@@Z PROC ; std::forward<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0> >, COMDAT

; 1504 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

	pop	ebp
	ret	0
??$forward@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@@std@@YA$$QAU?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@0@AAU10@@Z ENDP ; std::forward<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xrefwrap
;	COMDAT ??$?0U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@@?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@QAE@$$QAU01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
??$?0U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@@?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@QAE@$$QAU01@@Z PROC ; std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0><std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0> >, COMDAT
; _this$ = ecx

; 269  : 		{	// construct

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	??$forward@U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@@std@@YA$$QAU?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@0@AAU10@@Z ; std::forward<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0> >
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx

; 270  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0U?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@@?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@QAE@$$QAU01@@Z ENDP ; std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0><std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xrefwrap
;	COMDAT ??$?0AAU?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@@?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@QAE@AAU01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
??$?0AAU?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@@?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@QAE@AAU01@@Z PROC ; std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0><std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0> &>, COMDAT
; _this$ = ecx

; 269  : 		{	// construct

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	??$forward@AAU?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@@std@@YAAAU?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@0@AAU10@@Z ; std::forward<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0> &>
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx

; 270  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0AAU?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@@?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@QAE@AAU01@@Z ENDP ; std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0><std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0> &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\type_traits
;	COMDAT ??$forward@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@@std@@YA$$QAU?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@@std@@YA$$QAU?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@0@AAU10@@Z PROC ; std::forward<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0> >, COMDAT

; 1504 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

	pop	ebp
	ret	0
??$forward@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@@std@@YA$$QAU?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@0@AAU10@@Z ENDP ; std::forward<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xrefwrap
;	COMDAT ??$?0U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@@?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@QAE@$$QAU01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
??$?0U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@@?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@QAE@$$QAU01@@Z PROC ; std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0><std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0> >, COMDAT
; _this$ = ecx

; 269  : 		{	// construct

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	??$forward@U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@@std@@YA$$QAU?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@0@AAU10@@Z ; std::forward<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0> >
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx

; 270  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0U?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@@?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@QAE@$$QAU01@@Z ENDP ; std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0>::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0><std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xrefwrap
;	COMDAT ??$?0AAU?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@@?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@QAE@AAU01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
??$?0AAU?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@@?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@QAE@AAU01@@Z PROC ; std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0><std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0> &>, COMDAT
; _this$ = ecx

; 269  : 		{	// construct

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	??$forward@AAU?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@@std@@YAAAU?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@0@AAU10@@Z ; std::forward<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0> &>
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx

; 270  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0AAU?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@@?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@QAE@AAU01@@Z ENDP ; std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0><std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0> &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\type_traits
;	COMDAT ??$forward@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@@std@@YA$$QAU?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@@std@@YA$$QAU?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@0@AAU10@@Z PROC ; std::forward<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0> >, COMDAT

; 1504 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

	pop	ebp
	ret	0
??$forward@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@@std@@YA$$QAU?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@0@AAU10@@Z ENDP ; std::forward<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xrefwrap
;	COMDAT ??$?0U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@@?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@QAE@$$QAU01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
??$?0U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@@?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@QAE@$$QAU01@@Z PROC ; std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0><std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0> >, COMDAT
; _this$ = ecx

; 269  : 		{	// construct

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	??$forward@U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@@std@@YA$$QAU?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@0@AAU10@@Z ; std::forward<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0> >
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx

; 270  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0U?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@@?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@QAE@$$QAU01@@Z ENDP ; std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0><std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xrefwrap
;	COMDAT ?_Get@?$_Callable_base@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@QAEAAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get@?$_Callable_base@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@QAEAAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@XZ PROC ; std::_Callable_base<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>::_Get, COMDAT
; _this$ = ecx

; 184  : 		{	// return reference to stored object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 185  : 		return (_Object);

	mov	eax, DWORD PTR _this$[ebp]

; 186  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Get@?$_Callable_base@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@QAEAAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@XZ ENDP ; std::_Callable_base<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>::_Get
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xrefwrap
;	COMDAT ?_Get@?$_Callable_base@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@QAEAAV<lambda_e856d28dddb7588070dd099cfda6c634>@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get@?$_Callable_base@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@QAEAAV<lambda_e856d28dddb7588070dd099cfda6c634>@@XZ PROC ; std::_Callable_base<<lambda_e856d28dddb7588070dd099cfda6c634>,0>::_Get, COMDAT
; _this$ = ecx

; 184  : 		{	// return reference to stored object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 185  : 		return (_Object);

	mov	eax, DWORD PTR _this$[ebp]

; 186  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Get@?$_Callable_base@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@QAEAAV<lambda_e856d28dddb7588070dd099cfda6c634>@@XZ ENDP ; std::_Callable_base<<lambda_e856d28dddb7588070dd099cfda6c634>,0>::_Get
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xrefwrap
;	COMDAT ??0?$_Callable_base@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@QAE@ABV<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
??0?$_Callable_base@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@QAE@ABV<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@@Z PROC ; std::_Callable_base<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>::_Callable_base<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>, COMDAT
; _this$ = ecx

; 175  : 		{	// construct from value

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx

; 176  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Callable_base@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@QAE@ABV<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@@Z ENDP ; std::_Callable_base<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>::_Callable_base<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xrefwrap
;	COMDAT ?_Get@?$_Callable_base@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@QAEAAV<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get@?$_Callable_base@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@QAEAAV<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@XZ PROC ; std::_Callable_base<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>::_Get, COMDAT
; _this$ = ecx

; 184  : 		{	// return reference to stored object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 185  : 		return (_Object);

	mov	eax, DWORD PTR _this$[ebp]

; 186  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Get@?$_Callable_base@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@QAEAAV<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@XZ ENDP ; std::_Callable_base<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0>::_Get
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xrefwrap
;	COMDAT ??0?$_Callable_base@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@QAE@ABV<lambda_3b020cec0f1508adac4c896f138918cf>@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
??0?$_Callable_base@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@QAE@ABV<lambda_3b020cec0f1508adac4c896f138918cf>@@@Z PROC ; std::_Callable_base<<lambda_3b020cec0f1508adac4c896f138918cf>,0>::_Callable_base<<lambda_3b020cec0f1508adac4c896f138918cf>,0>, COMDAT
; _this$ = ecx

; 175  : 		{	// construct from value

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx

; 176  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Callable_base@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@QAE@ABV<lambda_3b020cec0f1508adac4c896f138918cf>@@@Z ENDP ; std::_Callable_base<<lambda_3b020cec0f1508adac4c896f138918cf>,0>::_Callable_base<<lambda_3b020cec0f1508adac4c896f138918cf>,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xrefwrap
;	COMDAT ?_Get@?$_Callable_base@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@QAEAAV<lambda_3b020cec0f1508adac4c896f138918cf>@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get@?$_Callable_base@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@QAEAAV<lambda_3b020cec0f1508adac4c896f138918cf>@@XZ PROC ; std::_Callable_base<<lambda_3b020cec0f1508adac4c896f138918cf>,0>::_Get, COMDAT
; _this$ = ecx

; 184  : 		{	// return reference to stored object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 185  : 		return (_Object);

	mov	eax, DWORD PTR _this$[ebp]

; 186  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Get@?$_Callable_base@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@QAEAAV<lambda_3b020cec0f1508adac4c896f138918cf>@@XZ ENDP ; std::_Callable_base<<lambda_3b020cec0f1508adac4c896f138918cf>,0>::_Get
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xrefwrap
;	COMDAT ??0?$_Callable_base@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@QAE@ABV<lambda_3648d362fc95221bbf9c4c4a922d1611>@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
??0?$_Callable_base@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@QAE@ABV<lambda_3648d362fc95221bbf9c4c4a922d1611>@@@Z PROC ; std::_Callable_base<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>::_Callable_base<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>, COMDAT
; _this$ = ecx

; 175  : 		{	// construct from value

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx

; 176  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Callable_base@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@QAE@ABV<lambda_3648d362fc95221bbf9c4c4a922d1611>@@@Z ENDP ; std::_Callable_base<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>::_Callable_base<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xrefwrap
;	COMDAT ?_Get@?$_Callable_base@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@QAEAAV<lambda_3648d362fc95221bbf9c4c4a922d1611>@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get@?$_Callable_base@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@QAEAAV<lambda_3648d362fc95221bbf9c4c4a922d1611>@@XZ PROC ; std::_Callable_base<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>::_Get, COMDAT
; _this$ = ecx

; 184  : 		{	// return reference to stored object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 185  : 		return (_Object);

	mov	eax, DWORD PTR _this$[ebp]

; 186  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Get@?$_Callable_base@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@QAEAAV<lambda_3648d362fc95221bbf9c4c4a922d1611>@@XZ ENDP ; std::_Callable_base<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0>::_Get
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ??$_Test_callable@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@@std@@YA_NAAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Test_callable@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@@std@@YA_NAAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Test_callable<<lambda_582637cdd8d6a2f689bc987be9ec55df> >, COMDAT

; 285  : 	{	// std::function must store arbitrary callable objects

	push	ebp
	mov	ebp, esp

; 286  : 	return (true);

	mov	al, 1

; 287  : 	}

	pop	ebp
	ret	0
??$_Test_callable@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@@std@@YA_NAAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Test_callable<<lambda_582637cdd8d6a2f689bc987be9ec55df> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xrefwrap
;	COMDAT ??$?0AAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@@?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@QAE@AAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
??$?0AAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@@?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@QAE@AAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@@Z PROC ; std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0><<lambda_582637cdd8d6a2f689bc987be9ec55df> &>, COMDAT
; _this$ = ecx

; 269  : 		{	// construct

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	??$forward@AAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@@std@@YAAAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@AAV1@@Z ; std::forward<<lambda_582637cdd8d6a2f689bc987be9ec55df> &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Callable_base@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@QAE@ABV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@@Z ; std::_Callable_base<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>::_Callable_base<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>

; 270  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0AAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@@?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@QAE@AAV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@@Z ENDP ; std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0><<lambda_582637cdd8d6a2f689bc987be9ec55df> &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ??$_Test_callable@V<lambda_e856d28dddb7588070dd099cfda6c634>@@@std@@YA_NAAV<lambda_e856d28dddb7588070dd099cfda6c634>@@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Test_callable@V<lambda_e856d28dddb7588070dd099cfda6c634>@@@std@@YA_NAAV<lambda_e856d28dddb7588070dd099cfda6c634>@@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Test_callable<<lambda_e856d28dddb7588070dd099cfda6c634> >, COMDAT

; 285  : 	{	// std::function must store arbitrary callable objects

	push	ebp
	mov	ebp, esp

; 286  : 	return (true);

	mov	al, 1

; 287  : 	}

	pop	ebp
	ret	0
??$_Test_callable@V<lambda_e856d28dddb7588070dd099cfda6c634>@@@std@@YA_NAAV<lambda_e856d28dddb7588070dd099cfda6c634>@@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Test_callable<<lambda_e856d28dddb7588070dd099cfda6c634> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xrefwrap
;	COMDAT ??$?0AAV<lambda_e856d28dddb7588070dd099cfda6c634>@@@?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@QAE@AAV<lambda_e856d28dddb7588070dd099cfda6c634>@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
??$?0AAV<lambda_e856d28dddb7588070dd099cfda6c634>@@@?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@QAE@AAV<lambda_e856d28dddb7588070dd099cfda6c634>@@@Z PROC ; std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0><<lambda_e856d28dddb7588070dd099cfda6c634> &>, COMDAT
; _this$ = ecx

; 269  : 		{	// construct

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	??$forward@AAV<lambda_e856d28dddb7588070dd099cfda6c634>@@@std@@YAAAV<lambda_e856d28dddb7588070dd099cfda6c634>@@AAV1@@Z ; std::forward<<lambda_e856d28dddb7588070dd099cfda6c634> &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Callable_base@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@QAE@ABV<lambda_e856d28dddb7588070dd099cfda6c634>@@@Z ; std::_Callable_base<<lambda_e856d28dddb7588070dd099cfda6c634>,0>::_Callable_base<<lambda_e856d28dddb7588070dd099cfda6c634>,0>

; 270  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0AAV<lambda_e856d28dddb7588070dd099cfda6c634>@@@?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@QAE@AAV<lambda_e856d28dddb7588070dd099cfda6c634>@@@Z ENDP ; std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0>::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0><<lambda_e856d28dddb7588070dd099cfda6c634> &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ??$_Test_callable@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@@std@@YA_NAAV<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Test_callable@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@@std@@YA_NAAV<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Test_callable<<lambda_7c9af1b141e25bc2e890d47a77a39da9> >, COMDAT

; 285  : 	{	// std::function must store arbitrary callable objects

	push	ebp
	mov	ebp, esp

; 286  : 	return (true);

	mov	al, 1

; 287  : 	}

	pop	ebp
	ret	0
??$_Test_callable@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@@std@@YA_NAAV<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Test_callable<<lambda_7c9af1b141e25bc2e890d47a77a39da9> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ??$_Test_callable@V<lambda_3b020cec0f1508adac4c896f138918cf>@@@std@@YA_NAAV<lambda_3b020cec0f1508adac4c896f138918cf>@@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Test_callable@V<lambda_3b020cec0f1508adac4c896f138918cf>@@@std@@YA_NAAV<lambda_3b020cec0f1508adac4c896f138918cf>@@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Test_callable<<lambda_3b020cec0f1508adac4c896f138918cf> >, COMDAT

; 285  : 	{	// std::function must store arbitrary callable objects

	push	ebp
	mov	ebp, esp

; 286  : 	return (true);

	mov	al, 1

; 287  : 	}

	pop	ebp
	ret	0
??$_Test_callable@V<lambda_3b020cec0f1508adac4c896f138918cf>@@@std@@YA_NAAV<lambda_3b020cec0f1508adac4c896f138918cf>@@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Test_callable<<lambda_3b020cec0f1508adac4c896f138918cf> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ??$_Test_callable@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@@std@@YA_NAAV<lambda_3648d362fc95221bbf9c4c4a922d1611>@@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Test_callable@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@@std@@YA_NAAV<lambda_3648d362fc95221bbf9c4c4a922d1611>@@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Test_callable<<lambda_3648d362fc95221bbf9c4c4a922d1611> >, COMDAT

; 285  : 	{	// std::function must store arbitrary callable objects

	push	ebp
	mov	ebp, esp

; 286  : 	return (true);

	mov	al, 1

; 287  : 	}

	pop	ebp
	ret	0
??$_Test_callable@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@@std@@YA_NAAV<lambda_3648d362fc95221bbf9c4c4a922d1611>@@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Test_callable<<lambda_3648d362fc95221bbf9c4c4a922d1611> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$construct@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@QAEXPAV?$unique_ptr@XU?$ThreadTerminator@$0A@@@@1@$$QAPAX@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
tv73 = -8						; size = 4
$T1 = -4						; size = 4
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@QAEXPAV?$unique_ptr@XU?$ThreadTerminator@$0A@@@@1@$$QAPAX@Z PROC ; std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> >::construct<std::unique_ptr<void,ThreadTerminator<0> >,void *>, COMDAT
; _this$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	push	ecx
	call	??$forward@PAX@std@@YA$$QAPAXAAPAX@Z	; std::forward<void *>
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR $T1[ebp]
	call	??0?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@QAE@PAX@Z ; std::unique_ptr<void,ThreadTerminator<0> >::unique_ptr<void,ThreadTerminator<0> >
	mov	DWORD PTR tv73[ebp], eax
	jmp	SHORT $LN1@construct
$LN3@construct:
	mov	DWORD PTR tv73[ebp], 0
$LN1@construct:

; 601  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@QAEXPAV?$unique_ptr@XU?$ThreadTerminator@$0A@@@@1@$$QAPAX@Z ENDP ; std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> >::construct<std::unique_ptr<void,ThreadTerminator<0> >,void *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$construct@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@AAPAX@?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@QAEXPAV?$unique_ptr@XU?$ThreadTerminator@$0A@@@@1@AAPAX@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
tv73 = -8						; size = 4
$T1 = -4						; size = 4
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@AAPAX@?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@QAEXPAV?$unique_ptr@XU?$ThreadTerminator@$0A@@@@1@AAPAX@Z PROC ; std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> >::construct<std::unique_ptr<void,ThreadTerminator<0> >,void * &>, COMDAT
; _this$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	push	ecx
	call	??$forward@AAPAX@std@@YAAAPAXAAPAX@Z	; std::forward<void * &>
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR $T1[ebp]
	call	??0?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@QAE@PAX@Z ; std::unique_ptr<void,ThreadTerminator<0> >::unique_ptr<void,ThreadTerminator<0> >
	mov	DWORD PTR tv73[ebp], eax
	jmp	SHORT $LN1@construct
$LN3@construct:
	mov	DWORD PTR tv73[ebp], 0
$LN1@construct:

; 601  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@AAPAX@?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@QAEXPAV?$unique_ptr@XU?$ThreadTerminator@$0A@@@@1@AAPAX@Z ENDP ; std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> >::construct<std::unique_ptr<void,ThreadTerminator<0> >,void * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\type_traits
;	COMDAT ??$forward@AAU?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@@std@@YAAAU?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAU?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@@std@@YAAAU?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@0@AAU10@@Z PROC ; std::forward<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0> &>, COMDAT

; 1504 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

	pop	ebp
	ret	0
??$forward@AAU?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@@std@@YAAAU?$_Callable_obj@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@0@AAU10@@Z ENDP ; std::forward<std::_Callable_obj<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0> &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\type_traits
;	COMDAT ??$forward@AAU?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@@std@@YAAAU?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAU?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@@std@@YAAAU?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@0@AAU10@@Z PROC ; std::forward<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0> &>, COMDAT

; 1504 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

	pop	ebp
	ret	0
??$forward@AAU?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@@std@@YAAAU?$_Callable_obj@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@0@AAU10@@Z ENDP ; std::forward<std::_Callable_obj<<lambda_e856d28dddb7588070dd099cfda6c634>,0> &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\type_traits
;	COMDAT ??$forward@AAU?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@@std@@YAAAU?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAU?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@@std@@YAAAU?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@0@AAU10@@Z PROC ; std::forward<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0> &>, COMDAT

; 1504 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

	pop	ebp
	ret	0
??$forward@AAU?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@std@@@std@@YAAAU?$_Callable_obj@V<lambda_7c9af1b141e25bc2e890d47a77a39da9>@@$0A@@0@AAU10@@Z ENDP ; std::forward<std::_Callable_obj<<lambda_7c9af1b141e25bc2e890d47a77a39da9>,0> &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\type_traits
;	COMDAT ??$forward@AAU?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@@std@@YAAAU?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAU?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@@std@@YAAAU?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@0@AAU10@@Z PROC ; std::forward<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0> &>, COMDAT

; 1504 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

	pop	ebp
	ret	0
??$forward@AAU?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@std@@@std@@YAAAU?$_Callable_obj@V<lambda_3b020cec0f1508adac4c896f138918cf>@@$0A@@0@AAU10@@Z ENDP ; std::forward<std::_Callable_obj<<lambda_3b020cec0f1508adac4c896f138918cf>,0> &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\type_traits
;	COMDAT ??$forward@AAU?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@@std@@YAAAU?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAU?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@@std@@YAAAU?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@0@AAU10@@Z PROC ; std::forward<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0> &>, COMDAT

; 1504 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

	pop	ebp
	ret	0
??$forward@AAU?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@std@@@std@@YAAAU?$_Callable_obj@V<lambda_3648d362fc95221bbf9c4c4a922d1611>@@$0A@@0@AAU10@@Z ENDP ; std::forward<std::_Callable_obj<<lambda_3648d362fc95221bbf9c4c4a922d1611>,0> &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\memory
;	COMDAT ??0?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@QAE@PAX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??0?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@QAE@PAX@Z PROC ; std::unique_ptr<void,ThreadTerminator<0> >::unique_ptr<void,ThreadTerminator<0> >, COMDAT
; _this$ = ecx

; 1365 : 		{	// construct with pointer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Unique_ptr_base@XU?$ThreadTerminator@$0A@@@$00@std@@QAE@PAX@Z ; std::_Unique_ptr_base<void,ThreadTerminator<0>,1>::_Unique_ptr_base<void,ThreadTerminator<0>,1>

; 1366 : 		static_assert(!is_pointer<_Dx>::value,
; 1367 : 			"unique_ptr constructed with null deleter pointer");
; 1368 : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@QAE@PAX@Z ENDP ; std::unique_ptr<void,ThreadTerminator<0> >::unique_ptr<void,ThreadTerminator<0> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xrefwrap
;	COMDAT ??0?$_Callable_base@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@QAE@ABV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
??0?$_Callable_base@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@QAE@ABV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@@Z PROC ; std::_Callable_base<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>::_Callable_base<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>, COMDAT
; _this$ = ecx

; 175  : 		{	// construct from value

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx

; 176  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Callable_base@V<lambda_582637cdd8d6a2f689bc987be9ec55df>@@$0A@@std@@QAE@ABV<lambda_582637cdd8d6a2f689bc987be9ec55df>@@@Z ENDP ; std::_Callable_base<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>::_Callable_base<<lambda_582637cdd8d6a2f689bc987be9ec55df>,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xrefwrap
;	COMDAT ??0?$_Callable_base@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@QAE@ABV<lambda_e856d28dddb7588070dd099cfda6c634>@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
??0?$_Callable_base@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@QAE@ABV<lambda_e856d28dddb7588070dd099cfda6c634>@@@Z PROC ; std::_Callable_base<<lambda_e856d28dddb7588070dd099cfda6c634>,0>::_Callable_base<<lambda_e856d28dddb7588070dd099cfda6c634>,0>, COMDAT
; _this$ = ecx

; 175  : 		{	// construct from value

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx

; 176  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Callable_base@V<lambda_e856d28dddb7588070dd099cfda6c634>@@$0A@@std@@QAE@ABV<lambda_e856d28dddb7588070dd099cfda6c634>@@@Z ENDP ; std::_Callable_base<<lambda_e856d28dddb7588070dd099cfda6c634>,0>::_Callable_base<<lambda_e856d28dddb7588070dd099cfda6c634>,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\memory
;	COMDAT ??0?$_Unique_ptr_base@XU?$ThreadTerminator@$0A@@@$00@std@@QAE@PAX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??0?$_Unique_ptr_base@XU?$ThreadTerminator@$0A@@@$00@std@@QAE@PAX@Z PROC ; std::_Unique_ptr_base<void,ThreadTerminator<0>,1>::_Unique_ptr_base<void,ThreadTerminator<0>,1>, COMDAT
; _this$ = ecx

; 1295 : 		{	// construct with pointer and deleter

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [eax], ecx

; 1296 : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Unique_ptr_base@XU?$ThreadTerminator@$0A@@@$00@std@@QAE@PAX@Z ENDP ; std::_Unique_ptr_base<void,ThreadTerminator<0>,1>::_Unique_ptr_base<void,ThreadTerminator<0>,1>
_TEXT	ENDS
END
