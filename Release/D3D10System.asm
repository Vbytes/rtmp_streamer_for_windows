; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.21005.1 

	TITLE	F:\songmm_moon_stone_obs\OBS\Source\D3D10System.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_R3D3D10System@@8				; D3D10System::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AUSavedBlendState@@@8			; SavedBlendState `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@D3D10System@@8			; D3D10System::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@GraphicsSystem@@8			; GraphicsSystem::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R2D3D10System@@8				; D3D10System::`RTTI Base Class Array'
PUBLIC	__GUID_50c83a1c_e072_4c48_87b0_3630fa36a6d0
PUBLIC	??_R0?AUMatrix@@@8				; Matrix `RTTI Type Descriptor'
PUBLIC	__GUID_770aae78_f26f_4dba_a829_253c83d1b387
PUBLIC	??_R0?AVGraphicsSystem@@@8			; GraphicsSystem `RTTI Type Descriptor'
PUBLIC	??_R0?AVD3D10System@@@8				; D3D10System `RTTI Type Descriptor'
PUBLIC	??_R2GraphicsSystem@@8				; GraphicsSystem::`RTTI Base Class Array'
PUBLIC	??_R0?AUVect@@@8				; Vect `RTTI Type Descriptor'
PUBLIC	??_7D3D10System@@6B@				; D3D10System::`vftable'
PUBLIC	??_R3GraphicsSystem@@8				; GraphicsSystem::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AUDeviceOutputData@@@8			; DeviceOutputData `RTTI Type Descriptor'
PUBLIC	??_R4D3D10System@@6B@				; D3D10System::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVUVCoordList@@@8				; UVCoordList `RTTI Type Descriptor'
PUBLIC	??_R0?AUVect2@@@8				; Vect2 `RTTI Type Descriptor'
EXTRN	__imp_?KillSpaces@String@@QAEAAV1@XZ:PROC
EXTRN	__imp_?Clear@StringList@@QAEXXZ:PROC
EXTRN	__imp_??6StringList@@QAEAAV0@PB_W@Z:PROC
EXTRN	__imp_??ZVect2@@QAEAAU0@ABU0@@Z:PROC
EXTRN	__imp_?ClampMax@Vect2@@QAEAAU1@ABU1@@Z:PROC
EXTRN	__imp_?Abs@Vect2@@QAEAAU1@XZ:PROC
EXTRN	__imp_??0Vect@@QAE@ABUVect2@@@Z:PROC
EXTRN	__imp_??GVect@@QBE?AU0@ABU0@@Z:PROC
EXTRN	__imp_??YVect@@QAEAAU0@ABU0@@Z:PROC
EXTRN	__imp_??4Vect@@QAEAAU0@ABU0@@Z:PROC
EXTRN	__imp_??4Vect@@QAEAAU0@ABUVect2@@@Z:PROC
EXTRN	__imp_?Set@Vect@@QAEAAU1@MM@Z:PROC
EXTRN	__imp_?Set@Vect@@QAEAAU1@MMM@Z:PROC
EXTRN	__imp_??0AxisAngle@@QAE@MMMM@Z:PROC
EXTRN	__imp_??0Matrix@@QAE@XZ:PROC
EXTRN	__imp_?Rotate@Matrix@@QAEAAU1@ABUAxisAngle@@@Z:PROC
EXTRN	__imp_?SetIdentity@Matrix@@QAEAAU1@XZ:PROC
EXTRN	__imp_?GetTranspose@Matrix@@QBE?AU1@XZ:PROC
EXTRN	__imp_??4Vect2@@QAEAAU0@ABUVect@@@Z:PROC
EXTRN	__imp_?TransformVector@Vect@@QAEAAU1@ABUMatrix@@@Z:PROC
EXTRN	__imp_?GetViewProj@Shader@@IBEPAXXZ:PROC
EXTRN	__imp_??0OutputDuplicator@@QAE@XZ:PROC
EXTRN	_IID_ID3D10Texture2D:BYTE
EXTRN	__imp__D3D10CreateDeviceAndSwapChain1@36:PROC
EXTRN	__imp_?sstri@@YGPA_WPB_W0@Z:PROC
EXTRN	__imp_??0GraphicsSystem@@QAE@XZ:PROC
EXTRN	__imp_??1GraphicsSystem@@UAE@XZ:PROC
EXTRN	__imp_?Init@GraphicsSystem@@UAEXXZ:PROC
EXTRN	__imp_?OSGetVersion@@YGHXZ:PROC
EXTRN	__imp_?Matrix4x4Transpose@@YAXPAM0@Z:PROC
EXTRN	__imp__CreateDXGIFactory1@8:PROC
EXTRN	__imp_?Matrix4x4Convert@@YAXPAMABUMatrix@@@Z:PROC
EXTRN	__imp_?SetInt@ConfigFile@@QAEXPB_W0H@Z:PROC
EXTRN	__imp_?Matrix4x4Multiply@@YAXPAM00@Z:PROC
EXTRN	__imp_?Matrix4x4Frustum@@YAXPAMNNNNNN@Z:PROC
EXTRN	__imp_?Matrix4x4Ortho@@YAXPAMNNNNNN@Z:PROC
;	COMDAT ??_R0?AUVect2@@@8
data$r	SEGMENT
??_R0?AUVect2@@@8 DD FLAT:??_7type_info@@6B@		; Vect2 `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUVect2@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AVUVCoordList@@@8
data$r	SEGMENT
??_R0?AVUVCoordList@@@8 DD FLAT:??_7type_info@@6B@	; UVCoordList `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVUVCoordList@@', 00H
data$r	ENDS
;	COMDAT ??_R4D3D10System@@6B@
rdata$r	SEGMENT
??_R4D3D10System@@6B@ DD 00H				; D3D10System::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVD3D10System@@@8
	DD	FLAT:??_R3D3D10System@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUDeviceOutputData@@@8
data$r	SEGMENT
??_R0?AUDeviceOutputData@@@8 DD FLAT:??_7type_info@@6B@	; DeviceOutputData `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUDeviceOutputData@@', 00H
data$r	ENDS
;	COMDAT ??_R3GraphicsSystem@@8
rdata$r	SEGMENT
??_R3GraphicsSystem@@8 DD 00H				; GraphicsSystem::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2GraphicsSystem@@8
rdata$r	ENDS
;	COMDAT ??_7D3D10System@@6B@
CONST	SEGMENT
??_7D3D10System@@6B@ DD FLAT:??_R4D3D10System@@6B@	; D3D10System::`vftable'
	DD	FLAT:?ResizeView@D3D10System@@EAEXXZ
	DD	FLAT:?UnloadAllData@D3D10System@@EAEXXZ
	DD	FLAT:??_ED3D10System@@UAEPAXI@Z
	DD	FLAT:?GetDevice@D3D10System@@UAEPAXXZ
	DD	FLAT:?Init@D3D10System@@UAEXXZ
	DD	FLAT:?CreateTextureFromSharedHandle@D3D10System@@UAEPAVTexture@@IIPAX@Z
	DD	FLAT:?CreateTexture@D3D10System@@UAEPAVTexture@@IIW4GSColorFormat@@PAXHH@Z
	DD	FLAT:?CreateTextureFromFile@D3D10System@@UAEPAVTexture@@PB_WH@Z
	DD	FLAT:?CreateRenderTarget@D3D10System@@UAEPAVTexture@@IIW4GSColorFormat@@H@Z
	DD	FLAT:?CreateGDITexture@D3D10System@@UAEPAVTexture@@II@Z
	DD	FLAT:?GetTextureFileInfo@D3D10System@@UAE_NPB_WAAUTextureInfo@@@Z
	DD	FLAT:?CreateSamplerState@D3D10System@@UAEPAVSamplerState@@AAUSamplerInfo@@@Z
	DD	FLAT:?GetNumOutputs@D3D10System@@UAEIXZ
	DD	FLAT:?CreateOutputDuplicator@D3D10System@@UAEPAVOutputDuplicator@@I@Z
	DD	FLAT:?CreateVertexShader@D3D10System@@UAEPAVShader@@PB_W0@Z
	DD	FLAT:?CreatePixelShader@D3D10System@@UAEPAVShader@@PB_W0@Z
	DD	FLAT:?CreateVertexBuffer@D3D10System@@UAEPAVVertexBuffer@@PAUVBData@@H@Z
	DD	FLAT:?LoadVertexBuffer@D3D10System@@UAEXPAVVertexBuffer@@@Z
	DD	FLAT:?LoadTexture@D3D10System@@UAEXPAVTexture@@I@Z
	DD	FLAT:?LoadSamplerState@D3D10System@@UAEXPAVSamplerState@@I@Z
	DD	FLAT:?LoadVertexShader@D3D10System@@UAEXPAVShader@@@Z
	DD	FLAT:?LoadPixelShader@D3D10System@@UAEXPAVShader@@@Z
	DD	FLAT:?GetCurrentPixelShader@D3D10System@@UAEPAVShader@@XZ
	DD	FLAT:?GetCurrentVertexShader@D3D10System@@UAEPAVShader@@XZ
	DD	FLAT:?SetRenderTarget@D3D10System@@UAEXPAVTexture@@@Z
	DD	FLAT:?Draw@D3D10System@@UAEXW4GSDrawMode@@KK@Z
	DD	FLAT:?EnableBlending@D3D10System@@UAEXH@Z
	DD	FLAT:?BlendFunction@D3D10System@@UAEXW4GSBlendType@@0M@Z
	DD	FLAT:?ClearColorBuffer@D3D10System@@UAEXK@Z
	DD	FLAT:?DrawSpriteEx@D3D10System@@UAEXPAVTexture@@KMMMMMMMM@Z
	DD	FLAT:?DrawBox@D3D10System@@UAEXABUVect2@@0@Z
	DD	FLAT:?SetCropping@D3D10System@@UAEXMMMM@Z
	DD	FLAT:?Ortho@D3D10System@@UAEXMMMMMM@Z
	DD	FLAT:?Frustum@D3D10System@@UAEXMMMMMM@Z
	DD	FLAT:?SetViewport@D3D10System@@UAEXMMMM@Z
	DD	FLAT:?SetScissorRect@D3D10System@@UAEXPAUXRect@@@Z
	DD	FLAT:?CreateSharedTexture@D3D10System@@UAEPAVTexture@@II@Z
	DD	FLAT:?ResetViewMatrix@D3D10System@@EAEXXZ
	DD	FLAT:?CopyTexture@D3D10System@@UAEXPAVTexture@@0@Z
	DD	FLAT:?DrawSpriteExRotate@D3D10System@@UAEXPAVTexture@@KMMMMMMMMMM@Z
	DD	FLAT:?CreateVertexShaderFromBlob@D3D10System@@UAEPAVShader@@ABV?$vector@DV?$allocator@D@std@@@std@@PB_W1@Z
	DD	FLAT:?CreatePixelShaderFromBlob@D3D10System@@UAEPAVShader@@ABV?$vector@DV?$allocator@D@std@@@std@@PB_W1@Z
	DD	FLAT:?CreateVertexShaderBlob@D3D10System@@EAEXAAV?$vector@DV?$allocator@D@std@@@std@@PB_W1@Z
	DD	FLAT:?CreatePixelShaderBlob@D3D10System@@EAEXAAV?$vector@DV?$allocator@D@std@@@std@@PB_W1@Z
CONST	ENDS
;	COMDAT ??_R0?AUVect@@@8
data$r	SEGMENT
??_R0?AUVect@@@8 DD FLAT:??_7type_info@@6B@		; Vect `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUVect@@', 00H
data$r	ENDS
;	COMDAT ??_R2GraphicsSystem@@8
rdata$r	SEGMENT
??_R2GraphicsSystem@@8 DD FLAT:??_R1A@?0A@EA@GraphicsSystem@@8 ; GraphicsSystem::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R0?AVD3D10System@@@8
data$r	SEGMENT
??_R0?AVD3D10System@@@8 DD FLAT:??_7type_info@@6B@	; D3D10System `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVD3D10System@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AVGraphicsSystem@@@8
data$r	SEGMENT
??_R0?AVGraphicsSystem@@@8 DD FLAT:??_7type_info@@6B@	; GraphicsSystem `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVGraphicsSystem@@', 00H
data$r	ENDS
;	COMDAT __GUID_770aae78_f26f_4dba_a829_253c83d1b387
CONST	SEGMENT
__GUID_770aae78_f26f_4dba_a829_253c83d1b387 DD 0770aae78H
	DW	0f26fH
	DW	04dbaH
	DB	0a8H
	DB	029H
	DB	025H
	DB	03cH
	DB	083H
	DB	0d1H
	DB	0b3H
	DB	087H
CONST	ENDS
;	COMDAT ??_R0?AUMatrix@@@8
data$r	SEGMENT
??_R0?AUMatrix@@@8 DD FLAT:??_7type_info@@6B@		; Matrix `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUMatrix@@', 00H
data$r	ENDS
;	COMDAT __GUID_50c83a1c_e072_4c48_87b0_3630fa36a6d0
CONST	SEGMENT
__GUID_50c83a1c_e072_4c48_87b0_3630fa36a6d0 DD 050c83a1cH
	DW	0e072H
	DW	04c48H
	DB	087H
	DB	0b0H
	DB	036H
	DB	030H
	DB	0faH
	DB	036H
	DB	0a6H
	DB	0d0H
CONST	ENDS
;	COMDAT ??_R2D3D10System@@8
rdata$r	SEGMENT
??_R2D3D10System@@8 DD FLAT:??_R1A@?0A@EA@D3D10System@@8 ; D3D10System::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@GraphicsSystem@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@GraphicsSystem@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@GraphicsSystem@@8 DD FLAT:??_R0?AVGraphicsSystem@@@8 ; GraphicsSystem::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3GraphicsSystem@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@D3D10System@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@D3D10System@@8 DD FLAT:??_R0?AVD3D10System@@@8 ; D3D10System::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3D3D10System@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUSavedBlendState@@@8
data$r	SEGMENT
??_R0?AUSavedBlendState@@@8 DD FLAT:??_7type_info@@6B@	; SavedBlendState `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUSavedBlendState@@', 00H
data$r	ENDS
;	COMDAT ??_R3D3D10System@@8
rdata$r	SEGMENT
??_R3D3D10System@@8 DD 00H				; D3D10System::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2D3D10System@@8
$SG4294909741 DB 'C', 00H, 'o', 00H, 'u', 00H, 'l', 00H, 'd', 00H, ' ', 00H
	DB	'n', 00H, 'o', 00H, 't', 00H, ' ', 00H, 'q', 00H, 'u', 00H, 'e'
	DB	00H, 'r', 00H, 'y', 00H, ' ', 00H, 'a', 00H, 'd', 00H, 'a', 00H
	DB	'p', 00H, 't', 00H, 'e', 00H, 'r', 00H, ' ', 00H, '%', 00H, 'u'
	DB	00H, 00H, 00H
	ORG $+2
$SG4294909740 DB '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H
	DB	'-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-'
	DB	00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H
	DB	'-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-'
	DB	00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H
	DB	'-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-'
	DB	00H, '-', 00H, '-', 00H, '-', 00H, 00H, 00H
	ORG $+2
$SG4294909739 DB 'A', 00H, 'd', 00H, 'a', 00H, 'p', 00H, 't', 00H, 'e', 00H
	DB	'r', 00H, ' ', 00H, '%', 00H, 'u', 00H, 00H, 00H
	ORG $+2
$SG4294909738 DB ' ', 00H, ' ', 00H, 'V', 00H, 'i', 00H, 'd', 00H, 'e', 00H
	DB	'o', 00H, ' ', 00H, 'A', 00H, 'd', 00H, 'a', 00H, 'p', 00H, 't'
	DB	00H, 'e', 00H, 'r', 00H, ':', 00H, ' ', 00H, '%', 00H, 's', 00H
	DB	00H, 00H
$SG4294909737 DB ' ', 00H, ' ', 00H, 'V', 00H, 'i', 00H, 'd', 00H, 'e', 00H
	DB	'o', 00H, ' ', 00H, 'A', 00H, 'd', 00H, 'a', 00H, 'p', 00H, 't'
	DB	00H, 'e', 00H, 'r', 00H, ' ', 00H, 'D', 00H, 'e', 00H, 'd', 00H
	DB	'i', 00H, 'c', 00H, 'a', 00H, 't', 00H, 'e', 00H, 'd', 00H, ' '
	DB	00H, 'V', 00H, 'i', 00H, 'd', 00H, 'e', 00H, 'o', 00H, ' ', 00H
	DB	'M', 00H, 'e', 00H, 'm', 00H, 'o', 00H, 'r', 00H, 'y', 00H, ':'
	DB	00H, ' ', 00H, '%', 00H, 'u', 00H, 00H, 00H
	ORG $+2
$SG4294909736 DB ' ', 00H, ' ', 00H, 'V', 00H, 'i', 00H, 'd', 00H, 'e', 00H
	DB	'o', 00H, ' ', 00H, 'A', 00H, 'd', 00H, 'a', 00H, 'p', 00H, 't'
	DB	00H, 'e', 00H, 'r', 00H, ' ', 00H, 'S', 00H, 'h', 00H, 'a', 00H
	DB	'r', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 'S', 00H, 'y', 00H, 's'
	DB	00H, 't', 00H, 'e', 00H, 'm', 00H, ' ', 00H, 'M', 00H, 'e', 00H
	DB	'm', 00H, 'o', 00H, 'r', 00H, 'y', 00H, ':', 00H, ' ', 00H, '%'
	DB	00H, 'u', 00H, 00H, 00H
	ORG $+2
$SG4294909735 DB 't', 00H, 'r', 00H, 'u', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG4294909734 DB 'f', 00H, 'a', 00H, 'l', 00H, 's', 00H, 'e', 00H, 00H, 00H
$SG4294909727 DB 'V', 00H, 'i', 00H, 'd', 00H, 'e', 00H, 'o', 00H, 00H, 00H
$SG4294909733 DB ' ', 00H, ' ', 00H, 'V', 00H, 'i', 00H, 'd', 00H, 'e', 00H
	DB	'o', 00H, ' ', 00H, 'A', 00H, 'd', 00H, 'a', 00H, 'p', 00H, 't'
	DB	00H, 'e', 00H, 'r', 00H, ' ', 00H, 'O', 00H, 'u', 00H, 't', 00H
	DB	'p', 00H, 'u', 00H, 't', 00H, ' ', 00H, '%', 00H, 'u', 00H, ':'
	DB	00H, ' ', 00H, 'p', 00H, 'o', 00H, 's', 00H, '=', 00H, '{', 00H
	DB	'%', 00H, 'd', 00H, ',', 00H, ' ', 00H, '%', 00H, 'd', 00H, '}'
	DB	00H, ',', 00H, ' ', 00H, 's', 00H, 'i', 00H, 'z', 00H, 'e', 00H
	DB	'=', 00H, '{', 00H, '%', 00H, 'd', 00H, ',', 00H, ' ', 00H, '%'
	DB	00H, 'd', 00H, '}', 00H, ',', 00H, ' ', 00H, 'a', 00H, 't', 00H
	DB	't', 00H, 'a', 00H, 'c', 00H, 'h', 00H, 'e', 00H, 'd', 00H, '='
	DB	00H, '%', 00H, 's', 00H, 00H, 00H
$SG4294909732 DB 'C', 00H, 'o', 00H, 'u', 00H, 'l', 00H, 'd', 00H, ' ', 00H
	DB	'n', 00H, 'o', 00H, 't', 00H, ' ', 00H, 'q', 00H, 'u', 00H, 'e'
	DB	00H, 'r', 00H, 'y', 00H, ' ', 00H, 'a', 00H, 'd', 00H, 'a', 00H
	DB	'p', 00H, 't', 00H, 'e', 00H, 'r', 00H, ' ', 00H, '%', 00H, 'u'
	DB	00H, 00H, 00H
	ORG $+2
$SG4294909731 DB 'N', 00H, 'V', 00H, 'I', 00H, 'D', 00H, 'I', 00H, 'A', 00H
	DB	00H, 00H
	ORG $+2
$SG4294909730 DB 'N', 00H, 'v', 00H, 'i', 00H, 'd', 00H, 'i', 00H, 'a', 00H
	DB	' ', 00H, 'o', 00H, 'p', 00H, 't', 00H, 'i', 00H, 'm', 00H, 'u'
	DB	00H, 's', 00H, ' ', 00H, 'd', 00H, 'e', 00H, 't', 00H, 'e', 00H
	DB	'c', 00H, 't', 00H, 'e', 00H, 'd', 00H, ',', 00H, ' ', 00H, 's'
	DB	00H, 'e', 00H, 'c', 00H, 'o', 00H, 'n', 00H, 'd', 00H, ' ', 00H
	DB	'a', 00H, 'd', 00H, 'a', 00H, 'p', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, ' ', 00H, 's', 00H, 'e', 00H, 'l', 00H, 'e', 00H, 'c', 00H
	DB	't', 00H, 'e', 00H, 'd', 00H, ',', 00H, ' ', 00H, 'i', 00H, 'g'
	DB	00H, 'n', 00H, 'o', 00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g', 00H
	DB	' ', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'l', 00H, 'e', 00H, 's'
	DB	00H, 's', 00H, ' ', 00H, 's', 00H, 'e', 00H, 'c', 00H, 'o', 00H
	DB	'n', 00H, 'd', 00H, ' ', 00H, 'a', 00H, 'd', 00H, 'a', 00H, 'p'
	DB	00H, 't', 00H, 'e', 00H, 'r', 00H, ',', 00H, ' ', 00H, 'I', 00H
	DB	' ', 00H, 'g', 00H, 'u', 00H, 'e', 00H, 's', 00H, 's', 00H, '.'
	DB	00H, 00H, 00H
$SG4294909729 DB 'C', 00H, 'o', 00H, 'u', 00H, 'l', 00H, 'd', 00H, ' ', 00H
	DB	'n', 00H, 'o', 00H, 't', 00H, ' ', 00H, 'g', 00H, 'e', 00H, 't'
	DB	00H, ' ', 00H, 'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H, ' ', 00H
	DB	'a', 00H, 'd', 00H, 'a', 00H, 'p', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, 00H, 00H
	ORG $+2
$SG4294909728 DB 'A', 00H, 'd', 00H, 'a', 00H, 'p', 00H, 't', 00H, 'e', 00H
	DB	'r', 00H, 00H, 00H
$SG4294909726 DB 'C', 00H, 'o', 00H, 'u', 00H, 'l', 00H, 'd', 00H, ' ', 00H
	DB	'n', 00H, 'o', 00H, 't', 00H, ' ', 00H, 'c', 00H, 'r', 00H, 'e'
	DB	00H, 'a', 00H, 't', 00H, 'e', 00H, ' ', 00H, 'D', 00H, 'X', 00H
	DB	'G', 00H, 'I', 00H, ' ', 00H, 'f', 00H, 'a', 00H, 'c', 00H, 't'
	DB	00H, 'o', 00H, 'r', 00H, 'y', 00H, 00H, 00H
$SG4294909723 DB 'V', 00H, 'i', 00H, 'd', 00H, 'e', 00H, 'o', 00H, 00H, 00H
$SG4294909725 DB 'I', 00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H
	DB	'd', 00H, ' ', 00H, 'a', 00H, 'd', 00H, 'a', 00H, 'p', 00H, 't'
	DB	00H, 'e', 00H, 'r', 00H, ' ', 00H, 'i', 00H, 'd', 00H, ' ', 00H
	DB	'%', 00H, 'd', 00H, ',', 00H, ' ', 00H, 'o', 00H, 'n', 00H, 'l'
	DB	00H, 'y', 00H, ' ', 00H, '%', 00H, 'd', 00H, ' ', 00H, 'a', 00H
	DB	'd', 00H, 'a', 00H, 'p', 00H, 't', 00H, 'e', 00H, 'r', 00H, 's'
	DB	00H, ' ', 00H, 'o', 00H, 'n', 00H, ' ', 00H, 's', 00H, 'y', 00H
	DB	's', 00H, 't', 00H, 'e', 00H, 'm', 00H, '.', 00H, ' ', 00H, 'R'
	DB	00H, 'e', 00H, 's', 00H, 'e', 00H, 't', 00H, 't', 00H, 'i', 00H
	DB	'n', 00H, 'g', 00H, ' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, '0'
	DB	00H, '.', 00H, 00H, 00H
	ORG $+2
$SG4294909724 DB 'A', 00H, 'd', 00H, 'a', 00H, 'p', 00H, 't', 00H, 'e', 00H
	DB	'r', 00H, 00H, 00H
$SG4294909722 DB 'C', 00H, 'o', 00H, 'u', 00H, 'l', 00H, 'd', 00H, ' ', 00H
	DB	'n', 00H, 'o', 00H, 't', 00H, ' ', 00H, 'g', 00H, 'e', 00H, 't'
	DB	00H, ' ', 00H, 'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H, ' ', 00H
	DB	'a', 00H, 'd', 00H, 'a', 00H, 'p', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, ' ', 00H, '%', 00H, 'd', 00H, 00H, 00H
$SG4294909721 DB 'U', 00H, 's', 00H, 'e', 00H, 'D', 00H, 'e', 00H, 'b', 00H
	DB	'u', 00H, 'g', 00H, 'D', 00H, '3', 00H, 'D', 00H, 00H, 00H
$SG4294909720 DB 'G', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 'r', 00H, 'a', 00H
	DB	'l', 00H, 00H, 00H
$SG4294909719 DB '<', 00H, 'u', 00H, 'n', 00H, 'k', 00H, 'n', 00H, 'o', 00H
	DB	'w', 00H, 'n', 00H, '>', 00H, 00H, 00H
$SG4294909718 DB 'L', 00H, 'o', 00H, 'a', 00H, 'd', 00H, 'i', 00H, 'n', 00H
	DB	'g', 00H, ' ', 00H, 'u', 00H, 'p', 00H, ' ', 00H, 'D', 00H, '3'
	DB	00H, 'D', 00H, '1', 00H, '0', 00H, ' ', 00H, 'o', 00H, 'n', 00H
	DB	' ', 00H, '%', 00H, 's', 00H, ' ', 00H, '(', 00H, 'A', 00H, 'd'
	DB	00H, 'a', 00H, 'p', 00H, 't', 00H, 'e', 00H, 'r', 00H, ' ', 00H
	DB	'%', 00H, 'u', 00H, ')', 00H, '.', 00H, '.', 00H, '.', 00H, 00H
	DB	00H
	ORG $+2
$SG4294909717 DB 'D', 00H, '3', 00H, 'D', 00H, '1', 00H, '0', 00H, 'C', 00H
	DB	'r', 00H, 'e', 00H, 'a', 00H, 't', 00H, 'e', 00H, 'D', 00H, 'e'
	DB	00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H, 'A', 00H, 'n', 00H
	DB	'd', 00H, 'S', 00H, 'w', 00H, 'a', 00H, 'p', 00H, 'C', 00H, 'h'
	DB	00H, 'a', 00H, 'i', 00H, 'n', 00H, '1', 00H, ':', 00H, ' ', 00H
	DB	'F', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H, ' '
	DB	00H, 'o', 00H, 'n', 00H, ' ', 00H, '%', 00H, 's', 00H, ':', 00H
	DB	' ', 00H, '0', 00H, 'x', 00H, '%', 00H, '0', 00H, '8', 00H, 'x'
	DB	00H, '.', 00H, ' ', 00H, 'T', 00H, 'r', 00H, 'y', 00H, 'i', 00H
	DB	'n', 00H, 'g', 00H, ' ', 00H, 'c', 00H, 'o', 00H, 'm', 00H, 'p'
	DB	00H, 'a', 00H, 't', 00H, 'i', 00H, 'b', 00H, 'i', 00H, 'l', 00H
	DB	'i', 00H, 't', 00H, 'y', 00H, ' ', 00H, 'm', 00H, 'o', 00H, 'd'
	DB	00H, 'e', 00H, 00H, 00H
$SG4294909716 DB 'D', 00H, '3', 00H, 'D', 00H, '1', 00H, '0', 00H, 'C', 00H
	DB	'r', 00H, 'e', 00H, 'a', 00H, 't', 00H, 'e', 00H, 'D', 00H, 'e'
	DB	00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H, 'A', 00H, 'n', 00H
	DB	'd', 00H, 'S', 00H, 'w', 00H, 'a', 00H, 'p', 00H, 'C', 00H, 'h'
	DB	00H, 'a', 00H, 'i', 00H, 'n', 00H, '1', 00H, ':', 00H, ' ', 00H
	DB	'F', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H, ' '
	DB	00H, 'o', 00H, 'n', 00H, ' ', 00H, '%', 00H, 's', 00H, ':', 00H
	DB	' ', 00H, '0', 00H, 'x', 00H, '%', 00H, '0', 00H, '8', 00H, 'x'
	DB	00H, 00H, 00H
	ORG $+2
$SG4294909714 DB 'U', 00H, 'n', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H
	DB	' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'c', 00H, 'r', 00H, 'e'
	DB	00H, 'a', 00H, 't', 00H, 'e', 00H, ' ', 00H, 'd', 00H, 'e', 00H
	DB	'p', 00H, 't', 00H, 'h', 00H, ' ', 00H, 's', 00H, 't', 00H, 'a'
	DB	00H, 't', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG4294909715 DB 'C', 00H, 'o', 00H, 'u', 00H, 'l', 00H, 'd', 00H, ' ', 00H
	DB	'n', 00H, 'o', 00H, 't', 00H, ' ', 00H, 'i', 00H, 'n', 00H, 'i'
	DB	00H, 't', 00H, 'i', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'z', 00H
	DB	'e', 00H, ' ', 00H, 'D', 00H, 'i', 00H, 'r', 00H, 'e', 00H, 'c'
	DB	00H, 't', 00H, 'X', 00H, ' ', 00H, '1', 00H, '0', 00H, ' ', 00H
	DB	'o', 00H, 'n', 00H, ' ', 00H, '%', 00H, 's', 00H, '.', 00H, ' '
	DB	00H, ' ', 00H, 'T', 00H, 'h', 00H, 'i', 00H, 's', 00H, ' ', 00H
	DB	'e', 00H, 'r', 00H, 'r', 00H, 'o', 00H, 'r', 00H, ' ', 00H, 'c'
	DB	00H, 'a', 00H, 'n', 00H, ' ', 00H, 'h', 00H, 'a', 00H, 'p', 00H
	DB	'p', 00H, 'e', 00H, 'n', 00H, ' ', 00H, 'f', 00H, 'o', 00H, 'r'
	DB	00H, ' ', 00H, 'o', 00H, 'n', 00H, 'e', 00H, ' ', 00H, 'o', 00H
	DB	'f', 00H, ' ', 00H, 't', 00H, 'h', 00H, 'e', 00H, ' ', 00H, 'f'
	DB	00H, 'o', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'w', 00H, 'i', 00H
	DB	'n', 00H, 'g', 00H, ' ', 00H, 'r', 00H, 'e', 00H, 'a', 00H, 's'
	DB	00H, 'o', 00H, 'n', 00H, 's', 00H, ':', 00H, 0dH, 00H, 0aH, 00H
	DB	0dH, 00H, 0aH, 00H, '1', 00H, '.', 00H, ')', 00H, ' ', 00H, 'Y'
	DB	00H, 'o', 00H, 'u', 00H, 'r', 00H, ' ', 00H, 'G', 00H, 'P', 00H
	DB	'U', 00H, ' ', 00H, 'i', 00H, 's', 00H, ' ', 00H, 'n', 00H, 'o'
	DB	00H, 't', 00H, ' ', 00H, 's', 00H, 'u', 00H, 'p', 00H, 'p', 00H
	DB	'o', 00H, 'r', 00H, 't', 00H, 'e', 00H, 'd', 00H, ' ', 00H, '('
	DB	00H, 'D', 00H, 'i', 00H, 'r', 00H, 'e', 00H, 'c', 00H, 't', 00H
	DB	'X', 00H, ' ', 00H, '1', 00H, '0', 00H, ' ', 00H, 'i', 00H, 's'
	DB	00H, ' ', 00H, 'r', 00H, 'e', 00H, 'q', 00H, 'u', 00H, 'i', 00H
	DB	'r', 00H, 'e', 00H, 'd', 00H, ' ', 00H, '-', 00H, ' ', 00H, 'n'
	DB	00H, 'o', 00H, 't', 00H, 'e', 00H, ' ', 00H, 't', 00H, 'h', 00H
	DB	'a', 00H, 't', 00H, ' ', 00H, 'm', 00H, 'a', 00H, 'n', 00H, 'y'
	DB	00H, ' ', 00H, 'i', 00H, 'n', 00H, 't', 00H, 'e', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 't', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 'l'
	DB	00H, 'a', 00H, 'p', 00H, 't', 00H, 'o', 00H, 'p', 00H, ' ', 00H
	DB	'G', 00H, 'P', 00H, 'U', 00H, 's', 00H, ' ', 00H, 'd', 00H, 'o'
	DB	00H, ' ', 00H, 'n', 00H, 'o', 00H, 't', 00H, ' ', 00H, 's', 00H
	DB	'u', 00H, 'p', 00H, 'p', 00H, 'o', 00H, 'r', 00H, 't', 00H, ' '
	DB	00H, 'D', 00H, 'X', 00H, '1', 00H, '0', 00H, ')', 00H, 0dH, 00H
	DB	0aH, 00H, '2', 00H, '.', 00H, ')', 00H, ' ', 00H, 'Y', 00H, 'o'
	DB	00H, 'u', 00H, '''', 00H, 'r', 00H, 'e', 00H, ' ', 00H, 'r', 00H
	DB	'u', 00H, 'n', 00H, 'n', 00H, 'i', 00H, 'n', 00H, 'g', 00H, ' '
	DB	00H, 'W', 00H, 'i', 00H, 'n', 00H, 'd', 00H, 'o', 00H, 'w', 00H
	DB	's', 00H, ' ', 00H, 'V', 00H, 'i', 00H, 's', 00H, 't', 00H, 'a'
	DB	00H, ' ', 00H, 'w', 00H, 'i', 00H, 't', 00H, 'h', 00H, 'o', 00H
	DB	'u', 00H, 't', 00H, ' ', 00H, 't', 00H, 'h', 00H, 'e', 00H, ' '
	DB	00H, '"', 00H, 'P', 00H, 'l', 00H, 'a', 00H, 't', 00H, 'f', 00H
	DB	'o', 00H, 'r', 00H, 'm', 00H, ' ', 00H, 'U', 00H, 'p', 00H, 'd'
	DB	00H, 'a', 00H, 't', 00H, 'e', 00H, '"', 00H, 0dH, 00H, 0aH, 00H
	DB	'3', 00H, '.', 00H, ')', 00H, ' ', 00H, 'Y', 00H, 'o', 00H, 'u'
	DB	00H, 'r', 00H, ' ', 00H, 'v', 00H, 'i', 00H, 'd', 00H, 'e', 00H
	DB	'o', 00H, ' ', 00H, 'c', 00H, 'a', 00H, 'r', 00H, 'd', 00H, ' '
	DB	00H, 'd', 00H, 'r', 00H, 'i', 00H, 'v', 00H, 'e', 00H, 'r', 00H
	DB	's', 00H, ' ', 00H, 'a', 00H, 'r', 00H, 'e', 00H, ' ', 00H, 'o'
	DB	00H, 'u', 00H, 't', 00H, ' ', 00H, 'o', 00H, 'f', 00H, ' ', 00H
	DB	'd', 00H, 'a', 00H, 't', 00H, 'e', 00H, 0dH, 00H, 0aH, 00H, 0dH
	DB	00H, 0aH, 00H, 'I', 00H, 'f', 00H, ' ', 00H, 'y', 00H, 'o', 00H
	DB	'u', 00H, ' ', 00H, 'a', 00H, 'r', 00H, 'e', 00H, ' ', 00H, 'u'
	DB	00H, 's', 00H, 'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H, 'a', 00H
	DB	' ', 00H, 'l', 00H, 'a', 00H, 'p', 00H, 't', 00H, 'o', 00H, 'p'
	DB	00H, ' ', 00H, 'w', 00H, 'i', 00H, 't', 00H, 'h', 00H, ' ', 00H
	DB	'N', 00H, 'V', 00H, 'I', 00H, 'D', 00H, 'I', 00H, 'A', 00H, ' '
	DB	00H, 'O', 00H, 'p', 00H, 't', 00H, 'i', 00H, 'm', 00H, 'u', 00H
	DB	's', 00H, ' ', 00H, 'o', 00H, 'r', 00H, ' ', 00H, 'A', 00H, 'M'
	DB	00H, 'D', 00H, ' ', 00H, 'S', 00H, 'w', 00H, 'i', 00H, 't', 00H
	DB	'c', 00H, 'h', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, ' '
	DB	00H, 'G', 00H, 'r', 00H, 'a', 00H, 'p', 00H, 'h', 00H, 'i', 00H
	DB	'c', 00H, 's', 00H, ',', 00H, ' ', 00H, 'm', 00H, 'a', 00H, 'k'
	DB	00H, 'e', 00H, ' ', 00H, 's', 00H, 'u', 00H, 'r', 00H, 'e', 00H
	DB	' ', 00H, 'O', 00H, 'B', 00H, 'S', 00H, ' ', 00H, 'i', 00H, 's'
	DB	00H, ' ', 00H, 's', 00H, 'e', 00H, 't', 00H, ' ', 00H, 't', 00H
	DB	'o', 00H, ' ', 00H, 'r', 00H, 'u', 00H, 'n', 00H, ' ', 00H, 'o'
	DB	00H, 'n', 00H, ' ', 00H, 't', 00H, 'h', 00H, 'e', 00H, ' ', 00H
	DB	'h', 00H, 'i', 00H, 'g', 00H, 'h', 00H, ' ', 00H, 'p', 00H, 'e'
	DB	00H, 'r', 00H, 'f', 00H, 'o', 00H, 'r', 00H, 'm', 00H, 'a', 00H
	DB	'n', 00H, 'c', 00H, 'e', 00H, ' ', 00H, 'G', 00H, 'P', 00H, 'U'
	DB	00H, ' ', 00H, 'i', 00H, 'n', 00H, ' ', 00H, 'y', 00H, 'o', 00H
	DB	'u', 00H, 'r', 00H, ' ', 00H, 'd', 00H, 'r', 00H, 'i', 00H, 'v'
	DB	00H, 'e', 00H, 'r', 00H, ' ', 00H, 's', 00H, 'e', 00H, 't', 00H
	DB	't', 00H, 'i', 00H, 'n', 00H, 'g', 00H, 's', 00H, '.', 00H, 00H
	DB	00H
	ORG $+2
$SG4294909704 DB 'C', 00H, 'o', 00H, 'u', 00H, 'l', 00H, 'd', 00H, ' ', 00H
	DB	'n', 00H, 'o', 00H, 't', 00H, ' ', 00H, 's', 00H, 'e', 00H, 't'
	DB	00H, ' ', 00H, 'b', 00H, 'l', 00H, 'e', 00H, 'n', 00H, 'd', 00H
	DB	' ', 00H, 's', 00H, 't', 00H, 'a', 00H, 't', 00H, 'e', 00H, 00H
	DB	00H
$SG4294909713 DB 'U', 00H, 'n', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H
	DB	' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'c', 00H, 'r', 00H, 'e'
	DB	00H, 'a', 00H, 't', 00H, 'e', 00H, ' ', 00H, 'r', 00H, 'a', 00H
	DB	's', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'i', 00H, 'z', 00H, 'e'
	DB	00H, 'r', 00H, ' ', 00H, 's', 00H, 't', 00H, 'a', 00H, 't', 00H
	DB	'e', 00H, 00H, 00H
$SG4294909712 DB 'U', 00H, 'n', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H
	DB	' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'c', 00H, 'r', 00H, 'e'
	DB	00H, 'a', 00H, 't', 00H, 'e', 00H, ' ', 00H, 's', 00H, 'c', 00H
	DB	'i', 00H, 's', 00H, 's', 00H, 'o', 00H, 'r', 00H, ' ', 00H, 's'
	DB	00H, 't', 00H, 'a', 00H, 't', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG4294909702 DB 'o', 00H, 'u', 00H, 't', 00H, 'p', 00H, 'u', 00H, 't', 00H
	DB	'C', 00H, 'o', 00H, 'l', 00H, 'o', 00H, 'r', 00H, 00H, 00H
_topologies DD	01H
	DD	02H
	DD	03H
	DD	04H
	DD	05H
$SG4294909711 DB 'U', 00H, 'n', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H
	DB	' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'g', 00H, 'e', 00H, 't'
	DB	00H, ' ', 00H, 'b', 00H, 'a', 00H, 'c', 00H, 'k', 00H, ' ', 00H
	DB	'b', 00H, 'u', 00H, 'f', 00H, 'f', 00H, 'e', 00H, 'r', 00H, ' '
	DB	00H, 'f', 00H, 'r', 00H, 'o', 00H, 'm', 00H, ' ', 00H, 's', 00H
	DB	'w', 00H, 'a', 00H, 'p', 00H, ' ', 00H, 'c', 00H, 'h', 00H, 'a'
	DB	00H, 'i', 00H, 'n', 00H, 00H, 00H
$SG4294909710 DB 'U', 00H, 'n', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H
	DB	' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'g', 00H, 'e', 00H, 't'
	DB	00H, ' ', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 'd', 00H, 'e', 00H
	DB	'r', 00H, ' ', 00H, 'v', 00H, 'i', 00H, 'e', 00H, 'w', 00H, ' '
	DB	00H, 'f', 00H, 'r', 00H, 'o', 00H, 'm', 00H, ' ', 00H, 'b', 00H
	DB	'a', 00H, 'c', 00H, 'k', 00H, ' ', 00H, 'b', 00H, 'u', 00H, 'f'
	DB	00H, 'f', 00H, 'e', 00H, 'r', 00H, 00H, 00H
	ORG $+2
$SG4294909709 DB 'U', 00H, 'n', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H
	DB	' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'c', 00H, 'r', 00H, 'e'
	DB	00H, 'a', 00H, 't', 00H, 'e', 00H, ' ', 00H, 'd', 00H, 'i', 00H
	DB	's', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, 'd', 00H, ' '
	DB	00H, 'b', 00H, 'l', 00H, 'e', 00H, 'n', 00H, 'd', 00H, ' ', 00H
	DB	's', 00H, 't', 00H, 'a', 00H, 't', 00H, 'e', 00H, 00H, 00H
$SG4294909708 DB 't', 00H, 'r', 00H, 'i', 00H, 'e', 00H, 'd', 00H, ' ', 00H
	DB	't', 00H, 'o', 00H, ' ', 00H, 's', 00H, 'e', 00H, 't', 00H, ' '
	DB	00H, 'a', 00H, ' ', 00H, 't', 00H, 'e', 00H, 'x', 00H, 't', 00H
	DB	'u', 00H, 'r', 00H, 'e', 00H, ' ', 00H, 't', 00H, 'h', 00H, 'a'
	DB	00H, 't', 00H, ' ', 00H, 'w', 00H, 'a', 00H, 's', 00H, 'n', 00H
	DB	'''', 00H, 't', 00H, ' ', 00H, 'a', 00H, ' ', 00H, 'r', 00H, 'e'
	DB	00H, 'n', 00H, 'd', 00H, 'e', 00H, 'r', 00H, ' ', 00H, 't', 00H
	DB	'a', 00H, 'r', 00H, 'g', 00H, 'e', 00H, 't', 00H, ' ', 00H, 'a'
	DB	00H, 's', 00H, ' ', 00H, 'a', 00H, ' ', 00H, 'r', 00H, 'e', 00H
	DB	'n', 00H, 'd', 00H, 'e', 00H, 'r', 00H, ' ', 00H, 't', 00H, 'a'
	DB	00H, 'r', 00H, 'g', 00H, 'e', 00H, 't', 00H, 00H, 00H
$SG4294909707 DB 'T', 00H, 'r', 00H, 'i', 00H, 'e', 00H, 'd', 00H, ' ', 00H
	DB	't', 00H, 'o', 00H, ' ', 00H, 'c', 00H, 'a', 00H, 'l', 00H, 'l'
	DB	00H, ' ', 00H, 'd', 00H, 'r', 00H, 'a', 00H, 'w', 00H, ' ', 00H
	DB	'w', 00H, 'i', 00H, 't', 00H, 'h', 00H, 'o', 00H, 'u', 00H, 't'
	DB	00H, ' ', 00H, 's', 00H, 'e', 00H, 't', 00H, 't', 00H, 'i', 00H
	DB	'n', 00H, 'g', 00H, ' ', 00H, 'a', 00H, ' ', 00H, 'v', 00H, 'e'
	DB	00H, 'r', 00H, 't', 00H, 'e', 00H, 'x', 00H, ' ', 00H, 'b', 00H
	DB	'u', 00H, 'f', 00H, 'f', 00H, 'e', 00H, 'r', 00H, 00H, 00H
	ORG $+2
$SG4294909706 DB 'T', 00H, 'r', 00H, 'i', 00H, 'e', 00H, 'd', 00H, ' ', 00H
	DB	't', 00H, 'o', 00H, ' ', 00H, 'c', 00H, 'a', 00H, 'l', 00H, 'l'
	DB	00H, ' ', 00H, 'd', 00H, 'r', 00H, 'a', 00H, 'w', 00H, ' ', 00H
	DB	'w', 00H, 'i', 00H, 't', 00H, 'h', 00H, 'o', 00H, 'u', 00H, 't'
	DB	00H, ' ', 00H, 's', 00H, 'e', 00H, 't', 00H, 't', 00H, 'i', 00H
	DB	'n', 00H, 'g', 00H, ' ', 00H, 'a', 00H, ' ', 00H, 'v', 00H, 'e'
	DB	00H, 'r', 00H, 't', 00H, 'e', 00H, 'x', 00H, ' ', 00H, 's', 00H
	DB	'h', 00H, 'a', 00H, 'd', 00H, 'e', 00H, 'r', 00H, 00H, 00H
	ORG $+2
$SG4294909705 DB 'T', 00H, 'r', 00H, 'i', 00H, 'e', 00H, 'd', 00H, ' ', 00H
	DB	't', 00H, 'o', 00H, ' ', 00H, 'c', 00H, 'a', 00H, 'l', 00H, 'l'
	DB	00H, ' ', 00H, 'd', 00H, 'r', 00H, 'a', 00H, 'w', 00H, ' ', 00H
	DB	'w', 00H, 'i', 00H, 't', 00H, 'h', 00H, 'o', 00H, 'u', 00H, 't'
	DB	00H, ' ', 00H, 's', 00H, 'e', 00H, 't', 00H, 't', 00H, 'i', 00H
	DB	'n', 00H, 'g', 00H, ' ', 00H, 'a', 00H, ' ', 00H, 'p', 00H, 'i'
	DB	00H, 'x', 00H, 'e', 00H, 'l', 00H, ' ', 00H, 's', 00H, 'h', 00H
	DB	'a', 00H, 'd', 00H, 'e', 00H, 'r', 00H, 00H, 00H
$SG4294909703 DB 'T', 00H, 'r', 00H, 'y', 00H, 'i', 00H, 'n', 00H, 'g', 00H
	DB	' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'd', 00H, 'r', 00H, 'a'
	DB	00H, 'w', 00H, ' ', 00H, 'a', 00H, ' ', 00H, 's', 00H, 'p', 00H
	DB	'r', 00H, 'i', 00H, 't', 00H, 'e', 00H, ' ', 00H, 'w', 00H, 'i'
	DB	00H, 't', 00H, 'h', 00H, ' ', 00H, 'a', 00H, ' ', 00H, 'N', 00H
	DB	'U', 00H, 'L', 00H, 'L', 00H, ' ', 00H, 't', 00H, 'e', 00H, 'x'
	DB	00H, 't', 00H, 'u', 00H, 'r', 00H, 'e', 00H, 00H, 00H
$SG4294909701 DB 'U', 00H, 'n', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H
	DB	' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'g', 00H, 'e', 00H, 't'
	DB	00H, ' ', 00H, 'b', 00H, 'a', 00H, 'c', 00H, 'k', 00H, ' ', 00H
	DB	'b', 00H, 'u', 00H, 'f', 00H, 'f', 00H, 'e', 00H, 'r', 00H, ' '
	DB	00H, 'f', 00H, 'r', 00H, 'o', 00H, 'm', 00H, ' ', 00H, 's', 00H
	DB	'w', 00H, 'a', 00H, 'p', 00H, ' ', 00H, 'c', 00H, 'h', 00H, 'a'
	DB	00H, 'i', 00H, 'n', 00H, 00H, 00H
	ORG $+3
$SG4294909700 DB 'U', 00H, 'n', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H
	DB	' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'g', 00H, 'e', 00H, 't'
	DB	00H, ' ', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 'd', 00H, 'e', 00H
	DB	'r', 00H, ' ', 00H, 'v', 00H, 'i', 00H, 'e', 00H, 'w', 00H, ' '
	DB	00H, 'f', 00H, 'r', 00H, 'o', 00H, 'm', 00H, ' ', 00H, 'b', 00H
	DB	'a', 00H, 'c', 00H, 'k', 00H, ' ', 00H, 'b', 00H, 'u', 00H, 'f'
	DB	00H, 'f', 00H, 'e', 00H, 'r', 00H, 00H, 00H
	ORG $+2
_blendConvert DD 01H
	DD	02H
	DD	03H
	DD	04H
	DD	05H
	DD	06H
	DD	09H
	DD	0aH
	DD	07H
	DD	08H
	DD	0eH
	DD	0fH
PUBLIC	?Clear@?$List@USavedBlendState@@@@QAEXXZ	; List<SavedBlendState>::Clear
PUBLIC	?SetSize@?$List@USavedBlendState@@@@QAEHI@Z	; List<SavedBlendState>::SetSize
PUBLIC	?Clear@?$List@PAUID3D10Buffer@@@@QAEXXZ		; List<ID3D10Buffer *>::Clear
PUBLIC	?SetSize@?$List@UDeviceOutputData@@@@QAEHI@Z	; List<DeviceOutputData>::SetSize
PUBLIC	?SetSize@?$List@UMonitorInfo@@@@QAEHI@Z		; List<MonitorInfo>::SetSize
PUBLIC	??A?$List@USavedBlendState@@@@QAEAAUSavedBlendState@@I@Z ; List<SavedBlendState>::operator[]
PUBLIC	?CreateNew@?$List@USavedBlendState@@@@QAEPAUSavedBlendState@@XZ ; List<SavedBlendState>::CreateNew
PUBLIC	?Num@?$List@USavedBlendState@@@@QBEIXZ		; List<SavedBlendState>::Num
PUBLIC	??1?$List@USavedBlendState@@@@QAE@XZ		; List<SavedBlendState>::~List<SavedBlendState>
PUBLIC	??0?$List@USavedBlendState@@@@QAE@XZ		; List<SavedBlendState>::List<SavedBlendState>
PUBLIC	?SetSize@?$List@PAUID3D10Buffer@@@@QAEHI@Z	; List<ID3D10Buffer *>::SetSize
PUBLIC	?Num@?$List@PAUID3D10Buffer@@@@QBEIXZ		; List<ID3D10Buffer *>::Num
PUBLIC	?Array@?$List@PAUID3D10Buffer@@@@QBEPAPAUID3D10Buffer@@XZ ; List<ID3D10Buffer *>::Array
PUBLIC	??1?$List@PAUID3D10Buffer@@@@QAE@XZ		; List<ID3D10Buffer *>::~List<ID3D10Buffer *>
PUBLIC	??0?$List@PAUID3D10Buffer@@@@QAE@XZ		; List<ID3D10Buffer *>::List<ID3D10Buffer *>
PUBLIC	??A?$List@UDeviceOutputData@@@@QAEAAUDeviceOutputData@@I@Z ; List<DeviceOutputData>::operator[]
PUBLIC	?CreateNew@?$List@UDeviceOutputData@@@@QAEPAUDeviceOutputData@@XZ ; List<DeviceOutputData>::CreateNew
PUBLIC	?Clear@?$List@UDeviceOutputData@@@@QAEXXZ	; List<DeviceOutputData>::Clear
PUBLIC	?Num@?$List@UDeviceOutputData@@@@QBEIXZ		; List<DeviceOutputData>::Num
PUBLIC	?CreateNew@?$List@UMonitorInfo@@@@QAEPAUMonitorInfo@@XZ ; List<MonitorInfo>::CreateNew
PUBLIC	?Clear@?$List@UMonitorInfo@@@@QAEXXZ		; List<MonitorInfo>::Clear
PUBLIC	??A?$List@UMatrix@@@@QAEAAUMatrix@@I@Z		; List<Matrix>::operator[]
PUBLIC	??A?$List@VUVCoordList@@@@QAEAAVUVCoordList@@I@Z ; List<UVCoordList>::operator[]
PUBLIC	?Clear@?$List@VUVCoordList@@@@QAEXXZ		; List<UVCoordList>::Clear
PUBLIC	?SetSize@?$List@VUVCoordList@@@@QAEHI@Z		; List<UVCoordList>::SetSize
PUBLIC	??1?$List@VUVCoordList@@@@QAE@XZ		; List<UVCoordList>::~List<UVCoordList>
PUBLIC	??0?$List@VUVCoordList@@@@QAE@XZ		; List<UVCoordList>::List<UVCoordList>
PUBLIC	??A?$List@UVect2@@@@QAEAAUVect2@@I@Z		; List<Vect2>::operator[]
PUBLIC	?Clear@?$List@UVect2@@@@QAEXXZ			; List<Vect2>::Clear
PUBLIC	?SetSize@?$List@UVect2@@@@QAEHI@Z		; List<Vect2>::SetSize
PUBLIC	??A?$List@UVect@@@@QAEAAUVect@@I@Z		; List<Vect>::operator[]
PUBLIC	?Clear@?$List@UVect@@@@QAEXXZ			; List<Vect>::Clear
PUBLIC	?SetSize@?$List@UVect@@@@QAEHI@Z		; List<Vect>::SetSize
PUBLIC	??1?$List@UVect@@@@QAE@XZ			; List<Vect>::~List<Vect>
PUBLIC	??0?$List@UVect@@@@QAE@XZ			; List<Vect>::List<Vect>
PUBLIC	?Clear@?$List@I@@QAEXXZ				; List<unsigned int>::Clear
PUBLIC	?SetSize@?$List@I@@QAEHI@Z			; List<unsigned int>::SetSize
PUBLIC	?Array@?$List@I@@QBEPAIXZ			; List<unsigned int>::Array
PUBLIC	??1?$List@I@@QAE@XZ				; List<unsigned int>::~List<unsigned int>
PUBLIC	??0?$List@I@@QAE@XZ				; List<unsigned int>::List<unsigned int>
PUBLIC	?CopyTexture@D3D10System@@UAEXPAVTexture@@0@Z	; D3D10System::CopyTexture
PUBLIC	?ResizeView@D3D10System@@EAEXXZ			; D3D10System::ResizeView
PUBLIC	?ResetViewMatrix@D3D10System@@EAEXXZ		; D3D10System::ResetViewMatrix
PUBLIC	?DrawBox@D3D10System@@UAEXABUVect2@@0@Z		; D3D10System::DrawBox
PUBLIC	?DrawSpriteExRotate@D3D10System@@UAEXPAVTexture@@KMMMMMMMMMM@Z ; D3D10System::DrawSpriteExRotate
PUBLIC	?DrawSpriteEx@D3D10System@@UAEXPAVTexture@@KMMMMMMMM@Z ; D3D10System::DrawSpriteEx
PUBLIC	?SetCropping@D3D10System@@UAEXMMMM@Z		; D3D10System::SetCropping
PUBLIC	?SetScissorRect@D3D10System@@UAEXPAUXRect@@@Z	; D3D10System::SetScissorRect
PUBLIC	?SetViewport@D3D10System@@UAEXMMMM@Z		; D3D10System::SetViewport
PUBLIC	?Frustum@D3D10System@@UAEXMMMMMM@Z		; D3D10System::Frustum
PUBLIC	?Ortho@D3D10System@@UAEXMMMMMM@Z		; D3D10System::Ortho
PUBLIC	?ClearColorBuffer@D3D10System@@UAEXK@Z		; D3D10System::ClearColorBuffer
PUBLIC	?BlendFunction@D3D10System@@UAEXW4GSBlendType@@0M@Z ; D3D10System::BlendFunction
PUBLIC	?EnableBlending@D3D10System@@UAEXH@Z		; D3D10System::EnableBlending
PUBLIC	?Draw@D3D10System@@UAEXW4GSDrawMode@@KK@Z	; D3D10System::Draw
PUBLIC	?SetRenderTarget@D3D10System@@UAEXPAVTexture@@@Z ; D3D10System::SetRenderTarget
PUBLIC	?GetCurrentVertexShader@D3D10System@@UAEPAVShader@@XZ ; D3D10System::GetCurrentVertexShader
PUBLIC	?GetCurrentPixelShader@D3D10System@@UAEPAVShader@@XZ ; D3D10System::GetCurrentPixelShader
PUBLIC	?LoadPixelShader@D3D10System@@UAEXPAVShader@@@Z	; D3D10System::LoadPixelShader
PUBLIC	?LoadVertexShader@D3D10System@@UAEXPAVShader@@@Z ; D3D10System::LoadVertexShader
PUBLIC	?LoadSamplerState@D3D10System@@UAEXPAVSamplerState@@I@Z ; D3D10System::LoadSamplerState
PUBLIC	?LoadTexture@D3D10System@@UAEXPAVTexture@@I@Z	; D3D10System::LoadTexture
PUBLIC	?LoadVertexBuffer@D3D10System@@UAEXPAVVertexBuffer@@@Z ; D3D10System::LoadVertexBuffer
PUBLIC	?CreateVertexBuffer@D3D10System@@UAEPAVVertexBuffer@@PAUVBData@@H@Z ; D3D10System::CreateVertexBuffer
PUBLIC	?CreatePixelShaderBlob@D3D10System@@EAEXAAV?$vector@DV?$allocator@D@std@@@std@@PB_W1@Z ; D3D10System::CreatePixelShaderBlob
PUBLIC	?CreateVertexShaderBlob@D3D10System@@EAEXAAV?$vector@DV?$allocator@D@std@@@std@@PB_W1@Z ; D3D10System::CreateVertexShaderBlob
PUBLIC	?CreatePixelShader@D3D10System@@UAEPAVShader@@PB_W0@Z ; D3D10System::CreatePixelShader
PUBLIC	?CreateVertexShader@D3D10System@@UAEPAVShader@@PB_W0@Z ; D3D10System::CreateVertexShader
PUBLIC	?CreatePixelShaderFromBlob@D3D10System@@UAEPAVShader@@ABV?$vector@DV?$allocator@D@std@@@std@@PB_W1@Z ; D3D10System::CreatePixelShaderFromBlob
PUBLIC	?CreateVertexShaderFromBlob@D3D10System@@UAEPAVShader@@ABV?$vector@DV?$allocator@D@std@@@std@@PB_W1@Z ; D3D10System::CreateVertexShaderFromBlob
PUBLIC	??0D3D10OutputDuplicator@@QAE@XZ		; D3D10OutputDuplicator::D3D10OutputDuplicator
PUBLIC	?CreateOutputDuplicator@D3D10System@@UAEPAVOutputDuplicator@@I@Z ; D3D10System::CreateOutputDuplicator
PUBLIC	?GetNumOutputs@D3D10System@@UAEIXZ		; D3D10System::GetNumOutputs
PUBLIC	?CreateSamplerState@D3D10System@@UAEPAVSamplerState@@AAUSamplerInfo@@@Z ; D3D10System::CreateSamplerState
PUBLIC	?GetTextureFileInfo@D3D10System@@UAE_NPB_WAAUTextureInfo@@@Z ; D3D10System::GetTextureFileInfo
PUBLIC	?CreateGDITexture@D3D10System@@UAEPAVTexture@@II@Z ; D3D10System::CreateGDITexture
PUBLIC	?CreateRenderTarget@D3D10System@@UAEPAVTexture@@IIW4GSColorFormat@@H@Z ; D3D10System::CreateRenderTarget
PUBLIC	?CreateTextureFromFile@D3D10System@@UAEPAVTexture@@PB_WH@Z ; D3D10System::CreateTextureFromFile
PUBLIC	?CreateTexture@D3D10System@@UAEPAVTexture@@IIW4GSColorFormat@@PAXHH@Z ; D3D10System::CreateTexture
PUBLIC	?CreateSharedTexture@D3D10System@@UAEPAVTexture@@II@Z ; D3D10System::CreateSharedTexture
PUBLIC	?CreateTextureFromSharedHandle@D3D10System@@UAEPAVTexture@@IIPAX@Z ; D3D10System::CreateTextureFromSharedHandle
PUBLIC	?Init@D3D10System@@UAEXXZ			; D3D10System::Init
PUBLIC	?GetDevice@D3D10System@@UAEPAXXZ		; D3D10System::GetDevice
PUBLIC	?UnloadAllData@D3D10System@@EAEXXZ		; D3D10System::UnloadAllData
PUBLIC	??1D3D10System@@UAE@XZ				; D3D10System::~D3D10System
PUBLIC	??_GD3D10System@@UAEPAXI@Z			; D3D10System::`scalar deleting destructor'
PUBLIC	??0D3D10System@@QAE@XZ				; D3D10System::D3D10System
PUBLIC	?LogVideoCardStats@@YAXXZ			; LogVideoCardStats
PUBLIC	?GetDisplayDevices@@YAXAAUDeviceOutputs@@@Z	; GetDisplayDevices
PUBLIC	?NumBuffersExpected@D3D10VertexShader@@ABEIXZ	; D3D10VertexShader::NumBuffersExpected
PUBLIC	?ClearData@DeviceOutputs@@QAEXXZ		; DeviceOutputs::ClearData
PUBLIC	?ClearData@DeviceOutputData@@QAEXXZ		; DeviceOutputData::ClearData
PUBLIC	??0VBData@@QAE@XZ				; VBData::VBData
PUBLIC	?CloseFloat@@YAHMMM@Z				; CloseFloat
PUBLIC	_fabsf
EXTRN	??_ED3D10System@@UAEPAXI@Z:PROC			; D3D10System::`vector deleting destructor'
	ALIGN	4

__Tuple_alloc DB 01H DUP (?)
	ALIGN	4

_ignore	DB	01H DUP (?)
	ALIGN	4

_allocator_arg DB 01H DUP (?)
	ALIGN	4

_piecewise_construct DB 01H DUP (?)
_BSS	ENDS
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
_ignore$initializer$ DD FLAT:??__Eignore@std@@YAXXZ
__Tuple_alloc$initializer$ DD FLAT:??__E_Tuple_alloc@std@@YAXXZ
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\math.h
;	COMDAT _fabsf
_TEXT	SEGMENT
tv70 = -4						; size = 4
__X$ = 8						; size = 4
_fabsf	PROC						; COMDAT

; 686  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 687  :     return (float)fabs(_X);

	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	andpd	xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv70[ebp], xmm0
	fld	DWORD PTR tv70[ebp]

; 688  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fabsf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\xmath.h
;	COMDAT ?CloseFloat@@YAHMMM@Z
_TEXT	SEGMENT
tv74 = -8						; size = 4
tv68 = -4						; size = 4
_f1$ = 8						; size = 4
_f2$ = 12						; size = 4
_precision$ = 16					; size = 4
?CloseFloat@@YAHMMM@Z PROC				; CloseFloat, COMDAT

; 115  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 116  :     return fabsf(f1-f2) <= precision;

	movss	xmm0, DWORD PTR _f1$[ebp]
	subss	xmm0, DWORD PTR _f2$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_fabsf
	add	esp, 4
	fstp	DWORD PTR tv74[ebp]
	movss	xmm0, DWORD PTR _precision$[ebp]
	comiss	xmm0, DWORD PTR tv74[ebp]
	jb	SHORT $LN3@CloseFloat
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@CloseFloat
$LN3@CloseFloat:
	mov	DWORD PTR tv68[ebp], 0
$LN4@CloseFloat:
	mov	eax, DWORD PTR tv68[ebp]

; 117  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CloseFloat@@YAHMMM@Z ENDP				; CloseFloat
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$di	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 70   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$di	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$di	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3451 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$di	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\tuple
;	COMDAT ??__Eignore@std@@YAXXZ
text$di	SEGMENT
??__Eignore@std@@YAXXZ PROC				; std::`dynamic initializer for 'ignore'', COMDAT

; 59   : const _Ignore ignore;

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET _ignore
	call	??0_Ignore@std@@QAE@XZ			; std::_Ignore::_Ignore
	pop	ebp
	ret	0
??__Eignore@std@@YAXXZ ENDP				; std::`dynamic initializer for 'ignore''
text$di	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\tuple
;	COMDAT ??__E_Tuple_alloc@std@@YAXXZ
text$di	SEGMENT
$T1 = -1						; size = 1
??__E_Tuple_alloc@std@@YAXXZ PROC			; std::`dynamic initializer for '_Tuple_alloc'', COMDAT

; 66   : const _Tuple_alloc_t _Tuple_alloc = _Tuple_alloc_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__E_Tuple_alloc@std@@YAXXZ ENDP			; std::`dynamic initializer for '_Tuple_alloc''
text$di	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\graphicssystem.h
;	COMDAT ??0VBData@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0VBData@@QAE@XZ PROC					; VBData::VBData, COMDAT
; _this$ = ecx

; 100  :     inline VBData() {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$List@UVect@@@@QAE@XZ		; List<Vect>::List<Vect>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$List@UVect@@@@QAE@XZ		; List<Vect>::List<Vect>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??0?$List@K@@QAE@XZ			; List<unsigned long>::List<unsigned long>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??0?$List@UVect@@@@QAE@XZ		; List<Vect>::List<Vect>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??0?$List@VUVCoordList@@@@QAE@XZ	; List<UVCoordList>::List<UVCoordList>
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0VBData@@QAE@XZ ENDP					; VBData::VBData
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.h
;	COMDAT ?ClearData@DeviceOutputData@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ClearData@DeviceOutputData@@QAEXXZ PROC		; DeviceOutputData::ClearData, COMDAT
; _this$ = ecx

; 228  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 229  :         strDevice.Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_?Clear@String@@QAEAAV1@XZ

; 230  :         monitors.Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?Clear@?$List@UMonitorInfo@@@@QAEXXZ	; List<MonitorInfo>::Clear

; 231  :         monitorNameList.Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	DWORD PTR __imp_?Clear@StringList@@QAEXXZ

; 232  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?ClearData@DeviceOutputData@@QAEXXZ ENDP		; DeviceOutputData::ClearData
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.h
;	COMDAT ?ClearData@DeviceOutputs@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$1 = -4						; size = 4
?ClearData@DeviceOutputs@@QAEXXZ PROC			; DeviceOutputs::ClearData, COMDAT
; _this$ = ecx

; 245  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 246  :         for(UINT i=0; i<devices.Num(); i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN3@ClearData
$LN2@ClearData:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN3@ClearData:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Num@?$List@UDeviceOutputData@@@@QBEIXZ	; List<DeviceOutputData>::Num
	cmp	DWORD PTR _i$1[ebp], eax
	jae	SHORT $LN1@ClearData

; 247  :             devices[i].ClearData();

	mov	ecx, DWORD PTR _i$1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UDeviceOutputData@@@@QAEAAUDeviceOutputData@@I@Z ; List<DeviceOutputData>::operator[]
	mov	ecx, eax
	call	?ClearData@DeviceOutputData@@QAEXXZ	; DeviceOutputData::ClearData
	jmp	SHORT $LN2@ClearData
$LN1@ClearData:

; 248  :         devices.Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$List@UDeviceOutputData@@@@QAEXXZ ; List<DeviceOutputData>::Clear

; 249  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?ClearData@DeviceOutputs@@QAEXXZ ENDP			; DeviceOutputs::ClearData
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\d3d10system.h
;	COMDAT ?NumBuffersExpected@D3D10VertexShader@@ABEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_count$ = -4						; size = 4
?NumBuffersExpected@D3D10VertexShader@@ABEIXZ PROC	; D3D10VertexShader::NumBuffersExpected, COMDAT
; _this$ = ecx

; 275  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 276  :         UINT count = 1;

	mov	DWORD PTR _count$[ebp], 1

; 277  :         if(bHasNormals)  count++;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+40]
	test	ecx, ecx
	je	SHORT $LN3@NumBuffers
	mov	edx, DWORD PTR _count$[ebp]
	add	edx, 1
	mov	DWORD PTR _count$[ebp], edx
$LN3@NumBuffers:

; 278  :         if(bHasColors)   count++;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+41]
	test	ecx, ecx
	je	SHORT $LN2@NumBuffers
	mov	edx, DWORD PTR _count$[ebp]
	add	edx, 1
	mov	DWORD PTR _count$[ebp], edx
$LN2@NumBuffers:

; 279  :         if(bHasTangents) count++;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+42]
	test	ecx, ecx
	je	SHORT $LN1@NumBuffers
	mov	edx, DWORD PTR _count$[ebp]
	add	edx, 1
	mov	DWORD PTR _count$[ebp], edx
$LN1@NumBuffers:

; 280  :         count += nTextureCoords;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _count$[ebp]
	add	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR _count$[ebp], ecx

; 281  : 
; 282  :         return count;

	mov	eax, DWORD PTR _count$[ebp]

; 283  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?NumBuffersExpected@D3D10VertexShader@@ABEIXZ ENDP	; D3D10VertexShader::NumBuffersExpected
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\d3d10system.cpp
;	COMDAT ?GetDisplayDevices@@YAXAAUDeviceOutputs@@@Z
_TEXT	SEGMENT
$T1 = -452						; size = 4
tv141 = -448						; size = 4
_iidVal$ = -444						; size = 4
tv81 = -440						; size = 4
tv144 = -436						; size = 4
tv78 = -432						; size = 4
tv67 = -428						; size = 4
_err$ = -424						; size = 4
_j$2 = -420						; size = 4
_deviceData$3 = -416					; size = 4
tv165 = -412						; size = 4
_factory$ = -408					; size = 4
_giOutput$4 = -404					; size = 4
_i$5 = -400						; size = 4
_monitorInfo$6 = -396					; size = 4
_giAdapter$7 = -392					; size = 4
_outputDesc$8 = -388					; size = 92
_adapterDesc$9 = -296					; size = 292
__$ArrayPad$ = -4					; size = 4
_deviceList$ = 8					; size = 4
?GetDisplayDevices@@YAXAAUDeviceOutputs@@@Z PROC	; GetDisplayDevices, COMDAT

; 25   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 452				; 000001c4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 26   :     HRESULT err;
; 27   : 
; 28   :     deviceList.ClearData();

	mov	ecx, DWORD PTR _deviceList$[ebp]
	call	?ClearData@DeviceOutputs@@QAEXXZ	; DeviceOutputs::ClearData

; 29   : 
; 30   : #ifdef USE_DXGI1_2
; 31   :     REFIID iidVal = OSGetVersion() >= 8 ? __uuidof(IDXGIFactory2) : __uuidof(IDXGIFactory1);

	call	DWORD PTR __imp_?OSGetVersion@@YGHXZ
	cmp	eax, 8
	jl	SHORT $LN18@GetDisplay
	mov	DWORD PTR tv67[ebp], OFFSET __GUID_50c83a1c_e072_4c48_87b0_3630fa36a6d0
	jmp	SHORT $LN19@GetDisplay
$LN18@GetDisplay:
	mov	DWORD PTR tv67[ebp], OFFSET __GUID_770aae78_f26f_4dba_a829_253c83d1b387
$LN19@GetDisplay:
	mov	eax, DWORD PTR tv67[ebp]
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR _iidVal$[ebp], ecx

; 32   : #else
; 33   :     REFIIF iidVal = __uuidof(IDXGIFactory1);
; 34   : #endif
; 35   : 
; 36   :     IDXGIFactory1 *factory;
; 37   :     if(SUCCEEDED(err = CreateDXGIFactory1(iidVal, (void**)&factory)))

	lea	edx, DWORD PTR _factory$[ebp]
	push	edx
	mov	eax, DWORD PTR _iidVal$[ebp]
	push	eax
	call	DWORD PTR __imp__CreateDXGIFactory1@8
	mov	DWORD PTR _err$[ebp], eax
	cmp	DWORD PTR _err$[ebp], 0
	jl	$LN15@GetDisplay

; 38   :     {
; 39   :         UINT i=0;

	mov	DWORD PTR _i$5[ebp], 0
$LN14@GetDisplay:

; 40   :         IDXGIAdapter1 *giAdapter;
; 41   : 
; 42   :         while(factory->EnumAdapters1(i++, &giAdapter) == S_OK)

	mov	ecx, DWORD PTR _i$5[ebp]
	mov	DWORD PTR tv78[ebp], ecx
	lea	edx, DWORD PTR _giAdapter$7[ebp]
	push	edx
	mov	eax, DWORD PTR tv78[ebp]
	push	eax
	mov	ecx, DWORD PTR _factory$[ebp]
	push	ecx
	mov	edx, DWORD PTR _factory$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+48]
	call	ecx
	mov	DWORD PTR tv81[ebp], eax
	mov	edx, DWORD PTR _i$5[ebp]
	add	edx, 1
	mov	DWORD PTR _i$5[ebp], edx
	cmp	DWORD PTR tv81[ebp], 0
	jne	$LN13@GetDisplay

; 43   :         {
; 44   :             //Log(TEXT("------------------------------------------"));
; 45   : 
; 46   :             DXGI_ADAPTER_DESC adapterDesc;
; 47   :             if(SUCCEEDED(err = giAdapter->GetDesc(&adapterDesc)))

	lea	eax, DWORD PTR _adapterDesc$9[ebp]
	push	eax
	mov	ecx, DWORD PTR _giAdapter$7[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _giAdapter$7[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx+32]
	call	ecx
	mov	DWORD PTR _err$[ebp], eax
	cmp	DWORD PTR _err$[ebp], 0
	jl	$LN12@GetDisplay

; 48   :             {
; 49   :                 if (adapterDesc.DedicatedVideoMemory != 0) {

	cmp	DWORD PTR _adapterDesc$9[ebp+272], 0
	je	$LN9@GetDisplay

; 50   :                     DeviceOutputData &deviceData = *deviceList.devices.CreateNew();

	mov	ecx, DWORD PTR _deviceList$[ebp]
	call	?CreateNew@?$List@UDeviceOutputData@@@@QAEPAUDeviceOutputData@@XZ ; List<DeviceOutputData>::CreateNew
	mov	DWORD PTR _deviceData$3[ebp], eax

; 51   :                     deviceData.strDevice = adapterDesc.Description;

	lea	edx, DWORD PTR _adapterDesc$9[ebp]
	push	edx
	mov	ecx, DWORD PTR _deviceData$3[ebp]
	call	DWORD PTR __imp_??4String@@QAEAAV0@PB_W@Z

; 52   : 
; 53   :                     UINT j=0;

	mov	DWORD PTR _j$2[ebp], 0
$LN10@GetDisplay:

; 54   :                     IDXGIOutput *giOutput;
; 55   :                     while(giAdapter->EnumOutputs(j++, &giOutput) == S_OK)

	mov	eax, DWORD PTR _j$2[ebp]
	mov	DWORD PTR tv141[ebp], eax
	lea	ecx, DWORD PTR _giOutput$4[ebp]
	push	ecx
	mov	edx, DWORD PTR tv141[ebp]
	push	edx
	mov	eax, DWORD PTR _giAdapter$7[ebp]
	push	eax
	mov	ecx, DWORD PTR _giAdapter$7[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+28]
	call	eax
	mov	DWORD PTR tv144[ebp], eax
	mov	ecx, DWORD PTR _j$2[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$2[ebp], ecx
	cmp	DWORD PTR tv144[ebp], 0
	jne	$LN9@GetDisplay

; 56   :                     {
; 57   :                         DXGI_OUTPUT_DESC outputDesc;
; 58   :                         if(SUCCEEDED(giOutput->GetDesc(&outputDesc)))

	lea	edx, DWORD PTR _outputDesc$8[ebp]
	push	edx
	mov	eax, DWORD PTR _giOutput$4[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _giOutput$4[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+28]
	call	eax
	test	eax, eax
	jl	$LN5@GetDisplay

; 59   :                         {
; 60   :                             if(outputDesc.AttachedToDesktop)

	cmp	DWORD PTR _outputDesc$8[ebp+80], 0
	je	$LN5@GetDisplay

; 61   :                             {
; 62   :                                 deviceData.monitorNameList << outputDesc.DeviceName;

	lea	ecx, DWORD PTR _outputDesc$8[ebp]
	push	ecx
	mov	ecx, DWORD PTR _deviceData$3[ebp]
	add	ecx, 16					; 00000010H
	call	DWORD PTR __imp_??6StringList@@QAEAAV0@PB_W@Z

; 63   : 
; 64   :                                 MonitorInfo &monitorInfo = *deviceData.monitors.CreateNew();

	mov	ecx, DWORD PTR _deviceData$3[ebp]
	add	ecx, 8
	call	?CreateNew@?$List@UMonitorInfo@@@@QAEPAUMonitorInfo@@XZ ; List<MonitorInfo>::CreateNew
	mov	DWORD PTR _monitorInfo$6[ebp], eax

; 65   :                                 monitorInfo.hMonitor = outputDesc.Monitor;

	mov	edx, DWORD PTR _monitorInfo$6[ebp]
	mov	eax, DWORD PTR _outputDesc$8[ebp+88]
	mov	DWORD PTR [edx], eax

; 66   :                                 mcpy(&monitorInfo.rect, &outputDesc.DesktopCoordinates, sizeof(RECT));

	mov	ecx, DWORD PTR _monitorInfo$6[ebp]
	add	ecx, 4
	mov	edx, DWORD PTR _outputDesc$8[ebp+64]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _outputDesc$8[ebp+68]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _outputDesc$8[ebp+72]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _outputDesc$8[ebp+76]
	mov	DWORD PTR [ecx+12], eax

; 67   :                                 switch (outputDesc.Rotation) {

	mov	ecx, DWORD PTR _outputDesc$8[ebp+84]
	mov	DWORD PTR tv165[ebp], ecx
	cmp	DWORD PTR tv165[ebp], 2
	je	SHORT $LN4@GetDisplay
	cmp	DWORD PTR tv165[ebp], 3
	je	SHORT $LN3@GetDisplay
	cmp	DWORD PTR tv165[ebp], 4
	je	SHORT $LN2@GetDisplay
	jmp	SHORT $LN5@GetDisplay
$LN4@GetDisplay:

; 68   :                                 case DXGI_MODE_ROTATION_ROTATE90:
; 69   :                                     monitorInfo.rotationDegrees = 90.0f;

	mov	edx, DWORD PTR _monitorInfo$6[ebp]
	movss	xmm0, DWORD PTR __real@42b40000
	movss	DWORD PTR [edx+20], xmm0

; 70   :                                     break;

	jmp	SHORT $LN5@GetDisplay
$LN3@GetDisplay:

; 71   :                                 case DXGI_MODE_ROTATION_ROTATE180:
; 72   :                                     monitorInfo.rotationDegrees = 180.0f;

	mov	eax, DWORD PTR _monitorInfo$6[ebp]
	movss	xmm0, DWORD PTR __real@43340000
	movss	DWORD PTR [eax+20], xmm0

; 73   :                                     break;

	jmp	SHORT $LN5@GetDisplay
$LN2@GetDisplay:

; 74   :                                 case DXGI_MODE_ROTATION_ROTATE270:
; 75   :                                     monitorInfo.rotationDegrees = 270.0f;

	mov	ecx, DWORD PTR _monitorInfo$6[ebp]
	movss	xmm0, DWORD PTR __real@43870000
	movss	DWORD PTR [ecx+20], xmm0
$LN5@GetDisplay:

; 76   :                                 }
; 77   :                             }
; 78   :                         }
; 79   : 
; 80   :                         giOutput->Release();

	mov	edx, DWORD PTR _giOutput$4[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _giOutput$4[ebp]
	push	ecx
	mov	edx, DWORD PTR [eax+8]
	call	edx

; 81   :                     }

	jmp	$LN10@GetDisplay
$LN9@GetDisplay:

; 82   :                 }
; 83   :             }
; 84   :             else

	jmp	SHORT $LN1@GetDisplay
$LN12@GetDisplay:

; 85   :                 AppWarning(TEXT("Could not query adapter %u"), i);

	mov	eax, DWORD PTR _i$5[ebp]
	push	eax
	push	OFFSET $SG4294909741
	call	DWORD PTR __imp_?AppWarning@@YAXPB_WZZ
	add	esp, 8
$LN1@GetDisplay:

; 86   : 
; 87   :             giAdapter->Release();

	mov	ecx, DWORD PTR _giAdapter$7[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _giAdapter$7[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx+8]
	call	ecx

; 88   :         }

	jmp	$LN14@GetDisplay
$LN13@GetDisplay:

; 89   : 
; 90   :         factory->Release();

	mov	edx, DWORD PTR _factory$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _factory$[ebp]
	push	ecx
	mov	edx, DWORD PTR [eax+8]
	call	edx
$LN15@GetDisplay:

; 91   :     }
; 92   : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDisplayDevices@@YAXAAUDeviceOutputs@@@Z ENDP	; GetDisplayDevices
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\d3d10system.cpp
;	COMDAT ?LogVideoCardStats@@YAXXZ
_TEXT	SEGMENT
$T1 = -444						; size = 4
_iidVal$ = -440						; size = 4
tv77 = -436						; size = 4
tv80 = -432						; size = 4
tv147 = -428						; size = 4
tv144 = -424						; size = 4
tv66 = -420						; size = 4
tv155 = -416						; size = 4
_err$ = -412						; size = 4
_factory$ = -408					; size = 4
_j$2 = -404						; size = 4
_output$3 = -400					; size = 4
_i$4 = -396						; size = 4
_giAdapter$5 = -392					; size = 4
_adapterDesc$6 = -388					; size = 292
_desc$7 = -96						; size = 92
__$ArrayPad$ = -4					; size = 4
?LogVideoCardStats@@YAXXZ PROC				; LogVideoCardStats, COMDAT

; 96   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 444				; 000001bcH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 97   :     HRESULT err;
; 98   : 
; 99   : #ifdef USE_DXGI1_2
; 100  :     REFIID iidVal = OSGetVersion() >= 8 ? __uuidof(IDXGIFactory2) : __uuidof(IDXGIFactory1);

	call	DWORD PTR __imp_?OSGetVersion@@YGHXZ
	cmp	eax, 8
	jl	SHORT $LN13@LogVideoCa
	mov	DWORD PTR tv66[ebp], OFFSET __GUID_50c83a1c_e072_4c48_87b0_3630fa36a6d0
	jmp	SHORT $LN14@LogVideoCa
$LN13@LogVideoCa:
	mov	DWORD PTR tv66[ebp], OFFSET __GUID_770aae78_f26f_4dba_a829_253c83d1b387
$LN14@LogVideoCa:
	mov	eax, DWORD PTR tv66[ebp]
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR _iidVal$[ebp], ecx

; 101  : #else
; 102  :     REFIIF iidVal = __uuidof(IDXGIFactory1);
; 103  : #endif
; 104  : 
; 105  :     IDXGIFactory1 *factory;
; 106  :     if(SUCCEEDED(err = CreateDXGIFactory1(iidVal, (void**)&factory)))

	lea	edx, DWORD PTR _factory$[ebp]
	push	edx
	mov	eax, DWORD PTR _iidVal$[ebp]
	push	eax
	call	DWORD PTR __imp__CreateDXGIFactory1@8
	mov	DWORD PTR _err$[ebp], eax
	cmp	DWORD PTR _err$[ebp], 0
	jl	$LN11@LogVideoCa

; 107  :     {
; 108  :         UINT i=0;

	mov	DWORD PTR _i$4[ebp], 0
$LN9@LogVideoCa:

; 109  :         IDXGIAdapter1 *giAdapter;
; 110  : 
; 111  :         while(factory->EnumAdapters1(i++, &giAdapter) == S_OK)

	mov	ecx, DWORD PTR _i$4[ebp]
	mov	DWORD PTR tv77[ebp], ecx
	lea	edx, DWORD PTR _giAdapter$5[ebp]
	push	edx
	mov	eax, DWORD PTR tv77[ebp]
	push	eax
	mov	ecx, DWORD PTR _factory$[ebp]
	push	ecx
	mov	edx, DWORD PTR _factory$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+48]
	call	ecx
	mov	DWORD PTR tv80[ebp], eax
	mov	edx, DWORD PTR _i$4[ebp]
	add	edx, 1
	mov	DWORD PTR _i$4[ebp], edx
	cmp	DWORD PTR tv80[ebp], 0
	jne	$LN8@LogVideoCa

; 112  :         {
; 113  :             DXGI_ADAPTER_DESC adapterDesc;
; 114  :             if(SUCCEEDED(err = giAdapter->GetDesc(&adapterDesc)))

	lea	eax, DWORD PTR _adapterDesc$6[ebp]
	push	eax
	mov	ecx, DWORD PTR _giAdapter$5[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _giAdapter$5[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx+32]
	call	ecx
	mov	DWORD PTR _err$[ebp], eax
	cmp	DWORD PTR _err$[ebp], 0
	jl	$LN7@LogVideoCa

; 115  :             {
; 116  :                 if (!(adapterDesc.VendorId == 0x1414 && adapterDesc.DeviceId == 0x8c)) { // Ignore Microsoft Basic Render Driver

	cmp	DWORD PTR _adapterDesc$6[ebp+256], 5140	; 00001414H
	jne	SHORT $LN5@LogVideoCa
	cmp	DWORD PTR _adapterDesc$6[ebp+260], 140	; 0000008cH
	je	$LN6@LogVideoCa
$LN5@LogVideoCa:

; 117  :                     Log(TEXT("------------------------------------------"));

	push	OFFSET $SG4294909740
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 4

; 118  :                     Log(TEXT("Adapter %u"), i);

	mov	edx, DWORD PTR _i$4[ebp]
	push	edx
	push	OFFSET $SG4294909739
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 8

; 119  :                     Log(TEXT("  Video Adapter: %s"), adapterDesc.Description);

	lea	eax, DWORD PTR _adapterDesc$6[ebp]
	push	eax
	push	OFFSET $SG4294909738
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 8

; 120  :                     Log(TEXT("  Video Adapter Dedicated Video Memory: %u"), adapterDesc.DedicatedVideoMemory);

	mov	ecx, DWORD PTR _adapterDesc$6[ebp+272]
	push	ecx
	push	OFFSET $SG4294909737
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 8

; 121  :                     Log(TEXT("  Video Adapter Shared System Memory: %u"), adapterDesc.SharedSystemMemory);

	mov	edx, DWORD PTR _adapterDesc$6[ebp+280]
	push	edx
	push	OFFSET $SG4294909736
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 8

; 122  : 
; 123  :                     UINT j = 0;

	mov	DWORD PTR _j$2[ebp], 0
$LN4@LogVideoCa:

; 124  :                     IDXGIOutput *output;
; 125  :                     while(SUCCEEDED(giAdapter->EnumOutputs(j++, &output)))

	mov	eax, DWORD PTR _j$2[ebp]
	mov	DWORD PTR tv144[ebp], eax
	lea	ecx, DWORD PTR _output$3[ebp]
	push	ecx
	mov	edx, DWORD PTR tv144[ebp]
	push	edx
	mov	eax, DWORD PTR _giAdapter$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _giAdapter$5[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+28]
	call	eax
	mov	DWORD PTR tv147[ebp], eax
	mov	ecx, DWORD PTR _j$2[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$2[ebp], ecx
	cmp	DWORD PTR tv147[ebp], 0
	jl	$LN6@LogVideoCa

; 126  :                     {
; 127  :                         DXGI_OUTPUT_DESC desc;
; 128  :                         if(SUCCEEDED(output->GetDesc(&desc)))

	lea	edx, DWORD PTR _desc$7[ebp]
	push	edx
	mov	eax, DWORD PTR _output$3[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _output$3[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+28]
	call	eax
	test	eax, eax
	jl	SHORT $LN2@LogVideoCa

; 129  :                             Log(TEXT("  Video Adapter Output %u: pos={%d, %d}, size={%d, %d}, attached=%s"), j,
; 130  :                                 desc.DesktopCoordinates.left, desc.DesktopCoordinates.top,
; 131  :                                 desc.DesktopCoordinates.right-desc.DesktopCoordinates.left, desc.DesktopCoordinates.bottom-desc.DesktopCoordinates.top,
; 132  :                                 desc.AttachedToDesktop ? L"true" : L"false");

	cmp	DWORD PTR _desc$7[ebp+80], 0
	je	SHORT $LN15@LogVideoCa
	mov	DWORD PTR tv155[ebp], OFFSET $SG4294909735
	jmp	SHORT $LN16@LogVideoCa
$LN15@LogVideoCa:
	mov	DWORD PTR tv155[ebp], OFFSET $SG4294909734
$LN16@LogVideoCa:
	mov	ecx, DWORD PTR tv155[ebp]
	push	ecx
	mov	edx, DWORD PTR _desc$7[ebp+76]
	sub	edx, DWORD PTR _desc$7[ebp+68]
	push	edx
	mov	eax, DWORD PTR _desc$7[ebp+72]
	sub	eax, DWORD PTR _desc$7[ebp+64]
	push	eax
	mov	ecx, DWORD PTR _desc$7[ebp+68]
	push	ecx
	mov	edx, DWORD PTR _desc$7[ebp+64]
	push	edx
	mov	eax, DWORD PTR _j$2[ebp]
	push	eax
	push	OFFSET $SG4294909733
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 28					; 0000001cH
$LN2@LogVideoCa:

; 133  :                         output->Release();

	mov	ecx, DWORD PTR _output$3[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _output$3[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx+8]
	call	ecx

; 134  :                     }

	jmp	$LN4@LogVideoCa
$LN6@LogVideoCa:

; 135  :                 }
; 136  :             }
; 137  :             else

	jmp	SHORT $LN1@LogVideoCa
$LN7@LogVideoCa:

; 138  :                 AppWarning(TEXT("Could not query adapter %u"), i);

	mov	edx, DWORD PTR _i$4[ebp]
	push	edx
	push	OFFSET $SG4294909732
	call	DWORD PTR __imp_?AppWarning@@YAXPB_WZZ
	add	esp, 8
$LN1@LogVideoCa:

; 139  : 
; 140  :             giAdapter->Release();

	mov	eax, DWORD PTR _giAdapter$5[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _giAdapter$5[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+8]
	call	eax

; 141  :         }

	jmp	$LN9@LogVideoCa
$LN8@LogVideoCa:

; 142  : 
; 143  :         factory->Release();

	mov	ecx, DWORD PTR _factory$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _factory$[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx+8]
	call	ecx
$LN11@LogVideoCa:

; 144  :     }
; 145  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?LogVideoCardStats@@YAXXZ ENDP				; LogVideoCardStats
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\d3d10system.cpp
;	COMDAT ?HandleNvidiaOptimus@@YAXPAUIDXGIFactory1@@AAPAUIDXGIAdapter1@@AAI@Z
_TEXT	SEGMENT
_name$1 = -304						; size = 8
_adapterDesc$ = -296					; size = 292
__$ArrayPad$ = -4					; size = 4
_factory$ = 8						; size = 4
_adapter$ = 12						; size = 4
_adapterID$ = 16					; size = 4
?HandleNvidiaOptimus@@YAXPAUIDXGIFactory1@@AAPAUIDXGIAdapter1@@AAI@Z PROC ; HandleNvidiaOptimus, COMDAT

; 148  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 304				; 00000130H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 149  :     if (adapterID != 1)

	mov	eax, DWORD PTR _adapterID$[ebp]
	cmp	DWORD PTR [eax], 1
	je	SHORT $LN7@HandleNvid

; 150  :         return;

	jmp	$LN9@HandleNvid
$LN7@HandleNvid:

; 151  : 
; 152  :     //NvOptimusEnablement = 0;
; 153  :     DXGI_ADAPTER_DESC adapterDesc;
; 154  :     if (SUCCEEDED(adapter->GetDesc(&adapterDesc)))

	lea	ecx, DWORD PTR _adapterDesc$[ebp]
	push	ecx
	mov	edx, DWORD PTR _adapter$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _adapter$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+32]
	call	ecx
	test	eax, eax
	jl	$LN9@HandleNvid

; 155  :     {
; 156  :         String name = adapterDesc.Description;

	lea	edx, DWORD PTR _adapterDesc$[ebp]
	push	edx
	lea	ecx, DWORD PTR _name$1[ebp]
	call	DWORD PTR __imp_??0String@@QAE@PB_W@Z

; 157  :         name.KillSpaces();

	lea	ecx, DWORD PTR _name$1[ebp]
	call	DWORD PTR __imp_?KillSpaces@String@@QAEAAV1@XZ

; 158  : 
; 159  :         if (name.IsEmpty())

	lea	ecx, DWORD PTR _name$1[ebp]
	call	DWORD PTR __imp_?IsEmpty@String@@QBEHXZ
	test	eax, eax
	je	SHORT $LN5@HandleNvid

; 160  :             return;

	lea	ecx, DWORD PTR _name$1[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	jmp	$LN9@HandleNvid
$LN5@HandleNvid:

; 161  : 
; 162  :         if (sstri(adapterDesc.Description, L"NVIDIA") != NULL)

	push	OFFSET $SG4294909731
	lea	eax, DWORD PTR _adapterDesc$[ebp]
	push	eax
	call	DWORD PTR __imp_?sstri@@YGPA_WPB_W0@Z
	test	eax, eax
	je	$LN4@HandleNvid

; 163  :         {
; 164  :             if (name[name.Length()-1] == 'M' || name[name.Length()-1] == 'm') {

	lea	ecx, DWORD PTR _name$1[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	mov	esi, eax
	lea	ecx, DWORD PTR _name$1[ebp]
	call	DWORD PTR __imp_?Length@String@@QBEIXZ
	movzx	ecx, WORD PTR [esi+eax*2-2]
	cmp	ecx, 77					; 0000004dH
	je	SHORT $LN2@HandleNvid
	lea	ecx, DWORD PTR _name$1[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	mov	esi, eax
	lea	ecx, DWORD PTR _name$1[ebp]
	call	DWORD PTR __imp_?Length@String@@QBEIXZ
	movzx	edx, WORD PTR [esi+eax*2-2]
	cmp	edx, 109				; 0000006dH
	jne	SHORT $LN4@HandleNvid
$LN2@HandleNvid:

; 165  :                 adapter->Release();

	mov	eax, DWORD PTR _adapter$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _adapter$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+8]
	call	edx

; 166  : 
; 167  :                 adapterID = 0;

	mov	eax, DWORD PTR _adapterID$[ebp]
	mov	DWORD PTR [eax], 0

; 168  :                 //NvOptimusEnablement = 1;
; 169  :                 Log(L"Nvidia optimus detected, second adapter selected, ignoring useless second adapter, I guess.");

	push	OFFSET $SG4294909730
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 4

; 170  :                 if(FAILED(factory->EnumAdapters1(adapterID, &adapter)))

	mov	ecx, DWORD PTR _adapter$[ebp]
	push	ecx
	mov	edx, DWORD PTR _adapterID$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _factory$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _factory$[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx+48]
	call	ecx
	test	eax, eax
	jge	SHORT $LN4@HandleNvid

; 171  :                     CrashError(TEXT("Could not get DXGI adapter"));

	push	OFFSET $SG4294909729
	call	DWORD PTR __imp_?CrashError@@YAXPB_WZZ
$LN4@HandleNvid:

; 172  :             }
; 173  :         }
; 174  :     }

	lea	ecx, DWORD PTR _name$1[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
$LN9@HandleNvid:

; 175  : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?HandleNvidiaOptimus@@YAXPAUIDXGIFactory1@@AAPAUIDXGIAdapter1@@AAI@Z ENDP ; HandleNvidiaOptimus
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\d3d10system.cpp
;	COMDAT ??0D3D10System@@QAE@XZ
_TEXT	SEGMENT
_iidVal$ = -600						; size = 4
tv141 = -596						; size = 4
$T1 = -592						; size = 4
tv144 = -588						; size = 4
_giAdapter$ = -584					; size = 4
tv249 = -580						; size = 4
tv244 = -576						; size = 4
tv87 = -572						; size = 4
tv193 = -568						; size = 4
_level$ = -564						; size = 4
_i$ = -560						; size = 4
_adapterName$ = -556					; size = 8
_createFlags$ = -548					; size = 4
_numAdapters$ = -544					; size = 4
_backBuffer$ = -540					; size = 4
_i$2 = -536						; size = 4
_adapter$ = -532					; size = 4
_adapterID$ = -528					; size = 4
_err$ = -524						; size = 4
_this$ = -520						; size = 4
_swapDesc$ = -516					; size = 60
_desc$ = -456						; size = 292
_depthDesc$ = -164					; size = 52
_disabledBlendDesc$ = -112				; size = 68
_rasterizerDesc$ = -44					; size = 40
__$ArrayPad$ = -4					; size = 4
??0D3D10System@@QAE@XZ PROC				; D3D10System::D3D10System, COMDAT
; _this$ = ecx

; 178  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 600				; 00000258H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0GraphicsSystem@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7D3D10System@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 184				; 000000b8H
	call	??0?$List@USavedBlendState@@@@QAE@XZ	; List<SavedBlendState>::List<SavedBlendState>

; 179  :     HRESULT err;
; 180  : 
; 181  : #ifdef USE_DXGI1_2
; 182  :     REFIID iidVal = OSGetVersion() >= 8 ? __uuidof(IDXGIFactory2) : __uuidof(IDXGIFactory1);

	call	DWORD PTR __imp_?OSGetVersion@@YGHXZ
	cmp	eax, 8
	jl	SHORT $LN22@D3D10Syste
	mov	DWORD PTR tv87[ebp], OFFSET __GUID_50c83a1c_e072_4c48_87b0_3630fa36a6d0
	jmp	SHORT $LN23@D3D10Syste
$LN22@D3D10Syste:
	mov	DWORD PTR tv87[ebp], OFFSET __GUID_770aae78_f26f_4dba_a829_253c83d1b387
$LN23@D3D10Syste:
	mov	ecx, DWORD PTR tv87[ebp]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	mov	DWORD PTR _iidVal$[ebp], edx

; 183  : #else
; 184  :     REFIID iidVal = __uuidof(IDXGIFactory1);
; 185  : #endif
; 186  : 
; 187  :     UINT adapterID = GlobalConfig->GetInt(TEXT("Video"), TEXT("Adapter"), 0);

	push	0
	push	OFFSET $SG4294909728
	push	OFFSET $SG4294909727
	mov	ecx, DWORD PTR ?GlobalConfig@@3PAVConfigFile@@A ; GlobalConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	mov	DWORD PTR _adapterID$[ebp], eax

; 188  : 
; 189  :     if(FAILED(err = CreateDXGIFactory1(iidVal, (void**)&factory)))

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 68					; 00000044H
	push	eax
	mov	ecx, DWORD PTR _iidVal$[ebp]
	push	ecx
	call	DWORD PTR __imp__CreateDXGIFactory1@8
	mov	DWORD PTR _err$[ebp], eax
	cmp	DWORD PTR _err$[ebp], 0
	jge	SHORT $LN19@D3D10Syste

; 190  :         CrashError(TEXT("Could not create DXGI factory"));

	push	OFFSET $SG4294909726
	call	DWORD PTR __imp_?CrashError@@YAXPB_WZZ
$LN19@D3D10Syste:

; 191  : 
; 192  :     UINT numAdapters = 0, i = 0;

	mov	DWORD PTR _numAdapters$[ebp], 0
	mov	DWORD PTR _i$[ebp], 0
$LN18@D3D10Syste:

; 193  :     IDXGIAdapter1 *giAdapter;
; 194  : 	//(),
; 195  :     while (factory->EnumAdapters1(i++, &giAdapter) == S_OK)

	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR tv141[ebp], edx
	lea	eax, DWORD PTR _giAdapter$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv141[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+68]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+48]
	call	ecx
	mov	DWORD PTR tv144[ebp], eax
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	cmp	DWORD PTR tv144[ebp], 0
	jne	SHORT $LN17@D3D10Syste

; 196  :     {
; 197  :         numAdapters++;

	mov	eax, DWORD PTR _numAdapters$[ebp]
	add	eax, 1
	mov	DWORD PTR _numAdapters$[ebp], eax

; 198  :         giAdapter->Release();

	mov	ecx, DWORD PTR _giAdapter$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _giAdapter$[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx+8]
	call	ecx

; 199  :     }

	jmp	SHORT $LN18@D3D10Syste
$LN17@D3D10Syste:

; 200  : 
; 201  :     if (adapterID >= numAdapters)

	mov	edx, DWORD PTR _adapterID$[ebp]
	cmp	edx, DWORD PTR _numAdapters$[ebp]
	jb	SHORT $LN16@D3D10Syste

; 202  :     {
; 203  :         Log(TEXT("Invalid adapter id %d, only %d adapters on system. Resetting to 0."), adapterID, numAdapters);

	mov	eax, DWORD PTR _numAdapters$[ebp]
	push	eax
	mov	ecx, DWORD PTR _adapterID$[ebp]
	push	ecx
	push	OFFSET $SG4294909725
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 12					; 0000000cH

; 204  :         GlobalConfig->SetInt(TEXT("Video"), TEXT("Adapter"), 0);

	push	0
	push	OFFSET $SG4294909724
	push	OFFSET $SG4294909723
	mov	ecx, DWORD PTR ?GlobalConfig@@3PAVConfigFile@@A ; GlobalConfig
	call	DWORD PTR __imp_?SetInt@ConfigFile@@QAEXPB_W0H@Z

; 205  :         adapterID = 0;

	mov	DWORD PTR _adapterID$[ebp], 0
$LN16@D3D10Syste:

; 206  :     }
; 207  : 
; 208  :     IDXGIAdapter1 *adapter;
; 209  :     if(FAILED(err = factory->EnumAdapters1(adapterID, &adapter)))

	lea	edx, DWORD PTR _adapter$[ebp]
	push	edx
	mov	eax, DWORD PTR _adapterID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+48]
	call	eax
	mov	DWORD PTR _err$[ebp], eax
	cmp	DWORD PTR _err$[ebp], 0
	jge	SHORT $LN15@D3D10Syste

; 210  :         CrashError(TEXT("Could not get DXGI adapter %d"), adapterID);

	mov	ecx, DWORD PTR _adapterID$[ebp]
	push	ecx
	push	OFFSET $SG4294909722
	call	DWORD PTR __imp_?CrashError@@YAXPB_WZZ
$LN15@D3D10Syste:

; 211  : 	//select adapters
; 212  :     HandleNvidiaOptimus(factory, adapter, adapterID);

	lea	edx, DWORD PTR _adapterID$[ebp]
	push	edx
	lea	eax, DWORD PTR _adapter$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	push	edx
	call	?HandleNvidiaOptimus@@YAXPAUIDXGIFactory1@@AAPAUIDXGIAdapter1@@AAI@Z ; HandleNvidiaOptimus
	add	esp, 12					; 0000000cH

; 213  : 
; 214  :     //------------------------------------------------------------------
; 215  : 
; 216  :     DXGI_SWAP_CHAIN_DESC swapDesc;
; 217  :     zero(&swapDesc, sizeof(swapDesc));

	push	60					; 0000003cH
	lea	eax, DWORD PTR _swapDesc$[ebp]
	push	eax
	call	?zero@@YGXPAXI@Z			; zero

; 218  :     swapDesc.BufferCount = 2;

	mov	DWORD PTR _swapDesc$[ebp+40], 2

; 219  :     swapDesc.BufferDesc.Format = DXGI_FORMAT_B8G8R8A8_UNORM;

	mov	DWORD PTR _swapDesc$[ebp+16], 87	; 00000057H

; 220  :     swapDesc.BufferDesc.Width  = App->renderFrameWidth;

	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	edx, DWORD PTR [ecx+636]
	mov	DWORD PTR _swapDesc$[ebp], edx

; 221  :     swapDesc.BufferDesc.Height = App->renderFrameHeight;

	mov	eax, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	ecx, DWORD PTR [eax+640]
	mov	DWORD PTR _swapDesc$[ebp+4], ecx

; 222  :     swapDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;

	mov	DWORD PTR _swapDesc$[ebp+36], 32	; 00000020H

; 223  :     swapDesc.OutputWindow = hwndRenderFrame;

	mov	edx, DWORD PTR ?hwndRenderFrame@@3PAUHWND__@@A ; hwndRenderFrame
	mov	DWORD PTR _swapDesc$[ebp+44], edx

; 224  :     swapDesc.SampleDesc.Count = 1;

	mov	DWORD PTR _swapDesc$[ebp+28], 1

; 225  :     swapDesc.Windowed = TRUE;

	mov	DWORD PTR _swapDesc$[ebp+48], 1

; 226  : 
; 227  :     bDisableCompatibilityMode = 1;//AppConfig->GetInt(TEXT("Video"), TEXT("DisableD3DCompatibilityMode"), 1) != 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+96], 1

; 228  : 
; 229  :     UINT createFlags = D3D10_CREATE_DEVICE_BGRA_SUPPORT;

	mov	DWORD PTR _createFlags$[ebp], 32	; 00000020H

; 230  :     if(GlobalConfig->GetInt(TEXT("General"), TEXT("UseDebugD3D")))

	push	0
	push	OFFSET $SG4294909721
	push	OFFSET $SG4294909720
	mov	ecx, DWORD PTR ?GlobalConfig@@3PAVConfigFile@@A ; GlobalConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	test	eax, eax
	je	SHORT $LN14@D3D10Syste

; 231  :         createFlags |= D3D10_CREATE_DEVICE_DEBUG;

	mov	ecx, DWORD PTR _createFlags$[ebp]
	or	ecx, 2
	mov	DWORD PTR _createFlags$[ebp], ecx
$LN14@D3D10Syste:

; 232  : 
; 233  :     D3D10_FEATURE_LEVEL1 level = bDisableCompatibilityMode ? D3D10_FEATURE_LEVEL_10_1 : D3D10_FEATURE_LEVEL_9_3;

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+96]
	test	eax, eax
	je	SHORT $LN24@D3D10Syste
	mov	DWORD PTR tv193[ebp], 41216		; 0000a100H
	jmp	SHORT $LN25@D3D10Syste
$LN24@D3D10Syste:
	mov	DWORD PTR tv193[ebp], 37632		; 00009300H
$LN25@D3D10Syste:
	mov	ecx, DWORD PTR tv193[ebp]
	mov	DWORD PTR _level$[ebp], ecx

; 234  : 
; 235  :     String adapterName;

	lea	ecx, DWORD PTR _adapterName$[ebp]
	call	DWORD PTR __imp_??0String@@QAE@XZ

; 236  :     DXGI_ADAPTER_DESC desc;
; 237  :     if (adapter->GetDesc(&desc) == S_OK)

	lea	edx, DWORD PTR _desc$[ebp]
	push	edx
	mov	eax, DWORD PTR _adapter$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _adapter$[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+32]
	call	eax
	test	eax, eax
	jne	SHORT $LN13@D3D10Syste

; 238  :         adapterName = desc.Description;

	lea	ecx, DWORD PTR _desc$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _adapterName$[ebp]
	call	DWORD PTR __imp_??4String@@QAEAAV0@PB_W@Z

; 239  :     else

	jmp	SHORT $LN12@D3D10Syste
$LN13@D3D10Syste:

; 240  :         adapterName = TEXT("<unknown>");

	push	OFFSET $SG4294909719
	lea	ecx, DWORD PTR _adapterName$[ebp]
	call	DWORD PTR __imp_??4String@@QAEAAV0@PB_W@Z
$LN12@D3D10Syste:

; 241  : 
; 242  :     adapterName.KillSpaces();

	lea	ecx, DWORD PTR _adapterName$[ebp]
	call	DWORD PTR __imp_?KillSpaces@String@@QAEAAV1@XZ

; 243  : 
; 244  :     Log(TEXT("Loading up D3D10 on %s (Adapter %u)..."), adapterName.Array(), adapterID+1);

	mov	edx, DWORD PTR _adapterID$[ebp]
	add	edx, 1
	push	edx
	lea	ecx, DWORD PTR _adapterName$[ebp]
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	push	OFFSET $SG4294909718
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 12					; 0000000cH

; 245  : 
; 246  :     //D3D10_CREATE_DEVICE_DEBUG
; 247  :     //D3D11_DRIVER_TYPE_REFERENCE, D3D11_DRIVER_TYPE_HARDWARE
; 248  : 	//main 
; 249  :     err = D3D10CreateDeviceAndSwapChain1(adapter, D3D10_DRIVER_TYPE_HARDWARE, NULL, createFlags, level, D3D10_1_SDK_VERSION, &swapDesc, &swap, &d3d);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 72					; 00000048H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 76					; 0000004cH
	push	ecx
	lea	edx, DWORD PTR _swapDesc$[ebp]
	push	edx
	push	32					; 00000020H
	mov	eax, DWORD PTR _level$[ebp]
	push	eax
	mov	ecx, DWORD PTR _createFlags$[ebp]
	push	ecx
	push	0
	push	0
	mov	edx, DWORD PTR _adapter$[ebp]
	push	edx
	call	DWORD PTR __imp__D3D10CreateDeviceAndSwapChain1@36
	mov	DWORD PTR _err$[ebp], eax

; 250  :     if(FAILED(err))

	cmp	DWORD PTR _err$[ebp], 0
	jge	$LN11@D3D10Syste

; 251  :     {
; 252  :         Log (TEXT("D3D10CreateDeviceAndSwapChain1: Failed on %s: 0x%08x. Trying compatibility mode"), adapterName.Array(), err);

	mov	eax, DWORD PTR _err$[ebp]
	push	eax
	lea	ecx, DWORD PTR _adapterName$[ebp]
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	push	OFFSET $SG4294909717
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 12					; 0000000cH

; 253  : 
; 254  :         bDisableCompatibilityMode = !bDisableCompatibilityMode;

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+96]
	test	edx, edx
	jne	SHORT $LN26@D3D10Syste
	mov	DWORD PTR tv244[ebp], 1
	jmp	SHORT $LN27@D3D10Syste
$LN26@D3D10Syste:
	mov	DWORD PTR tv244[ebp], 0
$LN27@D3D10Syste:
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR tv244[ebp]
	mov	BYTE PTR [eax+96], cl

; 255  :         level = bDisableCompatibilityMode ? D3D10_FEATURE_LEVEL_10_1 : D3D10_FEATURE_LEVEL_9_3;

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+96]
	test	eax, eax
	je	SHORT $LN28@D3D10Syste
	mov	DWORD PTR tv249[ebp], 41216		; 0000a100H
	jmp	SHORT $LN29@D3D10Syste
$LN28@D3D10Syste:
	mov	DWORD PTR tv249[ebp], 37632		; 00009300H
$LN29@D3D10Syste:
	mov	ecx, DWORD PTR tv249[ebp]
	mov	DWORD PTR _level$[ebp], ecx

; 256  :         err = D3D10CreateDeviceAndSwapChain1(adapter, D3D10_DRIVER_TYPE_HARDWARE, NULL, createFlags, level, D3D10_1_SDK_VERSION, &swapDesc, &swap, &d3d);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 72					; 00000048H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 76					; 0000004cH
	push	eax
	lea	ecx, DWORD PTR _swapDesc$[ebp]
	push	ecx
	push	32					; 00000020H
	mov	edx, DWORD PTR _level$[ebp]
	push	edx
	mov	eax, DWORD PTR _createFlags$[ebp]
	push	eax
	push	0
	push	0
	mov	ecx, DWORD PTR _adapter$[ebp]
	push	ecx
	call	DWORD PTR __imp__D3D10CreateDeviceAndSwapChain1@36
	mov	DWORD PTR _err$[ebp], eax
$LN11@D3D10Syste:

; 257  :     }
; 258  : 
; 259  :     if(FAILED(err))

	cmp	DWORD PTR _err$[ebp], 0
	jge	SHORT $LN10@D3D10Syste

; 260  :     {
; 261  :         Log (TEXT("D3D10CreateDeviceAndSwapChain1: Failed on %s: 0x%08x"), adapterName.Array(), err);

	mov	edx, DWORD PTR _err$[ebp]
	push	edx
	lea	ecx, DWORD PTR _adapterName$[ebp]
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	push	OFFSET $SG4294909716
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 12					; 0000000cH

; 262  :         CrashError(TEXT("Could not initialize DirectX 10 on %s.  This error can happen for one of the following reasons:\r\n\r\n1.) Your GPU is not supported (DirectX 10 is required - note that many integrated laptop GPUs do not support DX10)\r\n2.) You're running Windows Vista without the \"Platform Update\"\r\n3.) Your video card drivers are out of date\r\n\r\nIf you are using a laptop with NVIDIA Optimus or AMD Switchable Graphics, make sure OBS is set to run on the high performance GPU in your driver settings."), adapterName.Array());

	lea	ecx, DWORD PTR _adapterName$[ebp]
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	push	OFFSET $SG4294909715
	call	DWORD PTR __imp_?CrashError@@YAXPB_WZZ
$LN10@D3D10Syste:

; 263  :     }
; 264  : 
; 265  :     adapter->Release();

	mov	eax, DWORD PTR _adapter$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _adapter$[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+8]
	call	eax

; 266  : 
; 267  :     //------------------------------------------------------------------
; 268  : 
; 269  :     D3D10_DEPTH_STENCIL_DESC depthDesc;
; 270  :     zero(&depthDesc, sizeof(depthDesc));

	push	52					; 00000034H
	lea	ecx, DWORD PTR _depthDesc$[ebp]
	push	ecx
	call	?zero@@YGXPAXI@Z			; zero

; 271  :     depthDesc.DepthEnable = FALSE;

	mov	DWORD PTR _depthDesc$[ebp], 0

; 272  : 	//
; 273  :     err = d3d->CreateDepthStencilState(&depthDesc, &depthState);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 84					; 00000054H
	push	edx
	lea	eax, DWORD PTR _depthDesc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+336]
	call	eax
	mov	DWORD PTR _err$[ebp], eax

; 274  :     if(FAILED(err))

	cmp	DWORD PTR _err$[ebp], 0
	jge	SHORT $LN9@D3D10Syste

; 275  :         CrashError(TEXT("Unable to create depth state"));

	push	OFFSET $SG4294909714
	call	DWORD PTR __imp_?CrashError@@YAXPB_WZZ
$LN9@D3D10Syste:

; 276  : 
; 277  :     d3d->OMSetDepthStencilState(depthState, 0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+104]
	call	edx

; 278  : 
; 279  :     //------------------------------------------------------------------
; 280  : 
; 281  :     D3D10_RASTERIZER_DESC rasterizerDesc;
; 282  :     zero(&rasterizerDesc, sizeof(rasterizerDesc));

	push	40					; 00000028H
	lea	eax, DWORD PTR _rasterizerDesc$[ebp]
	push	eax
	call	?zero@@YGXPAXI@Z			; zero

; 283  :     rasterizerDesc.FillMode = D3D10_FILL_SOLID;

	mov	DWORD PTR _rasterizerDesc$[ebp], 3

; 284  :     rasterizerDesc.CullMode = D3D10_CULL_NONE;

	mov	DWORD PTR _rasterizerDesc$[ebp+4], 1

; 285  :     rasterizerDesc.FrontCounterClockwise = FALSE;

	mov	DWORD PTR _rasterizerDesc$[ebp+8], 0

; 286  :     rasterizerDesc.DepthClipEnable = TRUE;

	mov	DWORD PTR _rasterizerDesc$[ebp+24], 1

; 287  : 
; 288  :     err = d3d->CreateRasterizerState(&rasterizerDesc, &rasterizerState);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 88					; 00000058H
	push	ecx
	lea	edx, DWORD PTR _rasterizerDesc$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+340]
	call	edx
	mov	DWORD PTR _err$[ebp], eax

; 289  :     if(FAILED(err))

	cmp	DWORD PTR _err$[ebp], 0
	jge	SHORT $LN8@D3D10Syste

; 290  :         CrashError(TEXT("Unable to create rasterizer state"));

	push	OFFSET $SG4294909713
	call	DWORD PTR __imp_?CrashError@@YAXPB_WZZ
$LN8@D3D10Syste:

; 291  : 
; 292  :     d3d->RSSetState(rasterizerState);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+116]
	call	ecx

; 293  : 
; 294  :     //------------------------------------------------------------------
; 295  : 
; 296  :     rasterizerDesc.ScissorEnable = TRUE;

	mov	DWORD PTR _rasterizerDesc$[ebp+28], 1

; 297  : 
; 298  :     err = d3d->CreateRasterizerState(&rasterizerDesc, &scissorState);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 92					; 0000005cH
	push	edx
	lea	eax, DWORD PTR _rasterizerDesc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+340]
	call	eax
	mov	DWORD PTR _err$[ebp], eax

; 299  :     if(FAILED(err))

	cmp	DWORD PTR _err$[ebp], 0
	jge	SHORT $LN7@D3D10Syste

; 300  :         CrashError(TEXT("Unable to create scissor state"));

	push	OFFSET $SG4294909712
	call	DWORD PTR __imp_?CrashError@@YAXPB_WZZ
$LN7@D3D10Syste:

; 301  : 
; 302  :     //------------------------------------------------------------------
; 303  : 
; 304  :     ID3D10Texture2D *backBuffer = NULL;

	mov	DWORD PTR _backBuffer$[ebp], 0

; 305  :     err = swap->GetBuffer(0, IID_ID3D10Texture2D, (void**)&backBuffer);

	lea	ecx, DWORD PTR _backBuffer$[ebp]
	push	ecx
	push	OFFSET _IID_ID3D10Texture2D
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+36]
	call	ecx
	mov	DWORD PTR _err$[ebp], eax

; 306  :     if(FAILED(err))

	cmp	DWORD PTR _err$[ebp], 0
	jge	SHORT $LN6@D3D10Syste

; 307  :         CrashError(TEXT("Unable to get back buffer from swap chain"));

	push	OFFSET $SG4294909711
	call	DWORD PTR __imp_?CrashError@@YAXPB_WZZ
$LN6@D3D10Syste:

; 308  : 
; 309  :     err = d3d->CreateRenderTargetView(backBuffer, NULL, &swapRenderView);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 80					; 00000050H
	push	edx
	push	0
	mov	eax, DWORD PTR _backBuffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+304]
	call	eax
	mov	DWORD PTR _err$[ebp], eax

; 310  :     if(FAILED(err))

	cmp	DWORD PTR _err$[ebp], 0
	jge	SHORT $LN5@D3D10Syste

; 311  :         CrashError(TEXT("Unable to get render view from back buffer"));

	push	OFFSET $SG4294909710
	call	DWORD PTR __imp_?CrashError@@YAXPB_WZZ
$LN5@D3D10Syste:

; 312  : 
; 313  :     backBuffer->Release();

	mov	ecx, DWORD PTR _backBuffer$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _backBuffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx+8]
	call	ecx

; 314  : 
; 315  :     //------------------------------------------------------------------
; 316  : 
; 317  :     D3D10_BLEND_DESC disabledBlendDesc;
; 318  :     zero(&disabledBlendDesc, sizeof(disabledBlendDesc));

	push	68					; 00000044H
	lea	edx, DWORD PTR _disabledBlendDesc$[ebp]
	push	edx
	call	?zero@@YGXPAXI@Z			; zero

; 319  :     for(int i=0; i<8; i++)

	mov	DWORD PTR _i$2[ebp], 0
	jmp	SHORT $LN4@D3D10Syste
$LN3@D3D10Syste:
	mov	eax, DWORD PTR _i$2[ebp]
	add	eax, 1
	mov	DWORD PTR _i$2[ebp], eax
$LN4@D3D10Syste:
	cmp	DWORD PTR _i$2[ebp], 8
	jge	SHORT $LN2@D3D10Syste

; 320  :     {
; 321  :         disabledBlendDesc.BlendEnable[i]        = TRUE;

	mov	ecx, DWORD PTR _i$2[ebp]
	mov	DWORD PTR _disabledBlendDesc$[ebp+ecx*4+4], 1

; 322  :         disabledBlendDesc.RenderTargetWriteMask[i] = D3D10_COLOR_WRITE_ENABLE_ALL;

	mov	edx, DWORD PTR _i$2[ebp]
	mov	BYTE PTR _disabledBlendDesc$[ebp+edx+60], 15 ; 0000000fH

; 323  :     }

	jmp	SHORT $LN3@D3D10Syste
$LN2@D3D10Syste:

; 324  :     disabledBlendDesc.BlendOpAlpha          = D3D10_BLEND_OP_ADD;

	mov	DWORD PTR _disabledBlendDesc$[ebp+56], 1

; 325  :     disabledBlendDesc.BlendOp               = D3D10_BLEND_OP_ADD;

	mov	DWORD PTR _disabledBlendDesc$[ebp+44], 1

; 326  :     disabledBlendDesc.SrcBlendAlpha         = D3D10_BLEND_ONE;

	mov	DWORD PTR _disabledBlendDesc$[ebp+48], 2

; 327  :     disabledBlendDesc.DestBlendAlpha        = D3D10_BLEND_ZERO;

	mov	DWORD PTR _disabledBlendDesc$[ebp+52], 1

; 328  :     disabledBlendDesc.SrcBlend              = D3D10_BLEND_ONE;

	mov	DWORD PTR _disabledBlendDesc$[ebp+36], 2

; 329  :     disabledBlendDesc.DestBlend             = D3D10_BLEND_ZERO;

	mov	DWORD PTR _disabledBlendDesc$[ebp+40], 1

; 330  : 
; 331  :     err = d3d->CreateBlendState(&disabledBlendDesc, &disabledBlend);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 196				; 000000c4H
	push	eax
	lea	ecx, DWORD PTR _disabledBlendDesc$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+332]
	call	ecx
	mov	DWORD PTR _err$[ebp], eax

; 332  :     if(FAILED(err))

	cmp	DWORD PTR _err$[ebp], 0
	jge	SHORT $LN1@D3D10Syste

; 333  :         CrashError(TEXT("Unable to create disabled blend state"));

	push	OFFSET $SG4294909709
	call	DWORD PTR __imp_?CrashError@@YAXPB_WZZ
$LN1@D3D10Syste:

; 334  : 
; 335  :     this->BlendFunction(GS_BLEND_SRCALPHA, GS_BLEND_INVSRCALPHA, 1.0f);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	5
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BlendFunction@D3D10System@@UAEXW4GSBlendType@@0M@Z ; D3D10System::BlendFunction

; 336  :     bBlendingEnabled = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+200], 1

; 337  : }

	lea	ecx, DWORD PTR _adapterName$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
$LN21@D3D10Syste:
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
??0D3D10System@@QAE@XZ ENDP				; D3D10System::D3D10System
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GD3D10System@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GD3D10System@@UAEPAXI@Z PROC				; D3D10System::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1D3D10System@@UAE@XZ			; D3D10System::~D3D10System
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GD3D10System@@UAEPAXI@Z ENDP				; D3D10System::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\d3d10system.cpp
;	COMDAT ??1D3D10System@@UAE@XZ
_TEXT	SEGMENT
tv91 = -36						; size = 4
$T1 = -32						; size = 4
tv83 = -28						; size = 4
$T2 = -24						; size = 4
tv146 = -20						; size = 4
$T3 = -16						; size = 4
$T4 = -12						; size = 4
_i$5 = -8						; size = 4
_this$ = -4						; size = 4
??1D3D10System@@UAE@XZ PROC				; D3D10System::~D3D10System, COMDAT
; _this$ = ecx

; 340  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7D3D10System@@6B@

; 341  :     delete spriteVertexBuffer;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+204]
	mov	DWORD PTR $T2[ebp], edx
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR $T4[ebp], eax
	cmp	DWORD PTR $T4[ebp], 0
	je	SHORT $LN15@D3D10Syste
	push	1
	mov	ecx, DWORD PTR $T4[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR $T4[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	mov	DWORD PTR tv83[ebp], eax
	jmp	SHORT $LN16@D3D10Syste
$LN15@D3D10Syste:
	mov	DWORD PTR tv83[ebp], 0
$LN16@D3D10Syste:

; 342  :     delete boxVertexBuffer;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+208]
	mov	DWORD PTR $T1[ebp], edx
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR $T3[ebp], eax
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN17@D3D10Syste
	push	1
	mov	ecx, DWORD PTR $T3[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR $T3[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	mov	DWORD PTR tv91[ebp], eax
	jmp	SHORT $LN18@D3D10Syste
$LN17@D3D10Syste:
	mov	DWORD PTR tv91[ebp], 0
$LN18@D3D10Syste:

; 343  : 
; 344  :     for(UINT i=0; i<blends.Num(); i++)

	mov	DWORD PTR _i$5[ebp], 0
	jmp	SHORT $LN12@D3D10Syste
$LN11@D3D10Syste:
	mov	ecx, DWORD PTR _i$5[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$5[ebp], ecx
$LN12@D3D10Syste:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 184				; 000000b8H
	call	?Num@?$List@USavedBlendState@@@@QBEIXZ	; List<SavedBlendState>::Num
	cmp	DWORD PTR _i$5[ebp], eax
	jae	SHORT $LN10@D3D10Syste

; 345  :         SafeRelease(blends[i].blendState);

	mov	edx, DWORD PTR _i$5[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 184				; 000000b8H
	call	??A?$List@USavedBlendState@@@@QAEAAUSavedBlendState@@I@Z ; List<SavedBlendState>::operator[]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN9@D3D10Syste
	mov	eax, DWORD PTR _i$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 184				; 000000b8H
	call	??A?$List@USavedBlendState@@@@QAEAAUSavedBlendState@@I@Z ; List<SavedBlendState>::operator[]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR tv146[ebp], ecx
	mov	edx, DWORD PTR tv146[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv146[ebp]
	push	ecx
	mov	edx, DWORD PTR [eax+8]
	call	edx
	mov	eax, DWORD PTR _i$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 184				; 000000b8H
	call	??A?$List@USavedBlendState@@@@QAEAAUSavedBlendState@@I@Z ; List<SavedBlendState>::operator[]
	mov	DWORD PTR [eax+8], 0
$LN9@D3D10Syste:
	jmp	SHORT $LN11@D3D10Syste
$LN10@D3D10Syste:

; 346  : 
; 347  :     SafeRelease(scissorState);

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+92], 0
	je	SHORT $LN8@D3D10Syste
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+92]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+92]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+8]
	call	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+92], 0
$LN8@D3D10Syste:

; 348  :     SafeRelease(rasterizerState);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+88], 0
	je	SHORT $LN7@D3D10Syste
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+88]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+88], 0
$LN7@D3D10Syste:

; 349  :     SafeRelease(depthState);

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+84], 0
	je	SHORT $LN6@D3D10Syste
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+84]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+8]
	call	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+84], 0
$LN6@D3D10Syste:

; 350  :     SafeRelease(disabledBlend);

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+196], 0
	je	SHORT $LN5@D3D10Syste
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+196]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+196]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+8]
	call	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+196], 0
$LN5@D3D10Syste:

; 351  :     SafeRelease(swapRenderView);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+80], 0
	je	SHORT $LN4@D3D10Syste
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+80], 0
$LN4@D3D10Syste:

; 352  :     SafeRelease(swap);

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+76], 0
	je	SHORT $LN3@D3D10Syste
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+8]
	call	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+76], 0
$LN3@D3D10Syste:

; 353  :     SafeRelease(d3d);

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+72], 0
	je	SHORT $LN2@D3D10Syste
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+8]
	call	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+72], 0
$LN2@D3D10Syste:

; 354  :     SafeRelease(factory);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+68], 0
	je	SHORT $LN13@D3D10Syste
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+68], 0
$LN13@D3D10Syste:

; 355  : }

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 184				; 000000b8H
	call	??1?$List@USavedBlendState@@@@QAE@XZ	; List<SavedBlendState>::~List<SavedBlendState>
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1GraphicsSystem@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1D3D10System@@UAE@XZ ENDP				; D3D10System::~D3D10System
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\d3d10system.cpp
;	COMDAT ?UnloadAllData@D3D10System@@EAEXXZ
_TEXT	SEGMENT
_zeroVal$ = -64						; size = 4
_i$1 = -60						; size = 4
_this$ = -56						; size = 4
_nullBuff$ = -52					; size = 32
_bla$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
?UnloadAllData@D3D10System@@EAEXXZ PROC			; D3D10System::UnloadAllData, COMDAT
; _this$ = ecx

; 358  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 359  :     LoadVertexShader(NULL);

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+80]
	call	eax

; 360  :     LoadPixelShader(NULL);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+84]
	call	eax

; 361  :     LoadVertexBuffer(NULL);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+68]
	call	eax

; 362  :     for(UINT i=0; i<8; i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN3@UnloadAllD
$LN2@UnloadAllD:
	mov	ecx, DWORD PTR _i$1[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$1[ebp], ecx
$LN3@UnloadAllD:
	cmp	DWORD PTR _i$1[ebp], 8
	jae	SHORT $LN1@UnloadAllD

; 363  :     {
; 364  :         LoadSamplerState(NULL, i);

	mov	edx, DWORD PTR _i$1[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+76]
	call	eax

; 365  :         LoadTexture(NULL, i);

	mov	ecx, DWORD PTR _i$1[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+72]
	call	edx

; 366  :     }

	jmp	SHORT $LN2@UnloadAllD
$LN1@UnloadAllD:

; 367  : 
; 368  :     UINT zeroVal = 0;

	mov	DWORD PTR _zeroVal$[ebp], 0

; 369  :     LPVOID nullBuff[8];
; 370  :     float bla[4] = {1.0f, 1.0f, 1.0f, 1.0f};

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _bla$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _bla$[ebp+4], xmm0
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _bla$[ebp+8], xmm0
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _bla$[ebp+12], xmm0

; 371  : 
; 372  :     zero(nullBuff, sizeof(nullBuff));

	push	32					; 00000020H
	lea	eax, DWORD PTR _nullBuff$[ebp]
	push	eax
	call	?zero@@YGXPAXI@Z			; zero

; 373  : 
; 374  :     d3d->VSSetConstantBuffers(0, 1, (ID3D10Buffer**)nullBuff);

	lea	ecx, DWORD PTR _nullBuff$[ebp]
	push	ecx
	push	1
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+12]
	call	ecx

; 375  :     d3d->PSSetConstantBuffers(0, 1, (ID3D10Buffer**)nullBuff);

	lea	edx, DWORD PTR _nullBuff$[ebp]
	push	edx
	push	1
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+40]
	call	edx

; 376  :     d3d->OMSetDepthStencilState(NULL, 0);

	push	0
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+104]
	call	edx

; 377  :     d3d->PSSetSamplers(0, 1, (ID3D10SamplerState**)nullBuff);

	lea	eax, DWORD PTR _nullBuff$[ebp]
	push	eax
	push	1
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+24]
	call	eax

; 378  :     d3d->OMSetBlendState(NULL, bla, 0xFFFFFFFF);

	push	-1
	lea	ecx, DWORD PTR _bla$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+100]
	call	ecx

; 379  :     d3d->OMSetRenderTargets(1, (ID3D10RenderTargetView**)nullBuff, NULL);

	push	0
	lea	edx, DWORD PTR _nullBuff$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+96]
	call	edx

; 380  :     d3d->IASetVertexBuffers(0, 8, (ID3D10Buffer**)nullBuff, &zeroVal, &zeroVal);

	lea	eax, DWORD PTR _zeroVal$[ebp]
	push	eax
	lea	ecx, DWORD PTR _zeroVal$[ebp]
	push	ecx
	lea	edx, DWORD PTR _nullBuff$[ebp]
	push	edx
	push	8
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+48]
	call	edx

; 381  :     d3d->PSSetShaderResources(0, 8, (ID3D10ShaderResourceView**)nullBuff);

	lea	eax, DWORD PTR _nullBuff$[ebp]
	push	eax
	push	8
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+16]
	call	eax

; 382  :     d3d->IASetInputLayout(NULL);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+44]
	call	eax

; 383  :     d3d->PSSetShader(NULL);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+20]
	call	eax

; 384  :     d3d->VSSetShader(NULL);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+28]
	call	eax

; 385  :     d3d->RSSetState(NULL);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+116]
	call	eax

; 386  :     d3d->RSSetScissorRects(0, NULL);

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+124]
	call	eax

; 387  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?UnloadAllData@D3D10System@@EAEXXZ ENDP			; D3D10System::UnloadAllData
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\d3d10system.cpp
;	COMDAT ?GetDevice@D3D10System@@UAEPAXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetDevice@D3D10System@@UAEPAXXZ PROC			; D3D10System::GetDevice, COMDAT
; _this$ = ecx

; 390  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 391  :     return (LPVOID)d3d;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+72]

; 392  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetDevice@D3D10System@@UAEPAXXZ ENDP			; D3D10System::GetDevice
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\d3d10system.cpp
;	COMDAT ?Init@D3D10System@@UAEXXZ
_TEXT	SEGMENT
tv134 = -24						; size = 4
$T1 = -20						; size = 4
tv69 = -16						; size = 4
$T2 = -12						; size = 4
_this$ = -8						; size = 4
_data$ = -4						; size = 4
?Init@D3D10System@@UAEXXZ PROC				; D3D10System::Init, COMDAT
; _this$ = ecx

; 396  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 397  :     VBData *data = new VBData;

	push	40					; 00000028H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	cmp	DWORD PTR $T2[ebp], 0
	je	SHORT $LN3@Init
	mov	ecx, DWORD PTR $T2[ebp]
	call	??0VBData@@QAE@XZ			; VBData::VBData
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@Init
$LN3@Init:
	mov	DWORD PTR tv69[ebp], 0
$LN4@Init:
	mov	eax, DWORD PTR tv69[ebp]
	mov	DWORD PTR _data$[ebp], eax

; 398  :     data->UVList.SetSize(1);

	push	1
	mov	ecx, DWORD PTR _data$[ebp]
	add	ecx, 32					; 00000020H
	call	?SetSize@?$List@VUVCoordList@@@@QAEHI@Z	; List<UVCoordList>::SetSize

; 399  : 
; 400  :     data->VertList.SetSize(4);

	push	4
	mov	ecx, DWORD PTR _data$[ebp]
	call	?SetSize@?$List@UVect@@@@QAEHI@Z	; List<Vect>::SetSize

; 401  :     data->UVList[0].SetSize(4);

	push	4
	push	0
	mov	ecx, DWORD PTR _data$[ebp]
	add	ecx, 32					; 00000020H
	call	??A?$List@VUVCoordList@@@@QAEAAVUVCoordList@@I@Z ; List<UVCoordList>::operator[]
	mov	ecx, eax
	call	?SetSize@?$List@UVect2@@@@QAEHI@Z	; List<Vect2>::SetSize

; 402  : 
; 403  :     spriteVertexBuffer = CreateVertexBuffer(data, FALSE);

	push	0
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+64]
	call	edx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+204], eax

; 404  : 
; 405  :     //------------------------------------------------------------------
; 406  : 
; 407  :     data = new VBData;

	push	40					; 00000028H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 0
	je	SHORT $LN5@Init
	mov	ecx, DWORD PTR $T1[ebp]
	call	??0VBData@@QAE@XZ			; VBData::VBData
	mov	DWORD PTR tv134[ebp], eax
	jmp	SHORT $LN6@Init
$LN5@Init:
	mov	DWORD PTR tv134[ebp], 0
$LN6@Init:
	mov	edx, DWORD PTR tv134[ebp]
	mov	DWORD PTR _data$[ebp], edx

; 408  :     data->VertList.SetSize(5);

	push	5
	mov	ecx, DWORD PTR _data$[ebp]
	call	?SetSize@?$List@UVect@@@@QAEHI@Z	; List<Vect>::SetSize

; 409  :     boxVertexBuffer = CreateVertexBuffer(data, FALSE);

	push	0
	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+64]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+208], eax

; 410  : 
; 411  :     //------------------------------------------------------------------
; 412  : 
; 413  :     GraphicsSystem::Init();

	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_?Init@GraphicsSystem@@UAEXXZ

; 414  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Init@D3D10System@@UAEXXZ ENDP				; D3D10System::Init
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\d3d10system.cpp
;	COMDAT ?CreateTextureFromSharedHandle@D3D10System@@UAEPAVTexture@@IIPAX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_width$ = 8						; size = 4
_height$ = 12						; size = 4
_handle$ = 16						; size = 4
?CreateTextureFromSharedHandle@D3D10System@@UAEPAVTexture@@IIPAX@Z PROC ; D3D10System::CreateTextureFromSharedHandle, COMDAT
; _this$ = ecx

; 420  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 421  :     return D3D10Texture::CreateFromSharedHandle(width, height, handle);

	mov	eax, DWORD PTR _handle$[ebp]
	push	eax
	mov	ecx, DWORD PTR _height$[ebp]
	push	ecx
	mov	edx, DWORD PTR _width$[ebp]
	push	edx
	call	?CreateFromSharedHandle@D3D10Texture@@CAPAVTexture@@IIPAX@Z ; D3D10Texture::CreateFromSharedHandle
	add	esp, 12					; 0000000cH

; 422  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?CreateTextureFromSharedHandle@D3D10System@@UAEPAVTexture@@IIPAX@Z ENDP ; D3D10System::CreateTextureFromSharedHandle
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\d3d10system.cpp
;	COMDAT ?CreateSharedTexture@D3D10System@@UAEPAVTexture@@II@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_width$ = 8						; size = 4
_height$ = 12						; size = 4
?CreateSharedTexture@D3D10System@@UAEPAVTexture@@II@Z PROC ; D3D10System::CreateSharedTexture, COMDAT
; _this$ = ecx

; 425  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 426  :     return D3D10Texture::CreateShared(width, height);

	mov	eax, DWORD PTR _height$[ebp]
	push	eax
	mov	ecx, DWORD PTR _width$[ebp]
	push	ecx
	call	?CreateShared@D3D10Texture@@CAPAVTexture@@II@Z ; D3D10Texture::CreateShared
	add	esp, 8

; 427  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?CreateSharedTexture@D3D10System@@UAEPAVTexture@@II@Z ENDP ; D3D10System::CreateSharedTexture
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\d3d10system.cpp
;	COMDAT ?CreateTexture@D3D10System@@UAEPAVTexture@@IIW4GSColorFormat@@PAXHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_width$ = 8						; size = 4
_height$ = 12						; size = 4
_colorFormat$ = 16					; size = 4
_lpData$ = 20						; size = 4
_bBuildMipMaps$ = 24					; size = 4
_bStatic$ = 28						; size = 4
?CreateTexture@D3D10System@@UAEPAVTexture@@IIW4GSColorFormat@@PAXHH@Z PROC ; D3D10System::CreateTexture, COMDAT
; _this$ = ecx

; 430  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 431  :     return D3D10Texture::CreateTexture(width, height, colorFormat, lpData, bBuildMipMaps, bStatic);

	mov	eax, DWORD PTR _bStatic$[ebp]
	push	eax
	mov	ecx, DWORD PTR _bBuildMipMaps$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpData$[ebp]
	push	edx
	mov	eax, DWORD PTR _colorFormat$[ebp]
	push	eax
	mov	ecx, DWORD PTR _height$[ebp]
	push	ecx
	mov	edx, DWORD PTR _width$[ebp]
	push	edx
	call	?CreateTexture@D3D10Texture@@CAPAVTexture@@IIW4GSColorFormat@@PAXHH@Z ; D3D10Texture::CreateTexture
	add	esp, 24					; 00000018H

; 432  : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?CreateTexture@D3D10System@@UAEPAVTexture@@IIW4GSColorFormat@@PAXHH@Z ENDP ; D3D10System::CreateTexture
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\d3d10system.cpp
;	COMDAT ?CreateTextureFromFile@D3D10System@@UAEPAVTexture@@PB_WH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lpFile$ = 8						; size = 4
_bBuildMipMaps$ = 12					; size = 4
?CreateTextureFromFile@D3D10System@@UAEPAVTexture@@PB_WH@Z PROC ; D3D10System::CreateTextureFromFile, COMDAT
; _this$ = ecx

; 435  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 436  :     return D3D10Texture::CreateFromFile(lpFile, bBuildMipMaps);

	mov	eax, DWORD PTR _bBuildMipMaps$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpFile$[ebp]
	push	ecx
	call	?CreateFromFile@D3D10Texture@@CAPAVTexture@@PB_WH@Z ; D3D10Texture::CreateFromFile
	add	esp, 8

; 437  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?CreateTextureFromFile@D3D10System@@UAEPAVTexture@@PB_WH@Z ENDP ; D3D10System::CreateTextureFromFile
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\d3d10system.cpp
;	COMDAT ?CreateRenderTarget@D3D10System@@UAEPAVTexture@@IIW4GSColorFormat@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_width$ = 8						; size = 4
_height$ = 12						; size = 4
_colorFormat$ = 16					; size = 4
_bGenMipMaps$ = 20					; size = 4
?CreateRenderTarget@D3D10System@@UAEPAVTexture@@IIW4GSColorFormat@@H@Z PROC ; D3D10System::CreateRenderTarget, COMDAT
; _this$ = ecx

; 440  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 441  :     return D3D10Texture::CreateRenderTarget(width, height, colorFormat, bGenMipMaps);

	mov	eax, DWORD PTR _bGenMipMaps$[ebp]
	push	eax
	mov	ecx, DWORD PTR _colorFormat$[ebp]
	push	ecx
	mov	edx, DWORD PTR _height$[ebp]
	push	edx
	mov	eax, DWORD PTR _width$[ebp]
	push	eax
	call	?CreateRenderTarget@D3D10Texture@@CAPAVTexture@@IIW4GSColorFormat@@H@Z ; D3D10Texture::CreateRenderTarget
	add	esp, 16					; 00000010H

; 442  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?CreateRenderTarget@D3D10System@@UAEPAVTexture@@IIW4GSColorFormat@@H@Z ENDP ; D3D10System::CreateRenderTarget
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\d3d10system.cpp
;	COMDAT ?CreateGDITexture@D3D10System@@UAEPAVTexture@@II@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_width$ = 8						; size = 4
_height$ = 12						; size = 4
?CreateGDITexture@D3D10System@@UAEPAVTexture@@II@Z PROC	; D3D10System::CreateGDITexture, COMDAT
; _this$ = ecx

; 445  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 446  :     return D3D10Texture::CreateGDITexture(width, height);

	mov	eax, DWORD PTR _height$[ebp]
	push	eax
	mov	ecx, DWORD PTR _width$[ebp]
	push	ecx
	call	?CreateGDITexture@D3D10Texture@@CAPAVTexture@@II@Z ; D3D10Texture::CreateGDITexture
	add	esp, 8

; 447  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?CreateGDITexture@D3D10System@@UAEPAVTexture@@II@Z ENDP	; D3D10System::CreateGDITexture
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\d3d10system.cpp
;	COMDAT ?GetTextureFileInfo@D3D10System@@UAE_NPB_WAAUTextureInfo@@@Z
_TEXT	SEGMENT
_this$ = -48						; size = 4
tv72 = -44						; size = 4
_ii$ = -40						; size = 36
__$ArrayPad$ = -4					; size = 4
_lpFile$ = 8						; size = 4
_info$ = 12						; size = 4
?GetTextureFileInfo@D3D10System@@UAE_NPB_WAAUTextureInfo@@@Z PROC ; D3D10System::GetTextureFileInfo, COMDAT
; _this$ = ecx

; 450  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 451  :     D3DX10_IMAGE_INFO ii;
; 452  :     if(SUCCEEDED(D3DX10GetImageInfoFromFile(lpFile, NULL, &ii, NULL)))

	push	0
	lea	eax, DWORD PTR _ii$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpFile$[ebp]
	push	ecx
	call	DWORD PTR __imp__D3DX10GetImageInfoFromFileW@16
	test	eax, eax
	jl	$LN14@GetTexture

; 453  :     {
; 454  :         info.width = ii.Width;

	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR _ii$[ebp]
	mov	DWORD PTR [edx+4], eax

; 455  :         info.height = ii.Height;

	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR _ii$[ebp+4]
	mov	DWORD PTR [ecx+8], edx

; 456  :         switch(ii.Format)

	mov	eax, DWORD PTR _ii$[ebp+24]
	mov	DWORD PTR tv72[ebp], eax
	mov	ecx, DWORD PTR tv72[ebp]
	sub	ecx, 2
	mov	DWORD PTR tv72[ebp], ecx
	cmp	DWORD PTR tv72[ebp], 86			; 00000056H
	ja	SHORT $LN1@GetTexture
	mov	edx, DWORD PTR tv72[ebp]
	movzx	eax, BYTE PTR $LN17@GetTexture[edx]
	jmp	DWORD PTR $LN18@GetTexture[eax*4]
$LN11@GetTexture:

; 457  :         {
; 458  :             case DXGI_FORMAT_A8_UNORM:              info.type = GS_ALPHA;       break;

	mov	ecx, DWORD PTR _info$[ebp]
	mov	DWORD PTR [ecx], 1
	jmp	SHORT $LN12@GetTexture
$LN10@GetTexture:

; 459  :             case DXGI_FORMAT_R8_UNORM:              info.type = GS_GRAYSCALE;   break;

	mov	edx, DWORD PTR _info$[ebp]
	mov	DWORD PTR [edx], 2
	jmp	SHORT $LN12@GetTexture
$LN9@GetTexture:

; 460  :             case DXGI_FORMAT_B8G8R8X8_UNORM:        info.type = GS_BGR;         break;

	mov	eax, DWORD PTR _info$[ebp]
	mov	DWORD PTR [eax], 5
	jmp	SHORT $LN12@GetTexture
$LN8@GetTexture:

; 461  :             case DXGI_FORMAT_B8G8R8A8_UNORM:        info.type = GS_BGRA;        break;

	mov	ecx, DWORD PTR _info$[ebp]
	mov	DWORD PTR [ecx], 6
	jmp	SHORT $LN12@GetTexture
$LN7@GetTexture:

; 462  :             case DXGI_FORMAT_R8G8B8A8_UNORM:        info.type = GS_RGBA;        break;

	mov	edx, DWORD PTR _info$[ebp]
	mov	DWORD PTR [edx], 4
	jmp	SHORT $LN12@GetTexture
$LN6@GetTexture:

; 463  :             case DXGI_FORMAT_R16G16B16A16_FLOAT:    info.type = GS_RGBA16F;     break;

	mov	eax, DWORD PTR _info$[ebp]
	mov	DWORD PTR [eax], 7
	jmp	SHORT $LN12@GetTexture
$LN5@GetTexture:

; 464  :             case DXGI_FORMAT_R32G32B32A32_FLOAT:    info.type = GS_RGBA32F;     break;

	mov	ecx, DWORD PTR _info$[ebp]
	mov	DWORD PTR [ecx], 8
	jmp	SHORT $LN12@GetTexture
$LN4@GetTexture:

; 465  :             case DXGI_FORMAT_BC1_UNORM:             info.type = GS_DXT1;        break;

	mov	edx, DWORD PTR _info$[ebp]
	mov	DWORD PTR [edx], 12			; 0000000cH
	jmp	SHORT $LN12@GetTexture
$LN3@GetTexture:

; 466  :             case DXGI_FORMAT_BC2_UNORM:             info.type = GS_DXT3;        break;

	mov	eax, DWORD PTR _info$[ebp]
	mov	DWORD PTR [eax], 13			; 0000000dH
	jmp	SHORT $LN12@GetTexture
$LN2@GetTexture:

; 467  :             case DXGI_FORMAT_BC3_UNORM:             info.type = GS_DXT5;        break;

	mov	ecx, DWORD PTR _info$[ebp]
	mov	DWORD PTR [ecx], 14			; 0000000eH
	jmp	SHORT $LN12@GetTexture
$LN1@GetTexture:

; 468  :             default:
; 469  :                 info.type = GS_UNKNOWNFORMAT;

	mov	edx, DWORD PTR _info$[ebp]
	mov	DWORD PTR [edx], 0
$LN12@GetTexture:

; 470  :         }
; 471  : 
; 472  :         return true;

	mov	al, 1
	jmp	SHORT $LN15@GetTexture
$LN14@GetTexture:

; 473  :     }
; 474  : 
; 475  :     return false;

	xor	al, al
$LN15@GetTexture:

; 476  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	2
$LN18@GetTexture:
	DD	$LN5@GetTexture
	DD	$LN6@GetTexture
	DD	$LN7@GetTexture
	DD	$LN10@GetTexture
	DD	$LN11@GetTexture
	DD	$LN4@GetTexture
	DD	$LN3@GetTexture
	DD	$LN2@GetTexture
	DD	$LN8@GetTexture
	DD	$LN9@GetTexture
	DD	$LN1@GetTexture
$LN17@GetTexture:
	DB	0
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	1
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	2
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	3
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	4
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	5
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	6
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	7
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	8
	DB	9
?GetTextureFileInfo@D3D10System@@UAE_NPB_WAAUTextureInfo@@@Z ENDP ; D3D10System::GetTextureFileInfo
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\d3d10system.cpp
;	COMDAT ?CreateSamplerState@D3D10System@@UAEPAVSamplerState@@AAUSamplerInfo@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_info$ = 8						; size = 4
?CreateSamplerState@D3D10System@@UAEPAVSamplerState@@AAUSamplerInfo@@@Z PROC ; D3D10System::CreateSamplerState, COMDAT
; _this$ = ecx

; 479  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 480  :     return D3D10SamplerState::CreateSamplerState(info);

	mov	eax, DWORD PTR _info$[ebp]
	push	eax
	call	?CreateSamplerState@D3D10SamplerState@@CAPAVSamplerState@@AAUSamplerInfo@@@Z ; D3D10SamplerState::CreateSamplerState
	add	esp, 4

; 481  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?CreateSamplerState@D3D10System@@UAEPAVSamplerState@@AAUSamplerInfo@@@Z ENDP ; D3D10System::CreateSamplerState
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\d3d10system.cpp
;	COMDAT ?GetNumOutputs@D3D10System@@UAEIXZ
_TEXT	SEGMENT
_outputInterface$1 = -20				; size = 4
_this$ = -16						; size = 4
_count$ = -12						; size = 4
_device$ = -8						; size = 4
_adapter$2 = -4						; size = 4
?GetNumOutputs@D3D10System@@UAEIXZ PROC			; D3D10System::GetNumOutputs, COMDAT
; _this$ = ecx

; 485  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 486  :     UINT count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 487  : 
; 488  :     IDXGIDevice *device;
; 489  :     if(SUCCEEDED(d3d->QueryInterface(__uuidof(IDXGIDevice), (void**)&device)))

	lea	eax, DWORD PTR _device$[ebp]
	push	eax
	push	OFFSET __GUID_54ec77fa_1377_44e6_8c32_88fd5f44c84c
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx]
	call	eax
	test	eax, eax
	jl	SHORT $LN4@GetNumOutp

; 490  :     {
; 491  :         IDXGIAdapter *adapter;
; 492  :         if(SUCCEEDED(device->GetAdapter(&adapter)))

	lea	ecx, DWORD PTR _adapter$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _device$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _device$[ebp]
	push	ecx
	mov	edx, DWORD PTR [eax+28]
	call	edx
	test	eax, eax
	jl	SHORT $LN3@GetNumOutp
$LN2@GetNumOutp:

; 493  :         {
; 494  :             IDXGIOutput *outputInterface;
; 495  : 
; 496  :             while(SUCCEEDED(adapter->EnumOutputs(count, &outputInterface)))

	lea	eax, DWORD PTR _outputInterface$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _count$[ebp]
	push	ecx
	mov	edx, DWORD PTR _adapter$2[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _adapter$2[ebp]
	push	ecx
	mov	edx, DWORD PTR [eax+28]
	call	edx
	test	eax, eax
	jl	SHORT $LN1@GetNumOutp

; 497  :             {
; 498  :                 count++;

	mov	eax, DWORD PTR _count$[ebp]
	add	eax, 1
	mov	DWORD PTR _count$[ebp], eax

; 499  :                 outputInterface->Release();

	mov	ecx, DWORD PTR _outputInterface$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _outputInterface$1[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx+8]
	call	ecx

; 500  :             }

	jmp	SHORT $LN2@GetNumOutp
$LN1@GetNumOutp:

; 501  : 
; 502  :             adapter->Release();

	mov	edx, DWORD PTR _adapter$2[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _adapter$2[ebp]
	push	ecx
	mov	edx, DWORD PTR [eax+8]
	call	edx
$LN3@GetNumOutp:

; 503  :         }
; 504  : 
; 505  :         device->Release();

	mov	eax, DWORD PTR _device$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _device$[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+8]
	call	eax
$LN4@GetNumOutp:

; 506  :     }
; 507  : 
; 508  :     return count;

	mov	eax, DWORD PTR _count$[ebp]

; 509  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumOutputs@D3D10System@@UAEIXZ ENDP			; D3D10System::GetNumOutputs
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\d3d10system.cpp
;	COMDAT ?CreateOutputDuplicator@D3D10System@@UAEPAVOutputDuplicator@@I@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
tv89 = -24						; size = 4
$T1 = -20						; size = 4
tv69 = -16						; size = 4
$T2 = -12						; size = 4
$T3 = -8						; size = 4
_duplicator$ = -4					; size = 4
_outputID$ = 8						; size = 4
?CreateOutputDuplicator@D3D10System@@UAEPAVOutputDuplicator@@I@Z PROC ; D3D10System::CreateOutputDuplicator, COMDAT
; _this$ = ecx

; 512  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 513  :     D3D10OutputDuplicator *duplicator = new D3D10OutputDuplicator;

	push	28					; 0000001cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	cmp	DWORD PTR $T2[ebp], 0
	je	SHORT $LN4@CreateOutp
	mov	ecx, DWORD PTR $T2[ebp]
	call	??0D3D10OutputDuplicator@@QAE@XZ
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN5@CreateOutp
$LN4@CreateOutp:
	mov	DWORD PTR tv69[ebp], 0
$LN5@CreateOutp:
	mov	eax, DWORD PTR tv69[ebp]
	mov	DWORD PTR _duplicator$[ebp], eax

; 514  :     if(duplicator->Init(outputID))

	mov	ecx, DWORD PTR _outputID$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _duplicator$[ebp]
	call	?Init@D3D10OutputDuplicator@@QAE_NI@Z	; D3D10OutputDuplicator::Init
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN1@CreateOutp

; 515  :         return duplicator;

	mov	eax, DWORD PTR _duplicator$[ebp]
	jmp	SHORT $LN2@CreateOutp
$LN1@CreateOutp:

; 516  : 
; 517  :     delete duplicator;

	mov	eax, DWORD PTR _duplicator$[ebp]
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR $T3[ebp], ecx
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN6@CreateOutp
	push	1
	mov	edx, DWORD PTR $T3[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR $T3[ebp]
	mov	edx, DWORD PTR [eax]
	call	edx
	mov	DWORD PTR tv89[ebp], eax
	jmp	SHORT $LN7@CreateOutp
$LN6@CreateOutp:
	mov	DWORD PTR tv89[ebp], 0
$LN7@CreateOutp:

; 518  :     return NULL;

	xor	eax, eax
$LN2@CreateOutp:

; 519  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?CreateOutputDuplicator@D3D10System@@UAEPAVOutputDuplicator@@I@Z ENDP ; D3D10System::CreateOutputDuplicator
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0D3D10OutputDuplicator@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0D3D10OutputDuplicator@@QAE@XZ PROC			; D3D10OutputDuplicator::D3D10OutputDuplicator, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0OutputDuplicator@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7D3D10OutputDuplicator@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0D3D10OutputDuplicator@@QAE@XZ ENDP			; D3D10OutputDuplicator::D3D10OutputDuplicator
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\d3d10system.cpp
;	COMDAT ?CreateVertexShaderFromBlob@D3D10System@@UAEPAVShader@@ABV?$vector@DV?$allocator@D@std@@@std@@PB_W1@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_blob$ = 8						; size = 4
_lpShader$ = 12						; size = 4
_lpFileName$ = 16					; size = 4
?CreateVertexShaderFromBlob@D3D10System@@UAEPAVShader@@ABV?$vector@DV?$allocator@D@std@@@std@@PB_W1@Z PROC ; D3D10System::CreateVertexShaderFromBlob, COMDAT
; _this$ = ecx

; 525  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 526  :     return D3D10VertexShader::CreateVertexShaderFromBlob(blob, lpShader, lpFileName);

	mov	eax, DWORD PTR _lpFileName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpShader$[ebp]
	push	ecx
	mov	edx, DWORD PTR _blob$[ebp]
	push	edx
	call	?CreateVertexShaderFromBlob@D3D10VertexShader@@CAPAVShader@@ABV?$vector@DV?$allocator@D@std@@@std@@PB_W1@Z ; D3D10VertexShader::CreateVertexShaderFromBlob
	add	esp, 12					; 0000000cH

; 527  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?CreateVertexShaderFromBlob@D3D10System@@UAEPAVShader@@ABV?$vector@DV?$allocator@D@std@@@std@@PB_W1@Z ENDP ; D3D10System::CreateVertexShaderFromBlob
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\d3d10system.cpp
;	COMDAT ?CreatePixelShaderFromBlob@D3D10System@@UAEPAVShader@@ABV?$vector@DV?$allocator@D@std@@@std@@PB_W1@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_blob$ = 8						; size = 4
_lpShader$ = 12						; size = 4
_lpFileName$ = 16					; size = 4
?CreatePixelShaderFromBlob@D3D10System@@UAEPAVShader@@ABV?$vector@DV?$allocator@D@std@@@std@@PB_W1@Z PROC ; D3D10System::CreatePixelShaderFromBlob, COMDAT
; _this$ = ecx

; 530  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 531  :     return D3D10PixelShader::CreatePixelShaderFromBlob(blob, lpShader, lpFileName);

	mov	eax, DWORD PTR _lpFileName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpShader$[ebp]
	push	ecx
	mov	edx, DWORD PTR _blob$[ebp]
	push	edx
	call	?CreatePixelShaderFromBlob@D3D10PixelShader@@CAPAVShader@@ABV?$vector@DV?$allocator@D@std@@@std@@PB_W1@Z ; D3D10PixelShader::CreatePixelShaderFromBlob
	add	esp, 12					; 0000000cH

; 532  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?CreatePixelShaderFromBlob@D3D10System@@UAEPAVShader@@ABV?$vector@DV?$allocator@D@std@@@std@@PB_W1@Z ENDP ; D3D10System::CreatePixelShaderFromBlob
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\d3d10system.cpp
;	COMDAT ?CreateVertexShader@D3D10System@@UAEPAVShader@@PB_W0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lpShader$ = 8						; size = 4
_lpFileName$ = 12					; size = 4
?CreateVertexShader@D3D10System@@UAEPAVShader@@PB_W0@Z PROC ; D3D10System::CreateVertexShader, COMDAT
; _this$ = ecx

; 535  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 536  :     return D3D10VertexShader::CreateVertexShader(lpShader, lpFileName);

	mov	eax, DWORD PTR _lpFileName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpShader$[ebp]
	push	ecx
	call	?CreateVertexShader@D3D10VertexShader@@CAPAVShader@@PB_W0@Z ; D3D10VertexShader::CreateVertexShader
	add	esp, 8

; 537  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?CreateVertexShader@D3D10System@@UAEPAVShader@@PB_W0@Z ENDP ; D3D10System::CreateVertexShader
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\d3d10system.cpp
;	COMDAT ?CreatePixelShader@D3D10System@@UAEPAVShader@@PB_W0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lpShader$ = 8						; size = 4
_lpFileName$ = 12					; size = 4
?CreatePixelShader@D3D10System@@UAEPAVShader@@PB_W0@Z PROC ; D3D10System::CreatePixelShader, COMDAT
; _this$ = ecx

; 540  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 541  :     return D3D10PixelShader::CreatePixelShader(lpShader, lpFileName);

	mov	eax, DWORD PTR _lpFileName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpShader$[ebp]
	push	ecx
	call	?CreatePixelShader@D3D10PixelShader@@CAPAVShader@@PB_W0@Z ; D3D10PixelShader::CreatePixelShader
	add	esp, 8

; 542  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?CreatePixelShader@D3D10System@@UAEPAVShader@@PB_W0@Z ENDP ; D3D10System::CreatePixelShader
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\d3d10system.cpp
;	COMDAT ?CreateVertexShaderBlob@D3D10System@@EAEXAAV?$vector@DV?$allocator@D@std@@@std@@PB_W1@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_blob$ = 8						; size = 4
_lpShader$ = 12						; size = 4
_lpFileName$ = 16					; size = 4
?CreateVertexShaderBlob@D3D10System@@EAEXAAV?$vector@DV?$allocator@D@std@@@std@@PB_W1@Z PROC ; D3D10System::CreateVertexShaderBlob, COMDAT
; _this$ = ecx

; 545  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 546  :     D3D10VertexShader::CreateVertexShaderBlob(blob, lpShader, lpFileName);

	mov	eax, DWORD PTR _lpFileName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpShader$[ebp]
	push	ecx
	mov	edx, DWORD PTR _blob$[ebp]
	push	edx
	call	?CreateVertexShaderBlob@D3D10VertexShader@@CAXAAV?$vector@DV?$allocator@D@std@@@std@@PB_W1@Z ; D3D10VertexShader::CreateVertexShaderBlob
	add	esp, 12					; 0000000cH

; 547  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?CreateVertexShaderBlob@D3D10System@@EAEXAAV?$vector@DV?$allocator@D@std@@@std@@PB_W1@Z ENDP ; D3D10System::CreateVertexShaderBlob
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\d3d10system.cpp
;	COMDAT ?CreatePixelShaderBlob@D3D10System@@EAEXAAV?$vector@DV?$allocator@D@std@@@std@@PB_W1@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_blob$ = 8						; size = 4
_lpShader$ = 12						; size = 4
_lpFileName$ = 16					; size = 4
?CreatePixelShaderBlob@D3D10System@@EAEXAAV?$vector@DV?$allocator@D@std@@@std@@PB_W1@Z PROC ; D3D10System::CreatePixelShaderBlob, COMDAT
; _this$ = ecx

; 550  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 551  :     D3D10PixelShader::CreatePixelShaderBlob(blob, lpShader, lpFileName);

	mov	eax, DWORD PTR _lpFileName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpShader$[ebp]
	push	ecx
	mov	edx, DWORD PTR _blob$[ebp]
	push	edx
	call	?CreatePixelShaderBlob@D3D10PixelShader@@CAXAAV?$vector@DV?$allocator@D@std@@@std@@PB_W1@Z ; D3D10PixelShader::CreatePixelShaderBlob
	add	esp, 12					; 0000000cH

; 552  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?CreatePixelShaderBlob@D3D10System@@EAEXAAV?$vector@DV?$allocator@D@std@@@std@@PB_W1@Z ENDP ; D3D10System::CreatePixelShaderBlob
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\d3d10system.cpp
;	COMDAT ?CreateVertexBuffer@D3D10System@@UAEPAVVertexBuffer@@PAUVBData@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_vbData$ = 8						; size = 4
_bStatic$ = 12						; size = 4
?CreateVertexBuffer@D3D10System@@UAEPAVVertexBuffer@@PAUVBData@@H@Z PROC ; D3D10System::CreateVertexBuffer, COMDAT
; _this$ = ecx

; 558  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 559  :     return D3D10VertexBuffer::CreateVertexBuffer(vbData, bStatic);

	mov	eax, DWORD PTR _bStatic$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vbData$[ebp]
	push	ecx
	call	?CreateVertexBuffer@D3D10VertexBuffer@@CAPAVVertexBuffer@@PAUVBData@@H@Z ; D3D10VertexBuffer::CreateVertexBuffer
	add	esp, 8

; 560  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?CreateVertexBuffer@D3D10System@@UAEPAVVertexBuffer@@PAUVBData@@H@Z ENDP ; D3D10System::CreateVertexBuffer
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\d3d10system.cpp
;	COMDAT ?LoadVertexBuffer@D3D10System@@UAEXPAVVertexBuffer@@@Z
_TEXT	SEGMENT
_offsets$1 = -36					; size = 8
_strides$2 = -28					; size = 8
_buffers$3 = -20					; size = 8
_nBuffersToClear$4 = -12				; size = 4
_d3dVB$5 = -8						; size = 4
_this$ = -4						; size = 4
_vb$ = 8						; size = 4
?LoadVertexBuffer@D3D10System@@UAEXPAVVertexBuffer@@@Z PROC ; D3D10System::LoadVertexBuffer, COMDAT
; _this$ = ecx

; 566  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 567  :     if(vb != curVertexBuffer)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _vb$[ebp]
	cmp	ecx, DWORD PTR [eax+168]
	je	$LN5@LoadVertex

; 568  :     {
; 569  :         D3D10VertexBuffer *d3dVB = static_cast<D3D10VertexBuffer*>(vb);

	mov	edx, DWORD PTR _vb$[ebp]
	mov	DWORD PTR _d3dVB$5[ebp], edx

; 570  :         if(curVertexShader)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+172], 0
	je	$LN3@LoadVertex

; 571  :         {
; 572  :             List<ID3D10Buffer*> buffers;

	lea	ecx, DWORD PTR _buffers$3[ebp]
	call	??0?$List@PAUID3D10Buffer@@@@QAE@XZ	; List<ID3D10Buffer *>::List<ID3D10Buffer *>

; 573  :             List<UINT> strides;

	lea	ecx, DWORD PTR _strides$2[ebp]
	call	??0?$List@I@@QAE@XZ			; List<unsigned int>::List<unsigned int>

; 574  :             List<UINT> offsets;

	lea	ecx, DWORD PTR _offsets$1[ebp]
	call	??0?$List@I@@QAE@XZ			; List<unsigned int>::List<unsigned int>

; 575  : 
; 576  :             if(d3dVB)

	cmp	DWORD PTR _d3dVB$5[ebp], 0
	je	SHORT $LN2@LoadVertex

; 577  :                 d3dVB->MakeBufferList(curVertexShader, buffers, strides);

	lea	ecx, DWORD PTR _strides$2[ebp]
	push	ecx
	lea	edx, DWORD PTR _buffers$3[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+172]
	push	ecx
	mov	ecx, DWORD PTR _d3dVB$5[ebp]
	call	?MakeBufferList@D3D10VertexBuffer@@ABEXPAVD3D10VertexShader@@AAV?$List@PAUID3D10Buffer@@@@AAV?$List@I@@@Z ; D3D10VertexBuffer::MakeBufferList

; 578  :             else

	jmp	SHORT $LN1@LoadVertex
$LN2@LoadVertex:

; 579  :             {
; 580  :                 UINT nBuffersToClear = curVertexShader->NumBuffersExpected();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+172]
	call	?NumBuffersExpected@D3D10VertexShader@@ABEIXZ ; D3D10VertexShader::NumBuffersExpected
	mov	DWORD PTR _nBuffersToClear$4[ebp], eax

; 581  :                 buffers.SetSize(nBuffersToClear);

	mov	eax, DWORD PTR _nBuffersToClear$4[ebp]
	push	eax
	lea	ecx, DWORD PTR _buffers$3[ebp]
	call	?SetSize@?$List@PAUID3D10Buffer@@@@QAEHI@Z ; List<ID3D10Buffer *>::SetSize

; 582  :                 strides.SetSize(nBuffersToClear);

	mov	ecx, DWORD PTR _nBuffersToClear$4[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strides$2[ebp]
	call	?SetSize@?$List@I@@QAEHI@Z		; List<unsigned int>::SetSize
$LN1@LoadVertex:

; 583  :             }
; 584  : 
; 585  :             offsets.SetSize(buffers.Num());

	lea	ecx, DWORD PTR _buffers$3[ebp]
	call	?Num@?$List@PAUID3D10Buffer@@@@QBEIXZ	; List<ID3D10Buffer *>::Num
	push	eax
	lea	ecx, DWORD PTR _offsets$1[ebp]
	call	?SetSize@?$List@I@@QAEHI@Z		; List<unsigned int>::SetSize

; 586  :             d3d->IASetVertexBuffers(0, buffers.Num(), buffers.Array(), strides.Array(), offsets.Array());

	lea	ecx, DWORD PTR _offsets$1[ebp]
	call	?Array@?$List@I@@QBEPAIXZ		; List<unsigned int>::Array
	push	eax
	lea	ecx, DWORD PTR _strides$2[ebp]
	call	?Array@?$List@I@@QBEPAIXZ		; List<unsigned int>::Array
	push	eax
	lea	ecx, DWORD PTR _buffers$3[ebp]
	call	?Array@?$List@PAUID3D10Buffer@@@@QBEPAPAUID3D10Buffer@@XZ ; List<ID3D10Buffer *>::Array
	push	eax
	lea	ecx, DWORD PTR _buffers$3[ebp]
	call	?Num@?$List@PAUID3D10Buffer@@@@QBEIXZ	; List<ID3D10Buffer *>::Num
	push	eax
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+48]
	call	ecx

; 587  :         }

	lea	ecx, DWORD PTR _offsets$1[ebp]
	call	??1?$List@I@@QAE@XZ			; List<unsigned int>::~List<unsigned int>
	lea	ecx, DWORD PTR _strides$2[ebp]
	call	??1?$List@I@@QAE@XZ			; List<unsigned int>::~List<unsigned int>
	lea	ecx, DWORD PTR _buffers$3[ebp]
	call	??1?$List@PAUID3D10Buffer@@@@QAE@XZ	; List<ID3D10Buffer *>::~List<ID3D10Buffer *>
$LN3@LoadVertex:

; 588  : 
; 589  :         curVertexBuffer = d3dVB;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _d3dVB$5[ebp]
	mov	DWORD PTR [edx+168], eax
$LN5@LoadVertex:

; 590  :     }
; 591  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?LoadVertexBuffer@D3D10System@@UAEXPAVVertexBuffer@@@Z ENDP ; D3D10System::LoadVertexBuffer
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\d3d10system.cpp
;	COMDAT ?LoadTexture@D3D10System@@UAEXPAVTexture@@I@Z
_TEXT	SEGMENT
_lpNull$1 = -12						; size = 4
_d3dTex$2 = -8						; size = 4
_this$ = -4						; size = 4
_texture$ = 8						; size = 4
_idTexture$ = 12					; size = 4
?LoadTexture@D3D10System@@UAEXPAVTexture@@I@Z PROC	; D3D10System::LoadTexture, COMDAT
; _this$ = ecx

; 594  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 595  :     if(curTextures[idTexture] != texture)

	mov	eax, DWORD PTR _idTexture$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+104]
	cmp	edx, DWORD PTR _texture$[ebp]
	je	SHORT $LN4@LoadTextur

; 596  :     {
; 597  :         D3D10Texture *d3dTex = static_cast<D3D10Texture*>(texture);

	mov	eax, DWORD PTR _texture$[ebp]
	mov	DWORD PTR _d3dTex$2[ebp], eax

; 598  :         if(d3dTex)

	cmp	DWORD PTR _d3dTex$2[ebp], 0
	je	SHORT $LN2@LoadTextur

; 599  :             d3d->PSSetShaderResources(idTexture, 1, &d3dTex->resource);

	mov	ecx, DWORD PTR _d3dTex$2[ebp]
	add	ecx, 8
	push	ecx
	push	1
	mov	edx, DWORD PTR _idTexture$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+16]
	call	edx

; 600  :         else

	jmp	SHORT $LN1@LoadTextur
$LN2@LoadTextur:

; 601  :         {
; 602  :             LPVOID lpNull = NULL;

	mov	DWORD PTR _lpNull$1[ebp], 0

; 603  :             d3d->PSSetShaderResources(idTexture, 1, (ID3D10ShaderResourceView**)&lpNull);

	lea	eax, DWORD PTR _lpNull$1[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _idTexture$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+16]
	call	ecx
$LN1@LoadTextur:

; 604  :         }
; 605  : 
; 606  :         curTextures[idTexture] = d3dTex;

	mov	edx, DWORD PTR _idTexture$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _d3dTex$2[ebp]
	mov	DWORD PTR [eax+edx*4+104], ecx
$LN4@LoadTextur:

; 607  :     }
; 608  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?LoadTexture@D3D10System@@UAEXPAVTexture@@I@Z ENDP	; D3D10System::LoadTexture
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\d3d10system.cpp
;	COMDAT ?LoadSamplerState@D3D10System@@UAEXPAVSamplerState@@I@Z
_TEXT	SEGMENT
_lpNull$1 = -12						; size = 4
_d3dSampler$2 = -8					; size = 4
_this$ = -4						; size = 4
_sampler$ = 8						; size = 4
_idSampler$ = 12					; size = 4
?LoadSamplerState@D3D10System@@UAEXPAVSamplerState@@I@Z PROC ; D3D10System::LoadSamplerState, COMDAT
; _this$ = ecx

; 611  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 612  :     if(curSamplers[idSampler] != sampler)

	mov	eax, DWORD PTR _idSampler$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+136]
	cmp	edx, DWORD PTR _sampler$[ebp]
	je	SHORT $LN4@LoadSample

; 613  :     {
; 614  :         D3D10SamplerState *d3dSampler = static_cast<D3D10SamplerState*>(sampler);

	mov	eax, DWORD PTR _sampler$[ebp]
	mov	DWORD PTR _d3dSampler$2[ebp], eax

; 615  :         if(d3dSampler)

	cmp	DWORD PTR _d3dSampler$2[ebp], 0
	je	SHORT $LN2@LoadSample

; 616  :             d3d->PSSetSamplers(idSampler, 1, &d3dSampler->state);

	mov	ecx, DWORD PTR _d3dSampler$2[ebp]
	add	ecx, 64					; 00000040H
	push	ecx
	push	1
	mov	edx, DWORD PTR _idSampler$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+24]
	call	edx

; 617  :         else

	jmp	SHORT $LN1@LoadSample
$LN2@LoadSample:

; 618  :         {
; 619  :             LPVOID lpNull = NULL;

	mov	DWORD PTR _lpNull$1[ebp], 0

; 620  :             d3d->PSSetSamplers(idSampler, 1, (ID3D10SamplerState**)&lpNull);

	lea	eax, DWORD PTR _lpNull$1[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _idSampler$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+24]
	call	ecx
$LN1@LoadSample:

; 621  :         }
; 622  :         curSamplers[idSampler] = d3dSampler;

	mov	edx, DWORD PTR _idSampler$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _d3dSampler$2[ebp]
	mov	DWORD PTR [eax+edx*4+136], ecx
$LN4@LoadSample:

; 623  :     }
; 624  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?LoadSamplerState@D3D10System@@UAEXPAVSamplerState@@I@Z ENDP ; D3D10System::LoadSamplerState
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\d3d10system.cpp
;	COMDAT ?LoadVertexShader@D3D10System@@UAEXPAVShader@@@Z
_TEXT	SEGMENT
_lpNULL$1 = -16						; size = 4
_lastVertexBuffer$2 = -12				; size = 4
_shader$3 = -8						; size = 4
_this$ = -4						; size = 4
_vShader$ = 8						; size = 4
?LoadVertexShader@D3D10System@@UAEXPAVShader@@@Z PROC	; D3D10System::LoadVertexShader, COMDAT
; _this$ = ecx

; 627  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 628  :     if(curVertexShader != vShader)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+172]
	cmp	ecx, DWORD PTR _vShader$[ebp]
	je	$LN6@LoadVertex

; 629  :     {
; 630  :         if(vShader)

	cmp	DWORD PTR _vShader$[ebp], 0
	je	$LN4@LoadVertex

; 631  :         {
; 632  :             D3D10VertexBuffer *lastVertexBuffer = curVertexBuffer;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+168]
	mov	DWORD PTR _lastVertexBuffer$2[ebp], eax

; 633  :             if(curVertexBuffer)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+168], 0
	je	SHORT $LN3@LoadVertex

; 634  :                 LoadVertexBuffer(NULL);

	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+68]
	call	edx
$LN3@LoadVertex:

; 635  : 
; 636  :             D3D10VertexShader *shader = static_cast<D3D10VertexShader*>(vShader);

	mov	eax, DWORD PTR _vShader$[ebp]
	mov	DWORD PTR _shader$3[ebp], eax

; 637  : 
; 638  :             d3d->VSSetShader(shader->vertexShader);

	mov	ecx, DWORD PTR _shader$3[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+28]
	call	edx

; 639  :             d3d->IASetInputLayout(shader->inputLayout);

	mov	eax, DWORD PTR _shader$3[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+44]
	call	ecx

; 640  :             d3d->VSSetConstantBuffers(0, 1, &shader->constantBuffer);

	mov	edx, DWORD PTR _shader$3[ebp]
	add	edx, 24					; 00000018H
	push	edx
	push	1
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+12]
	call	edx

; 641  : 
; 642  :             if(lastVertexBuffer)

	cmp	DWORD PTR _lastVertexBuffer$2[ebp], 0
	je	SHORT $LN2@LoadVertex

; 643  :                 LoadVertexBuffer(lastVertexBuffer);

	mov	eax, DWORD PTR _lastVertexBuffer$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+68]
	call	eax
$LN2@LoadVertex:

; 644  :         }
; 645  :         else

	jmp	SHORT $LN1@LoadVertex
$LN4@LoadVertex:

; 646  :         {
; 647  :             LPVOID lpNULL = NULL;

	mov	DWORD PTR _lpNULL$1[ebp], 0

; 648  : 
; 649  :             d3d->VSSetShader(NULL);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+28]
	call	eax

; 650  :             d3d->VSSetConstantBuffers(0, 1, (ID3D10Buffer**)&lpNULL);

	lea	ecx, DWORD PTR _lpNULL$1[ebp]
	push	ecx
	push	1
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+12]
	call	ecx
$LN1@LoadVertex:

; 651  :         }
; 652  : 
; 653  :         curVertexShader = static_cast<D3D10VertexShader*>(vShader);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _vShader$[ebp]
	mov	DWORD PTR [edx+172], eax
$LN6@LoadVertex:

; 654  :     }
; 655  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?LoadVertexShader@D3D10System@@UAEXPAVShader@@@Z ENDP	; D3D10System::LoadVertexShader
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\d3d10system.cpp
;	COMDAT ?LoadPixelShader@D3D10System@@UAEXPAVShader@@@Z
_TEXT	SEGMENT
_lpNULL$1 = -56						; size = 4
_i$2 = -52						; size = 4
_shader$3 = -48						; size = 4
_i$4 = -44						; size = 4
_this$ = -40						; size = 4
_states$5 = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
_pShader$ = 8						; size = 4
?LoadPixelShader@D3D10System@@UAEXPAVShader@@@Z PROC	; D3D10System::LoadPixelShader, COMDAT
; _this$ = ecx

; 658  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 659  :     if(curPixelShader != pShader)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+176]
	cmp	ecx, DWORD PTR _pShader$[ebp]
	je	$LN10@LoadPixelS

; 660  :     {
; 661  :         if(pShader)

	cmp	DWORD PTR _pShader$[ebp], 0
	je	$LN8@LoadPixelS

; 662  :         {
; 663  :             D3D10PixelShader *shader = static_cast<D3D10PixelShader*>(pShader);

	mov	edx, DWORD PTR _pShader$[ebp]
	mov	DWORD PTR _shader$3[ebp], edx

; 664  : 
; 665  :             d3d->PSSetShader(shader->pixelShader);

	mov	eax, DWORD PTR _shader$3[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+20]
	call	ecx

; 666  :             d3d->PSSetConstantBuffers(0, 1, &shader->constantBuffer);

	mov	edx, DWORD PTR _shader$3[ebp]
	add	edx, 24					; 00000018H
	push	edx
	push	1
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+40]
	call	edx

; 667  : 
; 668  :             for(UINT i=0; i<shader->Samplers.Num(); i++)

	mov	DWORD PTR _i$4[ebp], 0
	jmp	SHORT $LN7@LoadPixelS
$LN6@LoadPixelS:
	mov	eax, DWORD PTR _i$4[ebp]
	add	eax, 1
	mov	DWORD PTR _i$4[ebp], eax
$LN7@LoadPixelS:
	mov	ecx, DWORD PTR _shader$3[ebp]
	add	ecx, 16					; 00000010H
	call	?Num@?$List@UShaderSampler@@@@QBEIXZ	; List<ShaderSampler>::Num
	cmp	DWORD PTR _i$4[ebp], eax
	jae	SHORT $LN5@LoadPixelS

; 669  :                 LoadSamplerState(shader->Samplers[i].sampler, i);

	mov	ecx, DWORD PTR _i$4[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$4[ebp]
	push	edx
	mov	ecx, DWORD PTR _shader$3[ebp]
	add	ecx, 16					; 00000010H
	call	??A?$List@UShaderSampler@@@@QAEAAUShaderSampler@@I@Z ; List<ShaderSampler>::operator[]
	mov	eax, DWORD PTR [eax+8]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+76]
	call	eax
	jmp	SHORT $LN6@LoadPixelS
$LN5@LoadPixelS:

; 670  :         }
; 671  :         else

	jmp	$LN4@LoadPixelS
$LN8@LoadPixelS:

; 672  :         {
; 673  :             LPVOID lpNULL = NULL;

	mov	DWORD PTR _lpNULL$1[ebp], 0

; 674  : 
; 675  :             d3d->PSSetShader(NULL);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+20]
	call	eax

; 676  :             d3d->PSSetConstantBuffers(0, 1, (ID3D10Buffer**)&lpNULL);

	lea	ecx, DWORD PTR _lpNULL$1[ebp]
	push	ecx
	push	1
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+40]
	call	ecx

; 677  : 
; 678  :             for(UINT i=0; i<8; i++)

	mov	DWORD PTR _i$2[ebp], 0
	jmp	SHORT $LN3@LoadPixelS
$LN2@LoadPixelS:
	mov	edx, DWORD PTR _i$2[ebp]
	add	edx, 1
	mov	DWORD PTR _i$2[ebp], edx
$LN3@LoadPixelS:
	cmp	DWORD PTR _i$2[ebp], 8
	jae	SHORT $LN1@LoadPixelS

; 679  :                 curSamplers[i] = NULL;

	mov	eax, DWORD PTR _i$2[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax*4+136], 0
	jmp	SHORT $LN2@LoadPixelS
$LN1@LoadPixelS:

; 680  : 
; 681  :             ID3D10SamplerState *states[8];
; 682  :             zero(states, sizeof(states));

	push	32					; 00000020H
	lea	edx, DWORD PTR _states$5[ebp]
	push	edx
	call	?zero@@YGXPAXI@Z			; zero

; 683  :             d3d->PSSetSamplers(0, 8, states);

	lea	eax, DWORD PTR _states$5[ebp]
	push	eax
	push	8
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+24]
	call	eax
$LN4@LoadPixelS:

; 684  :         }
; 685  : 
; 686  :         curPixelShader = static_cast<D3D10PixelShader*>(pShader);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _pShader$[ebp]
	mov	DWORD PTR [ecx+176], edx
$LN10@LoadPixelS:

; 687  :     }
; 688  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
?LoadPixelShader@D3D10System@@UAEXPAVShader@@@Z ENDP	; D3D10System::LoadPixelShader
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\d3d10system.cpp
;	COMDAT ?GetCurrentPixelShader@D3D10System@@UAEPAVShader@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCurrentPixelShader@D3D10System@@UAEPAVShader@@XZ PROC ; D3D10System::GetCurrentPixelShader, COMDAT
; _this$ = ecx

; 691  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 692  :     return curPixelShader;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+176]

; 693  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCurrentPixelShader@D3D10System@@UAEPAVShader@@XZ ENDP ; D3D10System::GetCurrentPixelShader
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\d3d10system.cpp
;	COMDAT ?GetCurrentVertexShader@D3D10System@@UAEPAVShader@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCurrentVertexShader@D3D10System@@UAEPAVShader@@XZ PROC ; D3D10System::GetCurrentVertexShader, COMDAT
; _this$ = ecx

; 696  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 697  :     return curVertexShader;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+172]

; 698  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCurrentVertexShader@D3D10System@@UAEPAVShader@@XZ ENDP ; D3D10System::GetCurrentVertexShader
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\d3d10system.cpp
;	COMDAT ?SetRenderTarget@D3D10System@@UAEXPAVTexture@@@Z
_TEXT	SEGMENT
_view$1 = -8						; size = 4
_this$ = -4						; size = 4
_texture$ = 8						; size = 4
?SetRenderTarget@D3D10System@@UAEXPAVTexture@@@Z PROC	; D3D10System::SetRenderTarget, COMDAT
; _this$ = ecx

; 701  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 702  :     if(curRenderTarget != texture)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	cmp	ecx, DWORD PTR _texture$[ebp]
	je	SHORT $LN5@SetRenderT

; 703  :     {
; 704  :         if(texture)

	cmp	DWORD PTR _texture$[ebp], 0
	je	SHORT $LN3@SetRenderT

; 705  :         {
; 706  :             ID3D10RenderTargetView *view = static_cast<D3D10Texture*>(texture)->renderTarget;

	mov	edx, DWORD PTR _texture$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _view$1[ebp], eax

; 707  :             if(!view)

	cmp	DWORD PTR _view$1[ebp], 0
	jne	SHORT $LN2@SetRenderT

; 708  :             {
; 709  :                 AppWarning(TEXT("tried to set a texture that wasn't a render target as a render target"));

	push	OFFSET $SG4294909708
	call	DWORD PTR __imp_?AppWarning@@YAXPB_WZZ
	add	esp, 4

; 710  :                 return;

	jmp	SHORT $LN5@SetRenderT
$LN2@SetRenderT:

; 711  :             }
; 712  : 
; 713  :             d3d->OMSetRenderTargets(1, &view, NULL);

	push	0
	lea	ecx, DWORD PTR _view$1[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+96]
	call	ecx

; 714  :         }
; 715  :         else

	jmp	SHORT $LN1@SetRenderT
$LN3@SetRenderT:

; 716  :             d3d->OMSetRenderTargets(1, &swapRenderView, NULL);

	push	0
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 80					; 00000050H
	push	edx
	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+96]
	call	edx
$LN1@SetRenderT:

; 717  : 
; 718  :         curRenderTarget = static_cast<D3D10Texture*>(texture);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _texture$[ebp]
	mov	DWORD PTR [eax+100], ecx
$LN5@SetRenderT:

; 719  :     }
; 720  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetRenderTarget@D3D10System@@UAEXPAVTexture@@@Z ENDP	; D3D10System::SetRenderTarget
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\d3d10system.cpp
;	COMDAT ?Draw@D3D10System@@UAEXW4GSDrawMode@@KK@Z
_TEXT	SEGMENT
_newTopology$ = -8					; size = 4
_this$ = -4						; size = 4
_drawMode$ = 8						; size = 4
_startVert$ = 12					; size = 4
_nVerts$ = 16						; size = 4
?Draw@D3D10System@@UAEXW4GSDrawMode@@KK@Z PROC		; D3D10System::Draw, COMDAT
; _this$ = ecx

; 725  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 726  :     if(!curVertexBuffer)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+168], 0
	jne	SHORT $LN5@Draw

; 727  :     {
; 728  :         AppWarning(TEXT("Tried to call draw without setting a vertex buffer"));

	push	OFFSET $SG4294909707
	call	DWORD PTR __imp_?AppWarning@@YAXPB_WZZ
	add	esp, 4

; 729  :         return;

	jmp	$LN6@Draw
$LN5@Draw:

; 730  :     }
; 731  : 
; 732  :     if(!curVertexShader)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+172], 0
	jne	SHORT $LN4@Draw

; 733  :     {
; 734  :         AppWarning(TEXT("Tried to call draw without setting a vertex shader"));

	push	OFFSET $SG4294909706
	call	DWORD PTR __imp_?AppWarning@@YAXPB_WZZ
	add	esp, 4

; 735  :         return;

	jmp	$LN6@Draw
$LN4@Draw:

; 736  :     }
; 737  : 
; 738  :     if(!curPixelShader)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+176], 0
	jne	SHORT $LN3@Draw

; 739  :     {
; 740  :         AppWarning(TEXT("Tried to call draw without setting a pixel shader"));

	push	OFFSET $SG4294909705
	call	DWORD PTR __imp_?AppWarning@@YAXPB_WZZ
	add	esp, 4

; 741  :         return;

	jmp	$LN6@Draw
$LN3@Draw:

; 742  :     }
; 743  : 
; 744  :     curVertexShader->SetMatrix(curVertexShader->GetViewProj(), curViewProjMatrix);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 340				; 00000154H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+172]
	call	DWORD PTR __imp_?GetViewProj@Shader@@IBEPAXXZ
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+172]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+172]
	mov	eax, DWORD PTR [edx+36]
	call	eax

; 745  : 
; 746  :     curVertexShader->UpdateParams();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+172]
	call	?UpdateParams@D3D10Shader@@IAEXXZ	; D3D10Shader::UpdateParams

; 747  :     curPixelShader->UpdateParams();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+176]
	call	?UpdateParams@D3D10Shader@@IAEXXZ	; D3D10Shader::UpdateParams

; 748  : 
; 749  :     D3D10_PRIMITIVE_TOPOLOGY newTopology = topologies[(int)drawMode];

	mov	eax, DWORD PTR _drawMode$[ebp]
	mov	ecx, DWORD PTR _topologies[eax*4]
	mov	DWORD PTR _newTopology$[ebp], ecx

; 750  :     if(newTopology != curTopology)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _newTopology$[ebp]
	cmp	eax, DWORD PTR [edx+180]
	je	SHORT $LN2@Draw

; 751  :     {
; 752  :         d3d->IASetPrimitiveTopology(newTopology);

	mov	ecx, DWORD PTR _newTopology$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+72]
	call	ecx

; 753  :         curTopology = newTopology;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _newTopology$[ebp]
	mov	DWORD PTR [edx+180], eax
$LN2@Draw:

; 754  :     }
; 755  : 
; 756  :     if(nVerts == 0)

	cmp	DWORD PTR _nVerts$[ebp], 0
	jne	SHORT $LN1@Draw

; 757  :         nVerts = static_cast<D3D10VertexBuffer*>(curVertexBuffer)->numVerts;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+168]
	mov	eax, DWORD PTR [edx+56]
	mov	DWORD PTR _nVerts$[ebp], eax
$LN1@Draw:

; 758  : 
; 759  :     d3d->Draw(nVerts, startVert);

	mov	ecx, DWORD PTR _startVert$[ebp]
	push	ecx
	mov	edx, DWORD PTR _nVerts$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+36]
	call	edx
$LN6@Draw:

; 760  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?Draw@D3D10System@@UAEXW4GSDrawMode@@KK@Z ENDP		; D3D10System::Draw
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\d3d10system.cpp
;	COMDAT ?EnableBlending@D3D10System@@UAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_bEnable$ = 8						; size = 4
?EnableBlending@D3D10System@@UAEXH@Z PROC		; D3D10System::EnableBlending, COMDAT
; _this$ = ecx

; 769  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 770  :     if(bBlendingEnabled != bEnable)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+200]
	cmp	ecx, DWORD PTR _bEnable$[ebp]
	je	SHORT $LN4@EnableBlen

; 771  :     {
; 772  :         if(bBlendingEnabled = bEnable)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _bEnable$[ebp]
	mov	DWORD PTR [edx+200], eax
	cmp	DWORD PTR _bEnable$[ebp], 0
	je	SHORT $LN2@EnableBlen

; 773  :             d3d->OMSetBlendState(curBlendState, curBlendFactor, 0xFFFFFFFF);

	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 404				; 00000194H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+192]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+100]
	call	eax

; 774  :         else

	jmp	SHORT $LN4@EnableBlen
$LN2@EnableBlen:

; 775  :             d3d->OMSetBlendState(disabledBlend, curBlendFactor, 0xFFFFFFFF);

	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 404				; 00000194H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+196]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN4@EnableBlen:

; 776  :     }
; 777  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?EnableBlending@D3D10System@@UAEXH@Z ENDP		; D3D10System::EnableBlending
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\d3d10system.cpp
;	COMDAT ?BlendFunction@D3D10System@@UAEXW4GSBlendType@@0M@Z
_TEXT	SEGMENT
tv66 = -100						; size = 4
_i$1 = -96						; size = 4
_savedBlend$ = -92					; size = 4
_blendInfo$2 = -88					; size = 4
_i$3 = -84						; size = 4
_bUseFactor$ = -77					; size = 1
_this$ = -76						; size = 4
_blendDesc$ = -72					; size = 68
__$ArrayPad$ = -4					; size = 4
_srcFactor$ = 8						; size = 4
_destFactor$ = 12					; size = 4
_fFactor$ = 16						; size = 4
?BlendFunction@D3D10System@@UAEXW4GSBlendType@@0M@Z PROC ; D3D10System::BlendFunction, COMDAT
; _this$ = ecx

; 780  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 781  :     bool bUseFactor = (srcFactor >= GS_BLEND_FACTOR || destFactor >= GS_BLEND_FACTOR);

	cmp	DWORD PTR _srcFactor$[ebp], 10		; 0000000aH
	jge	SHORT $LN15@BlendFunct
	cmp	DWORD PTR _destFactor$[ebp], 10		; 0000000aH
	jge	SHORT $LN15@BlendFunct
	mov	DWORD PTR tv66[ebp], 0
	jmp	SHORT $LN16@BlendFunct
$LN15@BlendFunct:
	mov	DWORD PTR tv66[ebp], 1
$LN16@BlendFunct:
	mov	al, BYTE PTR tv66[ebp]
	mov	BYTE PTR _bUseFactor$[ebp], al

; 782  : 
; 783  :     if(bUseFactor)

	movzx	ecx, BYTE PTR _bUseFactor$[ebp]
	test	ecx, ecx
	je	SHORT $LN12@BlendFunct

; 784  :         curBlendFactor[0] = curBlendFactor[1] = curBlendFactor[2] = curBlendFactor[3] = fFactor;

	mov	edx, 4
	imul	eax, edx, 3
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _fFactor$[ebp]
	movss	DWORD PTR [ecx+eax+404], xmm0
	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _fFactor$[ebp]
	movss	DWORD PTR [eax+edx+404], xmm0
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _fFactor$[ebp]
	movss	DWORD PTR [edx+ecx+404], xmm0
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _fFactor$[ebp]
	movss	DWORD PTR [edx+ecx+404], xmm0
$LN12@BlendFunct:

; 785  : 
; 786  :     for(UINT i=0; i<blends.Num(); i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN11@BlendFunct
$LN10@BlendFunct:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN11@BlendFunct:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 184				; 000000b8H
	call	?Num@?$List@USavedBlendState@@@@QBEIXZ	; List<SavedBlendState>::Num
	cmp	DWORD PTR _i$1[ebp], eax
	jae	$LN9@BlendFunct

; 787  :     {
; 788  :         SavedBlendState &blendInfo = blends[i];

	mov	ecx, DWORD PTR _i$1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 184				; 000000b8H
	call	??A?$List@USavedBlendState@@@@QAEAAUSavedBlendState@@I@Z ; List<SavedBlendState>::operator[]
	mov	DWORD PTR _blendInfo$2[ebp], eax

; 789  :         if(blendInfo.srcFactor == srcFactor && blendInfo.destFactor == destFactor)

	mov	edx, DWORD PTR _blendInfo$2[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR _srcFactor$[ebp]
	jne	SHORT $LN8@BlendFunct
	mov	ecx, DWORD PTR _blendInfo$2[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR _destFactor$[ebp]
	jne	SHORT $LN8@BlendFunct

; 790  :         {
; 791  :             if(bUseFactor || curBlendState != blendInfo.blendState)

	movzx	eax, BYTE PTR _bUseFactor$[ebp]
	test	eax, eax
	jne	SHORT $LN6@BlendFunct
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _blendInfo$2[ebp]
	mov	eax, DWORD PTR [ecx+192]
	cmp	eax, DWORD PTR [edx+8]
	je	SHORT $LN7@BlendFunct
$LN6@BlendFunct:

; 792  :             {
; 793  :                 d3d->OMSetBlendState(blendInfo.blendState, curBlendFactor, 0xFFFFFFFF);

	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 404				; 00000194H
	push	ecx
	mov	edx, DWORD PTR _blendInfo$2[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+100]
	call	eax

; 794  :                 curBlendState = blendInfo.blendState;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _blendInfo$2[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+192], eax
$LN7@BlendFunct:

; 795  :             }
; 796  :             return;

	jmp	$LN13@BlendFunct
$LN8@BlendFunct:

; 797  :         }
; 798  :     }

	jmp	$LN10@BlendFunct
$LN9@BlendFunct:

; 799  : 
; 800  :     //blend wasn't found, create a new one and save it for later
; 801  :     D3D10_BLEND_DESC blendDesc;
; 802  :     zero(&blendDesc, sizeof(blendDesc));

	push	68					; 00000044H
	lea	ecx, DWORD PTR _blendDesc$[ebp]
	push	ecx
	call	?zero@@YGXPAXI@Z			; zero

; 803  :     for(int i=0; i<8; i++)

	mov	DWORD PTR _i$3[ebp], 0
	jmp	SHORT $LN5@BlendFunct
$LN4@BlendFunct:
	mov	edx, DWORD PTR _i$3[ebp]
	add	edx, 1
	mov	DWORD PTR _i$3[ebp], edx
$LN5@BlendFunct:
	cmp	DWORD PTR _i$3[ebp], 8
	jge	SHORT $LN3@BlendFunct

; 804  :     {
; 805  :         blendDesc.BlendEnable[i]            = TRUE;

	mov	eax, DWORD PTR _i$3[ebp]
	mov	DWORD PTR _blendDesc$[ebp+eax*4+4], 1

; 806  :         blendDesc.RenderTargetWriteMask[i]  = D3D10_COLOR_WRITE_ENABLE_ALL;

	mov	ecx, DWORD PTR _i$3[ebp]
	mov	BYTE PTR _blendDesc$[ebp+ecx+60], 15	; 0000000fH

; 807  :     }

	jmp	SHORT $LN4@BlendFunct
$LN3@BlendFunct:

; 808  :     blendDesc.BlendOpAlpha              = D3D10_BLEND_OP_ADD;

	mov	DWORD PTR _blendDesc$[ebp+56], 1

; 809  :     blendDesc.BlendOp                   = D3D10_BLEND_OP_ADD;

	mov	DWORD PTR _blendDesc$[ebp+44], 1

; 810  :     blendDesc.SrcBlendAlpha             = D3D10_BLEND_ONE;

	mov	DWORD PTR _blendDesc$[ebp+48], 2

; 811  :     blendDesc.DestBlendAlpha            = D3D10_BLEND_ZERO;

	mov	DWORD PTR _blendDesc$[ebp+52], 1

; 812  :     blendDesc.SrcBlend                  = blendConvert[srcFactor];

	mov	edx, DWORD PTR _srcFactor$[ebp]
	mov	eax, DWORD PTR _blendConvert[edx*4]
	mov	DWORD PTR _blendDesc$[ebp+36], eax

; 813  :     blendDesc.DestBlend                 = blendConvert[destFactor];

	mov	ecx, DWORD PTR _destFactor$[ebp]
	mov	edx, DWORD PTR _blendConvert[ecx*4]
	mov	DWORD PTR _blendDesc$[ebp+40], edx

; 814  : 
; 815  :     SavedBlendState *savedBlend = blends.CreateNew();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 184				; 000000b8H
	call	?CreateNew@?$List@USavedBlendState@@@@QAEPAUSavedBlendState@@XZ ; List<SavedBlendState>::CreateNew
	mov	DWORD PTR _savedBlend$[ebp], eax

; 816  :     savedBlend->destFactor      = destFactor;

	mov	eax, DWORD PTR _savedBlend$[ebp]
	mov	ecx, DWORD PTR _destFactor$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 817  :     savedBlend->srcFactor       = srcFactor;

	mov	edx, DWORD PTR _savedBlend$[ebp]
	mov	eax, DWORD PTR _srcFactor$[ebp]
	mov	DWORD PTR [edx], eax

; 818  : 
; 819  :     if(FAILED(d3d->CreateBlendState(&blendDesc, &savedBlend->blendState)))

	mov	ecx, DWORD PTR _savedBlend$[ebp]
	add	ecx, 8
	push	ecx
	lea	edx, DWORD PTR _blendDesc$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+332]
	call	edx
	test	eax, eax
	jge	SHORT $LN2@BlendFunct

; 820  :         CrashError(TEXT("Could not set blend state"));

	push	OFFSET $SG4294909704
	call	DWORD PTR __imp_?CrashError@@YAXPB_WZZ
$LN2@BlendFunct:

; 821  : 
; 822  :     if(bBlendingEnabled)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+200], 0
	je	SHORT $LN1@BlendFunct

; 823  :         d3d->OMSetBlendState(savedBlend->blendState, curBlendFactor, 0xFFFFFFFF);

	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 404				; 00000194H
	push	ecx
	mov	edx, DWORD PTR _savedBlend$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN1@BlendFunct:

; 824  : 
; 825  :     curBlendState = savedBlend->blendState;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _savedBlend$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+192], eax
$LN13@BlendFunct:

; 826  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?BlendFunction@D3D10System@@UAEXW4GSBlendType@@0M@Z ENDP ; D3D10System::BlendFunction
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\d3d10system.cpp
;	COMDAT ?ClearColorBuffer@D3D10System@@UAEXK@Z
_TEXT	SEGMENT
_floatColor$ = -32					; size = 16
_d3dTex$ = -8						; size = 4
_this$ = -4						; size = 4
_color$ = 8						; size = 4
?ClearColorBuffer@D3D10System@@UAEXK@Z PROC		; D3D10System::ClearColorBuffer, COMDAT
; _this$ = ecx

; 829  : {

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -16				; fffffff0H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [esp+4], ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 830  :     Color4 floatColor;

	lea	ecx, DWORD PTR _floatColor$[ebp]
	call	DWORD PTR __imp_??0Vect4@@QAE@XZ

; 831  :     floatColor.MakeFromRGBA(color);

	mov	eax, DWORD PTR _color$[ebx]
	push	eax
	lea	ecx, DWORD PTR _floatColor$[ebp]
	call	DWORD PTR __imp_?MakeFromRGBA@Vect4@@QAEAAU1@K@Z

; 832  : 
; 833  :     D3D10Texture *d3dTex = static_cast<D3D10Texture*>(curRenderTarget);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	DWORD PTR _d3dTex$[ebp], edx

; 834  :     if(d3dTex)

	cmp	DWORD PTR _d3dTex$[ebp], 0
	je	SHORT $LN2@ClearColor

; 835  :         d3d->ClearRenderTargetView(d3dTex->renderTarget, floatColor.ptr);

	lea	eax, DWORD PTR _floatColor$[ebp]
	push	eax
	mov	ecx, DWORD PTR _d3dTex$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+140]
	call	edx

; 836  :     else

	jmp	SHORT $LN3@ClearColor
$LN2@ClearColor:

; 837  :         d3d->ClearRenderTargetView(swapRenderView, floatColor.ptr);

	lea	eax, DWORD PTR _floatColor$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+140]
	call	edx
$LN3@ClearColor:

; 838  : }

	mov	esp, ebp
	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	4
?ClearColorBuffer@D3D10System@@UAEXK@Z ENDP		; D3D10System::ClearColorBuffer
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\d3d10system.cpp
;	COMDAT ?Ortho@D3D10System@@UAEXMMMMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_left$ = 8						; size = 4
_right$ = 12						; size = 4
_top$ = 16						; size = 4
_bottom$ = 20						; size = 4
_znear$ = 24						; size = 4
_zfar$ = 28						; size = 4
?Ortho@D3D10System@@UAEXMMMMMM@Z PROC			; D3D10System::Ortho, COMDAT
; _this$ = ecx

; 844  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 845  :     Matrix4x4Ortho(curProjMatrix, left, right, top, bottom, znear, zfar);

	cvtss2sd xmm0, DWORD PTR _zfar$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _znear$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _bottom$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _top$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _right$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _left$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 212				; 000000d4H
	push	eax
	call	DWORD PTR __imp_?Matrix4x4Ortho@@YAXPAMNNNNNN@Z
	add	esp, 52					; 00000034H

; 846  :     ResetViewMatrix();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax

; 847  : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?Ortho@D3D10System@@UAEXMMMMMM@Z ENDP			; D3D10System::Ortho
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\d3d10system.cpp
;	COMDAT ?Frustum@D3D10System@@UAEXMMMMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_left$ = 8						; size = 4
_right$ = 12						; size = 4
_top$ = 16						; size = 4
_bottom$ = 20						; size = 4
_znear$ = 24						; size = 4
_zfar$ = 28						; size = 4
?Frustum@D3D10System@@UAEXMMMMMM@Z PROC			; D3D10System::Frustum, COMDAT
; _this$ = ecx

; 850  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 851  :     Matrix4x4Frustum(curProjMatrix, left, right, top, bottom, znear, zfar);

	cvtss2sd xmm0, DWORD PTR _zfar$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _znear$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _bottom$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _top$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _right$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _left$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 212				; 000000d4H
	push	eax
	call	DWORD PTR __imp_?Matrix4x4Frustum@@YAXPAMNNNNNN@Z
	add	esp, 52					; 00000034H

; 852  :     ResetViewMatrix();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax

; 853  : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?Frustum@D3D10System@@UAEXMMMMMM@Z ENDP			; D3D10System::Frustum
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\d3d10system.cpp
;	COMDAT ?SetViewport@D3D10System@@UAEXMMMM@Z
_TEXT	SEGMENT
_this$ = -32						; size = 4
_vp$ = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_width$ = 16						; size = 4
_height$ = 20						; size = 4
?SetViewport@D3D10System@@UAEXMMMM@Z PROC		; D3D10System::SetViewport, COMDAT
; _this$ = ecx

; 857  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 858  :     D3D10_VIEWPORT vp;
; 859  :     zero(&vp, sizeof(vp));

	push	24					; 00000018H
	lea	eax, DWORD PTR _vp$[ebp]
	push	eax
	call	?zero@@YGXPAXI@Z			; zero

; 860  :     vp.MaxDepth = 1.0f;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _vp$[ebp+20], xmm0

; 861  :     vp.TopLeftX = INT(x);

	cvttss2si ecx, DWORD PTR _x$[ebp]
	mov	DWORD PTR _vp$[ebp], ecx

; 862  :     vp.TopLeftY = INT(y);

	cvttss2si edx, DWORD PTR _y$[ebp]
	mov	DWORD PTR _vp$[ebp+4], edx

; 863  :     vp.Width    = UINT(width);

	movss	xmm0, DWORD PTR _width$[ebp]
	call	__ftoui3
	mov	DWORD PTR _vp$[ebp+8], eax

; 864  :     vp.Height   = UINT(height);

	movss	xmm0, DWORD PTR _height$[ebp]
	call	__ftoui3
	mov	DWORD PTR _vp$[ebp+12], eax

; 865  :     d3d->RSSetViewports(1, &vp);

	lea	eax, DWORD PTR _vp$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+120]
	call	eax

; 866  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?SetViewport@D3D10System@@UAEXMMMM@Z ENDP		; D3D10System::SetViewport
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\d3d10system.cpp
;	COMDAT ?SetScissorRect@D3D10System@@UAEXPAUXRect@@@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
_rc$1 = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_pRect$ = 8						; size = 4
?SetScissorRect@D3D10System@@UAEXPAUXRect@@@Z PROC	; D3D10System::SetScissorRect, COMDAT
; _this$ = ecx

; 869  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 870  :     if(pRect)

	cmp	DWORD PTR _pRect$[ebp], 0
	je	SHORT $LN2@SetScissor

; 871  :     {
; 872  :         d3d->RSSetState(scissorState);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+116]
	call	ecx

; 873  :         D3D10_RECT rc = {pRect->x, pRect->y, pRect->x+pRect->cx, pRect->y+pRect->cy};

	mov	edx, DWORD PTR _pRect$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _rc$1[ebp], eax
	mov	ecx, DWORD PTR _pRect$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _rc$1[ebp+4], edx
	mov	eax, DWORD PTR _pRect$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pRect$[ebp]
	add	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR _rc$1[ebp+8], ecx
	mov	eax, DWORD PTR _pRect$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _pRect$[ebp]
	add	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR _rc$1[ebp+12], ecx

; 874  :         d3d->RSSetScissorRects(1, &rc);

	lea	eax, DWORD PTR _rc$1[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+124]
	call	eax

; 875  :     }
; 876  :     else

	jmp	SHORT $LN3@SetScissor
$LN2@SetScissor:

; 877  :     {
; 878  :         d3d->RSSetState(rasterizerState);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+88]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+116]
	call	edx

; 879  :         d3d->RSSetScissorRects(0, NULL);

	push	0
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+124]
	call	edx
$LN3@SetScissor:

; 880  :     }
; 881  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
?SetScissorRect@D3D10System@@UAEXPAUXRect@@@Z ENDP	; D3D10System::SetScissorRect
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\d3d10system.cpp
;	COMDAT ?SetCropping@D3D10System@@UAEXMMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_left$ = 8						; size = 4
_top$ = 12						; size = 4
_right$ = 16						; size = 4
_bottom$ = 20						; size = 4
?SetCropping@D3D10System@@UAEXMMMM@Z PROC		; D3D10System::SetCropping, COMDAT
; _this$ = ecx

; 885  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 886  :     curCropping[0] = left;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _left$[ebp]
	movss	DWORD PTR [edx+ecx+420], xmm0

; 887  :     curCropping[1] = top;

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _top$[ebp]
	movss	DWORD PTR [ecx+eax+420], xmm0

; 888  :     curCropping[2] = right;

	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _right$[ebp]
	movss	DWORD PTR [eax+edx+420], xmm0

; 889  :     curCropping[3] = bottom;

	mov	ecx, 4
	imul	edx, ecx, 3
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _bottom$[ebp]
	movss	DWORD PTR [eax+edx+420], xmm0

; 890  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?SetCropping@D3D10System@@UAEXMMMM@Z ENDP		; D3D10System::SetCropping
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\d3d10system.cpp
;	COMDAT ?DrawSpriteEx@D3D10System@@UAEXPAVTexture@@KMMMMMMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_texture$ = 8						; size = 4
_color$ = 12						; size = 4
_x$ = 16						; size = 4
_y$ = 20						; size = 4
_x2$ = 24						; size = 4
_y2$ = 28						; size = 4
_u$ = 32						; size = 4
_v$ = 36						; size = 4
_u2$ = 40						; size = 4
_v2$ = 44						; size = 4
?DrawSpriteEx@D3D10System@@UAEXPAVTexture@@KMMMMMMMM@Z PROC ; D3D10System::DrawSpriteEx, COMDAT
; _this$ = ecx

; 893  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 894  :     DrawSpriteExRotate(texture, color, x, y, x2, y2, 0.0f, u, v, u2, v2, 0.0f);

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _v2$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _u2$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _v$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _u$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y2$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x2$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _color$[ebp]
	push	eax
	mov	ecx, DWORD PTR _texture$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+156]
	call	edx

; 895  : }

	mov	esp, ebp
	pop	ebp
	ret	40					; 00000028H
?DrawSpriteEx@D3D10System@@UAEXPAVTexture@@KMMMMMMMM@Z ENDP ; D3D10System::DrawSpriteEx
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\d3d10system.cpp
;	COMDAT ?DrawSpriteExRotate@D3D10System@@UAEXPAVTexture@@KMMMMMMMMMM@Z
_TEXT	SEGMENT
_rotMatrix$1 = -368					; size = 64
$T2 = -304						; size = 16
_rotMatrix$3 = -288					; size = 64
$T4 = -224						; size = 16
$T5 = -208						; size = 16
$T6 = -192						; size = 16
_val$7 = -176						; size = 16
_val$8 = -160						; size = 16
_minVal$9 = -144					; size = 8
_center$10 = -136					; size = 8
_tempFloat$11 = -128					; size = 4
_tempFloat$12 = -124					; size = 4
_totalUVSize$ = -120					; size = 8
_invMult$ = -112					; size = 8
tv166 = -104						; size = 4
tv133 = -100						; size = 4
tv130 = -96						; size = 4
tv200 = -92						; size = 4
tv215 = -88						; size = 4
tv199 = -84						; size = 4
tv211 = -80						; size = 4
tv171 = -76						; size = 4
tv212 = -72						; size = 4
_hColor$ = -68						; size = 4
tv203 = -64						; size = 4
_coords$13 = -60					; size = 4
_totalSize$ = -56					; size = 8
_i$14 = -48						; size = 4
_i$15 = -44						; size = 4
_data$ = -40						; size = 4
_i$16 = -36						; size = 4
_bFlipX$ = -32						; size = 1
_bFlipY$ = -31						; size = 1
_cropXUnder$ = -30					; size = 1
_cropYUnder$ = -29					; size = 1
_coords$ = -28						; size = 4
_this$ = -24						; size = 4
_cropMult$ = -20					; size = 16
__$ArrayPad$ = -4					; size = 4
_texture$ = 8						; size = 4
_color$ = 12						; size = 4
_x$ = 16						; size = 4
_y$ = 20						; size = 4
_x2$ = 24						; size = 4
_y2$ = 28						; size = 4
_degrees$ = 32						; size = 4
_u$ = 36						; size = 4
_v$ = 40						; size = 4
_u2$ = 44						; size = 4
_v2$ = 48						; size = 4
_texDegrees$ = 52					; size = 4
?DrawSpriteExRotate@D3D10System@@UAEXPAVTexture@@KMMMMMMMMMM@Z PROC ; D3D10System::DrawSpriteExRotate, COMDAT
; _this$ = ecx

; 898  : {

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -16				; fffffff0H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [esp+4], ebp
	mov	ebp, esp
	sub	esp, 380				; 0000017cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 899  :     if(!curPixelShader)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+176], 0
	jne	SHORT $LN18@DrawSprite

; 900  :         return; 

	jmp	$LN19@DrawSprite
$LN18@DrawSprite:

; 901  : 
; 902  :     if(!texture)

	cmp	DWORD PTR _texture$[ebx], 0
	jne	SHORT $LN17@DrawSprite

; 903  :     {
; 904  :         AppWarning(TEXT("Trying to draw a sprite with a NULL texture"));

	push	OFFSET $SG4294909703
	call	DWORD PTR __imp_?AppWarning@@YAXPB_WZZ
	add	esp, 4

; 905  :         return;

	jmp	$LN19@DrawSprite
$LN17@DrawSprite:

; 906  :     }
; 907  : 
; 908  :     HANDLE hColor = curPixelShader->GetParameterByName(TEXT("outputColor"));

	push	OFFSET $SG4294909702
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+176]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+176]
	mov	eax, DWORD PTR [edx+16]
	call	eax
	mov	DWORD PTR _hColor$[ebp], eax

; 909  : 
; 910  :     if(hColor)

	cmp	DWORD PTR _hColor$[ebp], 0
	je	SHORT $LN16@DrawSprite

; 911  :         curPixelShader->SetColor(hColor, color);

	mov	ecx, DWORD PTR _color$[ebx]
	push	ecx
	mov	edx, DWORD PTR _hColor$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+176]
	call	DWORD PTR __imp_?SetColor@Shader@@QAEXPAXK@Z
$LN16@DrawSprite:

; 912  : 
; 913  :     //------------------------------
; 914  :     // crop positional values
; 915  : 
; 916  :     Vect2 totalSize = Vect2(x2-x, y2-y);

	movss	xmm0, DWORD PTR _y2$[ebx]
	subss	xmm0, DWORD PTR _y$[ebx]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _x2$[ebx]
	subss	xmm0, DWORD PTR _x$[ebx]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _totalSize$[ebp]
	call	DWORD PTR __imp_??0Vect2@@QAE@MM@Z

; 917  :     Vect2 invMult   = Vect2(totalSize.x < 0.0f ? -1.0f : 1.0f, totalSize.y < 0.0f ? -1.0f : 1.0f);

	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR _totalSize$[ebp+4]
	jbe	SHORT $LN21@DrawSprite
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR tv130[ebp], xmm0
	jmp	SHORT $LN22@DrawSprite
$LN21@DrawSprite:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv130[ebp], xmm0
$LN22@DrawSprite:
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR _totalSize$[ebp]
	jbe	SHORT $LN23@DrawSprite
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR tv133[ebp], xmm0
	jmp	SHORT $LN24@DrawSprite
$LN23@DrawSprite:
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR tv133[ebp], xmm0
$LN24@DrawSprite:
	push	ecx
	movss	xmm0, DWORD PTR tv130[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR tv133[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _invMult$[ebp]
	call	DWORD PTR __imp_??0Vect2@@QAE@MM@Z

; 918  :     totalSize.Abs();

	lea	ecx, DWORD PTR _totalSize$[ebp]
	call	DWORD PTR __imp_?Abs@Vect2@@QAEAAU1@XZ

; 919  : 
; 920  :     if(y2-y < 0) {

	movss	xmm0, DWORD PTR _y2$[ebx]
	subss	xmm0, DWORD PTR _y$[ebx]
	movss	xmm1, DWORD PTR __real@00000000
	comiss	xmm1, xmm0
	jbe	SHORT $LN15@DrawSprite

; 921  :         float tempFloat = curCropping[1];

	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+420]
	movss	DWORD PTR _tempFloat$12[ebp], xmm0

; 922  :         curCropping[1] = curCropping[3];

	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+420]
	mov	DWORD PTR [eax+edx+420], ecx

; 923  :         curCropping[3] = tempFloat;

	mov	edx, 4
	imul	eax, edx, 3
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _tempFloat$12[ebp]
	movss	DWORD PTR [ecx+eax+420], xmm0
$LN15@DrawSprite:

; 924  :     }
; 925  : 
; 926  :     if(x2-x < 0) {

	movss	xmm0, DWORD PTR _x2$[ebx]
	subss	xmm0, DWORD PTR _x$[ebx]
	movss	xmm1, DWORD PTR __real@00000000
	comiss	xmm1, xmm0
	jbe	SHORT $LN14@DrawSprite

; 927  :         float tempFloat = curCropping[0];

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+420]
	movss	DWORD PTR _tempFloat$11[ebp], xmm0

; 928  :         curCropping[0] = curCropping[2];

	mov	edx, 4
	shl	edx, 1
	mov	eax, 4
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [esi+edx+420]
	mov	DWORD PTR [eax+ecx+420], edx

; 929  :         curCropping[2] = tempFloat;

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _tempFloat$11[ebp]
	movss	DWORD PTR [ecx+eax+420], xmm0
$LN14@DrawSprite:

; 930  :     }
; 931  : 
; 932  :     bool bFlipX = (x2 - x) < 0.0f;

	movss	xmm0, DWORD PTR _x2$[ebx]
	subss	xmm0, DWORD PTR _x$[ebx]
	movss	xmm1, DWORD PTR __real@00000000
	comiss	xmm1, xmm0
	jbe	SHORT $LN25@DrawSprite
	mov	DWORD PTR tv166[ebp], 1
	jmp	SHORT $LN26@DrawSprite
$LN25@DrawSprite:
	mov	DWORD PTR tv166[ebp], 0
$LN26@DrawSprite:
	mov	dl, BYTE PTR tv166[ebp]
	mov	BYTE PTR _bFlipX$[ebp], dl

; 933  :     bool bFlipY = (y2 - y) < 0.0f;

	movss	xmm0, DWORD PTR _y2$[ebx]
	subss	xmm0, DWORD PTR _y$[ebx]
	movss	xmm1, DWORD PTR __real@00000000
	comiss	xmm1, xmm0
	jbe	SHORT $LN27@DrawSprite
	mov	DWORD PTR tv171[ebp], 1
	jmp	SHORT $LN28@DrawSprite
$LN27@DrawSprite:
	mov	DWORD PTR tv171[ebp], 0
$LN28@DrawSprite:
	mov	al, BYTE PTR tv171[ebp]
	mov	BYTE PTR _bFlipY$[ebp], al

; 934  : 
; 935  :     x  += curCropping[0] * invMult.x;

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+edx+420]
	mulss	xmm0, DWORD PTR _invMult$[ebp]
	addss	xmm0, DWORD PTR _x$[ebx]
	movss	DWORD PTR _x$[ebx], xmm0

; 936  :     y  += curCropping[1] * invMult.y;

	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+420]
	mulss	xmm0, DWORD PTR _invMult$[ebp+4]
	addss	xmm0, DWORD PTR _y$[ebx]
	movss	DWORD PTR _y$[ebx], xmm0

; 937  :     x2 -= curCropping[2] * invMult.x;

	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+420]
	mulss	xmm0, DWORD PTR _invMult$[ebp]
	movss	xmm1, DWORD PTR _x2$[ebx]
	subss	xmm1, xmm0
	movss	DWORD PTR _x2$[ebx], xmm1

; 938  :     y2 -= curCropping[3] * invMult.y;

	mov	edx, 4
	imul	eax, edx, 3
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+420]
	mulss	xmm0, DWORD PTR _invMult$[ebp+4]
	movss	xmm1, DWORD PTR _y2$[ebx]
	subss	xmm1, xmm0
	movss	DWORD PTR _y2$[ebx], xmm1

; 939  : 
; 940  :     bool cropXUnder = bFlipX ? ((x - x2) < 0.0f) : ((x2 - x) < 0.0f);

	movzx	edx, BYTE PTR _bFlipX$[ebp]
	test	edx, edx
	je	SHORT $LN33@DrawSprite
	movss	xmm0, DWORD PTR _x$[ebx]
	subss	xmm0, DWORD PTR _x2$[ebx]
	movss	xmm1, DWORD PTR __real@00000000
	comiss	xmm1, xmm0
	jbe	SHORT $LN31@DrawSprite
	mov	DWORD PTR tv200[ebp], 1
	jmp	SHORT $LN32@DrawSprite
$LN31@DrawSprite:
	mov	DWORD PTR tv200[ebp], 0
$LN32@DrawSprite:
	mov	eax, DWORD PTR tv200[ebp]
	mov	DWORD PTR tv203[ebp], eax
	jmp	SHORT $LN34@DrawSprite
$LN33@DrawSprite:
	movss	xmm0, DWORD PTR _x2$[ebx]
	subss	xmm0, DWORD PTR _x$[ebx]
	movss	xmm1, DWORD PTR __real@00000000
	comiss	xmm1, xmm0
	jbe	SHORT $LN29@DrawSprite
	mov	DWORD PTR tv199[ebp], 1
	jmp	SHORT $LN30@DrawSprite
$LN29@DrawSprite:
	mov	DWORD PTR tv199[ebp], 0
$LN30@DrawSprite:
	mov	ecx, DWORD PTR tv199[ebp]
	mov	DWORD PTR tv203[ebp], ecx
$LN34@DrawSprite:
	mov	dl, BYTE PTR tv203[ebp]
	mov	BYTE PTR _cropXUnder$[ebp], dl

; 941  :     bool cropYUnder = bFlipY ? ((y - y2) < 0.0f) : ((y2 - y) < 0.0f);

	movzx	eax, BYTE PTR _bFlipY$[ebp]
	test	eax, eax
	je	SHORT $LN39@DrawSprite
	movss	xmm0, DWORD PTR _y$[ebx]
	subss	xmm0, DWORD PTR _y2$[ebx]
	movss	xmm1, DWORD PTR __real@00000000
	comiss	xmm1, xmm0
	jbe	SHORT $LN37@DrawSprite
	mov	DWORD PTR tv212[ebp], 1
	jmp	SHORT $LN38@DrawSprite
$LN37@DrawSprite:
	mov	DWORD PTR tv212[ebp], 0
$LN38@DrawSprite:
	mov	ecx, DWORD PTR tv212[ebp]
	mov	DWORD PTR tv215[ebp], ecx
	jmp	SHORT $LN40@DrawSprite
$LN39@DrawSprite:
	movss	xmm0, DWORD PTR _y2$[ebx]
	subss	xmm0, DWORD PTR _y$[ebx]
	movss	xmm1, DWORD PTR __real@00000000
	comiss	xmm1, xmm0
	jbe	SHORT $LN35@DrawSprite
	mov	DWORD PTR tv211[ebp], 1
	jmp	SHORT $LN36@DrawSprite
$LN35@DrawSprite:
	mov	DWORD PTR tv211[ebp], 0
$LN36@DrawSprite:
	mov	edx, DWORD PTR tv211[ebp]
	mov	DWORD PTR tv215[ebp], edx
$LN40@DrawSprite:
	mov	al, BYTE PTR tv215[ebp]
	mov	BYTE PTR _cropYUnder$[ebp], al

; 942  : 
; 943  :     // cropped out completely (eg mouse cursor texture)
; 944  :     if (cropXUnder || cropYUnder)

	movzx	ecx, BYTE PTR _cropXUnder$[ebp]
	test	ecx, ecx
	jne	SHORT $LN12@DrawSprite
	movzx	edx, BYTE PTR _cropYUnder$[ebp]
	test	edx, edx
	je	SHORT $LN13@DrawSprite
$LN12@DrawSprite:

; 945  :         return;

	jmp	$LN19@DrawSprite
$LN13@DrawSprite:

; 946  : 
; 947  :     //------------------------------
; 948  :     // crop texture coordinate values
; 949  : 
; 950  :     float cropMult[4];
; 951  :     cropMult[0] = curCropping[0]/totalSize.x;

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [edx+ecx+420]
	divss	xmm0, DWORD PTR _totalSize$[ebp]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	DWORD PTR _cropMult$[ebp+ecx], xmm0

; 952  :     cropMult[1] = curCropping[1]/totalSize.y;

	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+edx+420]
	divss	xmm0, DWORD PTR _totalSize$[ebp+4]
	mov	ecx, 4
	shl	ecx, 0
	movss	DWORD PTR _cropMult$[ebp+ecx], xmm0

; 953  :     cropMult[2] = curCropping[2]/totalSize.x;

	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [eax+edx+420]
	divss	xmm0, DWORD PTR _totalSize$[ebp]
	mov	ecx, 4
	shl	ecx, 1
	movss	DWORD PTR _cropMult$[ebp+ecx], xmm0

; 954  :     cropMult[3] = curCropping[3]/totalSize.y;

	mov	edx, 4
	imul	eax, edx, 3
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR [ecx+eax+420]
	divss	xmm0, DWORD PTR _totalSize$[ebp+4]
	mov	edx, 4
	imul	eax, edx, 3
	movss	DWORD PTR _cropMult$[ebp+eax], xmm0

; 955  : 
; 956  :     Vect2 totalUVSize = Vect2(u2-u, v2-v);

	movss	xmm0, DWORD PTR _v2$[ebx]
	subss	xmm0, DWORD PTR _v$[ebx]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _u2$[ebx]
	subss	xmm0, DWORD PTR _u$[ebx]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _totalUVSize$[ebp]
	call	DWORD PTR __imp_??0Vect2@@QAE@MM@Z

; 957  :     u  += cropMult[0] * totalUVSize.x;

	mov	ecx, 4
	imul	edx, ecx, 0
	movss	xmm0, DWORD PTR _cropMult$[ebp+edx]
	mulss	xmm0, DWORD PTR _totalUVSize$[ebp]
	addss	xmm0, DWORD PTR _u$[ebx]
	movss	DWORD PTR _u$[ebx], xmm0

; 958  :     v  += cropMult[1] * totalUVSize.y;

	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR _cropMult$[ebp+eax]
	mulss	xmm0, DWORD PTR _totalUVSize$[ebp+4]
	addss	xmm0, DWORD PTR _v$[ebx]
	movss	DWORD PTR _v$[ebx], xmm0

; 959  :     u2 -= cropMult[2] * totalUVSize.x;

	mov	ecx, 4
	shl	ecx, 1
	movss	xmm0, DWORD PTR _cropMult$[ebp+ecx]
	mulss	xmm0, DWORD PTR _totalUVSize$[ebp]
	movss	xmm1, DWORD PTR _u2$[ebx]
	subss	xmm1, xmm0
	movss	DWORD PTR _u2$[ebx], xmm1

; 960  :     v2 -= cropMult[3] * totalUVSize.y;

	mov	edx, 4
	imul	eax, edx, 3
	movss	xmm0, DWORD PTR _cropMult$[ebp+eax]
	mulss	xmm0, DWORD PTR _totalUVSize$[ebp+4]
	movss	xmm1, DWORD PTR _v2$[ebx]
	subss	xmm1, xmm0
	movss	DWORD PTR _v2$[ebx], xmm1

; 961  : 
; 962  :     //------------------------------
; 963  :     // draw
; 964  : 
; 965  :     VBData *data = spriteVertexBuffer->GetData();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+204]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+204]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	DWORD PTR _data$[ebp], eax

; 966  :     data->VertList[0].Set(x,  y,  0.0f);

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebx]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebx]
	movss	DWORD PTR [esp], xmm0
	push	0
	mov	ecx, DWORD PTR _data$[ebp]
	call	??A?$List@UVect@@@@QAEAAUVect@@I@Z	; List<Vect>::operator[]
	mov	ecx, eax
	call	DWORD PTR __imp_?Set@Vect@@QAEAAU1@MMM@Z

; 967  :     data->VertList[1].Set(x,  y2, 0.0f);

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y2$[ebx]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebx]
	movss	DWORD PTR [esp], xmm0
	push	1
	mov	ecx, DWORD PTR _data$[ebp]
	call	??A?$List@UVect@@@@QAEAAUVect@@I@Z	; List<Vect>::operator[]
	mov	ecx, eax
	call	DWORD PTR __imp_?Set@Vect@@QAEAAU1@MMM@Z

; 968  :     data->VertList[2].Set(x2, y,  0.0f);

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebx]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x2$[ebx]
	movss	DWORD PTR [esp], xmm0
	push	2
	mov	ecx, DWORD PTR _data$[ebp]
	call	??A?$List@UVect@@@@QAEAAUVect@@I@Z	; List<Vect>::operator[]
	mov	ecx, eax
	call	DWORD PTR __imp_?Set@Vect@@QAEAAU1@MMM@Z

; 969  :     data->VertList[3].Set(x2, y2, 0.0f);

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _y2$[ebx]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x2$[ebx]
	movss	DWORD PTR [esp], xmm0
	push	3
	mov	ecx, DWORD PTR _data$[ebp]
	call	??A?$List@UVect@@@@QAEAAUVect@@I@Z	; List<Vect>::operator[]
	mov	ecx, eax
	call	DWORD PTR __imp_?Set@Vect@@QAEAAU1@MMM@Z

; 970  : 
; 971  :     if (!CloseFloat(degrees, 0.0f)) {

	push	ecx
	movss	xmm0, DWORD PTR __real@3c23d70a
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _degrees$[ebx]
	movss	DWORD PTR [esp], xmm0
	call	?CloseFloat@@YAHMMM@Z			; CloseFloat
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN8@DrawSprite

; 972  :         List<Vect> &coords = data->VertList;

	mov	ecx, DWORD PTR _data$[ebp]
	mov	DWORD PTR _coords$13[ebp], ecx

; 973  : 
; 974  :         Vect2 center(x+totalSize.x/2, y+totalSize.y/2);

	movss	xmm0, DWORD PTR _totalSize$[ebp+4]
	divss	xmm0, DWORD PTR __real@40000000
	addss	xmm0, DWORD PTR _y$[ebx]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	movss	xmm0, DWORD PTR _totalSize$[ebp]
	divss	xmm0, DWORD PTR __real@40000000
	addss	xmm0, DWORD PTR _x$[ebx]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _center$10[ebp]
	call	DWORD PTR __imp_??0Vect2@@QAE@MM@Z

; 975  : 
; 976  :         Matrix rotMatrix;

	lea	ecx, DWORD PTR _rotMatrix$3[ebp]
	call	DWORD PTR __imp_??0Matrix@@QAE@XZ

; 977  :         rotMatrix.SetIdentity();

	lea	ecx, DWORD PTR _rotMatrix$3[ebp]
	call	DWORD PTR __imp_?SetIdentity@Matrix@@QAEAAU1@XZ

; 978  :         rotMatrix.Rotate(AxisAngle(0.0f, 0.0f, 1.0f, RAD(degrees)));

	movss	xmm0, DWORD PTR _degrees$[ebx]
	mulss	xmm0, DWORD PTR __real@3c8efa35
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T2[ebp]
	call	DWORD PTR __imp_??0AxisAngle@@QAE@MMMM@Z
	push	eax
	lea	ecx, DWORD PTR _rotMatrix$3[ebp]
	call	DWORD PTR __imp_?Rotate@Matrix@@QAEAAU1@ABUAxisAngle@@@Z

; 979  : 
; 980  :         for (int i = 0; i < 4; i++) {

	mov	DWORD PTR _i$16[ebp], 0
	jmp	SHORT $LN10@DrawSprite
$LN9@DrawSprite:
	mov	edx, DWORD PTR _i$16[ebp]
	add	edx, 1
	mov	DWORD PTR _i$16[ebp], edx
$LN10@DrawSprite:
	cmp	DWORD PTR _i$16[ebp], 4
	jge	$LN8@DrawSprite

; 981  :             Vect val = coords[i]-Vect(center);

	lea	eax, DWORD PTR _center$10[ebp]
	push	eax
	lea	ecx, DWORD PTR $T4[ebp]
	call	DWORD PTR __imp_??0Vect@@QAE@ABUVect2@@@Z
	push	eax
	lea	ecx, DWORD PTR _val$7[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$16[ebp]
	push	edx
	mov	ecx, DWORD PTR _coords$13[ebp]
	call	??A?$List@UVect@@@@QAEAAUVect@@I@Z	; List<Vect>::operator[]
	mov	ecx, eax
	call	DWORD PTR __imp_??GVect@@QBE?AU0@ABU0@@Z

; 982  :             val.TransformVector(rotMatrix);

	lea	eax, DWORD PTR _rotMatrix$3[ebp]
	push	eax
	lea	ecx, DWORD PTR _val$7[ebp]
	call	DWORD PTR __imp_?TransformVector@Vect@@QAEAAU1@ABUMatrix@@@Z

; 983  :             coords[i] = val;

	lea	ecx, DWORD PTR _val$7[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$16[ebp]
	push	edx
	mov	ecx, DWORD PTR _coords$13[ebp]
	call	??A?$List@UVect@@@@QAEAAUVect@@I@Z	; List<Vect>::operator[]
	mov	ecx, eax
	call	DWORD PTR __imp_??4Vect@@QAEAAU0@ABU0@@Z

; 984  :             coords[i] += Vect(center);

	lea	eax, DWORD PTR _center$10[ebp]
	push	eax
	lea	ecx, DWORD PTR $T6[ebp]
	call	DWORD PTR __imp_??0Vect@@QAE@ABUVect2@@@Z
	push	eax
	mov	ecx, DWORD PTR _i$16[ebp]
	push	ecx
	mov	ecx, DWORD PTR _coords$13[ebp]
	call	??A?$List@UVect@@@@QAEAAUVect@@I@Z	; List<Vect>::operator[]
	mov	ecx, eax
	call	DWORD PTR __imp_??YVect@@QAEAAU0@ABU0@@Z

; 985  :         }

	jmp	$LN9@DrawSprite
$LN8@DrawSprite:

; 986  :     }
; 987  : 
; 988  :     List<UVCoord> &coords = data->UVList[0];

	push	0
	mov	ecx, DWORD PTR _data$[ebp]
	add	ecx, 32					; 00000020H
	call	??A?$List@VUVCoordList@@@@QAEAAVUVCoordList@@I@Z ; List<UVCoordList>::operator[]
	mov	DWORD PTR _coords$[ebp], eax

; 989  :     coords[0].Set(u,  v);

	push	ecx
	movss	xmm0, DWORD PTR _v$[ebx]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _u$[ebx]
	movss	DWORD PTR [esp], xmm0
	push	0
	mov	ecx, DWORD PTR _coords$[ebp]
	call	??A?$List@UVect2@@@@QAEAAUVect2@@I@Z	; List<Vect2>::operator[]
	mov	ecx, eax
	call	DWORD PTR __imp_?Set@Vect2@@QAEAAU1@MM@Z

; 990  :     coords[1].Set(u,  v2);

	push	ecx
	movss	xmm0, DWORD PTR _v2$[ebx]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _u$[ebx]
	movss	DWORD PTR [esp], xmm0
	push	1
	mov	ecx, DWORD PTR _coords$[ebp]
	call	??A?$List@UVect2@@@@QAEAAUVect2@@I@Z	; List<Vect2>::operator[]
	mov	ecx, eax
	call	DWORD PTR __imp_?Set@Vect2@@QAEAAU1@MM@Z

; 991  :     coords[2].Set(u2, v);

	push	ecx
	movss	xmm0, DWORD PTR _v$[ebx]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _u2$[ebx]
	movss	DWORD PTR [esp], xmm0
	push	2
	mov	ecx, DWORD PTR _coords$[ebp]
	call	??A?$List@UVect2@@@@QAEAAUVect2@@I@Z	; List<Vect2>::operator[]
	mov	ecx, eax
	call	DWORD PTR __imp_?Set@Vect2@@QAEAAU1@MM@Z

; 992  :     coords[3].Set(u2, v2);

	push	ecx
	movss	xmm0, DWORD PTR _v2$[ebx]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _u2$[ebx]
	movss	DWORD PTR [esp], xmm0
	push	3
	mov	ecx, DWORD PTR _coords$[ebp]
	call	??A?$List@UVect2@@@@QAEAAUVect2@@I@Z	; List<Vect2>::operator[]
	mov	ecx, eax
	call	DWORD PTR __imp_?Set@Vect2@@QAEAAU1@MM@Z

; 993  : 
; 994  :     if (!CloseFloat(texDegrees, 0.0f)) {

	push	ecx
	movss	xmm0, DWORD PTR __real@3c23d70a
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _texDegrees$[ebx]
	movss	DWORD PTR [esp], xmm0
	call	?CloseFloat@@YAHMMM@Z			; CloseFloat
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN1@DrawSprite

; 995  :         Matrix rotMatrix;

	lea	ecx, DWORD PTR _rotMatrix$1[ebp]
	call	DWORD PTR __imp_??0Matrix@@QAE@XZ

; 996  :         rotMatrix.SetIdentity();

	lea	ecx, DWORD PTR _rotMatrix$1[ebp]
	call	DWORD PTR __imp_?SetIdentity@Matrix@@QAEAAU1@XZ

; 997  :         rotMatrix.Rotate(AxisAngle(0.0f, 0.0f, 1.0f, -RAD(texDegrees)));

	movss	xmm0, DWORD PTR _texDegrees$[ebx]
	mulss	xmm0, DWORD PTR __real@3c8efa35
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T5[ebp]
	call	DWORD PTR __imp_??0AxisAngle@@QAE@MMMM@Z
	push	eax
	lea	ecx, DWORD PTR _rotMatrix$1[ebp]
	call	DWORD PTR __imp_?Rotate@Matrix@@QAEAAU1@ABUAxisAngle@@@Z

; 998  : 
; 999  :         Vect2 minVal = Vect2(0.0f, 0.0f);

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _minVal$9[ebp]
	call	DWORD PTR __imp_??0Vect2@@QAE@MM@Z

; 1000 :         for (int i = 0; i < 4; i++) {

	mov	DWORD PTR _i$15[ebp], 0
	jmp	SHORT $LN6@DrawSprite
$LN5@DrawSprite:
	mov	edx, DWORD PTR _i$15[ebp]
	add	edx, 1
	mov	DWORD PTR _i$15[ebp], edx
$LN6@DrawSprite:
	cmp	DWORD PTR _i$15[ebp], 4
	jge	SHORT $LN4@DrawSprite

; 1001 :             Vect val = Vect(coords[i]);

	mov	eax, DWORD PTR _i$15[ebp]
	push	eax
	mov	ecx, DWORD PTR _coords$[ebp]
	call	??A?$List@UVect2@@@@QAEAAUVect2@@I@Z	; List<Vect2>::operator[]
	push	eax
	lea	ecx, DWORD PTR _val$8[ebp]
	call	DWORD PTR __imp_??0Vect@@QAE@ABUVect2@@@Z

; 1002 :             val.TransformVector(rotMatrix);

	lea	ecx, DWORD PTR _rotMatrix$1[ebp]
	push	ecx
	lea	ecx, DWORD PTR _val$8[ebp]
	call	DWORD PTR __imp_?TransformVector@Vect@@QAEAAU1@ABUMatrix@@@Z

; 1003 :             coords[i] = val;

	lea	edx, DWORD PTR _val$8[ebp]
	push	edx
	mov	eax, DWORD PTR _i$15[ebp]
	push	eax
	mov	ecx, DWORD PTR _coords$[ebp]
	call	??A?$List@UVect2@@@@QAEAAUVect2@@I@Z	; List<Vect2>::operator[]
	mov	ecx, eax
	call	DWORD PTR __imp_??4Vect2@@QAEAAU0@ABUVect@@@Z

; 1004 :             minVal.ClampMax(coords[i]);

	mov	ecx, DWORD PTR _i$15[ebp]
	push	ecx
	mov	ecx, DWORD PTR _coords$[ebp]
	call	??A?$List@UVect2@@@@QAEAAUVect2@@I@Z	; List<Vect2>::operator[]
	push	eax
	lea	ecx, DWORD PTR _minVal$9[ebp]
	call	DWORD PTR __imp_?ClampMax@Vect2@@QAEAAU1@ABU1@@Z

; 1005 :         }

	jmp	SHORT $LN5@DrawSprite
$LN4@DrawSprite:

; 1006 : 
; 1007 :         for (int i = 0; i < 4; i++)

	mov	DWORD PTR _i$14[ebp], 0
	jmp	SHORT $LN3@DrawSprite
$LN2@DrawSprite:
	mov	edx, DWORD PTR _i$14[ebp]
	add	edx, 1
	mov	DWORD PTR _i$14[ebp], edx
$LN3@DrawSprite:
	cmp	DWORD PTR _i$14[ebp], 4
	jge	SHORT $LN1@DrawSprite

; 1008 :             coords[i] -= minVal;

	lea	eax, DWORD PTR _minVal$9[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$14[ebp]
	push	ecx
	mov	ecx, DWORD PTR _coords$[ebp]
	call	??A?$List@UVect2@@@@QAEAAUVect2@@I@Z	; List<Vect2>::operator[]
	mov	ecx, eax
	call	DWORD PTR __imp_??ZVect2@@QAEAAU0@ABU0@@Z
	jmp	SHORT $LN2@DrawSprite
$LN1@DrawSprite:

; 1009 :     }
; 1010 : 
; 1011 :     spriteVertexBuffer->FlushBuffers();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+204]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+204]
	mov	eax, DWORD PTR [edx+4]
	call	eax

; 1012 : 
; 1013 :     LoadVertexBuffer(spriteVertexBuffer);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+204]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+68]
	call	eax

; 1014 :     LoadTexture(texture);

	push	0
	mov	ecx, DWORD PTR _texture$[ebx]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+72]
	call	edx

; 1015 : 
; 1016 :     Draw(GS_TRIANGLESTRIP);

	push	0
	push	0
	push	4
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax
$LN19@DrawSprite:

; 1017 : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	48					; 00000030H
?DrawSpriteExRotate@D3D10System@@UAEXPAVTexture@@KMMMMMMMMMM@Z ENDP ; D3D10System::DrawSpriteExRotate
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\d3d10system.cpp
;	COMDAT ?DrawBox@D3D10System@@UAEXABUVect2@@0@Z
_TEXT	SEGMENT
_bottomRight$ = -16					; size = 8
_data$ = -8						; size = 4
_this$ = -4						; size = 4
_upperLeft$ = 8						; size = 4
_size$ = 12						; size = 4
?DrawBox@D3D10System@@UAEXABUVect2@@0@Z PROC		; D3D10System::DrawBox, COMDAT
; _this$ = ecx

; 1020 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1021 :     VBData *data = boxVertexBuffer->GetData();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+208]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+208]
	mov	edx, DWORD PTR [eax+8]
	call	edx
	mov	DWORD PTR _data$[ebp], eax

; 1022 : 
; 1023 :     Vect2 bottomRight = upperLeft+size;

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	lea	ecx, DWORD PTR _bottomRight$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _upperLeft$[ebp]
	call	DWORD PTR __imp_??HVect2@@QBE?AU0@ABU0@@Z

; 1024 : 
; 1025 :     data->VertList[0] = upperLeft;

	mov	edx, DWORD PTR _upperLeft$[ebp]
	push	edx
	push	0
	mov	ecx, DWORD PTR _data$[ebp]
	call	??A?$List@UVect@@@@QAEAAUVect@@I@Z	; List<Vect>::operator[]
	mov	ecx, eax
	call	DWORD PTR __imp_??4Vect@@QAEAAU0@ABUVect2@@@Z

; 1026 :     data->VertList[1].Set(bottomRight.x, upperLeft.y);

	mov	eax, DWORD PTR _upperLeft$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+4]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _bottomRight$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	1
	mov	ecx, DWORD PTR _data$[ebp]
	call	??A?$List@UVect@@@@QAEAAUVect@@I@Z	; List<Vect>::operator[]
	mov	ecx, eax
	call	DWORD PTR __imp_?Set@Vect@@QAEAAU1@MM@Z

; 1027 :     data->VertList[2].Set(bottomRight.x, bottomRight.y);

	push	ecx
	movss	xmm0, DWORD PTR _bottomRight$[ebp+4]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _bottomRight$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	2
	mov	ecx, DWORD PTR _data$[ebp]
	call	??A?$List@UVect@@@@QAEAAUVect@@I@Z	; List<Vect>::operator[]
	mov	ecx, eax
	call	DWORD PTR __imp_?Set@Vect@@QAEAAU1@MM@Z

; 1028 :     data->VertList[3].Set(upperLeft.x, bottomRight.y);

	push	ecx
	movss	xmm0, DWORD PTR _bottomRight$[ebp+4]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _upperLeft$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx]
	movss	DWORD PTR [esp], xmm0
	push	3
	mov	ecx, DWORD PTR _data$[ebp]
	call	??A?$List@UVect@@@@QAEAAUVect@@I@Z	; List<Vect>::operator[]
	mov	ecx, eax
	call	DWORD PTR __imp_?Set@Vect@@QAEAAU1@MM@Z

; 1029 :     data->VertList[4] = upperLeft;

	mov	edx, DWORD PTR _upperLeft$[ebp]
	push	edx
	push	4
	mov	ecx, DWORD PTR _data$[ebp]
	call	??A?$List@UVect@@@@QAEAAUVect@@I@Z	; List<Vect>::operator[]
	mov	ecx, eax
	call	DWORD PTR __imp_??4Vect@@QAEAAU0@ABUVect2@@@Z

; 1030 : 
; 1031 :     boxVertexBuffer->FlushBuffers();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+208]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+208]
	mov	edx, DWORD PTR [eax+4]
	call	edx

; 1032 : 
; 1033 :     LoadVertexBuffer(boxVertexBuffer);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+208]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+68]
	call	edx

; 1034 : 
; 1035 :     Draw(GS_LINESTRIP);

	push	0
	push	0
	push	2
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+100]
	call	eax

; 1036 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?DrawBox@D3D10System@@UAEXABUVect2@@0@Z ENDP		; D3D10System::DrawBox
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\d3d10system.cpp
;	COMDAT ?ResetViewMatrix@D3D10System@@EAEXXZ
_TEXT	SEGMENT
$T1 = -80						; size = 64
_this$ = -4						; size = 4
?ResetViewMatrix@D3D10System@@EAEXXZ PROC		; D3D10System::ResetViewMatrix, COMDAT
; _this$ = ecx

; 1039 : {

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -16				; fffffff0H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [esp+4], ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	mov	DWORD PTR _this$[ebp], ecx

; 1040 :     Matrix4x4Convert(curViewMatrix, MatrixStack[curMatrix].GetTranspose());

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	??A?$List@UMatrix@@@@QAEAAUMatrix@@I@Z	; List<Matrix>::operator[]
	mov	ecx, eax
	call	DWORD PTR __imp_?GetTranspose@Matrix@@QBE?AU1@XZ
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 276				; 00000114H
	push	eax
	call	DWORD PTR __imp_?Matrix4x4Convert@@YAXPAMABUMatrix@@@Z
	add	esp, 8

; 1041 :     Matrix4x4Multiply(curViewProjMatrix, curViewMatrix, curProjMatrix);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 212				; 000000d4H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 276				; 00000114H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 340				; 00000154H
	push	eax
	call	DWORD PTR __imp_?Matrix4x4Multiply@@YAXPAM00@Z
	add	esp, 12					; 0000000cH

; 1042 :     Matrix4x4Transpose(curViewProjMatrix, curViewProjMatrix);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 340				; 00000154H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 340				; 00000154H
	push	edx
	call	DWORD PTR __imp_?Matrix4x4Transpose@@YAXPAM0@Z
	add	esp, 8

; 1043 : }

	mov	esp, ebp
	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	0
?ResetViewMatrix@D3D10System@@EAEXXZ ENDP		; D3D10System::ResetViewMatrix
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\d3d10system.cpp
;	COMDAT ?ResizeView@D3D10System@@EAEXXZ
_TEXT	SEGMENT
_nullVal$ = -16						; size = 4
_err$ = -12						; size = 4
_backBuffer$ = -8					; size = 4
_this$ = -4						; size = 4
?ResizeView@D3D10System@@EAEXXZ PROC			; D3D10System::ResizeView, COMDAT
; _this$ = ecx

; 1046 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1047 :     LPVOID nullVal = NULL;

	mov	DWORD PTR _nullVal$[ebp], 0

; 1048 :     d3d->OMSetRenderTargets(1, (ID3D10RenderTargetView**)&nullVal, NULL);

	push	0
	lea	eax, DWORD PTR _nullVal$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+96]
	call	eax

; 1049 : 
; 1050 :     SafeRelease(swapRenderView);

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+80], 0
	je	SHORT $LN3@ResizeView
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+80]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+8]
	call	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+80], 0
$LN3@ResizeView:

; 1051 : 
; 1052 :     swap->ResizeBuffers(2, 0, 0, DXGI_FORMAT_B8G8R8A8_UNORM, 0);

	push	0
	push	87					; 00000057H
	push	0
	push	0
	push	2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+52]
	call	edx

; 1053 : 
; 1054 :     ID3D10Texture2D *backBuffer = NULL;

	mov	DWORD PTR _backBuffer$[ebp], 0

; 1055 :     HRESULT err = swap->GetBuffer(0, IID_ID3D10Texture2D, (void**)&backBuffer);

	lea	eax, DWORD PTR _backBuffer$[ebp]
	push	eax
	push	OFFSET _IID_ID3D10Texture2D
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+36]
	call	eax
	mov	DWORD PTR _err$[ebp], eax

; 1056 :     if(FAILED(err))

	cmp	DWORD PTR _err$[ebp], 0
	jge	SHORT $LN2@ResizeView

; 1057 :         CrashError(TEXT("Unable to get back buffer from swap chain"));

	push	OFFSET $SG4294909701
	call	DWORD PTR __imp_?CrashError@@YAXPB_WZZ
$LN2@ResizeView:

; 1058 : 
; 1059 :     err = d3d->CreateRenderTargetView(backBuffer, NULL, &swapRenderView);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 80					; 00000050H
	push	ecx
	push	0
	mov	edx, DWORD PTR _backBuffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+304]
	call	edx
	mov	DWORD PTR _err$[ebp], eax

; 1060 :     if(FAILED(err))

	cmp	DWORD PTR _err$[ebp], 0
	jge	SHORT $LN1@ResizeView

; 1061 :         CrashError(TEXT("Unable to get render view from back buffer"));

	push	OFFSET $SG4294909700
	call	DWORD PTR __imp_?CrashError@@YAXPB_WZZ
$LN1@ResizeView:

; 1062 : 
; 1063 :     backBuffer->Release();

	mov	eax, DWORD PTR _backBuffer$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _backBuffer$[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+8]
	call	eax
$LN5@ResizeView:

; 1064 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ResizeView@D3D10System@@EAEXXZ ENDP			; D3D10System::ResizeView
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\d3d10system.cpp
;	COMDAT ?CopyTexture@D3D10System@@UAEXPAVTexture@@0@Z
_TEXT	SEGMENT
_d3d10Dest$ = -12					; size = 4
_d3d10Src$ = -8						; size = 4
_this$ = -4						; size = 4
_texDest$ = 8						; size = 4
_texSrc$ = 12						; size = 4
?CopyTexture@D3D10System@@UAEXPAVTexture@@0@Z PROC	; D3D10System::CopyTexture, COMDAT
; _this$ = ecx

; 1067 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1068 :     D3D10Texture *d3d10Dest = static_cast<D3D10Texture*>(texDest);

	mov	eax, DWORD PTR _texDest$[ebp]
	mov	DWORD PTR _d3d10Dest$[ebp], eax

; 1069 :     D3D10Texture *d3d10Src  = static_cast<D3D10Texture*>(texSrc);

	mov	ecx, DWORD PTR _texSrc$[ebp]
	mov	DWORD PTR _d3d10Src$[ebp], ecx

; 1070 : 
; 1071 :     d3d->CopyResource(d3d10Dest->texture, d3d10Src->texture);

	mov	edx, DWORD PTR _d3d10Src$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _d3d10Dest$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+132]
	call	edx

; 1072 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?CopyTexture@D3D10System@@UAEXPAVTexture@@0@Z ENDP	; D3D10System::CopyTexture
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??0?$List@I@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$List@I@@QAE@XZ PROC				; List<unsigned int>::List<unsigned int>, COMDAT
; _this$ = ecx

; 35   :     inline List() : array(NULL), num(0) {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$List@I@@QAE@XZ ENDP				; List<unsigned int>::List<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??1?$List@I@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$List@I@@QAE@XZ PROC				; List<unsigned int>::~List<unsigned int>, COMDAT
; _this$ = ecx

; 37   :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 38   :         Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$List@I@@QAEXXZ			; List<unsigned int>::Clear

; 39   :     }

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$List@I@@QAE@XZ ENDP				; List<unsigned int>::~List<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Array@?$List@I@@QBEPAIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Array@?$List@I@@QBEPAIXZ PROC				; List<unsigned int>::Array, COMDAT
; _this$ = ecx

; 41   :     inline T* Array() const             {return array;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	esp, ebp
	pop	ebp
	ret	0
?Array@?$List@I@@QBEPAIXZ ENDP				; List<unsigned int>::Array
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?SetSize@?$List@I@@QAEHI@Z
_TEXT	SEGMENT
_bClear$ = -16						; size = 4
_oldNum$ = -12						; size = 4
tv70 = -8						; size = 4
_this$ = -4						; size = 4
_n$ = 8							; size = 4
?SetSize@?$List@I@@QAEHI@Z PROC				; List<unsigned int>::SetSize, COMDAT
; _this$ = ecx

; 205  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 206  :         if(num == n)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _n$[ebp]
	jne	SHORT $LN4@SetSize

; 207  :             return FALSE;

	xor	eax, eax
	jmp	$LN5@SetSize
	jmp	SHORT $LN3@SetSize
$LN4@SetSize:

; 208  :         else if(!n)

	cmp	DWORD PTR _n$[ebp], 0
	jne	SHORT $LN3@SetSize

; 209  :         {
; 210  :             Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$List@I@@QAEXXZ			; List<unsigned int>::Clear

; 211  :             return TRUE;

	mov	eax, 1
	jmp	$LN5@SetSize
$LN3@SetSize:

; 212  :         }
; 213  : 
; 214  :         BOOL bClear=(n>num);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _n$[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jbe	SHORT $LN7@SetSize
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN8@SetSize
$LN7@SetSize:
	mov	DWORD PTR tv70[ebp], 0
$LN8@SetSize:
	mov	ecx, DWORD PTR tv70[ebp]
	mov	DWORD PTR _bClear$[ebp], ecx

; 215  :         UINT oldNum=num;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _oldNum$[ebp], eax

; 216  : 
; 217  :         num = n;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _n$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 218  :         array = (T*)ReAllocate(array, sizeof(T)*num);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 219  : 
; 220  :         if(bClear)

	cmp	DWORD PTR _bClear$[ebp], 0
	je	SHORT $LN1@SetSize

; 221  :             zero(&array[oldNum], sizeof(T)*(num-oldNum));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, DWORD PTR _oldNum$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _oldNum$[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	?zero@@YGXPAXI@Z			; zero
$LN1@SetSize:

; 222  : 
; 223  :         return TRUE;

	mov	eax, 1
$LN5@SetSize:

; 224  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetSize@?$List@I@@QAEHI@Z ENDP				; List<unsigned int>::SetSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Clear@?$List@I@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Clear@?$List@I@@QAEXXZ PROC				; List<unsigned int>::Clear, COMDAT
; _this$ = ecx

; 334  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 335  :         if(array)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@Clear

; 336  :         {
; 337  :             /*if(IsBadWritePtr(array, sizeof(T)*num))
; 338  :                 CrashError(TEXT("what the.."));*/
; 339  :             Free(array);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	?Free@@YAXPAX@Z				; Free
	add	esp, 4

; 340  :             array = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 341  :             num = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
$LN2@Clear:

; 342  :         }
; 343  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?Clear@?$List@I@@QAEXXZ ENDP				; List<unsigned int>::Clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??0?$List@UVect@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$List@UVect@@@@QAE@XZ PROC				; List<Vect>::List<Vect>, COMDAT
; _this$ = ecx

; 35   :     inline List() : array(NULL), num(0) {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$List@UVect@@@@QAE@XZ ENDP				; List<Vect>::List<Vect>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??1?$List@UVect@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$List@UVect@@@@QAE@XZ PROC				; List<Vect>::~List<Vect>, COMDAT
; _this$ = ecx

; 37   :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 38   :         Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$List@UVect@@@@QAEXXZ		; List<Vect>::Clear

; 39   :     }

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$List@UVect@@@@QAE@XZ ENDP				; List<Vect>::~List<Vect>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?SetSize@?$List@UVect@@@@QAEHI@Z
_TEXT	SEGMENT
_bClear$ = -16						; size = 4
_oldNum$ = -12						; size = 4
tv70 = -8						; size = 4
_this$ = -4						; size = 4
_n$ = 8							; size = 4
?SetSize@?$List@UVect@@@@QAEHI@Z PROC			; List<Vect>::SetSize, COMDAT
; _this$ = ecx

; 205  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 206  :         if(num == n)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _n$[ebp]
	jne	SHORT $LN4@SetSize

; 207  :             return FALSE;

	xor	eax, eax
	jmp	$LN5@SetSize
	jmp	SHORT $LN3@SetSize
$LN4@SetSize:

; 208  :         else if(!n)

	cmp	DWORD PTR _n$[ebp], 0
	jne	SHORT $LN3@SetSize

; 209  :         {
; 210  :             Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$List@UVect@@@@QAEXXZ		; List<Vect>::Clear

; 211  :             return TRUE;

	mov	eax, 1
	jmp	$LN5@SetSize
$LN3@SetSize:

; 212  :         }
; 213  : 
; 214  :         BOOL bClear=(n>num);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _n$[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jbe	SHORT $LN7@SetSize
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN8@SetSize
$LN7@SetSize:
	mov	DWORD PTR tv70[ebp], 0
$LN8@SetSize:
	mov	ecx, DWORD PTR tv70[ebp]
	mov	DWORD PTR _bClear$[ebp], ecx

; 215  :         UINT oldNum=num;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _oldNum$[ebp], eax

; 216  : 
; 217  :         num = n;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _n$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 218  :         array = (T*)ReAllocate(array, sizeof(T)*num);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 4
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 219  : 
; 220  :         if(bClear)

	cmp	DWORD PTR _bClear$[ebp], 0
	je	SHORT $LN1@SetSize

; 221  :             zero(&array[oldNum], sizeof(T)*(num-oldNum));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, DWORD PTR _oldNum$[ebp]
	shl	eax, 4
	push	eax
	mov	ecx, DWORD PTR _oldNum$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx]
	push	ecx
	call	?zero@@YGXPAXI@Z			; zero
$LN1@SetSize:

; 222  : 
; 223  :         return TRUE;

	mov	eax, 1
$LN5@SetSize:

; 224  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetSize@?$List@UVect@@@@QAEHI@Z ENDP			; List<Vect>::SetSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Clear@?$List@UVect@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Clear@?$List@UVect@@@@QAEXXZ PROC			; List<Vect>::Clear, COMDAT
; _this$ = ecx

; 334  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 335  :         if(array)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@Clear

; 336  :         {
; 337  :             /*if(IsBadWritePtr(array, sizeof(T)*num))
; 338  :                 CrashError(TEXT("what the.."));*/
; 339  :             Free(array);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	?Free@@YAXPAX@Z				; Free
	add	esp, 4

; 340  :             array = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 341  :             num = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
$LN2@Clear:

; 342  :         }
; 343  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?Clear@?$List@UVect@@@@QAEXXZ ENDP			; List<Vect>::Clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??A?$List@UVect@@@@QAEAAUVect@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
??A?$List@UVect@@@@QAEAAUVect@@I@Z PROC			; List<Vect>::operator[], COMDAT
; _this$ = ecx

; 379  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 380  :         assert(index < num);
; 381  :         if(index >= num) {DumpError(TEXT("Out of range!  List<%S>::operator[](%d)"), typeid(T).name(), index); return array[0];}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN1@operator
	mov	edx, DWORD PTR _index$[ebp]
	push	edx
	push	OFFSET ?__type_info_root_node@@3U__type_info_node@@A ; __type_info_root_node
	mov	ecx, OFFSET ??_R0?AUVect@@@8
	call	?name@type_info@@QBEPBDPAU__type_info_node@@@Z ; type_info::name
	push	eax
	push	OFFSET ??_C@_1FA@KCLJOBNL@?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CB?$AA?5?$AA?5?$AAL?$AAi?$AAs?$AAt?$AA?$DM?$AA?$CF?$AAS?$AA?$DO?$AA?3?$AA?3?$AAo?$AAp?$AAe?$AAr?$AAa?$AAt?$AAo@
	call	DWORD PTR __imp_?DumpError@@YAXPB_WZZ
	mov	eax, 16					; 00000010H
	imul	eax, eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN3@operator
$LN1@operator:

; 382  :         return array[index];

	mov	eax, DWORD PTR _index$[ebp]
	shl	eax, 4
	mov	edx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [edx]
$LN3@operator:

; 383  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$List@UVect@@@@QAEAAUVect@@I@Z ENDP			; List<Vect>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?SetSize@?$List@UVect2@@@@QAEHI@Z
_TEXT	SEGMENT
_bClear$ = -16						; size = 4
_oldNum$ = -12						; size = 4
tv70 = -8						; size = 4
_this$ = -4						; size = 4
_n$ = 8							; size = 4
?SetSize@?$List@UVect2@@@@QAEHI@Z PROC			; List<Vect2>::SetSize, COMDAT
; _this$ = ecx

; 205  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 206  :         if(num == n)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _n$[ebp]
	jne	SHORT $LN4@SetSize

; 207  :             return FALSE;

	xor	eax, eax
	jmp	$LN5@SetSize
	jmp	SHORT $LN3@SetSize
$LN4@SetSize:

; 208  :         else if(!n)

	cmp	DWORD PTR _n$[ebp], 0
	jne	SHORT $LN3@SetSize

; 209  :         {
; 210  :             Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$List@UVect2@@@@QAEXXZ		; List<Vect2>::Clear

; 211  :             return TRUE;

	mov	eax, 1
	jmp	$LN5@SetSize
$LN3@SetSize:

; 212  :         }
; 213  : 
; 214  :         BOOL bClear=(n>num);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _n$[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jbe	SHORT $LN7@SetSize
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN8@SetSize
$LN7@SetSize:
	mov	DWORD PTR tv70[ebp], 0
$LN8@SetSize:
	mov	ecx, DWORD PTR tv70[ebp]
	mov	DWORD PTR _bClear$[ebp], ecx

; 215  :         UINT oldNum=num;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _oldNum$[ebp], eax

; 216  : 
; 217  :         num = n;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _n$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 218  :         array = (T*)ReAllocate(array, sizeof(T)*num);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 3
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 219  : 
; 220  :         if(bClear)

	cmp	DWORD PTR _bClear$[ebp], 0
	je	SHORT $LN1@SetSize

; 221  :             zero(&array[oldNum], sizeof(T)*(num-oldNum));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, DWORD PTR _oldNum$[ebp]
	shl	eax, 3
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _oldNum$[ebp]
	lea	ecx, DWORD PTR [edx+eax*8]
	push	ecx
	call	?zero@@YGXPAXI@Z			; zero
$LN1@SetSize:

; 222  : 
; 223  :         return TRUE;

	mov	eax, 1
$LN5@SetSize:

; 224  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetSize@?$List@UVect2@@@@QAEHI@Z ENDP			; List<Vect2>::SetSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Clear@?$List@UVect2@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Clear@?$List@UVect2@@@@QAEXXZ PROC			; List<Vect2>::Clear, COMDAT
; _this$ = ecx

; 334  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 335  :         if(array)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@Clear

; 336  :         {
; 337  :             /*if(IsBadWritePtr(array, sizeof(T)*num))
; 338  :                 CrashError(TEXT("what the.."));*/
; 339  :             Free(array);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	?Free@@YAXPAX@Z				; Free
	add	esp, 4

; 340  :             array = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 341  :             num = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
$LN2@Clear:

; 342  :         }
; 343  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?Clear@?$List@UVect2@@@@QAEXXZ ENDP			; List<Vect2>::Clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??A?$List@UVect2@@@@QAEAAUVect2@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
??A?$List@UVect2@@@@QAEAAUVect2@@I@Z PROC		; List<Vect2>::operator[], COMDAT
; _this$ = ecx

; 379  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 380  :         assert(index < num);
; 381  :         if(index >= num) {DumpError(TEXT("Out of range!  List<%S>::operator[](%d)"), typeid(T).name(), index); return array[0];}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN1@operator
	mov	edx, DWORD PTR _index$[ebp]
	push	edx
	push	OFFSET ?__type_info_root_node@@3U__type_info_node@@A ; __type_info_root_node
	mov	ecx, OFFSET ??_R0?AUVect2@@@8
	call	?name@type_info@@QBEPBDPAU__type_info_node@@@Z ; type_info::name
	push	eax
	push	OFFSET ??_C@_1FA@KCLJOBNL@?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CB?$AA?5?$AA?5?$AAL?$AAi?$AAs?$AAt?$AA?$DM?$AA?$CF?$AAS?$AA?$DO?$AA?3?$AA?3?$AAo?$AAp?$AAe?$AAr?$AAa?$AAt?$AAo@
	call	DWORD PTR __imp_?DumpError@@YAXPB_WZZ
	mov	eax, 8
	imul	eax, eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN3@operator
$LN1@operator:

; 382  :         return array[index];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _index$[ebp]
	lea	eax, DWORD PTR [eax+ecx*8]
$LN3@operator:

; 383  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$List@UVect2@@@@QAEAAUVect2@@I@Z ENDP		; List<Vect2>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??0?$List@VUVCoordList@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$List@VUVCoordList@@@@QAE@XZ PROC			; List<UVCoordList>::List<UVCoordList>, COMDAT
; _this$ = ecx

; 35   :     inline List() : array(NULL), num(0) {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$List@VUVCoordList@@@@QAE@XZ ENDP			; List<UVCoordList>::List<UVCoordList>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??1?$List@VUVCoordList@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$List@VUVCoordList@@@@QAE@XZ PROC			; List<UVCoordList>::~List<UVCoordList>, COMDAT
; _this$ = ecx

; 37   :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 38   :         Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$List@VUVCoordList@@@@QAEXXZ	; List<UVCoordList>::Clear

; 39   :     }

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$List@VUVCoordList@@@@QAE@XZ ENDP			; List<UVCoordList>::~List<UVCoordList>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?SetSize@?$List@VUVCoordList@@@@QAEHI@Z
_TEXT	SEGMENT
_bClear$ = -16						; size = 4
_oldNum$ = -12						; size = 4
tv70 = -8						; size = 4
_this$ = -4						; size = 4
_n$ = 8							; size = 4
?SetSize@?$List@VUVCoordList@@@@QAEHI@Z PROC		; List<UVCoordList>::SetSize, COMDAT
; _this$ = ecx

; 205  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 206  :         if(num == n)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _n$[ebp]
	jne	SHORT $LN4@SetSize

; 207  :             return FALSE;

	xor	eax, eax
	jmp	$LN5@SetSize
	jmp	SHORT $LN3@SetSize
$LN4@SetSize:

; 208  :         else if(!n)

	cmp	DWORD PTR _n$[ebp], 0
	jne	SHORT $LN3@SetSize

; 209  :         {
; 210  :             Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$List@VUVCoordList@@@@QAEXXZ	; List<UVCoordList>::Clear

; 211  :             return TRUE;

	mov	eax, 1
	jmp	$LN5@SetSize
$LN3@SetSize:

; 212  :         }
; 213  : 
; 214  :         BOOL bClear=(n>num);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _n$[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jbe	SHORT $LN7@SetSize
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN8@SetSize
$LN7@SetSize:
	mov	DWORD PTR tv70[ebp], 0
$LN8@SetSize:
	mov	ecx, DWORD PTR tv70[ebp]
	mov	DWORD PTR _bClear$[ebp], ecx

; 215  :         UINT oldNum=num;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _oldNum$[ebp], eax

; 216  : 
; 217  :         num = n;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _n$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 218  :         array = (T*)ReAllocate(array, sizeof(T)*num);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 3
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 219  : 
; 220  :         if(bClear)

	cmp	DWORD PTR _bClear$[ebp], 0
	je	SHORT $LN1@SetSize

; 221  :             zero(&array[oldNum], sizeof(T)*(num-oldNum));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, DWORD PTR _oldNum$[ebp]
	shl	eax, 3
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _oldNum$[ebp]
	lea	ecx, DWORD PTR [edx+eax*8]
	push	ecx
	call	?zero@@YGXPAXI@Z			; zero
$LN1@SetSize:

; 222  : 
; 223  :         return TRUE;

	mov	eax, 1
$LN5@SetSize:

; 224  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetSize@?$List@VUVCoordList@@@@QAEHI@Z ENDP		; List<UVCoordList>::SetSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Clear@?$List@VUVCoordList@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Clear@?$List@VUVCoordList@@@@QAEXXZ PROC		; List<UVCoordList>::Clear, COMDAT
; _this$ = ecx

; 334  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 335  :         if(array)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@Clear

; 336  :         {
; 337  :             /*if(IsBadWritePtr(array, sizeof(T)*num))
; 338  :                 CrashError(TEXT("what the.."));*/
; 339  :             Free(array);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	?Free@@YAXPAX@Z				; Free
	add	esp, 4

; 340  :             array = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 341  :             num = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
$LN2@Clear:

; 342  :         }
; 343  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?Clear@?$List@VUVCoordList@@@@QAEXXZ ENDP		; List<UVCoordList>::Clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??A?$List@VUVCoordList@@@@QAEAAVUVCoordList@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
??A?$List@VUVCoordList@@@@QAEAAVUVCoordList@@I@Z PROC	; List<UVCoordList>::operator[], COMDAT
; _this$ = ecx

; 379  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 380  :         assert(index < num);
; 381  :         if(index >= num) {DumpError(TEXT("Out of range!  List<%S>::operator[](%d)"), typeid(T).name(), index); return array[0];}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN1@operator
	mov	edx, DWORD PTR _index$[ebp]
	push	edx
	push	OFFSET ?__type_info_root_node@@3U__type_info_node@@A ; __type_info_root_node
	mov	ecx, OFFSET ??_R0?AVUVCoordList@@@8
	call	?name@type_info@@QBEPBDPAU__type_info_node@@@Z ; type_info::name
	push	eax
	push	OFFSET ??_C@_1FA@KCLJOBNL@?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CB?$AA?5?$AA?5?$AAL?$AAi?$AAs?$AAt?$AA?$DM?$AA?$CF?$AAS?$AA?$DO?$AA?3?$AA?3?$AAo?$AAp?$AAe?$AAr?$AAa?$AAt?$AAo@
	call	DWORD PTR __imp_?DumpError@@YAXPB_WZZ
	mov	eax, 8
	imul	eax, eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN3@operator
$LN1@operator:

; 382  :         return array[index];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _index$[ebp]
	lea	eax, DWORD PTR [eax+ecx*8]
$LN3@operator:

; 383  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$List@VUVCoordList@@@@QAEAAVUVCoordList@@I@Z ENDP	; List<UVCoordList>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??A?$List@UMatrix@@@@QAEAAUMatrix@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
??A?$List@UMatrix@@@@QAEAAUMatrix@@I@Z PROC		; List<Matrix>::operator[], COMDAT
; _this$ = ecx

; 379  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 380  :         assert(index < num);
; 381  :         if(index >= num) {DumpError(TEXT("Out of range!  List<%S>::operator[](%d)"), typeid(T).name(), index); return array[0];}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN1@operator
	mov	edx, DWORD PTR _index$[ebp]
	push	edx
	push	OFFSET ?__type_info_root_node@@3U__type_info_node@@A ; __type_info_root_node
	mov	ecx, OFFSET ??_R0?AUMatrix@@@8
	call	?name@type_info@@QBEPBDPAU__type_info_node@@@Z ; type_info::name
	push	eax
	push	OFFSET ??_C@_1FA@KCLJOBNL@?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CB?$AA?5?$AA?5?$AAL?$AAi?$AAs?$AAt?$AA?$DM?$AA?$CF?$AAS?$AA?$DO?$AA?3?$AA?3?$AAo?$AAp?$AAe?$AAr?$AAa?$AAt?$AAo@
	call	DWORD PTR __imp_?DumpError@@YAXPB_WZZ
	mov	eax, 64					; 00000040H
	imul	eax, eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN3@operator
$LN1@operator:

; 382  :         return array[index];

	mov	eax, DWORD PTR _index$[ebp]
	shl	eax, 6
	mov	edx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [edx]
$LN3@operator:

; 383  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$List@UMatrix@@@@QAEAAUMatrix@@I@Z ENDP		; List<Matrix>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Clear@?$List@UMonitorInfo@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Clear@?$List@UMonitorInfo@@@@QAEXXZ PROC		; List<MonitorInfo>::Clear, COMDAT
; _this$ = ecx

; 334  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 335  :         if(array)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@Clear

; 336  :         {
; 337  :             /*if(IsBadWritePtr(array, sizeof(T)*num))
; 338  :                 CrashError(TEXT("what the.."));*/
; 339  :             Free(array);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	?Free@@YAXPAX@Z				; Free
	add	esp, 4

; 340  :             array = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 341  :             num = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
$LN2@Clear:

; 342  :         }
; 343  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?Clear@?$List@UMonitorInfo@@@@QAEXXZ ENDP		; List<MonitorInfo>::Clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?CreateNew@?$List@UMonitorInfo@@@@QAEPAUMonitorInfo@@XZ
_TEXT	SEGMENT
_value$ = -8						; size = 4
_this$ = -4						; size = 4
?CreateNew@?$List@UMonitorInfo@@@@QAEPAUMonitorInfo@@XZ PROC ; List<MonitorInfo>::CreateNew, COMDAT
; _this$ = ecx

; 346  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 347  :         SetSize(num+1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSize@?$List@UMonitorInfo@@@@QAEHI@Z	; List<MonitorInfo>::SetSize

; 348  : 
; 349  :         T *value = &array[num-1];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1
	imul	ecx, eax, 24
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx]
	mov	DWORD PTR _value$[ebp], ecx

; 350  : 
; 351  :         return value;

	mov	eax, DWORD PTR _value$[ebp]

; 352  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?CreateNew@?$List@UMonitorInfo@@@@QAEPAUMonitorInfo@@XZ ENDP ; List<MonitorInfo>::CreateNew
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Num@?$List@UDeviceOutputData@@@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Num@?$List@UDeviceOutputData@@@@QBEIXZ PROC		; List<DeviceOutputData>::Num, COMDAT
; _this$ = ecx

; 42   :     inline unsigned int Num() const     {return num;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	esp, ebp
	pop	ebp
	ret	0
?Num@?$List@UDeviceOutputData@@@@QBEIXZ ENDP		; List<DeviceOutputData>::Num
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Clear@?$List@UDeviceOutputData@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Clear@?$List@UDeviceOutputData@@@@QAEXXZ PROC		; List<DeviceOutputData>::Clear, COMDAT
; _this$ = ecx

; 334  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 335  :         if(array)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@Clear

; 336  :         {
; 337  :             /*if(IsBadWritePtr(array, sizeof(T)*num))
; 338  :                 CrashError(TEXT("what the.."));*/
; 339  :             Free(array);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	?Free@@YAXPAX@Z				; Free
	add	esp, 4

; 340  :             array = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 341  :             num = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
$LN2@Clear:

; 342  :         }
; 343  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?Clear@?$List@UDeviceOutputData@@@@QAEXXZ ENDP		; List<DeviceOutputData>::Clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?CreateNew@?$List@UDeviceOutputData@@@@QAEPAUDeviceOutputData@@XZ
_TEXT	SEGMENT
_value$ = -8						; size = 4
_this$ = -4						; size = 4
?CreateNew@?$List@UDeviceOutputData@@@@QAEPAUDeviceOutputData@@XZ PROC ; List<DeviceOutputData>::CreateNew, COMDAT
; _this$ = ecx

; 346  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 347  :         SetSize(num+1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSize@?$List@UDeviceOutputData@@@@QAEHI@Z ; List<DeviceOutputData>::SetSize

; 348  : 
; 349  :         T *value = &array[num-1];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1
	imul	ecx, eax, 24
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx]
	mov	DWORD PTR _value$[ebp], ecx

; 350  : 
; 351  :         return value;

	mov	eax, DWORD PTR _value$[ebp]

; 352  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?CreateNew@?$List@UDeviceOutputData@@@@QAEPAUDeviceOutputData@@XZ ENDP ; List<DeviceOutputData>::CreateNew
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??A?$List@UDeviceOutputData@@@@QAEAAUDeviceOutputData@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
??A?$List@UDeviceOutputData@@@@QAEAAUDeviceOutputData@@I@Z PROC ; List<DeviceOutputData>::operator[], COMDAT
; _this$ = ecx

; 379  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 380  :         assert(index < num);
; 381  :         if(index >= num) {DumpError(TEXT("Out of range!  List<%S>::operator[](%d)"), typeid(T).name(), index); return array[0];}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN1@operator
	mov	edx, DWORD PTR _index$[ebp]
	push	edx
	push	OFFSET ?__type_info_root_node@@3U__type_info_node@@A ; __type_info_root_node
	mov	ecx, OFFSET ??_R0?AUDeviceOutputData@@@8
	call	?name@type_info@@QBEPBDPAU__type_info_node@@@Z ; type_info::name
	push	eax
	push	OFFSET ??_C@_1FA@KCLJOBNL@?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CB?$AA?5?$AA?5?$AAL?$AAi?$AAs?$AAt?$AA?$DM?$AA?$CF?$AAS?$AA?$DO?$AA?3?$AA?3?$AAo?$AAp?$AAe?$AAr?$AAa?$AAt?$AAo@
	call	DWORD PTR __imp_?DumpError@@YAXPB_WZZ
	mov	eax, 24					; 00000018H
	imul	eax, eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN3@operator
$LN1@operator:

; 382  :         return array[index];

	imul	eax, DWORD PTR _index$[ebp], 24
	mov	edx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [edx]
$LN3@operator:

; 383  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$List@UDeviceOutputData@@@@QAEAAUDeviceOutputData@@I@Z ENDP ; List<DeviceOutputData>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??0?$List@PAUID3D10Buffer@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$List@PAUID3D10Buffer@@@@QAE@XZ PROC		; List<ID3D10Buffer *>::List<ID3D10Buffer *>, COMDAT
; _this$ = ecx

; 35   :     inline List() : array(NULL), num(0) {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$List@PAUID3D10Buffer@@@@QAE@XZ ENDP		; List<ID3D10Buffer *>::List<ID3D10Buffer *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??1?$List@PAUID3D10Buffer@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$List@PAUID3D10Buffer@@@@QAE@XZ PROC		; List<ID3D10Buffer *>::~List<ID3D10Buffer *>, COMDAT
; _this$ = ecx

; 37   :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 38   :         Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$List@PAUID3D10Buffer@@@@QAEXXZ	; List<ID3D10Buffer *>::Clear

; 39   :     }

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$List@PAUID3D10Buffer@@@@QAE@XZ ENDP		; List<ID3D10Buffer *>::~List<ID3D10Buffer *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Array@?$List@PAUID3D10Buffer@@@@QBEPAPAUID3D10Buffer@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Array@?$List@PAUID3D10Buffer@@@@QBEPAPAUID3D10Buffer@@XZ PROC ; List<ID3D10Buffer *>::Array, COMDAT
; _this$ = ecx

; 41   :     inline T* Array() const             {return array;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	esp, ebp
	pop	ebp
	ret	0
?Array@?$List@PAUID3D10Buffer@@@@QBEPAPAUID3D10Buffer@@XZ ENDP ; List<ID3D10Buffer *>::Array
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Num@?$List@PAUID3D10Buffer@@@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Num@?$List@PAUID3D10Buffer@@@@QBEIXZ PROC		; List<ID3D10Buffer *>::Num, COMDAT
; _this$ = ecx

; 42   :     inline unsigned int Num() const     {return num;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	esp, ebp
	pop	ebp
	ret	0
?Num@?$List@PAUID3D10Buffer@@@@QBEIXZ ENDP		; List<ID3D10Buffer *>::Num
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?SetSize@?$List@PAUID3D10Buffer@@@@QAEHI@Z
_TEXT	SEGMENT
_bClear$ = -16						; size = 4
_oldNum$ = -12						; size = 4
tv70 = -8						; size = 4
_this$ = -4						; size = 4
_n$ = 8							; size = 4
?SetSize@?$List@PAUID3D10Buffer@@@@QAEHI@Z PROC		; List<ID3D10Buffer *>::SetSize, COMDAT
; _this$ = ecx

; 205  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 206  :         if(num == n)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _n$[ebp]
	jne	SHORT $LN4@SetSize

; 207  :             return FALSE;

	xor	eax, eax
	jmp	$LN5@SetSize
	jmp	SHORT $LN3@SetSize
$LN4@SetSize:

; 208  :         else if(!n)

	cmp	DWORD PTR _n$[ebp], 0
	jne	SHORT $LN3@SetSize

; 209  :         {
; 210  :             Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$List@PAUID3D10Buffer@@@@QAEXXZ	; List<ID3D10Buffer *>::Clear

; 211  :             return TRUE;

	mov	eax, 1
	jmp	$LN5@SetSize
$LN3@SetSize:

; 212  :         }
; 213  : 
; 214  :         BOOL bClear=(n>num);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _n$[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jbe	SHORT $LN7@SetSize
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN8@SetSize
$LN7@SetSize:
	mov	DWORD PTR tv70[ebp], 0
$LN8@SetSize:
	mov	ecx, DWORD PTR tv70[ebp]
	mov	DWORD PTR _bClear$[ebp], ecx

; 215  :         UINT oldNum=num;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _oldNum$[ebp], eax

; 216  : 
; 217  :         num = n;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _n$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 218  :         array = (T*)ReAllocate(array, sizeof(T)*num);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 219  : 
; 220  :         if(bClear)

	cmp	DWORD PTR _bClear$[ebp], 0
	je	SHORT $LN1@SetSize

; 221  :             zero(&array[oldNum], sizeof(T)*(num-oldNum));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, DWORD PTR _oldNum$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _oldNum$[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	?zero@@YGXPAXI@Z			; zero
$LN1@SetSize:

; 222  : 
; 223  :         return TRUE;

	mov	eax, 1
$LN5@SetSize:

; 224  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetSize@?$List@PAUID3D10Buffer@@@@QAEHI@Z ENDP		; List<ID3D10Buffer *>::SetSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??0?$List@USavedBlendState@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$List@USavedBlendState@@@@QAE@XZ PROC		; List<SavedBlendState>::List<SavedBlendState>, COMDAT
; _this$ = ecx

; 35   :     inline List() : array(NULL), num(0) {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$List@USavedBlendState@@@@QAE@XZ ENDP		; List<SavedBlendState>::List<SavedBlendState>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??1?$List@USavedBlendState@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$List@USavedBlendState@@@@QAE@XZ PROC		; List<SavedBlendState>::~List<SavedBlendState>, COMDAT
; _this$ = ecx

; 37   :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 38   :         Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$List@USavedBlendState@@@@QAEXXZ ; List<SavedBlendState>::Clear

; 39   :     }

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$List@USavedBlendState@@@@QAE@XZ ENDP		; List<SavedBlendState>::~List<SavedBlendState>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Num@?$List@USavedBlendState@@@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Num@?$List@USavedBlendState@@@@QBEIXZ PROC		; List<SavedBlendState>::Num, COMDAT
; _this$ = ecx

; 42   :     inline unsigned int Num() const     {return num;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	esp, ebp
	pop	ebp
	ret	0
?Num@?$List@USavedBlendState@@@@QBEIXZ ENDP		; List<SavedBlendState>::Num
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?CreateNew@?$List@USavedBlendState@@@@QAEPAUSavedBlendState@@XZ
_TEXT	SEGMENT
_value$ = -8						; size = 4
_this$ = -4						; size = 4
?CreateNew@?$List@USavedBlendState@@@@QAEPAUSavedBlendState@@XZ PROC ; List<SavedBlendState>::CreateNew, COMDAT
; _this$ = ecx

; 346  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 347  :         SetSize(num+1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSize@?$List@USavedBlendState@@@@QAEHI@Z ; List<SavedBlendState>::SetSize

; 348  : 
; 349  :         T *value = &array[num-1];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1
	imul	ecx, eax, 12
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx]
	mov	DWORD PTR _value$[ebp], ecx

; 350  : 
; 351  :         return value;

	mov	eax, DWORD PTR _value$[ebp]

; 352  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?CreateNew@?$List@USavedBlendState@@@@QAEPAUSavedBlendState@@XZ ENDP ; List<SavedBlendState>::CreateNew
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??A?$List@USavedBlendState@@@@QAEAAUSavedBlendState@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
??A?$List@USavedBlendState@@@@QAEAAUSavedBlendState@@I@Z PROC ; List<SavedBlendState>::operator[], COMDAT
; _this$ = ecx

; 379  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 380  :         assert(index < num);
; 381  :         if(index >= num) {DumpError(TEXT("Out of range!  List<%S>::operator[](%d)"), typeid(T).name(), index); return array[0];}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN1@operator
	mov	edx, DWORD PTR _index$[ebp]
	push	edx
	push	OFFSET ?__type_info_root_node@@3U__type_info_node@@A ; __type_info_root_node
	mov	ecx, OFFSET ??_R0?AUSavedBlendState@@@8
	call	?name@type_info@@QBEPBDPAU__type_info_node@@@Z ; type_info::name
	push	eax
	push	OFFSET ??_C@_1FA@KCLJOBNL@?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CB?$AA?5?$AA?5?$AAL?$AAi?$AAs?$AAt?$AA?$DM?$AA?$CF?$AAS?$AA?$DO?$AA?3?$AA?3?$AAo?$AAp?$AAe?$AAr?$AAa?$AAt?$AAo@
	call	DWORD PTR __imp_?DumpError@@YAXPB_WZZ
	mov	eax, 12					; 0000000cH
	imul	eax, eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN3@operator
$LN1@operator:

; 382  :         return array[index];

	imul	eax, DWORD PTR _index$[ebp], 12
	mov	edx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [edx]
$LN3@operator:

; 383  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$List@USavedBlendState@@@@QAEAAUSavedBlendState@@I@Z ENDP ; List<SavedBlendState>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?SetSize@?$List@UMonitorInfo@@@@QAEHI@Z
_TEXT	SEGMENT
_bClear$ = -16						; size = 4
_oldNum$ = -12						; size = 4
tv70 = -8						; size = 4
_this$ = -4						; size = 4
_n$ = 8							; size = 4
?SetSize@?$List@UMonitorInfo@@@@QAEHI@Z PROC		; List<MonitorInfo>::SetSize, COMDAT
; _this$ = ecx

; 205  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 206  :         if(num == n)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _n$[ebp]
	jne	SHORT $LN4@SetSize

; 207  :             return FALSE;

	xor	eax, eax
	jmp	$LN5@SetSize
	jmp	SHORT $LN3@SetSize
$LN4@SetSize:

; 208  :         else if(!n)

	cmp	DWORD PTR _n$[ebp], 0
	jne	SHORT $LN3@SetSize

; 209  :         {
; 210  :             Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$List@UMonitorInfo@@@@QAEXXZ	; List<MonitorInfo>::Clear

; 211  :             return TRUE;

	mov	eax, 1
	jmp	$LN5@SetSize
$LN3@SetSize:

; 212  :         }
; 213  : 
; 214  :         BOOL bClear=(n>num);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _n$[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jbe	SHORT $LN7@SetSize
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN8@SetSize
$LN7@SetSize:
	mov	DWORD PTR tv70[ebp], 0
$LN8@SetSize:
	mov	ecx, DWORD PTR tv70[ebp]
	mov	DWORD PTR _bClear$[ebp], ecx

; 215  :         UINT oldNum=num;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _oldNum$[ebp], eax

; 216  : 
; 217  :         num = n;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _n$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 218  :         array = (T*)ReAllocate(array, sizeof(T)*num);

	mov	eax, DWORD PTR _this$[ebp]
	imul	ecx, DWORD PTR [eax+4], 24
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 219  : 
; 220  :         if(bClear)

	cmp	DWORD PTR _bClear$[ebp], 0
	je	SHORT $LN1@SetSize

; 221  :             zero(&array[oldNum], sizeof(T)*(num-oldNum));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, DWORD PTR _oldNum$[ebp]
	imul	ecx, eax, 24
	push	ecx
	imul	edx, DWORD PTR _oldNum$[ebp], 24
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax]
	push	edx
	call	?zero@@YGXPAXI@Z			; zero
$LN1@SetSize:

; 222  : 
; 223  :         return TRUE;

	mov	eax, 1
$LN5@SetSize:

; 224  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetSize@?$List@UMonitorInfo@@@@QAEHI@Z ENDP		; List<MonitorInfo>::SetSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?SetSize@?$List@UDeviceOutputData@@@@QAEHI@Z
_TEXT	SEGMENT
_bClear$ = -16						; size = 4
_oldNum$ = -12						; size = 4
tv70 = -8						; size = 4
_this$ = -4						; size = 4
_n$ = 8							; size = 4
?SetSize@?$List@UDeviceOutputData@@@@QAEHI@Z PROC	; List<DeviceOutputData>::SetSize, COMDAT
; _this$ = ecx

; 205  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 206  :         if(num == n)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _n$[ebp]
	jne	SHORT $LN4@SetSize

; 207  :             return FALSE;

	xor	eax, eax
	jmp	$LN5@SetSize
	jmp	SHORT $LN3@SetSize
$LN4@SetSize:

; 208  :         else if(!n)

	cmp	DWORD PTR _n$[ebp], 0
	jne	SHORT $LN3@SetSize

; 209  :         {
; 210  :             Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$List@UDeviceOutputData@@@@QAEXXZ ; List<DeviceOutputData>::Clear

; 211  :             return TRUE;

	mov	eax, 1
	jmp	$LN5@SetSize
$LN3@SetSize:

; 212  :         }
; 213  : 
; 214  :         BOOL bClear=(n>num);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _n$[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jbe	SHORT $LN7@SetSize
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN8@SetSize
$LN7@SetSize:
	mov	DWORD PTR tv70[ebp], 0
$LN8@SetSize:
	mov	ecx, DWORD PTR tv70[ebp]
	mov	DWORD PTR _bClear$[ebp], ecx

; 215  :         UINT oldNum=num;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _oldNum$[ebp], eax

; 216  : 
; 217  :         num = n;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _n$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 218  :         array = (T*)ReAllocate(array, sizeof(T)*num);

	mov	eax, DWORD PTR _this$[ebp]
	imul	ecx, DWORD PTR [eax+4], 24
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 219  : 
; 220  :         if(bClear)

	cmp	DWORD PTR _bClear$[ebp], 0
	je	SHORT $LN1@SetSize

; 221  :             zero(&array[oldNum], sizeof(T)*(num-oldNum));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, DWORD PTR _oldNum$[ebp]
	imul	ecx, eax, 24
	push	ecx
	imul	edx, DWORD PTR _oldNum$[ebp], 24
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax]
	push	edx
	call	?zero@@YGXPAXI@Z			; zero
$LN1@SetSize:

; 222  : 
; 223  :         return TRUE;

	mov	eax, 1
$LN5@SetSize:

; 224  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetSize@?$List@UDeviceOutputData@@@@QAEHI@Z ENDP	; List<DeviceOutputData>::SetSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Clear@?$List@PAUID3D10Buffer@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Clear@?$List@PAUID3D10Buffer@@@@QAEXXZ PROC		; List<ID3D10Buffer *>::Clear, COMDAT
; _this$ = ecx

; 334  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 335  :         if(array)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@Clear

; 336  :         {
; 337  :             /*if(IsBadWritePtr(array, sizeof(T)*num))
; 338  :                 CrashError(TEXT("what the.."));*/
; 339  :             Free(array);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	?Free@@YAXPAX@Z				; Free
	add	esp, 4

; 340  :             array = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 341  :             num = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
$LN2@Clear:

; 342  :         }
; 343  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?Clear@?$List@PAUID3D10Buffer@@@@QAEXXZ ENDP		; List<ID3D10Buffer *>::Clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?SetSize@?$List@USavedBlendState@@@@QAEHI@Z
_TEXT	SEGMENT
_bClear$ = -16						; size = 4
_oldNum$ = -12						; size = 4
tv70 = -8						; size = 4
_this$ = -4						; size = 4
_n$ = 8							; size = 4
?SetSize@?$List@USavedBlendState@@@@QAEHI@Z PROC	; List<SavedBlendState>::SetSize, COMDAT
; _this$ = ecx

; 205  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 206  :         if(num == n)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _n$[ebp]
	jne	SHORT $LN4@SetSize

; 207  :             return FALSE;

	xor	eax, eax
	jmp	$LN5@SetSize
	jmp	SHORT $LN3@SetSize
$LN4@SetSize:

; 208  :         else if(!n)

	cmp	DWORD PTR _n$[ebp], 0
	jne	SHORT $LN3@SetSize

; 209  :         {
; 210  :             Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$List@USavedBlendState@@@@QAEXXZ ; List<SavedBlendState>::Clear

; 211  :             return TRUE;

	mov	eax, 1
	jmp	$LN5@SetSize
$LN3@SetSize:

; 212  :         }
; 213  : 
; 214  :         BOOL bClear=(n>num);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _n$[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jbe	SHORT $LN7@SetSize
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN8@SetSize
$LN7@SetSize:
	mov	DWORD PTR tv70[ebp], 0
$LN8@SetSize:
	mov	ecx, DWORD PTR tv70[ebp]
	mov	DWORD PTR _bClear$[ebp], ecx

; 215  :         UINT oldNum=num;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _oldNum$[ebp], eax

; 216  : 
; 217  :         num = n;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _n$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 218  :         array = (T*)ReAllocate(array, sizeof(T)*num);

	mov	eax, DWORD PTR _this$[ebp]
	imul	ecx, DWORD PTR [eax+4], 12
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 219  : 
; 220  :         if(bClear)

	cmp	DWORD PTR _bClear$[ebp], 0
	je	SHORT $LN1@SetSize

; 221  :             zero(&array[oldNum], sizeof(T)*(num-oldNum));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, DWORD PTR _oldNum$[ebp]
	imul	ecx, eax, 12
	push	ecx
	imul	edx, DWORD PTR _oldNum$[ebp], 12
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax]
	push	edx
	call	?zero@@YGXPAXI@Z			; zero
$LN1@SetSize:

; 222  : 
; 223  :         return TRUE;

	mov	eax, 1
$LN5@SetSize:

; 224  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetSize@?$List@USavedBlendState@@@@QAEHI@Z ENDP	; List<SavedBlendState>::SetSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Clear@?$List@USavedBlendState@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Clear@?$List@USavedBlendState@@@@QAEXXZ PROC		; List<SavedBlendState>::Clear, COMDAT
; _this$ = ecx

; 334  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 335  :         if(array)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@Clear

; 336  :         {
; 337  :             /*if(IsBadWritePtr(array, sizeof(T)*num))
; 338  :                 CrashError(TEXT("what the.."));*/
; 339  :             Free(array);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	?Free@@YAXPAX@Z				; Free
	add	esp, 4

; 340  :             array = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 341  :             num = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
$LN2@Clear:

; 342  :         }
; 343  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?Clear@?$List@USavedBlendState@@@@QAEXXZ ENDP		; List<SavedBlendState>::Clear
_TEXT	ENDS
END
