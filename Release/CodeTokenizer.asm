; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.21005.1 

	TITLE	F:\songmm_moon_stone_obs\OBS\Source\CodeTokenizer.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

EXTRN	__imp_??8String@@QBEHPB_W@Z:PROC
EXTRN	__imp_??9String@@QBEHPB_W@Z:PROC
EXTRN	__imp_?Length@String@@QBEIXZ:PROC
EXTRN	_iswdigit:PROC
EXTRN	__imp_?ValidIntString@@YGHPB_W@Z:PROC
EXTRN	__imp_?tstring_base_to_uint@@YAIPB_WPAPA_WH@Z:PROC
EXTRN	__imp_?Compare@String@@QBEHPB_W@Z:PROC
EXTRN	__imp_?tstoi@@YAHPA_W@Z:PROC
EXTRN	_iswalnum:PROC
EXTRN	__imp_?ValidFloatString@@YGHPB_W@Z:PROC
EXTRN	__imp_?schr@@YGPA_WPB_W_W@Z:PROC
EXTRN	__imp_?sstr@@YGPA_WPB_W0@Z:PROC
EXTRN	__imp_?IntString@@YA?AVString@@HH@Z:PROC
EXTRN	__imp_?tstof@@YANPA_W@Z:PROC
$SG4294934667 DB '}', 00H, 00H, 00H
$SG4294934666 DB ';', 00H, 00H, 00H
$SG4294934665 DB ')', 00H, 00H, 00H
$SG4294934664 DB ',', 00H, 00H, 00H
$SG4294934663 DB ']', 00H, 00H, 00H
$SG4294934662 DB '?', 00H, 00H, 00H
$SG4294934661 DB ':', 00H, 00H, 00H
$SG4294934660 DB '&', 00H, '&', 00H, 00H, 00H
	ORG $+2
$SG4294934659 DB '|', 00H, '|', 00H, 00H, 00H
	ORG $+2
$SG4294934658 DB '<', 00H, 00H, 00H
$SG4294934657 DB '>', 00H, 00H, 00H
$SG4294934656 DB '<', 00H, '=', 00H, 00H, 00H
	ORG $+2
$SG4294934655 DB '>', 00H, '=', 00H, 00H, 00H
	ORG $+2
$SG4294934654 DB '=', 00H, '=', 00H, 00H, 00H
	ORG $+2
$SG4294934653 DB '!', 00H, '=', 00H, 00H, 00H
	ORG $+2
$SG4294934652 DB '=', 00H, 00H, 00H
$SG4294934651 DB '-', 00H, '=', 00H, 00H, 00H
	ORG $+2
$SG4294934650 DB '+', 00H, '=', 00H, 00H, 00H
	ORG $+2
$SG4294934649 DB '/', 00H, '=', 00H, 00H, 00H
	ORG $+2
$SG4294934648 DB '*', 00H, '=', 00H, 00H, 00H
	ORG $+2
$SG4294934647 DB '<', 00H, '<', 00H, 00H, 00H
	ORG $+2
$SG4294934646 DB '>', 00H, '>', 00H, 00H, 00H
	ORG $+2
$SG4294934645 DB '-', 00H, 00H, 00H
$SG4294934644 DB '+', 00H, 00H, 00H
$SG4294934643 DB '/', 00H, 00H, 00H
$SG4294934642 DB '%', 00H, 00H, 00H
$SG4294934641 DB '*', 00H, 00H, 00H
$SG4294934640 DB '|', 00H, 00H, 00H
$SG4294934639 DB '&', 00H, 00H, 00H
$SG4294934638 DB '/', 00H, '/', 00H, 00H, 00H
	ORG $+2
$SG4294934637 DB '/', 00H, '*', 00H, 00H, 00H
	ORG $+2
$SG4294934636 DB '*', 00H, '/', 00H, 00H, 00H
	ORG $+2
$SG4294934635 DB '%', 00H, 'd', 00H, 00H, 00H
	ORG $+2
$SG4294934634 DB 'f', 00H, 00H, 00H
$SG4294934633 DB '-', 00H, 00H, 00H
$SG4294934632 DB 'f', 00H, 00H, 00H
$SG4294934631 DB '(', 00H, 00H, 00H
$SG4294934630 DB '(', 00H, 00H, 00H
$SG4294934629 DB ')', 00H, 00H, 00H
$SG4294934628 DB '(', 00H, 00H, 00H
$SG4294934627 DB '-', 00H, 00H, 00H
$SG4294934626 DB '<', 00H, '<', 00H, 00H, 00H
	ORG $+2
$SG4294934625 DB '>', 00H, '>', 00H, 00H, 00H
	ORG $+2
$SG4294934624 DB '*', 00H, 00H, 00H
$SG4294934623 DB '%', 00H, 'g', 00H, 00H, 00H
	ORG $+2
$SG4294934622 DB '/', 00H, 00H, 00H
$SG4294934621 DB '%', 00H, 'g', 00H, 00H, 00H
	ORG $+2
$SG4294934620 DB '+', 00H, 00H, 00H
$SG4294934619 DB '%', 00H, 'g', 00H, 00H, 00H
	ORG $+2
$SG4294934618 DB '-', 00H, 00H, 00H
$SG4294934617 DB '%', 00H, 'g', 00H, 00H, 00H
	ORG $+2
$SG4294934616 DB '|', 00H, 00H, 00H
$SG4294934615 DB '&', 00H, 00H, 00H
PUBLIC	?GotoToken@CodeTokenizer@@QAEHPB_WH@Z		; CodeTokenizer::GotoToken
PUBLIC	?PassString@CodeTokenizer@@QAEHPA_W@Z		; CodeTokenizer::PassString
PUBLIC	?PassParenthesis@CodeTokenizer@@QAEHPA_W@Z	; CodeTokenizer::PassParenthesis
PUBLIC	?PassBracers@CodeTokenizer@@QAEHPA_W@Z		; CodeTokenizer::PassBracers
PUBLIC	?GetNextToken@CodeTokenizer@@QAEHAAVString@@H@Z	; CodeTokenizer::GetNextToken
PUBLIC	?mcmp@@YGHPBX0I@Z				; mcmp
	ALIGN	4

__Tuple_alloc DB 01H DUP (?)
	ALIGN	4

_ignore	DB	01H DUP (?)
	ALIGN	4

_allocator_arg DB 01H DUP (?)
	ALIGN	4

_piecewise_construct DB 01H DUP (?)
_BSS	ENDS
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
_ignore$initializer$ DD FLAT:??__Eignore@std@@YAXXZ
__Tuple_alloc$initializer$ DD FLAT:??__E_Tuple_alloc@std@@YAXXZ
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\inline.h
;	COMDAT ?mcmp@@YGHPBX0I@Z
_TEXT	SEGMENT
tv83 = -48						; size = 4
tv82 = -44						; size = 4
tv76 = -40						; size = 4
tv73 = -36						; size = 4
tv72 = -32						; size = 4
tv68 = -28						; size = 4
_srcB$ = -24						; size = 4
_destB$ = -20						; size = 4
_iLenMod4$ = -16					; size = 4
_iLenDiv4$ = -12					; size = 4
_destDW$ = -8						; size = 4
_srcDW$ = -4						; size = 4
_pDest$ = 8						; size = 4
_pSrc$ = 12						; size = 4
_iLen$ = 16						; size = 4
?mcmp@@YGHPBX0I@Z PROC					; mcmp, COMDAT

; 216  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H

; 217  :     assert(pDest);
; 218  :     assert(pSrc);
; 219  : 
; 220  :     register size_t iLenMod4 = iLen&3;

	mov	eax, DWORD PTR _iLen$[ebp]
	and	eax, 3
	mov	DWORD PTR _iLenMod4$[ebp], eax

; 221  :     register size_t iLenDiv4 = iLen>>2;

	mov	ecx, DWORD PTR _iLen$[ebp]
	shr	ecx, 2
	mov	DWORD PTR _iLenDiv4$[ebp], ecx

; 222  : 
; 223  :     register DWORD *srcDW = (DWORD*)pSrc, *destDW = (DWORD*)pDest;

	mov	edx, DWORD PTR _pSrc$[ebp]
	mov	DWORD PTR _srcDW$[ebp], edx
	mov	eax, DWORD PTR _pDest$[ebp]
	mov	DWORD PTR _destDW$[ebp], eax
$LN6@mcmp:

; 224  :     while(iLenDiv4--)

	mov	ecx, DWORD PTR _iLenDiv4$[ebp]
	mov	DWORD PTR tv68[ebp], ecx
	mov	edx, DWORD PTR _iLenDiv4$[ebp]
	sub	edx, 1
	mov	DWORD PTR _iLenDiv4$[ebp], edx
	cmp	DWORD PTR tv68[ebp], 0
	je	SHORT $LN5@mcmp

; 225  :     {
; 226  :         if(*(srcDW++) != *(destDW++))

	mov	eax, DWORD PTR _srcDW$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv72[ebp], ecx
	mov	edx, DWORD PTR _destDW$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv73[ebp], eax
	mov	ecx, DWORD PTR _destDW$[ebp]
	add	ecx, 4
	mov	DWORD PTR _destDW$[ebp], ecx
	mov	edx, DWORD PTR _srcDW$[ebp]
	add	edx, 4
	mov	DWORD PTR _srcDW$[ebp], edx
	mov	eax, DWORD PTR tv72[ebp]
	cmp	eax, DWORD PTR tv73[ebp]
	je	SHORT $LN4@mcmp

; 227  :             return FALSE;

	xor	eax, eax
	jmp	SHORT $LN7@mcmp
$LN4@mcmp:

; 228  :     }

	jmp	SHORT $LN6@mcmp
$LN5@mcmp:

; 229  : 
; 230  :     register BYTE *srcB = (BYTE*)srcDW, *destB = (BYTE*)destDW;

	mov	ecx, DWORD PTR _srcDW$[ebp]
	mov	DWORD PTR _srcB$[ebp], ecx
	mov	edx, DWORD PTR _destDW$[ebp]
	mov	DWORD PTR _destB$[ebp], edx
$LN3@mcmp:

; 231  :     while(iLenMod4--)

	mov	eax, DWORD PTR _iLenMod4$[ebp]
	mov	DWORD PTR tv76[ebp], eax
	mov	ecx, DWORD PTR _iLenMod4$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _iLenMod4$[ebp], ecx
	cmp	DWORD PTR tv76[ebp], 0
	je	SHORT $LN2@mcmp

; 232  :     {
; 233  :         if(*(srcB++) != *(destB++))

	mov	edx, DWORD PTR _srcB$[ebp]
	movzx	eax, BYTE PTR [edx]
	mov	DWORD PTR tv82[ebp], eax
	mov	ecx, DWORD PTR _destB$[ebp]
	movzx	edx, BYTE PTR [ecx]
	mov	DWORD PTR tv83[ebp], edx
	mov	eax, DWORD PTR _destB$[ebp]
	add	eax, 1
	mov	DWORD PTR _destB$[ebp], eax
	mov	ecx, DWORD PTR _srcB$[ebp]
	add	ecx, 1
	mov	DWORD PTR _srcB$[ebp], ecx
	mov	edx, DWORD PTR tv82[ebp]
	cmp	edx, DWORD PTR tv83[ebp]
	je	SHORT $LN1@mcmp

; 234  :             return FALSE;

	xor	eax, eax
	jmp	SHORT $LN7@mcmp
$LN1@mcmp:

; 235  :     }

	jmp	SHORT $LN3@mcmp
$LN2@mcmp:

; 236  : 
; 237  :     return TRUE;

	mov	eax, 1
$LN7@mcmp:

; 238  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?mcmp@@YGHPBX0I@Z ENDP					; mcmp
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$di	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 70   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$di	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$di	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3451 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$di	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\tuple
;	COMDAT ??__Eignore@std@@YAXXZ
text$di	SEGMENT
??__Eignore@std@@YAXXZ PROC				; std::`dynamic initializer for 'ignore'', COMDAT

; 59   : const _Ignore ignore;

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET _ignore
	call	??0_Ignore@std@@QAE@XZ			; std::_Ignore::_Ignore
	pop	ebp
	ret	0
??__Eignore@std@@YAXXZ ENDP				; std::`dynamic initializer for 'ignore''
text$di	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\tuple
;	COMDAT ??__E_Tuple_alloc@std@@YAXXZ
text$di	SEGMENT
$T1 = -1						; size = 1
??__E_Tuple_alloc@std@@YAXXZ PROC			; std::`dynamic initializer for '_Tuple_alloc'', COMDAT

; 66   : const _Tuple_alloc_t _Tuple_alloc = _Tuple_alloc_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__E_Tuple_alloc@std@@YAXXZ ENDP			; std::`dynamic initializer for '_Tuple_alloc''
text$di	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\codetokenizer.cpp
;	COMDAT ?GetNextToken@CodeTokenizer@@QAEHAAVString@@H@Z
_TEXT	SEGMENT
$T1 = -84						; size = 8
_nextToken$2 = -76					; size = 8
_lpStart$ = -68						; size = 4
$T3 = -64						; size = 4
$T4 = -60						; size = 4
_lpPos$5 = -56						; size = 4
$T6 = -52						; size = 4
$T7 = -48						; size = 4
$T8 = -44						; size = 4
_val$9 = -40						; size = 4
_bFoundEnd$10 = -36					; size = 4
tv258 = -32						; size = 4
_bFoundEnd$11 = -28					; size = 4
tv232 = -24						; size = 4
_bAlphaNumeric$ = -20					; size = 4
_lpPos$12 = -16						; size = 4
_lpTokenStart$ = -12					; size = 4
_this$ = -8						; size = 4
_oldCH$ = -4						; size = 2
_token$ = 8						; size = 4
_bPeek$ = 12						; size = 4
?GetNextToken@CodeTokenizer@@QAEHAAVString@@H@Z PROC	; CodeTokenizer::GetNextToken, COMDAT
; _this$ = ecx

; 41   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 42   :     TSTR lpStart = lpTemp;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _lpStart$[ebp], ecx

; 43   : 
; 44   :     TSTR lpTokenStart = NULL;

	mov	DWORD PTR _lpTokenStart$[ebp], 0

; 45   :     BOOL bAlphaNumeric = FALSE;

	mov	DWORD PTR _bAlphaNumeric$[ebp], 0
$LN61@GetNextTok:

; 46   : 
; 47   :     while(*lpTemp)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	movzx	ecx, WORD PTR [eax]
	test	ecx, ecx
	je	$LN60@GetNextTok

; 48   :     {
; 49   :         if(mcmp(lpTemp, TEXT("//"), 2*sizeof(TCHAR)))

	push	4
	push	OFFSET $SG4294934638
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	?mcmp@@YGHPBX0I@Z			; mcmp
	test	eax, eax
	je	SHORT $LN59@GetNextTok

; 50   :         {
; 51   :             lpTemp = schr(lpTemp, '\n');

	push	10					; 0000000aH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	call	DWORD PTR __imp_?schr@@YGPA_WPB_W_W@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 52   : 
; 53   :             if(!lpTemp)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	jne	SHORT $LN58@GetNextTok

; 54   :                 return FALSE;

	xor	eax, eax
	jmp	$LN62@GetNextTok
$LN58@GetNextTok:

; 55   :         }

	jmp	SHORT $LN57@GetNextTok
$LN59@GetNextTok:

; 56   :         else if(mcmp(lpTemp, TEXT("/*"), 2*sizeof(TCHAR)))

	push	4
	push	OFFSET $SG4294934637
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	?mcmp@@YGHPBX0I@Z			; mcmp
	test	eax, eax
	je	SHORT $LN57@GetNextTok

; 57   :         {
; 58   :             lpTemp = sstr(lpTemp+2, TEXT("*/"));

	push	OFFSET $SG4294934636
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	add	eax, 4
	push	eax
	call	DWORD PTR __imp_?sstr@@YGPA_WPB_W0@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 59   : 
; 60   :             if(!lpTemp)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	jne	SHORT $LN55@GetNextTok

; 61   :                 return FALSE;

	xor	eax, eax
	jmp	$LN62@GetNextTok
$LN55@GetNextTok:

; 62   : 
; 63   :             lpTemp += 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], ecx
$LN57@GetNextTok:

; 64   :         }
; 65   : 
; 66   :         if((*lpTemp == '_') || iswalnum(*lpTemp))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	movzx	edx, WORD PTR [ecx]
	cmp	edx, 95					; 0000005fH
	je	SHORT $LN53@GetNextTok
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	movzx	edx, WORD PTR [ecx]
	push	edx
	call	_iswalnum
	add	esp, 4
	test	eax, eax
	je	SHORT $LN54@GetNextTok
$LN53@GetNextTok:

; 67   :         {
; 68   :             if(lpTokenStart)

	cmp	DWORD PTR _lpTokenStart$[ebp], 0
	je	SHORT $LN52@GetNextTok

; 69   :             {
; 70   :                 if(!bAlphaNumeric)

	cmp	DWORD PTR _bAlphaNumeric$[ebp], 0
	jne	SHORT $LN51@GetNextTok

; 71   :                     break;

	jmp	$LN60@GetNextTok
$LN51@GetNextTok:

; 72   :             }
; 73   :             else

	jmp	SHORT $LN50@GetNextTok
$LN52@GetNextTok:

; 74   :             {
; 75   :                 lpTokenStart = lpTemp;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _lpTokenStart$[ebp], ecx

; 76   :                 bAlphaNumeric = TRUE;

	mov	DWORD PTR _bAlphaNumeric$[ebp], 1
$LN50@GetNextTok:

; 77   :             }
; 78   :         }
; 79   :         else

	jmp	$LN49@GetNextTok
$LN54@GetNextTok:

; 80   :         {
; 81   :             if(lpTokenStart)

	cmp	DWORD PTR _lpTokenStart$[ebp], 0
	je	$LN48@GetNextTok

; 82   :             {
; 83   :                 if(bAlphaNumeric)

	cmp	DWORD PTR _bAlphaNumeric$[ebp], 0
	je	SHORT $LN47@GetNextTok

; 84   :                     break;

	jmp	$LN60@GetNextTok
$LN47@GetNextTok:

; 85   : 
; 86   :                 if(*lpTokenStart == '>' || *lpTokenStart == '<')

	mov	edx, DWORD PTR _lpTokenStart$[ebp]
	movzx	eax, WORD PTR [edx]
	cmp	eax, 62					; 0000003eH
	je	SHORT $LN45@GetNextTok
	mov	ecx, DWORD PTR _lpTokenStart$[ebp]
	movzx	edx, WORD PTR [ecx]
	cmp	edx, 60					; 0000003cH
	jne	SHORT $LN46@GetNextTok
$LN45@GetNextTok:

; 87   :                 {
; 88   :                     if((*lpTemp != '=') && (*lpTemp != '>') && (*lpTemp != '<'))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	movzx	edx, WORD PTR [ecx]
	cmp	edx, 61					; 0000003dH
	je	SHORT $LN46@GetNextTok
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	movzx	edx, WORD PTR [ecx]
	cmp	edx, 62					; 0000003eH
	je	SHORT $LN46@GetNextTok
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	movzx	edx, WORD PTR [ecx]
	cmp	edx, 60					; 0000003cH
	je	SHORT $LN46@GetNextTok

; 89   :                         break;

	jmp	$LN60@GetNextTok
$LN46@GetNextTok:

; 90   :                 }
; 91   : 
; 92   :                 if( ((*lpTokenStart == '=') && (*lpTemp != '=')) ||
; 93   :                     (*lpTokenStart == ';') ||
; 94   :                     (*lpTemp == ' ')   ||
; 95   :                     (*lpTemp == L'@') ||
; 96   :                     (*lpTemp == '\'')  ||
; 97   :                     (*lpTemp == '"')   ||
; 98   :                     (*lpTemp == ';')   ||
; 99   :                     (*lpTemp == '(')   ||
; 100  :                     (*lpTemp == ')')   ||
; 101  :                     (*lpTemp == '[')   ||
; 102  :                     (*lpTemp == ']')   ||
; 103  :                     (*lpTemp == '{')   ||
; 104  :                     (*lpTemp == '}')   ||
; 105  :                     (*lpTemp == '\r')  ||
; 106  :                     (*lpTemp == '\t')  ||
; 107  :                     (*lpTemp == '\n')  )

	mov	eax, DWORD PTR _lpTokenStart$[ebp]
	movzx	ecx, WORD PTR [eax]
	cmp	ecx, 61					; 0000003dH
	jne	SHORT $LN41@GetNextTok
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	movzx	ecx, WORD PTR [eax]
	cmp	ecx, 61					; 0000003dH
	jne	$LN42@GetNextTok
$LN41@GetNextTok:
	mov	edx, DWORD PTR _lpTokenStart$[ebp]
	movzx	eax, WORD PTR [edx]
	cmp	eax, 59					; 0000003bH
	je	$LN42@GetNextTok
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	movzx	eax, WORD PTR [edx]
	cmp	eax, 32					; 00000020H
	je	$LN42@GetNextTok
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	movzx	eax, WORD PTR [edx]
	cmp	eax, 19970				; 00004e02H
	je	$LN42@GetNextTok
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	movzx	eax, WORD PTR [edx]
	cmp	eax, 39					; 00000027H
	je	$LN42@GetNextTok
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	movzx	eax, WORD PTR [edx]
	cmp	eax, 34					; 00000022H
	je	$LN42@GetNextTok
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	movzx	eax, WORD PTR [edx]
	cmp	eax, 59					; 0000003bH
	je	SHORT $LN42@GetNextTok
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	movzx	eax, WORD PTR [edx]
	cmp	eax, 40					; 00000028H
	je	SHORT $LN42@GetNextTok
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	movzx	eax, WORD PTR [edx]
	cmp	eax, 41					; 00000029H
	je	SHORT $LN42@GetNextTok
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	movzx	eax, WORD PTR [edx]
	cmp	eax, 91					; 0000005bH
	je	SHORT $LN42@GetNextTok
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	movzx	eax, WORD PTR [edx]
	cmp	eax, 93					; 0000005dH
	je	SHORT $LN42@GetNextTok
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	movzx	eax, WORD PTR [edx]
	cmp	eax, 123				; 0000007bH
	je	SHORT $LN42@GetNextTok
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	movzx	eax, WORD PTR [edx]
	cmp	eax, 125				; 0000007dH
	je	SHORT $LN42@GetNextTok
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	movzx	eax, WORD PTR [edx]
	cmp	eax, 13					; 0000000dH
	je	SHORT $LN42@GetNextTok
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	movzx	eax, WORD PTR [edx]
	cmp	eax, 9
	je	SHORT $LN42@GetNextTok
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	movzx	eax, WORD PTR [edx]
	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN43@GetNextTok
$LN42@GetNextTok:

; 108  :                 {
; 109  :                     break;

	jmp	$LN60@GetNextTok
$LN43@GetNextTok:

; 110  :                 }
; 111  :             }
; 112  :             else

	jmp	$LN49@GetNextTok
$LN48@GetNextTok:

; 113  :             {
; 114  :                 if(*lpTemp == '"')

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	movzx	eax, WORD PTR [edx]
	cmp	eax, 34					; 00000022H
	jne	SHORT $LN39@GetNextTok

; 115  :                 {
; 116  :                     lpTokenStart = lpTemp;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _lpTokenStart$[ebp], edx

; 117  : 
; 118  :                     BOOL bFoundEnd = TRUE;

	mov	DWORD PTR _bFoundEnd$11[ebp], 1
$LN38@GetNextTok:

; 119  :                     while(*++lpTemp != '"')

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, 2
	mov	DWORD PTR tv232[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR tv232[ebp]
	mov	DWORD PTR [edx+12], eax
	mov	ecx, DWORD PTR tv232[ebp]
	movzx	edx, WORD PTR [ecx]
	cmp	edx, 34					; 00000022H
	je	SHORT $LN37@GetNextTok

; 120  :                     {
; 121  :                         if(!*lpTemp)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	movzx	edx, WORD PTR [ecx]
	test	edx, edx
	jne	SHORT $LN36@GetNextTok

; 122  :                         {
; 123  :                             bFoundEnd = FALSE;

	mov	DWORD PTR _bFoundEnd$11[ebp], 0

; 124  :                             break;

	jmp	SHORT $LN37@GetNextTok
$LN36@GetNextTok:

; 125  :                         }
; 126  :                     }

	jmp	SHORT $LN38@GetNextTok
$LN37@GetNextTok:

; 127  : 
; 128  :                     if(!bFoundEnd)

	cmp	DWORD PTR _bFoundEnd$11[ebp], 0
	jne	SHORT $LN35@GetNextTok

; 129  :                         return FALSE;

	xor	eax, eax
	jmp	$LN62@GetNextTok
$LN35@GetNextTok:

; 130  : 
; 131  :                     ++lpTemp;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], ecx

; 132  :                     break;

	jmp	$LN60@GetNextTok
$LN39@GetNextTok:

; 133  :                 }
; 134  :                 if(*lpTemp == ';')

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	movzx	edx, WORD PTR [ecx]
	cmp	edx, 59					; 0000003bH
	jne	SHORT $LN34@GetNextTok

; 135  :                 {
; 136  :                     lpTokenStart = lpTemp;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _lpTokenStart$[ebp], ecx

; 137  :                     ++lpTemp;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	add	eax, 2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 138  :                     break;

	jmp	$LN60@GetNextTok
$LN34@GetNextTok:

; 139  :                 }
; 140  : 
; 141  :                 if(*lpTemp == '\'')

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	movzx	ecx, WORD PTR [eax]
	cmp	ecx, 39					; 00000027H
	jne	SHORT $LN33@GetNextTok

; 142  :                 {
; 143  :                     lpTokenStart = lpTemp;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _lpTokenStart$[ebp], eax

; 144  : 
; 145  :                     BOOL bFoundEnd = TRUE;

	mov	DWORD PTR _bFoundEnd$10[ebp], 1
$LN32@GetNextTok:

; 146  :                     while(*++lpTemp != '\'')

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	add	edx, 2
	mov	DWORD PTR tv258[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR tv258[ebp]
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR tv258[ebp]
	movzx	eax, WORD PTR [edx]
	cmp	eax, 39					; 00000027H
	je	SHORT $LN31@GetNextTok

; 147  :                     {
; 148  :                         if(!*lpTemp)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	movzx	eax, WORD PTR [edx]
	test	eax, eax
	jne	SHORT $LN30@GetNextTok

; 149  :                         {
; 150  :                             bFoundEnd = FALSE;

	mov	DWORD PTR _bFoundEnd$10[ebp], 0

; 151  :                             break;

	jmp	SHORT $LN31@GetNextTok
$LN30@GetNextTok:

; 152  :                         }
; 153  :                     }

	jmp	SHORT $LN32@GetNextTok
$LN31@GetNextTok:

; 154  : 
; 155  :                     if(!bFoundEnd)

	cmp	DWORD PTR _bFoundEnd$10[ebp], 0
	jne	SHORT $LN29@GetNextTok

; 156  :                         return FALSE;

	xor	eax, eax
	jmp	$LN62@GetNextTok
$LN29@GetNextTok:

; 157  : 
; 158  :                     ++lpTemp;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	add	edx, 2
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx

; 159  :                     break;

	jmp	$LN60@GetNextTok

; 160  :                 }
; 161  :                 else if((*lpTemp == '(') ||

	jmp	SHORT $LN28@GetNextTok
$LN33@GetNextTok:

; 162  :                         (*lpTemp == ')') ||
; 163  :                         (*lpTemp == '[') ||
; 164  :                         (*lpTemp == ']') ||
; 165  :                         (*lpTemp == '{') ||
; 166  :                         (*lpTemp == '}'))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	movzx	eax, WORD PTR [edx]
	cmp	eax, 40					; 00000028H
	je	SHORT $LN26@GetNextTok
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	movzx	eax, WORD PTR [edx]
	cmp	eax, 41					; 00000029H
	je	SHORT $LN26@GetNextTok
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	movzx	eax, WORD PTR [edx]
	cmp	eax, 91					; 0000005bH
	je	SHORT $LN26@GetNextTok
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	movzx	eax, WORD PTR [edx]
	cmp	eax, 93					; 0000005dH
	je	SHORT $LN26@GetNextTok
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	movzx	eax, WORD PTR [edx]
	cmp	eax, 123				; 0000007bH
	je	SHORT $LN26@GetNextTok
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	movzx	eax, WORD PTR [edx]
	cmp	eax, 125				; 0000007dH
	jne	SHORT $LN28@GetNextTok
$LN26@GetNextTok:

; 167  :                 {
; 168  :                     lpTokenStart = lpTemp++;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _lpTokenStart$[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], ecx

; 169  :                     break;

	jmp	SHORT $LN60@GetNextTok
$LN28@GetNextTok:

; 170  :                 }
; 171  : 
; 172  :                 if( (*lpTemp != ' ')   &&
; 173  :                     (*lpTemp != L'@') &&
; 174  :                     (*lpTemp != '\r')  &&
; 175  :                     (*lpTemp != '\t')  &&
; 176  :                     (*lpTemp != '\n')  )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	movzx	edx, WORD PTR [ecx]
	cmp	edx, 32					; 00000020H
	je	SHORT $LN49@GetNextTok
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	movzx	edx, WORD PTR [ecx]
	cmp	edx, 19970				; 00004e02H
	je	SHORT $LN49@GetNextTok
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	movzx	edx, WORD PTR [ecx]
	cmp	edx, 13					; 0000000dH
	je	SHORT $LN49@GetNextTok
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	movzx	edx, WORD PTR [ecx]
	cmp	edx, 9
	je	SHORT $LN49@GetNextTok
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	movzx	edx, WORD PTR [ecx]
	cmp	edx, 10					; 0000000aH
	je	SHORT $LN49@GetNextTok

; 177  :                 {
; 178  :                     lpTokenStart = lpTemp;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _lpTokenStart$[ebp], ecx

; 179  :                     bAlphaNumeric = FALSE;

	mov	DWORD PTR _bAlphaNumeric$[ebp], 0
$LN49@GetNextTok:

; 180  :                 }
; 181  :             }
; 182  :         }
; 183  : 
; 184  :         ++lpTemp;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	add	eax, 2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 185  :     }

	jmp	$LN61@GetNextTok
$LN60@GetNextTok:

; 186  : 
; 187  :     if(!lpTokenStart)

	cmp	DWORD PTR _lpTokenStart$[ebp], 0
	jne	SHORT $LN24@GetNextTok

; 188  :         return FALSE;

	xor	eax, eax
	jmp	$LN62@GetNextTok
$LN24@GetNextTok:

; 189  : 
; 190  :     TCHAR oldCH = *lpTemp;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	cx, WORD PTR [eax]
	mov	WORD PTR _oldCH$[ebp], cx

; 191  :     *lpTemp = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	xor	ecx, ecx
	mov	WORD PTR [eax], cx

; 192  : 
; 193  :     token = lpTokenStart;

	mov	edx, DWORD PTR _lpTokenStart$[ebp]
	push	edx
	mov	ecx, DWORD PTR _token$[ebp]
	call	DWORD PTR __imp_??4String@@QAEAAV0@PB_W@Z

; 194  : 
; 195  :     *lpTemp = oldCH;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	dx, WORD PTR _oldCH$[ebp]
	mov	WORD PTR [ecx], dx

; 196  : 
; 197  :     if(bAlphaNumeric && iswdigit(*lpTokenStart)) //handle floating points

	cmp	DWORD PTR _bAlphaNumeric$[ebp], 0
	je	$LN23@GetNextTok
	mov	eax, DWORD PTR _lpTokenStart$[ebp]
	movzx	ecx, WORD PTR [eax]
	push	ecx
	call	_iswdigit
	add	esp, 4
	test	eax, eax
	je	$LN23@GetNextTok

; 198  :     {
; 199  :         if( (token.Length() > 2) && 
; 200  :             (lpTokenStart[0] == '0') &&
; 201  :             (lpTokenStart[1] == 'x')) //convert hex

	mov	ecx, DWORD PTR _token$[ebp]
	call	DWORD PTR __imp_?Length@String@@QBEIXZ
	cmp	eax, 2
	jbe	SHORT $LN22@GetNextTok
	mov	edx, 2
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _lpTokenStart$[ebp]
	movzx	edx, WORD PTR [ecx+eax]
	cmp	edx, 48					; 00000030H
	jne	SHORT $LN22@GetNextTok
	mov	eax, 2
	shl	eax, 0
	mov	ecx, DWORD PTR _lpTokenStart$[ebp]
	movzx	edx, WORD PTR [ecx+eax]
	cmp	edx, 120				; 00000078H
	jne	SHORT $LN22@GetNextTok

; 202  :         {
; 203  :             unsigned int val = tstring_base_to_uint(lpTokenStart, NULL, 0);

	push	0
	push	0
	mov	eax, DWORD PTR _lpTokenStart$[ebp]
	push	eax
	call	DWORD PTR __imp_?tstring_base_to_uint@@YAIPB_WPAPA_WH@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _val$9[ebp], eax

; 204  :             token = FormattedString(TEXT("%d"), val);

	mov	ecx, DWORD PTR _val$9[ebp]
	push	ecx
	push	OFFSET $SG4294934635
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	DWORD PTR __imp_?FormattedString@@YA?AVString@@PB_WZZ
	add	esp, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _token$[ebp]
	call	DWORD PTR __imp_??4String@@QAEAAV0@ABV0@@Z
	lea	ecx, DWORD PTR $T1[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 205  :         }
; 206  :         else

	jmp	$LN23@GetNextTok
$LN22@GetNextTok:

; 207  :         {
; 208  :             String nextToken;

	lea	ecx, DWORD PTR _nextToken$2[ebp]
	call	DWORD PTR __imp_??0String@@QAE@XZ

; 209  : 
; 210  :             TSTR lpPos = lpTemp;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _lpPos$12[ebp], ecx

; 211  :             if(!GetNextToken(nextToken)) return FALSE;

	push	0
	lea	edx, DWORD PTR _nextToken$2[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNextToken@CodeTokenizer@@QAEHAAVString@@H@Z ; CodeTokenizer::GetNextToken
	test	eax, eax
	jne	SHORT $LN20@GetNextTok
	mov	DWORD PTR $T8[ebp], 0
	lea	ecx, DWORD PTR _nextToken$2[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR $T8[ebp]
	jmp	$LN62@GetNextTok
$LN20@GetNextTok:

; 212  :             if(nextToken[0] == '.')

	lea	ecx, DWORD PTR _nextToken$2[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	mov	ecx, 2
	imul	edx, ecx, 0
	movzx	eax, WORD PTR [eax+edx]
	cmp	eax, 46					; 0000002eH
	jne	$LN19@GetNextTok

; 213  :             {
; 214  :                 lpPos = lpTemp;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _lpPos$12[ebp], edx

; 215  : 
; 216  :                 token << nextToken;

	lea	eax, DWORD PTR _nextToken$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _token$[ebp]
	call	DWORD PTR __imp_??6String@@QAEAAV0@ABV0@@Z

; 217  :                 if(!GetNextToken(nextToken)) return FALSE;

	push	0
	lea	ecx, DWORD PTR _nextToken$2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNextToken@CodeTokenizer@@QAEHAAVString@@H@Z ; CodeTokenizer::GetNextToken
	test	eax, eax
	jne	SHORT $LN18@GetNextTok
	mov	DWORD PTR $T7[ebp], 0
	lea	ecx, DWORD PTR _nextToken$2[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR $T7[ebp]
	jmp	$LN62@GetNextTok
$LN18@GetNextTok:

; 218  :                 if(iswdigit(nextToken[0]) || nextToken == TEXT("f"))

	lea	ecx, DWORD PTR _nextToken$2[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	mov	edx, 2
	imul	ecx, edx, 0
	mov	dx, WORD PTR [eax+ecx]
	movzx	eax, dx
	push	eax
	call	_iswdigit
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN16@GetNextTok
	push	OFFSET $SG4294934634
	lea	ecx, DWORD PTR _nextToken$2[ebp]
	call	DWORD PTR __imp_??8String@@QBEHPB_W@Z
	test	eax, eax
	je	SHORT $LN17@GetNextTok
$LN16@GetNextTok:

; 219  :                     token << nextToken;

	lea	ecx, DWORD PTR _nextToken$2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _token$[ebp]
	call	DWORD PTR __imp_??6String@@QAEAAV0@ABV0@@Z

; 220  :                 else

	jmp	SHORT $LN15@GetNextTok
$LN17@GetNextTok:

; 221  :                     lpTemp = lpPos;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _lpPos$12[ebp]
	mov	DWORD PTR [edx+12], eax
$LN15@GetNextTok:

; 222  :             }
; 223  :             else

	jmp	SHORT $LN14@GetNextTok
$LN19@GetNextTok:

; 224  :                 lpTemp = lpPos;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _lpPos$12[ebp]
	mov	DWORD PTR [ecx+12], edx
$LN14@GetNextTok:

; 225  : 
; 226  :             if(token[token.Length()-1] == 'e')

	mov	ecx, DWORD PTR _token$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	mov	esi, eax
	mov	ecx, DWORD PTR _token$[ebp]
	call	DWORD PTR __imp_?Length@String@@QBEIXZ
	movzx	eax, WORD PTR [esi+eax*2-2]
	cmp	eax, 101				; 00000065H
	jne	$LN13@GetNextTok

; 227  :             {
; 228  :                 if(*lpTemp == '-')

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	movzx	eax, WORD PTR [edx]
	cmp	eax, 45					; 0000002dH
	jne	$LN13@GetNextTok

; 229  :                 {
; 230  :                     TSTR lpPos = lpTemp++;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _lpPos$5[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], ecx

; 231  : 
; 232  :                     if(!GetNextToken(nextToken)) return FALSE;

	push	0
	lea	eax, DWORD PTR _nextToken$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNextToken@CodeTokenizer@@QAEHAAVString@@H@Z ; CodeTokenizer::GetNextToken
	test	eax, eax
	jne	SHORT $LN11@GetNextTok
	mov	DWORD PTR $T6[ebp], 0
	lea	ecx, DWORD PTR _nextToken$2[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR $T6[ebp]
	jmp	$LN62@GetNextTok
$LN11@GetNextTok:

; 233  :                     if(!iswdigit(nextToken[0]))

	lea	ecx, DWORD PTR _nextToken$2[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	mov	ecx, 2
	imul	edx, ecx, 0
	mov	ax, WORD PTR [eax+edx]
	movzx	ecx, ax
	push	ecx
	call	_iswdigit
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN10@GetNextTok

; 234  :                         lpTemp = lpPos;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _lpPos$5[ebp]
	mov	DWORD PTR [edx+12], eax

; 235  :                     else

	jmp	SHORT $LN13@GetNextTok
$LN10@GetNextTok:

; 236  :                         token << TEXT("-") << nextToken;

	lea	ecx, DWORD PTR _nextToken$2[ebp]
	push	ecx
	push	OFFSET $SG4294934633
	mov	ecx, DWORD PTR _token$[ebp]
	call	DWORD PTR __imp_??6String@@QAEAAV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@ABV0@@Z
$LN13@GetNextTok:

; 237  :                 }
; 238  :             }
; 239  : 
; 240  :             lpPos = lpTemp;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _lpPos$12[ebp], eax

; 241  :             if(!GetNextToken(nextToken)) return FALSE;

	push	0
	lea	ecx, DWORD PTR _nextToken$2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNextToken@CodeTokenizer@@QAEHAAVString@@H@Z ; CodeTokenizer::GetNextToken
	test	eax, eax
	jne	SHORT $LN8@GetNextTok
	mov	DWORD PTR $T4[ebp], 0
	lea	ecx, DWORD PTR _nextToken$2[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR $T4[ebp]
	jmp	$LN62@GetNextTok
$LN8@GetNextTok:

; 242  :             if(nextToken[0] == '.')

	lea	ecx, DWORD PTR _nextToken$2[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	mov	edx, 2
	imul	ecx, edx, 0
	movzx	edx, WORD PTR [eax+ecx]
	cmp	edx, 46					; 0000002eH
	jne	$LN7@GetNextTok

; 243  :             {
; 244  :                 lpPos = lpTemp;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _lpPos$12[ebp], ecx

; 245  : 
; 246  :                 token << nextToken;

	lea	edx, DWORD PTR _nextToken$2[ebp]
	push	edx
	mov	ecx, DWORD PTR _token$[ebp]
	call	DWORD PTR __imp_??6String@@QAEAAV0@ABV0@@Z

; 247  :                 if(!GetNextToken(nextToken)) return FALSE;

	push	0
	lea	eax, DWORD PTR _nextToken$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNextToken@CodeTokenizer@@QAEHAAVString@@H@Z ; CodeTokenizer::GetNextToken
	test	eax, eax
	jne	SHORT $LN6@GetNextTok
	mov	DWORD PTR $T3[ebp], 0
	lea	ecx, DWORD PTR _nextToken$2[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR $T3[ebp]
	jmp	SHORT $LN62@GetNextTok
$LN6@GetNextTok:

; 248  :                 if(iswdigit(nextToken[0]) || nextToken == TEXT("f"))

	lea	ecx, DWORD PTR _nextToken$2[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	mov	ecx, 2
	imul	edx, ecx, 0
	mov	ax, WORD PTR [eax+edx]
	movzx	ecx, ax
	push	ecx
	call	_iswdigit
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN4@GetNextTok
	push	OFFSET $SG4294934632
	lea	ecx, DWORD PTR _nextToken$2[ebp]
	call	DWORD PTR __imp_??8String@@QBEHPB_W@Z
	test	eax, eax
	je	SHORT $LN5@GetNextTok
$LN4@GetNextTok:

; 249  :                     token << nextToken;

	lea	edx, DWORD PTR _nextToken$2[ebp]
	push	edx
	mov	ecx, DWORD PTR _token$[ebp]
	call	DWORD PTR __imp_??6String@@QAEAAV0@ABV0@@Z

; 250  :                 else

	jmp	SHORT $LN3@GetNextTok
$LN5@GetNextTok:

; 251  :                     lpTemp = lpPos;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _lpPos$12[ebp]
	mov	DWORD PTR [eax+12], ecx
$LN3@GetNextTok:

; 252  :             }
; 253  :             else

	jmp	SHORT $LN2@GetNextTok
$LN7@GetNextTok:

; 254  :                 lpTemp = lpPos;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _lpPos$12[ebp]
	mov	DWORD PTR [edx+12], eax
$LN2@GetNextTok:

; 255  :         }

	lea	ecx, DWORD PTR _nextToken$2[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
$LN23@GetNextTok:

; 256  :     }
; 257  : 
; 258  :     if(bPeek)

	cmp	DWORD PTR _bPeek$[ebp], 0
	je	SHORT $LN1@GetNextTok

; 259  :         lpTemp = lpStart;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _lpStart$[ebp]
	mov	DWORD PTR [ecx+12], edx
$LN1@GetNextTok:

; 260  : 
; 261  :     return TRUE;

	mov	eax, 1
$LN62@GetNextTok:

; 262  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
?GetNextToken@CodeTokenizer@@QAEHAAVString@@H@Z ENDP	; CodeTokenizer::GetNextToken
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\codetokenizer.cpp
;	COMDAT ?PassBracers@CodeTokenizer@@QAEHPA_W@Z
_TEXT	SEGMENT
_curToken$ = -28					; size = 8
$T1 = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
$T4 = -8						; size = 4
_this$ = -4						; size = 4
_lpCodePos$ = 8						; size = 4
?PassBracers@CodeTokenizer@@QAEHPA_W@Z PROC		; CodeTokenizer::PassBracers, COMDAT
; _this$ = ecx

; 445  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 446  :     lpTemp = lpCodePos;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _lpCodePos$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 447  : 
; 448  :     String curToken;

	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??0String@@QAE@XZ

; 449  : 
; 450  :     if(!GetNextToken(curToken))

	push	0
	lea	edx, DWORD PTR _curToken$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNextToken@CodeTokenizer@@QAEHAAVString@@H@Z ; CodeTokenizer::GetNextToken
	test	eax, eax
	jne	SHORT $LN9@PassBracer

; 451  :         return FALSE;

	mov	DWORD PTR $T4[ebp], 0
	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR $T4[ebp]
	jmp	$LN10@PassBracer
$LN9@PassBracer:

; 452  :     if(curToken[0] != '{')

	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	mov	ecx, 2
	imul	edx, ecx, 0
	movzx	eax, WORD PTR [eax+edx]
	cmp	eax, 123				; 0000007bH
	je	SHORT $LN7@PassBracer

; 453  :         return FALSE;

	mov	DWORD PTR $T3[ebp], 0
	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR $T3[ebp]
	jmp	$LN10@PassBracer
$LN7@PassBracer:

; 454  : 
; 455  :     while(GetNextToken(curToken, TRUE))

	push	1
	lea	ecx, DWORD PTR _curToken$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNextToken@CodeTokenizer@@QAEHAAVString@@H@Z ; CodeTokenizer::GetNextToken
	test	eax, eax
	je	$LN6@PassBracer

; 456  :     {
; 457  :         if(curToken[0] == '}')

	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	mov	edx, 2
	imul	ecx, edx, 0
	movzx	edx, WORD PTR [eax+ecx]
	cmp	edx, 125				; 0000007dH
	jne	SHORT $LN5@PassBracer

; 458  :         {
; 459  :             GetNextToken(curToken);

	push	0
	lea	eax, DWORD PTR _curToken$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNextToken@CodeTokenizer@@QAEHAAVString@@H@Z ; CodeTokenizer::GetNextToken

; 460  :             return TRUE;

	mov	DWORD PTR $T2[ebp], 1
	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR $T2[ebp]
	jmp	$LN10@PassBracer
	jmp	SHORT $LN4@PassBracer
$LN5@PassBracer:

; 461  :         }
; 462  :         else if(curToken[0] == '{')

	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	mov	ecx, 2
	imul	edx, ecx, 0
	movzx	eax, WORD PTR [eax+edx]
	cmp	eax, 123				; 0000007bH
	jne	SHORT $LN3@PassBracer

; 463  :         {
; 464  :             PassBracers(lpTemp);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PassBracers@CodeTokenizer@@QAEHPA_W@Z	; CodeTokenizer::PassBracers

; 465  :             continue;

	jmp	$LN7@PassBracer
	jmp	SHORT $LN4@PassBracer
$LN3@PassBracer:

; 466  :         }
; 467  :         else if(curToken[0] == '"')

	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	mov	ecx, 2
	imul	edx, ecx, 0
	movzx	eax, WORD PTR [eax+edx]
	cmp	eax, 34					; 00000022H
	jne	SHORT $LN4@PassBracer

; 468  :         {
; 469  :             PassString(lpTemp);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PassString@CodeTokenizer@@QAEHPA_W@Z	; CodeTokenizer::PassString

; 470  :             continue;

	jmp	$LN7@PassBracer
$LN4@PassBracer:

; 471  :         }
; 472  : 
; 473  :         GetNextToken(curToken);

	push	0
	lea	eax, DWORD PTR _curToken$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNextToken@CodeTokenizer@@QAEHAAVString@@H@Z ; CodeTokenizer::GetNextToken

; 474  :     };

	jmp	$LN7@PassBracer
$LN6@PassBracer:

; 475  : 
; 476  :     return FALSE;

	mov	DWORD PTR $T1[ebp], 0
	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR $T1[ebp]
$LN10@PassBracer:

; 477  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?PassBracers@CodeTokenizer@@QAEHPA_W@Z ENDP		; CodeTokenizer::PassBracers
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\codetokenizer.cpp
;	COMDAT ?PassParenthesis@CodeTokenizer@@QAEHPA_W@Z
_TEXT	SEGMENT
_curToken$ = -28					; size = 8
$T1 = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
$T4 = -8						; size = 4
_this$ = -4						; size = 4
_lpCodePos$ = 8						; size = 4
?PassParenthesis@CodeTokenizer@@QAEHPA_W@Z PROC		; CodeTokenizer::PassParenthesis, COMDAT
; _this$ = ecx

; 480  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 481  :     lpTemp = lpCodePos;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _lpCodePos$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 482  : 
; 483  :     String curToken;

	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??0String@@QAE@XZ

; 484  : 
; 485  :     if(!GetNextToken(curToken))

	push	0
	lea	edx, DWORD PTR _curToken$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNextToken@CodeTokenizer@@QAEHAAVString@@H@Z ; CodeTokenizer::GetNextToken
	test	eax, eax
	jne	SHORT $LN11@PassParent

; 486  :         return FALSE;

	mov	DWORD PTR $T4[ebp], 0
	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR $T4[ebp]
	jmp	$LN12@PassParent
$LN11@PassParent:

; 487  :     if(curToken[0] != '(')

	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	mov	ecx, 2
	imul	edx, ecx, 0
	movzx	eax, WORD PTR [eax+edx]
	cmp	eax, 40					; 00000028H
	je	SHORT $LN9@PassParent

; 488  :         return FALSE;

	mov	DWORD PTR $T3[ebp], 0
	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR $T3[ebp]
	jmp	$LN12@PassParent
$LN9@PassParent:

; 489  : 
; 490  :     while(GetNextToken(curToken, TRUE))

	push	1
	lea	ecx, DWORD PTR _curToken$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNextToken@CodeTokenizer@@QAEHAAVString@@H@Z ; CodeTokenizer::GetNextToken
	test	eax, eax
	je	$LN8@PassParent

; 491  :     {
; 492  :         if(curToken[0] == ')')

	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	mov	edx, 2
	imul	ecx, edx, 0
	movzx	edx, WORD PTR [eax+ecx]
	cmp	edx, 41					; 00000029H
	jne	SHORT $LN7@PassParent

; 493  :         {
; 494  :             GetNextToken(curToken);

	push	0
	lea	eax, DWORD PTR _curToken$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNextToken@CodeTokenizer@@QAEHAAVString@@H@Z ; CodeTokenizer::GetNextToken

; 495  :             return TRUE;

	mov	DWORD PTR $T2[ebp], 1
	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR $T2[ebp]
	jmp	$LN12@PassParent
	jmp	$LN6@PassParent
$LN7@PassParent:

; 496  :         }
; 497  :         else if(curToken[0] == '(')

	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	mov	ecx, 2
	imul	edx, ecx, 0
	movzx	eax, WORD PTR [eax+edx]
	cmp	eax, 40					; 00000028H
	jne	SHORT $LN5@PassParent

; 498  :         {
; 499  :             PassParenthesis(lpTemp);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PassParenthesis@CodeTokenizer@@QAEHPA_W@Z ; CodeTokenizer::PassParenthesis

; 500  :             continue;

	jmp	$LN9@PassParent
	jmp	SHORT $LN6@PassParent
$LN5@PassParent:

; 501  :         }
; 502  :         else if(curToken[0] == '{')

	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	mov	ecx, 2
	imul	edx, ecx, 0
	movzx	eax, WORD PTR [eax+edx]
	cmp	eax, 123				; 0000007bH
	jne	SHORT $LN3@PassParent

; 503  :         {
; 504  :             PassBracers(lpTemp);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PassBracers@CodeTokenizer@@QAEHPA_W@Z	; CodeTokenizer::PassBracers

; 505  :             continue;

	jmp	$LN9@PassParent
	jmp	SHORT $LN6@PassParent
$LN3@PassParent:

; 506  :         }
; 507  :         else if(curToken[0] == '"')

	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	mov	ecx, 2
	imul	edx, ecx, 0
	movzx	eax, WORD PTR [eax+edx]
	cmp	eax, 34					; 00000022H
	jne	SHORT $LN6@PassParent

; 508  :         {
; 509  :             PassString(lpTemp);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PassString@CodeTokenizer@@QAEHPA_W@Z	; CodeTokenizer::PassString

; 510  :             continue;

	jmp	$LN9@PassParent
$LN6@PassParent:

; 511  :         }
; 512  :         GetNextToken(curToken);

	push	0
	lea	eax, DWORD PTR _curToken$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNextToken@CodeTokenizer@@QAEHAAVString@@H@Z ; CodeTokenizer::GetNextToken

; 513  :     }

	jmp	$LN9@PassParent
$LN8@PassParent:

; 514  : 
; 515  :     return FALSE;

	mov	DWORD PTR $T1[ebp], 0
	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR $T1[ebp]
$LN12@PassParent:

; 516  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?PassParenthesis@CodeTokenizer@@QAEHPA_W@Z ENDP		; CodeTokenizer::PassParenthesis
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\codetokenizer.cpp
;	COMDAT ?PassString@CodeTokenizer@@QAEHPA_W@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
_lpNextLeft$ = -8					; size = 4
_lpNextRight$ = -4					; size = 4
_lpCodePos$ = 8						; size = 4
?PassString@CodeTokenizer@@QAEHPA_W@Z PROC		; CodeTokenizer::PassString, COMDAT
; _this$ = ecx

; 519  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 520  :     TSTR lpNextLeft = schr(lpCodePos, '"');

	push	34					; 00000022H
	mov	eax, DWORD PTR _lpCodePos$[ebp]
	push	eax
	call	DWORD PTR __imp_?schr@@YGPA_WPB_W_W@Z
	mov	DWORD PTR _lpNextLeft$[ebp], eax

; 521  :     TSTR lpNextRight = lpNextLeft;

	mov	ecx, DWORD PTR _lpNextLeft$[ebp]
	mov	DWORD PTR _lpNextRight$[ebp], ecx
$LN4@PassString:

; 522  : 
; 523  :     while(1)

	mov	edx, 1
	test	edx, edx
	je	SHORT $LN3@PassString

; 524  :     {
; 525  :         lpNextRight = schr(lpNextRight+1, '"');

	push	34					; 00000022H
	mov	eax, DWORD PTR _lpNextRight$[ebp]
	add	eax, 2
	push	eax
	call	DWORD PTR __imp_?schr@@YGPA_WPB_W_W@Z
	mov	DWORD PTR _lpNextRight$[ebp], eax

; 526  :         if(!lpNextRight)

	cmp	DWORD PTR _lpNextRight$[ebp], 0
	jne	SHORT $LN2@PassString

; 527  :             return FALSE;

	xor	eax, eax
	jmp	SHORT $LN5@PassString
$LN2@PassString:

; 528  : 
; 529  :         if(lpNextRight[-1] != '\\')

	mov	ecx, 2
	imul	edx, ecx, -1
	mov	eax, DWORD PTR _lpNextRight$[ebp]
	movzx	ecx, WORD PTR [eax+edx]
	cmp	ecx, 92					; 0000005cH
	je	SHORT $LN1@PassString

; 530  :             break;

	jmp	SHORT $LN3@PassString
$LN1@PassString:

; 531  :     }

	jmp	SHORT $LN4@PassString
$LN3@PassString:

; 532  : 
; 533  :     lpTemp = lpNextRight+1;

	mov	edx, DWORD PTR _lpNextRight$[ebp]
	add	edx, 2
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx

; 534  : 
; 535  :     return TRUE;

	mov	eax, 1
$LN5@PassString:

; 536  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?PassString@CodeTokenizer@@QAEHPA_W@Z ENDP		; CodeTokenizer::PassString
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\codetokenizer.cpp
;	COMDAT ?GotoToken@CodeTokenizer@@QAEHPB_WH@Z
_TEXT	SEGMENT
_curToken$ = -20					; size = 8
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
_lpTarget$ = 8						; size = 4
_bPassToken$ = 12					; size = 4
?GotoToken@CodeTokenizer@@QAEHPB_WH@Z PROC		; CodeTokenizer::GotoToken, COMDAT
; _this$ = ecx

; 539  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 540  :     String curToken;

	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??0String@@QAE@XZ
$LN8@GotoToken:

; 541  : 
; 542  :     while(GetNextToken(curToken, TRUE))

	push	1
	lea	eax, DWORD PTR _curToken$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNextToken@CodeTokenizer@@QAEHAAVString@@H@Z ; CodeTokenizer::GetNextToken
	test	eax, eax
	je	$LN7@GotoToken

; 543  :     {
; 544  :         if(curToken == lpTarget)

	mov	ecx, DWORD PTR _lpTarget$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??8String@@QBEHPB_W@Z
	test	eax, eax
	je	SHORT $LN6@GotoToken

; 545  :         {
; 546  :             if(bPassToken)

	cmp	DWORD PTR _bPassToken$[ebp], 0
	je	SHORT $LN5@GotoToken

; 547  :                 GetNextToken(curToken);

	push	0
	lea	edx, DWORD PTR _curToken$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNextToken@CodeTokenizer@@QAEHAAVString@@H@Z ; CodeTokenizer::GetNextToken
$LN5@GotoToken:

; 548  :             return TRUE;

	mov	DWORD PTR $T2[ebp], 1
	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR $T2[ebp]
	jmp	$LN9@GotoToken
	jmp	SHORT $LN4@GotoToken
$LN6@GotoToken:

; 549  :         }
; 550  :         else if(curToken[0] == '{')

	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	mov	ecx, 2
	imul	edx, ecx, 0
	movzx	eax, WORD PTR [eax+edx]
	cmp	eax, 123				; 0000007bH
	jne	SHORT $LN3@GotoToken

; 551  :         {
; 552  :             PassBracers(lpTemp);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PassBracers@CodeTokenizer@@QAEHPA_W@Z	; CodeTokenizer::PassBracers

; 553  :             continue;

	jmp	SHORT $LN8@GotoToken
	jmp	SHORT $LN4@GotoToken
$LN3@GotoToken:

; 554  :         }
; 555  :         else if(curToken[0] == '(')

	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	mov	ecx, 2
	imul	edx, ecx, 0
	movzx	eax, WORD PTR [eax+edx]
	cmp	eax, 40					; 00000028H
	jne	SHORT $LN4@GotoToken

; 556  :         {
; 557  :             PassParenthesis(lpTemp);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PassParenthesis@CodeTokenizer@@QAEHPA_W@Z ; CodeTokenizer::PassParenthesis

; 558  :             continue;

	jmp	$LN8@GotoToken
$LN4@GotoToken:

; 559  :         }
; 560  :         GetNextToken(curToken);

	push	0
	lea	eax, DWORD PTR _curToken$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNextToken@CodeTokenizer@@QAEHAAVString@@H@Z ; CodeTokenizer::GetNextToken

; 561  :     }

	jmp	$LN8@GotoToken
$LN7@GotoToken:

; 562  : 
; 563  :     return FALSE;

	mov	DWORD PTR $T1[ebp], 0
	lea	ecx, DWORD PTR _curToken$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR $T1[ebp]
$LN9@GotoToken:

; 564  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GotoToken@CodeTokenizer@@QAEHPB_WH@Z ENDP		; CodeTokenizer::GotoToken
_TEXT	ENDS
END
