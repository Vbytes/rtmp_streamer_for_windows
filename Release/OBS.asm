; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.21005.1 

	TITLE	F:\songmm_moon_stone_obs\OBS\Source\OBS.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0N@LDJIAKLH@Comctl32?4dll?$AA@		; `string'
PUBLIC	??_C@_0BF@IABGBOLM@InitCommonControlsEx?$AA@	; `string'
PUBLIC	??_C@_1CC@HOAGLCLM@?$AAT?$AAe?$AAr?$AAm?$AAi?$AAn?$AAa?$AAt?$AAi?$AAn?$AAg?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AA@ ; `string'
PUBLIC	??_R1A@?0A@EA@Scene@@8				; Scene::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AUIconInfo@@@8				; IconInfo `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@OBS@@8				; OBS::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?SourceStaticProc@@3P6GJPAUHWND__@@IIJ@ZA	; SourceStaticProc
PUBLIC	??_R0?AUAudioDeviceInfo@@@8			; AudioDeviceInfo `RTTI Type Descriptor'
PUBLIC	?listboxProc@@3P6GJPAUHWND__@@IIJ@ZA		; listboxProc
PUBLIC	??_R0?AVOBS@@@8					; OBS `RTTI Type Descriptor'
PUBLIC	??_R0PAVSettingsPane@@@8			; SettingsPane * `RTTI Type Descriptor'
PUBLIC	??_R4OBS@@6B@					; OBS::`RTTI Complete Object Locator'
PUBLIC	??_R2Scene@@8					; Scene::`RTTI Base Class Array'
PUBLIC	?m@?1??CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY@@9@4@4UIsolationAwarePrivate_zHGnoyr_zBqHyr_vAsB@@A ; `CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY'::`2'::m
PUBLIC	?s_pfn@?1??IsolationAwareInitCommonControlsEx@@9@4@4P6GHPBUtagINITCOMMONCONTROLSEX@@@ZA ; `IsolationAwareInitCommonControlsEx'::`2'::s_pfn
PUBLIC	?s_module@?1??CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY@@9@4@4PAUHINSTANCE__@@A ; `CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY'::`2'::s_module
PUBLIC	?statusBarData@@3UStatusBarDrawData@@A		; statusBarData
PUBLIC	??_R4Scene@@6B@					; Scene::`RTTI Complete Object Locator'
PUBLIC	?listviewProc@@3P6GJPAUHWND__@@IIJ@ZA		; listviewProc
PUBLIC	??_R0?AVScene@@@8				; Scene `RTTI Type Descriptor'
PUBLIC	?c@?1??CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY@@9@4@4UIsolationAwarePrivate_pBAFGnAG_zBqHyr_vAsB@@B ; `CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY'::`2'::c
PUBLIC	??_SScene@@6B@					; Scene::`local vftable'
PUBLIC	??_R2OBS@@8					; OBS::`RTTI Base Class Array'
PUBLIC	??_R0?AUFontInfo@@@8				; FontInfo `RTTI Type Descriptor'
PUBLIC	??_R3OBS@@8					; OBS::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R3Scene@@8					; Scene::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_7OBS@@6B@					; OBS::`vftable'
EXTRN	__imp_?Join@StringList@@QAE?AVString@@V2@@Z:PROC
EXTRN	__imp_?CreateElement@XConfig@@QAEPAVXElement@@PB_W@Z:PROC
EXTRN	__imp_?DeselectAll@Scene@@AAEXXZ:PROC
EXTRN	__imp_?UpdateSettings@Scene@@UAEXXZ:PROC
EXTRN	?UpdateSettings@Scene@@UAEXXZ:PROC		; Scene::UpdateSettings
EXTRN	__imp_?NumSceneItems@Scene@@QBEIXZ:PROC
EXTRN	__imp_?GetSceneItem@Scene@@QBEPAVSceneItem@@I@Z:PROC
EXTRN	__imp_??0Scene@@QAE@XZ:PROC
EXTRN	__imp_?HasValue@?$List@VString@@@@QBEHABVString@@@Z:PROC
EXTRN	__imp__SetWindowPlacement@8:PROC
EXTRN	__imp__EnumDisplayMonitors@16:PROC
EXTRN	__imp__GetDiskFreeSpaceExW@16:PROC
EXTRN	__imp_?InitColorControl@@YAXPAUHINSTANCE__@@@Z:PROC
EXTRN	__imp__RegisterWindowMessageW@4:PROC
EXTRN	__imp__GetThreadId@4:PROC
EXTRN	__imp_?InitVolumeMeter@@YAXPAUHINSTANCE__@@@Z:PROC
EXTRN	__imp__CreateFontIndirectW@4:PROC
EXTRN	__imp__GetCurrentObject@8:PROC
EXTRN	__imp__SetFocus@4:PROC
EXTRN	__imp_?SetVolumeMeterValue@@YAMPAUHWND__@@MMMMMM@Z:PROC
EXTRN	__imp_?OSGetLoadedModuleList@@YGHPAXAAVStringList@@@Z:PROC
EXTRN	__imp_?ResetLogUpdateCallback@@YAXP6AXXZ@Z:PROC
EXTRN	__imp_?InsertImageSource@Scene@@UAEPAVSceneItem@@IPAVXElement@@@Z:PROC
EXTRN	?AddImageSource@Scene@@UAEPAVSceneItem@@PAVXElement@@@Z:PROC ; Scene::AddImageSource
EXTRN	__imp_??1Scene@@UAE@XZ:PROC
EXTRN	?InsertImageSource@Scene@@UAEPAVSceneItem@@IPAVXElement@@@Z:PROC ; Scene::InsertImageSource
EXTRN	__imp_?RemoveImageSource@Scene@@UAEXPAVSceneItem@@@Z:PROC
EXTRN	?Tick@Scene@@UAEXM@Z:PROC			; Scene::Tick
EXTRN	__imp_?AddImageSource@Scene@@UAEPAVSceneItem@@PAVXElement@@@Z:PROC
EXTRN	?RemoveImageSource@Scene@@UAEXPAVSceneItem@@@Z:PROC ; Scene::RemoveImageSource
EXTRN	__imp_?Preprocess@Scene@@UAEXXZ:PROC
EXTRN	?Render@Scene@@UAEXXZ:PROC			; Scene::Render
EXTRN	__imp_?Tick@Scene@@UAEXM@Z:PROC
EXTRN	?Preprocess@Scene@@UAEXXZ:PROC			; Scene::Preprocess
EXTRN	__imp_?RenderSelections@Scene@@UAEXPAVShader@@@Z:PROC
EXTRN	?BeginScene@Scene@@UAEXXZ:PROC			; Scene::BeginScene
EXTRN	__imp_?Render@Scene@@UAEXXZ:PROC
EXTRN	?RenderSelections@Scene@@UAEXPAVShader@@@Z:PROC	; Scene::RenderSelections
EXTRN	__imp_?EndScene@Scene@@UAEXXZ:PROC
EXTRN	__imp_?BeginScene@Scene@@UAEXXZ:PROC
EXTRN	?EndScene@Scene@@UAEXXZ:PROC			; Scene::EndScene
EXTRN	__imp__LoadIconW@8:PROC
EXTRN	__imp__GetWindowPlacement@8:PROC
EXTRN	__imp_?InsertElement@XElement@@QAEPAV1@IPB_W@Z:PROC
EXTRN	__imp_?RemoveElement@XElement@@QAEXPAV1@@Z:PROC
EXTRN	__imp_?InitVolumeControl@@YAXPAUHINSTANCE__@@@Z:PROC
EXTRN	__imp_?SetVolumeControlIcons@@YAXPAUHWND__@@PAUHICON__@@1@Z:PROC
EXTRN	__imp_?SetRender@SceneItem@@QAEX_N@Z:PROC
EXTRN	__imp__TerminateThread@8:PROC
EXTRN	__imp_?InitHotkeyExControl@@YAXPAUHINSTANCE__@@@Z:PROC
EXTRN	__imp_?SetVolumeControlValue@@YAMPAUHWND__@@M@Z:PROC
EXTRN	__imp__MonitorFromWindow@8:PROC
EXTRN	__imp_?OBSGetMainWindow@@YAPAUHWND__@@XZ:PROC
EXTRN	__imp_?OSMonitorDirectoryCallbackStop@@YAXPAUOSDirectoryMonitorData@@@Z:PROC
EXTRN	__imp__Shell_NotifyIconW@8:PROC
EXTRN	__imp__GetSystemTimeAsFileTime@4:PROC
EXTRN	__imp__IsBadReadPtr@8:PROC
EXTRN	__imp__SetMenu@8:PROC
EXTRN	__imp__GetSysColorBrush@4:PROC
EXTRN	__imp_?OBSGetAPIVersion@@YAIXZ:PROC
EXTRN	__imp_?GetFloat@ConfigFile@@QAEMPB_W0M@Z:PROC
EXTRN	__imp_?HasKey@ConfigFile@@QAEHPB_W0@Z:PROC
EXTRN	__imp_?Remove@ConfigFile@@QAEXPB_W0@Z:PROC
EXTRN	__imp_?SetVolumeControlMutedVal@@YAXPAUHWND__@@M@Z:PROC
EXTRN	__imp__GetSystemMetrics@4:PROC
EXTRN	__imp__GetTextColor@4:PROC
EXTRN	__imp__GetMonitorInfoW@8:PROC
EXTRN	__imp__CheckMenuItem@12:PROC
EXTRN	__imp__CreateSolidBrush@4:PROC
?SourceStaticProc@@3P6GJPAUHWND__@@IIJ@ZA DD 01H DUP (?) ; SourceStaticProc
?listboxProc@@3P6GJPAUHWND__@@IIJ@ZA DD 01H DUP (?)	; listboxProc
_BSS	ENDS
;	COMDAT ?m@?1??CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY@@9@4@4UIsolationAwarePrivate_zHGnoyr_zBqHyr_vAsB@@A
_BSS	SEGMENT
?m@?1??CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY@@9@4@4UIsolationAwarePrivate_zHGnoyr_zBqHyr_vAsB@@A DD 01H DUP (?) ; `CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY'::`2'::m
_BSS	ENDS
;	COMDAT ?s_pfn@?1??IsolationAwareInitCommonControlsEx@@9@4@4P6GHPBUtagINITCOMMONCONTROLSEX@@@ZA
_BSS	SEGMENT
?s_pfn@?1??IsolationAwareInitCommonControlsEx@@9@4@4P6GHPBUtagINITCOMMONCONTROLSEX@@@ZA DD 01H DUP (?) ; `IsolationAwareInitCommonControlsEx'::`2'::s_pfn
_BSS	ENDS
;	COMDAT ?s_module@?1??CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY@@9@4@4PAUHINSTANCE__@@A
_BSS	SEGMENT
?s_module@?1??CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY@@9@4@4PAUHINSTANCE__@@A DD 01H DUP (?) ; `CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY'::`2'::s_module
?statusBarData@@3UStatusBarDrawData@@A DB 010H DUP (?)	; statusBarData
?listviewProc@@3P6GJPAUHWND__@@IIJ@ZA DD 01H DUP (?)	; listviewProc
_BSS	ENDS
;	COMDAT ??_7OBS@@6B@
CONST	SEGMENT
??_7OBS@@6B@ DD	FLAT:??_R4OBS@@6B@			; OBS::`vftable'
	DD	FLAT:??_EOBS@@UAEPAXI@Z
	DD	FLAT:?GetIcon@OBS@@UAEPAUHICON__@@PAUHINSTANCE__@@H@Z
	DD	FLAT:?GetFont@OBS@@UAEPAUHFONT__@@PB_WHH@Z
	DD	FLAT:?RegisterSceneClass@OBS@@UAEXPB_W0P6GPAXPAVXElement@@@ZP6G_N1_N@Z3@Z
	DD	FLAT:?RegisterImageSourceClass@OBS@@UAEXPB_W0P6GPAXPAVXElement@@@ZP6G_N1_N@Z3@Z
	DD	FLAT:?CreateImageSource@OBS@@UAEPAVImageSource@@PB_WPAVXElement@@@Z
	DD	FLAT:?SetScene@OBS@@UAE_NPB_W@Z
	DD	FLAT:?InsertSourceItem@OBS@@UAEXIPA_W_N@Z
	DD	FLAT:?SetSceneCollection@OBS@@UAE_NPB_W@Z
	DD	FLAT:?SetDesktopVolume@OBS@@UAEXM_N@Z
	DD	FLAT:?GetDesktopVolume@OBS@@UAEMXZ
	DD	FLAT:?ToggleDesktopMute@OBS@@UAEXXZ
	DD	FLAT:?GetDesktopMuted@OBS@@UAE_NXZ
	DD	FLAT:?SetMicVolume@OBS@@UAEXM_N@Z
	DD	FLAT:?GetMicVolume@OBS@@UAEMXZ
	DD	FLAT:?ToggleMicMute@OBS@@UAEXXZ
	DD	FLAT:?GetMicMuted@OBS@@UAE_NXZ
	DD	FLAT:?ReportStartStreamTrigger@OBS@@UAEXXZ
	DD	FLAT:?ReportStopStreamTrigger@OBS@@UAEXXZ
	DD	FLAT:?ReportStartStreamingTrigger@OBS@@UAEXXZ
	DD	FLAT:?ReportStopStreamingTrigger@OBS@@UAEXXZ
	DD	FLAT:?ReportStartRecordingTrigger@OBS@@UAEXXZ
	DD	FLAT:?ReportStopRecordingTrigger@OBS@@UAEXXZ
	DD	FLAT:?ReportStartRecordingReplayBufferTrigger@OBS@@UAEXXZ
	DD	FLAT:?ReportStopRecordingReplayBufferTrigger@OBS@@UAEXXZ
	DD	FLAT:?ReportReplayBufferSavedTrigger@OBS@@UAEXVString@@I@Z
	DD	FLAT:?ReportOBSStatus@OBS@@UAEX_N0000@Z
	DD	FLAT:?ReportStreamStatus@OBS@@UAEX_N0INIIII@Z
	DD	FLAT:?ReportSwitchScenes@OBS@@UAEXPB_W@Z
	DD	FLAT:?ReportSwitchSceneCollections@OBS@@UAEXPB_W@Z
	DD	FLAT:?ReportScenesChanged@OBS@@UAEXXZ
	DD	FLAT:?ReportSceneCollectionsChanged@OBS@@UAEXXZ
	DD	FLAT:?ReportSourceOrderChanged@OBS@@UAEXXZ
	DD	FLAT:?ReportSourceChanged@OBS@@UAEXPB_WPAVXElement@@@Z
	DD	FLAT:?ReportSourcesAddedOrRemoved@OBS@@UAEXXZ
	DD	FLAT:?ReportMicVolumeChange@OBS@@UAEXM_N0@Z
	DD	FLAT:?ReportDesktopVolumeChange@OBS@@UAEXM_N0@Z
	DD	FLAT:?ReportLogUpdate@OBS@@UAEXPB_WI@Z
CONST	ENDS
;	COMDAT ??_R3Scene@@8
rdata$r	SEGMENT
??_R3Scene@@8 DD 00H					; Scene::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2Scene@@8
rdata$r	ENDS
;	COMDAT ??_R3OBS@@8
rdata$r	SEGMENT
??_R3OBS@@8 DD	00H					; OBS::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2OBS@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUFontInfo@@@8
data$r	SEGMENT
??_R0?AUFontInfo@@@8 DD FLAT:??_7type_info@@6B@		; FontInfo `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUFontInfo@@', 00H
data$r	ENDS
;	COMDAT ??_R2OBS@@8
rdata$r	SEGMENT
??_R2OBS@@8 DD	FLAT:??_R1A@?0A@EA@OBS@@8		; OBS::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_SScene@@6B@
CONST	SEGMENT
??_SScene@@6B@ DD FLAT:??_R4Scene@@6B@			; Scene::`local vftable'
	DD	FLAT:??_EScene@@UAEPAXI@Z
	DD	FLAT:?InsertImageSource@Scene@@UAEPAVSceneItem@@IPAVXElement@@@Z
	DD	FLAT:?AddImageSource@Scene@@UAEPAVSceneItem@@PAVXElement@@@Z
	DD	FLAT:?RemoveImageSource@Scene@@UAEXPAVSceneItem@@@Z
	DD	FLAT:?Tick@Scene@@UAEXM@Z
	DD	FLAT:?Preprocess@Scene@@UAEXXZ
	DD	FLAT:?Render@Scene@@UAEXXZ
	DD	FLAT:?UpdateSettings@Scene@@UAEXXZ
	DD	FLAT:?RenderSelections@Scene@@UAEXPAVShader@@@Z
	DD	FLAT:?BeginScene@Scene@@UAEXXZ
	DD	FLAT:?EndScene@Scene@@UAEXXZ
CONST	ENDS
;	COMDAT ?c@?1??CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY@@9@4@4UIsolationAwarePrivate_pBAFGnAG_zBqHyr_vAsB@@B
CONST	SEGMENT
?c@?1??CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY@@9@4@4UIsolationAwarePrivate_pBAFGnAG_zBqHyr_vAsB@@B DD FLAT:_IsolationAwarePrivatezlybNQyVOeNelJ@4 ; `CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY'::`2'::c
	DD	FLAT:??_C@_1BK@BFMCNHEO@?$AAC?$AAo?$AAm?$AAc?$AAt?$AAl?$AA3?$AA2?$AA?4?$AAd?$AAl?$AAl?$AA?$AA@
	DD	FLAT:_IsolationAwarePrivatezlybNQyVOeNeln@4
	DD	FLAT:??_C@_0N@LDJIAKLH@Comctl32?4dll?$AA@
CONST	ENDS
;	COMDAT ??_R0?AVScene@@@8
data$r	SEGMENT
??_R0?AVScene@@@8 DD FLAT:??_7type_info@@6B@		; Scene `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVScene@@', 00H
data$r	ENDS
;	COMDAT ??_R4Scene@@6B@
rdata$r	SEGMENT
??_R4Scene@@6B@ DD 00H					; Scene::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVScene@@@8
	DD	FLAT:??_R3Scene@@8
rdata$r	ENDS
;	COMDAT ??_R2Scene@@8
rdata$r	SEGMENT
??_R2Scene@@8 DD FLAT:??_R1A@?0A@EA@Scene@@8		; Scene::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R4OBS@@6B@
rdata$r	SEGMENT
??_R4OBS@@6B@ DD 00H					; OBS::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVOBS@@@8
	DD	FLAT:??_R3OBS@@8
rdata$r	ENDS
;	COMDAT ??_R0PAVSettingsPane@@@8
data$r	SEGMENT
??_R0PAVSettingsPane@@@8 DD FLAT:??_7type_info@@6B@	; SettingsPane * `RTTI Type Descriptor'
	DD	00H
	DB	'.PAVSettingsPane@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AVOBS@@@8
data$r	SEGMENT
??_R0?AVOBS@@@8 DD FLAT:??_7type_info@@6B@		; OBS `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVOBS@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AUAudioDeviceInfo@@@8
data$r	SEGMENT
??_R0?AUAudioDeviceInfo@@@8 DD FLAT:??_7type_info@@6B@	; AudioDeviceInfo `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUAudioDeviceInfo@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@OBS@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@OBS@@8 DD FLAT:??_R0?AVOBS@@@8		; OBS::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3OBS@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUIconInfo@@@8
data$r	SEGMENT
??_R0?AUIconInfo@@@8 DD FLAT:??_7type_info@@6B@		; IconInfo `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUIconInfo@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@Scene@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Scene@@8 DD FLAT:??_R0?AVScene@@@8	; Scene::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Scene@@8
rdata$r	ENDS
;	COMDAT ??_C@_1CC@HOAGLCLM@?$AAT?$AAe?$AAr?$AAm?$AAi?$AAn?$AAa?$AAt?$AAi?$AAn?$AAg?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@HOAGLCLM@?$AAT?$AAe?$AAr?$AAm?$AAi?$AAn?$AAa?$AAt?$AAi?$AAn?$AAg?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AA@ DB 'T'
	DB	00H, 'e', 00H, 'r', 00H, 'm', 00H, 'i', 00H, 'n', 00H, 'a', 00H
	DB	't', 00H, 'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H, '0', 00H, 'x'
	DB	00H, '%', 00H, 'x', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@IABGBOLM@InitCommonControlsEx?$AA@
CONST	SEGMENT
??_C@_0BF@IABGBOLM@InitCommonControlsEx?$AA@ DB 'InitCommonControlsEx', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LDJIAKLH@Comctl32?4dll?$AA@
CONST	SEGMENT
??_C@_0N@LDJIAKLH@Comctl32?4dll?$AA@ DB 'Comctl32.dll', 00H ; `string'
$SG4294800705 DB 'w', 00H, 'r', 00H, 'u', 00H, 's', 00H, 'r', 00H, '.', 00H
	DB	'd', 00H, 'l', 00H, 'l', 00H, 00H, 00H
	ORG $+2
$SG4294800704 DB 'D', 00H, 'i', 00H, 's', 00H, 'k', 00H, 'F', 00H, 'u', 00H
	DB	'l', 00H, 'l', 00H, 00H, 00H
	ORG $+2
$SG4294800707 DB 'M', 00H, 'S', 00H, 'I', 00H, 'M', 00H, 'G', 00H, '3', 00H
	DB	'2', 00H, 00H, 00H
$SG4294800706 DB 'AlphaBlend', 00H
	ORG $+2
$SG4294800701 DB 'p', 00H, 'l', 00H, 'u', 00H, 'g', 00H, 'i', 00H, 'n', 00H
	DB	's', 00H, '/', 00H, '*', 00H, '.', 00H, 'd', 00H, 'l', 00H, 'l'
	DB	00H, 00H, 00H
	ORG $+2
$SG4294800700 DB 'p', 00H, 'l', 00H, 'u', 00H, 'g', 00H, 'i', 00H, 'n', 00H
	DB	's', 00H, '/', 00H, 00H, 00H
$SG4294800702 DB 'B', 00H, 'a', 00H, 'd', 00H, 'A', 00H, 'p', 00H, 'p', 00H
	DB	'D', 00H, 'a', 00H, 't', 00H, 'a', 00H, 'P', 00H, 'e', 00H, 'r'
	DB	00H, 'm', 00H, 'i', 00H, 's', 00H, 's', 00H, 'i', 00H, 'o', 00H
	DB	'n', 00H, 's', 00H, 00H, 00H
$SG4294800698 DB 'LoadPlugin', 00H
$SG4294800703 DB '\', 00H, '.', 00H, 't', 00H, 'e', 00H, 's', 00H, 't', 00H
	DB	00H, 00H
	ORG $+2
$SG4294800697 DB 'OnStartStream', 00H
	ORG $+2
$SG4294800696 DB 'OnStopStream', 00H
	ORG $+3
$SG4294800699 DB 'LoadPluginEx', 00H
	ORG $+3
$SG4294800693 DB 'OnStartRecording', 00H
	ORG $+3
$SG4294800692 DB 'OnStopRecording', 00H
$SG4294800695 DB 'OnStartStreaming', 00H
	ORG $+3
$SG4294800694 DB 'OnStopStreaming', 00H
$SG4294800689 DB 'OnSceneSwitch', 00H
	ORG $+2
$SG4294800688 DB 'OnSceneCollectionSwitch', 00H
$SG4294800691 DB 'OnOBSStatus', 00H
$SG4294800690 DB 'OnStreamStatus', 00H
	ORG $+1
$SG4294800685 DB 'OnSourceOrderChanged', 00H
	ORG $+3
$SG4294800684 DB 'OnSourceChanged', 00H
$SG4294800687 DB 'OnScenesChanged', 00H
$SG4294800686 DB 'OnSceneCollectionsChanged', 00H
	ORG $+2
$SG4294800681 DB 'OnDesktopVolumeChanged', 00H
	ORG $+1
$SG4294800680 DB 'OnLogUpdate', 00H
$SG4294800683 DB 'OnSourcesAddedOrRemoved', 00H
$SG4294800682 DB 'OnMicVolumeChanged', 00H
	ORG $+1
$SG4294800677 DB 'OnReplayBufferSaved', 00H
$SG4294800676 DB 'F', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H
	DB	' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'i', 00H, 'n', 00H, 'i'
	DB	00H, 't', 00H, 'i', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'z', 00H
	DB	'e', 00H, ' ', 00H, 'p', 00H, 'l', 00H, 'u', 00H, 'g', 00H, 'i'
	DB	00H, 'n', 00H, ' ', 00H, '%', 00H, 's', 00H, 00H, 00H
	ORG $+2
$SG4294800679 DB 'OnStartRecordingReplayBuffer', 00H
	ORG $+3
$SG4294800678 DB 'OnStopRecordingReplayBuffer', 00H
$SG4294800675 DB 'F', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H
	DB	' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'l', 00H, 'o', 00H, 'a'
	DB	00H, 'd', 00H, ' ', 00H, 'p', 00H, 'l', 00H, 'u', 00H, 'g', 00H
	DB	'i', 00H, 'n', 00H, ' ', 00H, '%', 00H, 's', 00H, ',', 00H, ' '
	DB	00H, '%', 00H, 'd', 00H, 00H, 00H
	ORG $+2
$SG4294800673 DB 'C', 00H, 'o', 00H, 'u', 00H, 'l', 00H, 'd', 00H, ' ', 00H
	DB	'n', 00H, 'o', 00H, 't', 00H, ' ', 00H, 'i', 00H, 'n', 00H, 'i'
	DB	00H, 't', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'z', 00H, 'e', 00H
	DB	' ', 00H, 'c', 00H, 'o', 00H, 'm', 00H, 'm', 00H, 'o', 00H, 'n'
	DB	00H, ' ', 00H, 's', 00H, 'h', 00H, 'e', 00H, 'l', 00H, 'l', 00H
	DB	' ', 00H, 'c', 00H, 'o', 00H, 'n', 00H, 't', 00H, 'r', 00H, 'o'
	DB	00H, 'l', 00H, 's', 00H, 00H, 00H
$SG4294800672 DB 'e', 00H, 'n', 00H, 00H, 00H
	ORG $+2
$SG4294800674 DB 'P', 00H, 'l', 00H, 'u', 00H, 'g', 00H, 'i', 00H, 'n', 00H
	DB	's', 00H, '.', 00H, 'I', 00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l'
	DB	00H, 'i', 00H, 'd', 00H, 'V', 00H, 'e', 00H, 'r', 00H, 's', 00H
	DB	'i', 00H, 'o', 00H, 'n', 00H, 00H, 00H
	ORG $+2
$SG4294800669 DB 'S', 00H, 'c', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 00H, 00H
$SG4294800668 DB 'S', 00H, 'c', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 00H, 00H
$SG4294800671 DB 'L', 00H, 'a', 00H, 'n', 00H, 'g', 00H, 'u', 00H, 'a', 00H
	DB	'g', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG4294800670 DB 'G', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 'r', 00H, 'a', 00H
	DB	'l', 00H, 00H, 00H
$SG4294800665 DB 'S', 00H, 'o', 00H, 'u', 00H, 'r', 00H, 'c', 00H, 'e', 00H
	DB	's', 00H, '.', 00H, 'S', 00H, 'o', 00H, 'f', 00H, 't', 00H, 'w'
	DB	00H, 'a', 00H, 'r', 00H, 'e', 00H, 'C', 00H, 'a', 00H, 'p', 00H
	DB	't', 00H, 'u', 00H, 'r', 00H, 'e', 00H, 'S', 00H, 'o', 00H, 'u'
	DB	00H, 'r', 00H, 'c', 00H, 'e', 00H, '.', 00H, 'W', 00H, 'i', 00H
	DB	'n', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'C', 00H, 'a', 00H, 'p'
	DB	00H, 't', 00H, 'u', 00H, 'r', 00H, 'e', 00H, 00H, 00H
$SG4294800664 DB 'W', 00H, 'i', 00H, 'n', 00H, 'd', 00H, 'o', 00H, 'w', 00H
	DB	'C', 00H, 'a', 00H, 'p', 00H, 't', 00H, 'u', 00H, 'r', 00H, 'e'
	DB	00H, 'S', 00H, 'o', 00H, 'u', 00H, 'r', 00H, 'c', 00H, 'e', 00H
	DB	00H, 00H
$SG4294800667 DB 'S', 00H, 'o', 00H, 'u', 00H, 'r', 00H, 'c', 00H, 'e', 00H
	DB	's', 00H, '.', 00H, 'S', 00H, 'o', 00H, 'f', 00H, 't', 00H, 'w'
	DB	00H, 'a', 00H, 'r', 00H, 'e', 00H, 'C', 00H, 'a', 00H, 'p', 00H
	DB	't', 00H, 'u', 00H, 'r', 00H, 'e', 00H, 'S', 00H, 'o', 00H, 'u'
	DB	00H, 'r', 00H, 'c', 00H, 'e', 00H, 00H, 00H
$SG4294800666 DB 'D', 00H, 'e', 00H, 's', 00H, 'k', 00H, 't', 00H, 'o', 00H
	DB	'p', 00H, 'I', 00H, 'm', 00H, 'a', 00H, 'g', 00H, 'e', 00H, 'S'
	DB	00H, 'o', 00H, 'u', 00H, 'r', 00H, 'c', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG4294800661 DB 'S', 00H, 'o', 00H, 'u', 00H, 'r', 00H, 'c', 00H, 'e', 00H
	DB	's', 00H, '.', 00H, 'B', 00H, 'i', 00H, 't', 00H, 'm', 00H, 'a'
	DB	00H, 'p', 00H, 'S', 00H, 'o', 00H, 'u', 00H, 'r', 00H, 'c', 00H
	DB	'e', 00H, 00H, 00H
	ORG $+2
$SG4294800660 DB 'B', 00H, 'i', 00H, 't', 00H, 'm', 00H, 'a', 00H, 'p', 00H
	DB	'I', 00H, 'm', 00H, 'a', 00H, 'g', 00H, 'e', 00H, 'S', 00H, 'o'
	DB	00H, 'u', 00H, 'r', 00H, 'c', 00H, 'e', 00H, 00H, 00H
$SG4294800662 DB 'M', 00H, 'o', 00H, 'n', 00H, 'i', 00H, 't', 00H, 'o', 00H
	DB	'r', 00H, 'C', 00H, 'a', 00H, 'p', 00H, 't', 00H, 'u', 00H, 'r'
	DB	00H, 'e', 00H, 'S', 00H, 'o', 00H, 'u', 00H, 'r', 00H, 'c', 00H
	DB	'e', 00H, 00H, 00H
	ORG $+2
$SG4294800663 DB 'S', 00H, 'o', 00H, 'u', 00H, 'r', 00H, 'c', 00H, 'e', 00H
	DB	's', 00H, '.', 00H, 'S', 00H, 'o', 00H, 'f', 00H, 't', 00H, 'w'
	DB	00H, 'a', 00H, 'r', 00H, 'e', 00H, 'C', 00H, 'a', 00H, 'p', 00H
	DB	't', 00H, 'u', 00H, 'r', 00H, 'e', 00H, 'S', 00H, 'o', 00H, 'u'
	DB	00H, 'r', 00H, 'c', 00H, 'e', 00H, '.', 00H, 'M', 00H, 'o', 00H
	DB	'n', 00H, 'i', 00H, 't', 00H, 'o', 00H, 'r', 00H, 'C', 00H, 'a'
	DB	00H, 'p', 00H, 't', 00H, 'u', 00H, 'r', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG4294800657 DB 'S', 00H, 'o', 00H, 'u', 00H, 'r', 00H, 'c', 00H, 'e', 00H
	DB	's', 00H, '.', 00H, 'G', 00H, 'l', 00H, 'o', 00H, 'b', 00H, 'a'
	DB	00H, 'l', 00H, 'S', 00H, 'o', 00H, 'u', 00H, 'r', 00H, 'c', 00H
	DB	'e', 00H, 00H, 00H
	ORG $+2
$SG4294800656 DB 'G', 00H, 'l', 00H, 'o', 00H, 'b', 00H, 'a', 00H, 'l', 00H
	DB	'S', 00H, 'o', 00H, 'u', 00H, 'r', 00H, 'c', 00H, 'e', 00H, 00H
	DB	00H
	ORG $+2
$SG4294800659 DB 'S', 00H, 'o', 00H, 'u', 00H, 'r', 00H, 'c', 00H, 'e', 00H
	DB	's', 00H, '.', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'n', 00H, 's'
	DB	00H, 'i', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, 'S', 00H
	DB	'o', 00H, 'u', 00H, 'r', 00H, 'c', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG4294800658 DB 'B', 00H, 'i', 00H, 't', 00H, 'm', 00H, 'a', 00H, 'p', 00H
	DB	'T', 00H, 'r', 00H, 'a', 00H, 'n', 00H, 's', 00H, 'i', 00H, 't'
	DB	00H, 'i', 00H, 'o', 00H, 'n', 00H, 'S', 00H, 'o', 00H, 'u', 00H
	DB	'r', 00H, 'c', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG4294800653 DB 'O', 00H, 'B', 00H, 'S', 00H, 'R', 00H, 'e', 00H, 'n', 00H
	DB	'd', 00H, 'e', 00H, 'r', 00H, 'F', 00H, 'r', 00H, 'a', 00H, 'm'
	DB	00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG4294800652 DB 'C', 00H, 'o', 00H, 'u', 00H, 'l', 00H, 'd', 00H, ' ', 00H
	DB	'n', 00H, 'o', 00H, 't', 00H, ' ', 00H, 'r', 00H, 'e', 00H, 'g'
	DB	00H, 'i', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r', 00H, ' ', 00H
	DB	'r', 00H, 'e', 00H, 'n', 00H, 'd', 00H, 'e', 00H, 'r', 00H, ' '
	DB	00H, 'f', 00H, 'r', 00H, 'a', 00H, 'm', 00H, 'e', 00H, ' ', 00H
	DB	'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H, 00H, 00H
$SG4294800655 DB 'S', 00H, 'o', 00H, 'u', 00H, 'r', 00H, 'c', 00H, 'e', 00H
	DB	's', 00H, '.', 00H, 'T', 00H, 'e', 00H, 'x', 00H, 't', 00H, 'S'
	DB	00H, 'o', 00H, 'u', 00H, 'r', 00H, 'c', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG4294800654 DB 'T', 00H, 'e', 00H, 'x', 00H, 't', 00H, 'S', 00H, 'o', 00H
	DB	'u', 00H, 'r', 00H, 'c', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG4294800649 DB 'O', 00H, 'B', 00H, 'S', 00H, 'L', 00H, 'o', 00H, 'g', 00H
	DB	'W', 00H, 'i', 00H, 'n', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'C'
	DB	00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H, 00H, 00H
$SG4294800648 DB 'C', 00H, 'o', 00H, 'u', 00H, 'l', 00H, 'd', 00H, ' ', 00H
	DB	'n', 00H, 'o', 00H, 't', 00H, ' ', 00H, 'r', 00H, 'e', 00H, 'g'
	DB	00H, 'i', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r', 00H, ' ', 00H
	DB	'm', 00H, 'a', 00H, 'i', 00H, 'n', 00H, ' ', 00H, 'w', 00H, 'i'
	DB	00H, 'n', 00H, 'd', 00H, 'o', 00H, 'w', 00H, ' ', 00H, 'c', 00H
	DB	'l', 00H, 'a', 00H, 's', 00H, 's', 00H, 00H, 00H
	ORG $+2
$SG4294800651 DB 'O', 00H, 'B', 00H, 'S', 00H, 'P', 00H, 'r', 00H, 'o', 00H
	DB	'j', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, 'F'
	DB	00H, 'r', 00H, 'a', 00H, 'm', 00H, 'e', 00H, 00H, 00H
$SG4294800650 DB 'C', 00H, 'o', 00H, 'u', 00H, 'l', 00H, 'd', 00H, ' ', 00H
	DB	'n', 00H, 'o', 00H, 't', 00H, ' ', 00H, 'r', 00H, 'e', 00H, 'g'
	DB	00H, 'i', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r', 00H, ' ', 00H
	DB	'p', 00H, 'r', 00H, 'o', 00H, 'j', 00H, 'e', 00H, 'c', 00H, 't'
	DB	00H, 'o', 00H, 'r', 00H, ' ', 00H, 'f', 00H, 'r', 00H, 'a', 00H
	DB	'm', 00H, 'e', 00H, ' ', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's'
	DB	00H, 's', 00H, 00H, 00H
	ORG $+2
$SG4294800645 DB 'W', 00H, 'i', 00H, 'd', 00H, 't', 00H, 'h', 00H, 00H, 00H
$SG4294800644 DB 'G', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 'r', 00H, 'a', 00H
	DB	'l', 00H, 00H, 00H
$SG4294800647 DB 'O', 00H, 'B', 00H, 'S', 00H, 'W', 00H, 'i', 00H, 'n', 00H
	DB	'd', 00H, 'o', 00H, 'w', 00H, 'C', 00H, 'l', 00H, 'a', 00H, 's'
	DB	00H, 's', 00H, 00H, 00H
	ORG $+2
$SG4294800646 DB 'C', 00H, 'o', 00H, 'u', 00H, 'l', 00H, 'd', 00H, ' ', 00H
	DB	'n', 00H, 'o', 00H, 't', 00H, ' ', 00H, 'r', 00H, 'e', 00H, 'g'
	DB	00H, 'i', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r', 00H, ' ', 00H
	DB	'm', 00H, 'a', 00H, 'i', 00H, 'n', 00H, ' ', 00H, 'w', 00H, 'i'
	DB	00H, 'n', 00H, 'd', 00H, 'o', 00H, 'w', 00H, ' ', 00H, 'c', 00H
	DB	'l', 00H, 'a', 00H, 's', 00H, 's', 00H, 00H, 00H
	ORG $+2
$SG4294800641 DB 'P', 00H, 'o', 00H, 's', 00H, 'X', 00H, 00H, 00H
	ORG $+2
$SG4294800640 DB 'G', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 'r', 00H, 'a', 00H
	DB	'l', 00H, 00H, 00H
$SG4294800643 DB 'H', 00H, 'e', 00H, 'i', 00H, 'g', 00H, 'h', 00H, 't', 00H
	DB	00H, 00H
	ORG $+2
$SG4294800642 DB 'G', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 'r', 00H, 'a', 00H
	DB	'l', 00H, 00H, 00H
$SG4294800637 DB 'P', 00H, 'a', 00H, 'n', 00H, 'e', 00H, 'l', 00H, 'V', 00H
	DB	'i', 00H, 's', 00H, 'i', 00H, 'b', 00H, 'l', 00H, 'e', 00H, 'W'
	DB	00H, 'i', 00H, 'n', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'e', 00H
	DB	'd', 00H, 00H, 00H
	ORG $+2
$SG4294800636 DB 'G', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 'r', 00H, 'a', 00H
	DB	'l', 00H, 00H, 00H
$SG4294800639 DB 'P', 00H, 'o', 00H, 's', 00H, 'Y', 00H, 00H, 00H
	ORG $+2
$SG4294800638 DB 'G', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 'r', 00H, 'a', 00H
	DB	'l', 00H, 00H, 00H
$SG4294800633 DB 'O', 00H, 'B', 00H, 'S', 00H, 'W', 00H, 'i', 00H, 'n', 00H
	DB	'd', 00H, 'o', 00H, 'w', 00H, 'C', 00H, 'l', 00H, 'a', 00H, 's'
	DB	00H, 's', 00H, 00H, 00H
	ORG $+2
$SG4294800632 DB 'C', 00H, 'o', 00H, 'u', 00H, 'l', 00H, 'd', 00H, ' ', 00H
	DB	'n', 00H, 'o', 00H, 't', 00H, ' ', 00H, 'c', 00H, 'r', 00H, 'e'
	DB	00H, 'a', 00H, 't', 00H, 'e', 00H, ' ', 00H, 'm', 00H, 'a', 00H
	DB	'i', 00H, 'n', 00H, ' ', 00H, 'w', 00H, 'i', 00H, 'n', 00H, 'd'
	DB	00H, 'o', 00H, 'w', 00H, 00H, 00H
	ORG $+2
$SG4294800635 DB 'P', 00H, 'a', 00H, 'n', 00H, 'e', 00H, 'l', 00H, 'V', 00H
	DB	'i', 00H, 's', 00H, 'i', 00H, 'b', 00H, 'l', 00H, 'e', 00H, 'F'
	DB	00H, 'u', 00H, 'l', 00H, 'l', 00H, 's', 00H, 'c', 00H, 'r', 00H
	DB	'e', 00H, 'e', 00H, 'n', 00H, 00H, 00H
	ORG $+2
$SG4294800634 DB 'G', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 'r', 00H, 'a', 00H
	DB	'l', 00H, 00H, 00H
$SG4294800629 DB 'O', 00H, 'B', 00H, 'S', 00H, ' ', 00H, 'P', 00H, 'r', 00H
	DB	'o', 00H, 'j', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, ' ', 00H, 'W', 00H, 'i', 00H, 'n', 00H, 'd', 00H, 'o', 00H
	DB	'w', 00H, 00H, 00H
	ORG $+2
$SG4294800628 DB 'O', 00H, 'B', 00H, 'S', 00H, 'P', 00H, 'r', 00H, 'o', 00H
	DB	'j', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, 'F'
	DB	00H, 'r', 00H, 'a', 00H, 'm', 00H, 'e', 00H, 00H, 00H
$SG4294800631 DB 'O', 00H, 'B', 00H, 'S', 00H, 'R', 00H, 'e', 00H, 'n', 00H
	DB	'd', 00H, 'e', 00H, 'r', 00H, 'F', 00H, 'r', 00H, 'a', 00H, 'm'
	DB	00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG4294800630 DB 'C', 00H, 'o', 00H, 'u', 00H, 'l', 00H, 'd', 00H, ' ', 00H
	DB	'n', 00H, 'o', 00H, 't', 00H, ' ', 00H, 'c', 00H, 'r', 00H, 'e'
	DB	00H, 'a', 00H, 't', 00H, 'e', 00H, ' ', 00H, 'r', 00H, 'e', 00H
	DB	'n', 00H, 'd', 00H, 'e', 00H, 'r', 00H, ' ', 00H, 'f', 00H, 'r'
	DB	00H, 'a', 00H, 'm', 00H, 'e', 00H, 00H, 00H
$SG4294800625 DB 'L', 00H, 'o', 00H, 'g', 00H, 'P', 00H, 'o', 00H, 's', 00H
	DB	'Y', 00H, 00H, 00H
$SG4294800624 DB 'G', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 'r', 00H, 'a', 00H
	DB	'l', 00H, 00H, 00H
$SG4294800627 DB 'L', 00H, 'o', 00H, 'g', 00H, 'P', 00H, 'o', 00H, 's', 00H
	DB	'X', 00H, 00H, 00H
$SG4294800626 DB 'G', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 'r', 00H, 'a', 00H
	DB	'l', 00H, 00H, 00H
$SG4294800621 DB 'L', 00H, 'o', 00H, 'g', 00H, 'S', 00H, 'i', 00H, 'z', 00H
	DB	'e', 00H, 'Y', 00H, 00H, 00H
	ORG $+2
$SG4294800620 DB 'G', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 'r', 00H, 'a', 00H
	DB	'l', 00H, 00H, 00H
$SG4294800623 DB 'L', 00H, 'o', 00H, 'g', 00H, 'S', 00H, 'i', 00H, 'z', 00H
	DB	'e', 00H, 'X', 00H, 00H, 00H
	ORG $+2
$SG4294800622 DB 'G', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 'r', 00H, 'a', 00H
	DB	'l', 00H, 00H, 00H
$SG4294800617 DB 00H, 00H
	ORG $+2
$SG4294800616 DB 'E', 00H, 'D', 00H, 'I', 00H, 'T', 00H, 00H, 00H
	ORG $+2
$SG4294800619 DB 'L', 00H, 'o', 00H, 'g', 00H, 'W', 00H, 'i', 00H, 'n', 00H
	DB	'd', 00H, 'o', 00H, 'w', 00H, 00H, 00H
$SG4294800618 DB 'O', 00H, 'B', 00H, 'S', 00H, 'L', 00H, 'o', 00H, 'g', 00H
	DB	'W', 00H, 'i', 00H, 'n', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'C'
	DB	00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H, 00H, 00H
$SG4294800613 DB 00H, 00H
	ORG $+2
$SG4294800612 DB 'O', 00H, 'B', 00H, 'S', 00H, 'V', 00H, 'o', 00H, 'l', 00H
	DB	'u', 00H, 'm', 00H, 'e', 00H, 'C', 00H, 'o', 00H, 'n', 00H, 't'
	DB	00H, 'r', 00H, 'o', 00H, 'l', 00H, 00H, 00H
	ORG $+2
$SG4294800615 DB 'L', 00H, 'I', 00H, 'S', 00H, 'T', 00H, 'B', 00H, 'O', 00H
	DB	'X', 00H, 00H, 00H
$SG4294800614 DB 'S', 00H, 'y', 00H, 's', 00H, 'L', 00H, 'i', 00H, 's', 00H
	DB	't', 00H, 'V', 00H, 'i', 00H, 'e', 00H, 'w', 00H, '3', 00H, '2'
	DB	00H, 00H, 00H
$SG4294800609 DB 'O', 00H, 'B', 00H, 'S', 00H, 'V', 00H, 'o', 00H, 'l', 00H
	DB	'u', 00H, 'm', 00H, 'e', 00H, 'C', 00H, 'o', 00H, 'n', 00H, 't'
	DB	00H, 'r', 00H, 'o', 00H, 'l', 00H, 00H, 00H
	ORG $+2
$SG4294800608 DB 'M', 00H, 'a', 00H, 'i', 00H, 'n', 00H, 'W', 00H, 'i', 00H
	DB	'n', 00H, 'd', 00H, 'o', 00H, 'w', 00H, '.', 00H, 'D', 00H, 'a'
	DB	00H, 's', 00H, 'h', 00H, 'b', 00H, 'o', 00H, 'a', 00H, 'r', 00H
	DB	'd', 00H, 00H, 00H
	ORG $+2
$SG4294800611 DB 'O', 00H, 'B', 00H, 'S', 00H, 'V', 00H, 'o', 00H, 'l', 00H
	DB	'u', 00H, 'm', 00H, 'e', 00H, 'M', 00H, 'e', 00H, 't', 00H, 'e'
	DB	00H, 'r', 00H, 00H, 00H
	ORG $+2
$SG4294800610 DB 'O', 00H, 'B', 00H, 'S', 00H, 'V', 00H, 'o', 00H, 'l', 00H
	DB	'u', 00H, 'm', 00H, 'e', 00H, 'M', 00H, 'e', 00H, 't', 00H, 'e'
	DB	00H, 'r', 00H, 00H, 00H
	ORG $+2
$SG4294800605 DB 'S', 00H, 'T', 00H, 'A', 00H, 'T', 00H, 'I', 00H, 'C', 00H
	DB	00H, 00H
	ORG $+2
$SG4294800604 DB 'M', 00H, 'a', 00H, 'i', 00H, 'n', 00H, 'W', 00H, 'i', 00H
	DB	'n', 00H, 'd', 00H, 'o', 00H, 'w', 00H, '.', 00H, 'S', 00H, 'o'
	DB	00H, 'u', 00H, 'r', 00H, 'c', 00H, 'e', 00H, 's', 00H, 00H, 00H
	ORG $+2
$SG4294800607 DB 'B', 00H, 'U', 00H, 'T', 00H, 'T', 00H, 'O', 00H, 'N', 00H
	DB	00H, 00H
	ORG $+2
$SG4294800606 DB 'M', 00H, 'a', 00H, 'i', 00H, 'n', 00H, 'W', 00H, 'i', 00H
	DB	'n', 00H, 'd', 00H, 'o', 00H, 'w', 00H, '.', 00H, 'S', 00H, 'c'
	DB	00H, 'e', 00H, 'n', 00H, 'e', 00H, 's', 00H, 00H, 00H
$SG4294800601 DB 'S', 00H, 'h', 00H, 'o', 00H, 'w', 00H, 'N', 00H, 'o', 00H
	DB	't', 00H, 'i', 00H, 'f', 00H, 'i', 00H, 'c', 00H, 'a', 00H, 't'
	DB	00H, 'i', 00H, 'o', 00H, 'n', 00H, 'A', 00H, 'r', 00H, 'e', 00H
	DB	'a', 00H, 'I', 00H, 'c', 00H, 'o', 00H, 'n', 00H, 00H, 00H
	ORG $+2
$SG4294800600 DB 'G', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 'r', 00H, 'a', 00H
	DB	'l', 00H, 00H, 00H
$SG4294800603 DB 'S', 00H, 'T', 00H, 'A', 00H, 'T', 00H, 'I', 00H, 'C', 00H
	DB	00H, 00H
	ORG $+2
$SG4294800602 DB 'T', 00H, 'a', 00H, 's', 00H, 'k', 00H, 'b', 00H, 'a', 00H
	DB	'r', 00H, 'C', 00H, 'r', 00H, 'e', 00H, 'a', 00H, 't', 00H, 'e'
	DB	00H, 'd', 00H, 00H, 00H
	ORG $+2
$SG4294800597 DB '\', 00H, 's', 00H, 'c', 00H, 'e', 00H, 'n', 00H, 'e', 00H
	DB	'C', 00H, 'o', 00H, 'l', 00H, 'l', 00H, 'e', 00H, 'c', 00H, 't'
	DB	00H, 'i', 00H, 'o', 00H, 'n', 00H, '\', 00H, '*', 00H, '.', 00H
	DB	'x', 00H, 'c', 00H, 'o', 00H, 'n', 00H, 'f', 00H, 'i', 00H, 'g'
	DB	00H, 00H, 00H
	ORG $+2
$SG4294800599 DB '\', 00H, 's', 00H, 'c', 00H, 'e', 00H, 'n', 00H, 'e', 00H
	DB	'C', 00H, 'o', 00H, 'l', 00H, 'l', 00H, 'e', 00H, 'c', 00H, 't'
	DB	00H, 'i', 00H, 'o', 00H, 'n', 00H, '\', 00H, 00H, 00H
$SG4294800596 DB '\', 00H, 's', 00H, 'c', 00H, 'e', 00H, 'n', 00H, 'e', 00H
	DB	'C', 00H, 'o', 00H, 'l', 00H, 'l', 00H, 'e', 00H, 'c', 00H, 't'
	DB	00H, 'i', 00H, 'o', 00H, 'n', 00H, '\', 00H, 's', 00H, 'c', 00H
	DB	'e', 00H, 'n', 00H, 'e', 00H, 's', 00H, '.', 00H, 'x', 00H, 'c'
	DB	00H, 'o', 00H, 'n', 00H, 'f', 00H, 'i', 00H, 'g', 00H, 00H, 00H
$SG4294800598 DB '.', 00H, 'x', 00H, 'c', 00H, 'o', 00H, 'n', 00H, 'f', 00H
	DB	'i', 00H, 'g', 00H, 00H, 00H
	ORG $+2
$SG4294800593 DB 'S', 00H, 'c', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 'C', 00H
	DB	'o', 00H, 'l', 00H, 'l', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'i'
	DB	00H, 'o', 00H, 'n', 00H, 00H, 00H
$SG4294800592 DB 'G', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 'r', 00H, 'a', 00H
	DB	'l', 00H, 00H, 00H
$SG4294800595 DB '\', 00H, 's', 00H, 'c', 00H, 'e', 00H, 'n', 00H, 'e', 00H
	DB	's', 00H, '.', 00H, 'x', 00H, 'c', 00H, 'o', 00H, 'n', 00H, 'f'
	DB	00H, 'i', 00H, 'g', 00H, 00H, 00H
$SG4294800594 DB 's', 00H, 'c', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 's', 00H
	DB	00H, 00H
	ORG $+2
$SG4294800589 DB 's', 00H, 'c', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 's', 00H
	DB	00H, 00H
	ORG $+2
$SG4294800588 DB 's', 00H, 'c', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 's', 00H
	DB	00H, 00H
	ORG $+2
$SG4294800591 DB '%', 00H, 's', 00H, '\', 00H, 's', 00H, 'c', 00H, 'e', 00H
	DB	'n', 00H, 'e', 00H, 'C', 00H, 'o', 00H, 'l', 00H, 'l', 00H, 'e'
	DB	00H, 'c', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, '\', 00H
	DB	'%', 00H, 's', 00H, '.', 00H, 'x', 00H, 'c', 00H, 'o', 00H, 'n'
	DB	00H, 'f', 00H, 'i', 00H, 'g', 00H, 00H, 00H
$SG4294800590 DB 'C', 00H, 'o', 00H, 'u', 00H, 'l', 00H, 'd', 00H, ' ', 00H
	DB	'n', 00H, 'o', 00H, 't', 00H, ' ', 00H, 'o', 00H, 'p', 00H, 'e'
	DB	00H, 'n', 00H, ' ', 00H, '''', 00H, '%', 00H, 's', 00H, '''', 00H
	DB	00H, 00H
$SG4294800585 DB 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H, 00H, 00H
$SG4294800584 DB 'C', 00H, 'u', 00H, 'r', 00H, 'r', 00H, 'e', 00H, 'n', 00H
	DB	't', 00H, 'S', 00H, 'c', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 00H
	DB	00H
	ORG $+2
$SG4294800587 DB 'S', 00H, 'c', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 00H, 00H
$SG4294800586 DB 'S', 00H, 'c', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 00H, 00H
$SG4294800581 DB 'A', 00H, 'u', 00H, 't', 00H, 'o', 00H, 'R', 00H, 'e', 00H
	DB	'c', 00H, 'o', 00H, 'n', 00H, 'n', 00H, 'e', 00H, 'c', 00H, 't'
	DB	00H, 00H, 00H
$SG4294800580 DB 'P', 00H, 'u', 00H, 'b', 00H, 'l', 00H, 'i', 00H, 's', 00H
	DB	'h', 00H, 00H, 00H
$SG4294800583 DB 'G', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 'r', 00H, 'a', 00H
	DB	'l', 00H, 00H, 00H
$SG4294800582 DB 'h', 00H, 'o', 00H, 't', 00H, 'k', 00H, 'e', 00H, 'y', 00H
	DB	00H, 00H
	ORG $+2
$SG4294800577 DB 'L', 00H, 'a', 00H, 's', 00H, 't', 00H, 'U', 00H, 'p', 00H
	DB	'd', 00H, 'a', 00H, 't', 00H, 'e', 00H, 'C', 00H, 'h', 00H, 'e'
	DB	00H, 'c', 00H, 'k', 00H, 00H, 00H
$SG4294800576 DB 'G', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 'r', 00H, 'a', 00H
	DB	'l', 00H, 00H, 00H
$SG4294800579 DB 'A', 00H, 'u', 00H, 't', 00H, 'o', 00H, 'R', 00H, 'e', 00H
	DB	'c', 00H, 'o', 00H, 'n', 00H, 'n', 00H, 'e', 00H, 'c', 00H, 't'
	DB	00H, 'T', 00H, 'i', 00H, 'm', 00H, 'e', 00H, 'o', 00H, 'u', 00H
	DB	't', 00H, 00H, 00H
	ORG $+2
$SG4294800578 DB 'P', 00H, 'u', 00H, 'b', 00H, 'l', 00H, 'i', 00H, 's', 00H
	DB	'h', 00H, 00H, 00H
$SG4294800573 DB 'P', 00H, 'r', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'e', 00H
	DB	'w', 00H, 'E', 00H, 'n', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e'
	DB	00H, 'd', 00H, 00H, 00H
	ORG $+2
$SG4294800572 DB 'G', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 'r', 00H, 'a', 00H
	DB	'l', 00H, 00H, 00H
$SG4294800575 DB 'L', 00H, 'a', 00H, 's', 00H, 't', 00H, 'U', 00H, 'p', 00H
	DB	'd', 00H, 'a', 00H, 't', 00H, 'e', 00H, 'C', 00H, 'h', 00H, 'e'
	DB	00H, 'c', 00H, 'k', 00H, 00H, 00H
$SG4294800574 DB 'G', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 'r', 00H, 'a', 00H
	DB	'l', 00H, 00H, 00H
$SG4294800569 DB 'J', 00H, 'u', 00H, 's', 00H, 't', 00H, ' ', 00H, 'a', 00H
	DB	' ', 00H, 's', 00H, 'l', 00H, 'i', 00H, 'g', 00H, 'h', 00H, 't'
	DB	00H, ' ', 00H, 'i', 00H, 's', 00H, 's', 00H, 'u', 00H, 'e', 00H
	DB	' ', 00H, 'y', 00H, 'o', 00H, 'u', 00H, ' ', 00H, 'm', 00H, 'i'
	DB	00H, 'g', 00H, 'h', 00H, 't', 00H, ' ', 00H, 'w', 00H, 'a', 00H
	DB	'n', 00H, 't', 00H, ' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'b'
	DB	00H, 'e', 00H, ' ', 00H, 'a', 00H, 'w', 00H, 'a', 00H, 'r', 00H
	DB	'e', 00H, ' ', 00H, 'o', 00H, 'f', 00H, 00H, 00H
$SG4294800560 DB 'S', 00H, 'h', 00H, 'o', 00H, 'w', 00H, 'N', 00H, 'o', 00H
	DB	't', 00H, 'i', 00H, 'f', 00H, 'i', 00H, 'c', 00H, 'a', 00H, 't'
	DB	00H, 'i', 00H, 'o', 00H, 'n', 00H, 'A', 00H, 'r', 00H, 'e', 00H
	DB	'a', 00H, 'I', 00H, 'c', 00H, 'o', 00H, 'n', 00H, 00H, 00H
	ORG $+2
$SG4294800568 DB 'W', 00H, 'e', 00H, 'b', 00H, 'r', 00H, 'o', 00H, 'o', 00H
	DB	't', 00H, ' ', 00H, 'S', 00H, 'e', 00H, 'c', 00H, 'u', 00H, 'r'
	DB	00H, 'e', 00H, 'a', 00H, 'n', 00H, 'y', 00H, 'w', 00H, 'h', 00H
	DB	'e', 00H, 'r', 00H, 'e', 00H, ' ', 00H, 'a', 00H, 'p', 00H, 'p'
	DB	00H, 'e', 00H, 'a', 00H, 'r', 00H, 's', 00H, ' ', 00H, 't', 00H
	DB	'o', 00H, ' ', 00H, 'b', 00H, 'e', 00H, ' ', 00H, 'a', 00H, 'c'
	DB	00H, 't', 00H, 'i', 00H, 'v', 00H, 'e', 00H, '.', 00H, ' ', 00H
	DB	' ', 00H, 'T', 00H, 'h', 00H, 'i', 00H, 's', 00H, ' ', 00H, 'p'
	DB	00H, 'r', 00H, 'o', 00H, 'd', 00H, 'u', 00H, 'c', 00H, 't', 00H
	DB	' ', 00H, 'w', 00H, 'i', 00H, 'l', 00H, 'l', 00H, ' ', 00H, 'c'
	DB	00H, 'a', 00H, 'u', 00H, 's', 00H, 'e', 00H, ' ', 00H, 'p', 00H
	DB	'r', 00H, 'o', 00H, 'b', 00H, 'l', 00H, 'e', 00H, 'm', 00H, 's'
	DB	00H, ' ', 00H, 'w', 00H, 'i', 00H, 't', 00H, 'h', 00H, ' ', 00H
	DB	'O', 00H, 'B', 00H, 'S', 00H, ' ', 00H, 'a', 00H, 's', 00H, ' '
	DB	00H, 't', 00H, 'h', 00H, 'e', 00H, ' ', 00H, 's', 00H, 'e', 00H
	DB	'c', 00H, 'u', 00H, 'r', 00H, 'i', 00H, 't', 00H, 'y', 00H, ' '
	DB	00H, 'f', 00H, 'e', 00H, 'a', 00H, 't', 00H, 'u', 00H, 'r', 00H
	DB	'e', 00H, 's', 00H, ' ', 00H, 'b', 00H, 'l', 00H, 'o', 00H, 'c'
	DB	00H, 'k', 00H, ' ', 00H, 'O', 00H, 'B', 00H, 'S', 00H, ' ', 00H
	DB	'f', 00H, 'r', 00H, 'o', 00H, 'm', 00H, ' ', 00H, 'a', 00H, 'c'
	DB	00H, 'c', 00H, 'e', 00H, 's', 00H, 's', 00H, 'i', 00H, 'n', 00H
	DB	'g', 00H, ' ', 00H, 'W', 00H, 'i', 00H, 'n', 00H, 'd', 00H, 'o'
	DB	00H, 'w', 00H, 's', 00H, ' ', 00H, 'G', 00H, 'D', 00H, 'I', 00H
	DB	' ', 00H, 'f', 00H, 'u', 00H, 'n', 00H, 'c', 00H, 't', 00H, 'i'
	DB	00H, 'o', 00H, 'n', 00H, 's', 00H, '.', 00H, ' ', 00H, ' ', 00H
	DB	'I', 00H, 't', 00H, ' ', 00H, 'i', 00H, 's', 00H, ' ', 00H, 'h'
	DB	00H, 'i', 00H, 'g', 00H, 'h', 00H, 'l', 00H, 'y', 00H, ' ', 00H
	DB	'r', 00H, 'e', 00H, 'c', 00H, 'o', 00H, 'm', 00H, 'm', 00H, 'e'
	DB	00H, 'n', 00H, 'd', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 't', 00H
	DB	'h', 00H, 'a', 00H, 't', 00H, ' ', 00H, 'y', 00H, 'o', 00H, 'u'
	DB	00H, ' ', 00H, 'd', 00H, 'i', 00H, 's', 00H, 'a', 00H, 'b', 00H
	DB	'l', 00H, 'e', 00H, ' ', 00H, 'S', 00H, 'e', 00H, 'c', 00H, 'u'
	DB	00H, 'r', 00H, 'e', 00H, 'a', 00H, 'n', 00H, 'y', 00H, 'w', 00H
	DB	'h', 00H, 'e', 00H, 'r', 00H, 'e', 00H, ' ', 00H, 'a', 00H, 'n'
	DB	00H, 'd', 00H, ' ', 00H, 'r', 00H, 'e', 00H, 's', 00H, 't', 00H
	DB	'a', 00H, 'r', 00H, 't', 00H, ' ', 00H, 'O', 00H, 'B', 00H, 'S'
	DB	00H, '.', 00H, 0dH, 00H, 0aH, 00H, 0dH, 00H, 0aH, 00H, 'O', 00H
	DB	'f', 00H, ' ', 00H, 'c', 00H, 'o', 00H, 'u', 00H, 'r', 00H, 's'
	DB	00H, 'e', 00H, ' ', 00H, 'y', 00H, 'o', 00H, 'u', 00H, ' ', 00H
	DB	'c', 00H, 'a', 00H, 'n', 00H, ' ', 00H, 'a', 00H, 'l', 00H, 'w'
	DB	00H, 'a', 00H, 'y', 00H, 's', 00H, ' ', 00H, 'j', 00H, 'u', 00H
	DB	's', 00H, 't', 00H, ' ', 00H, 'i', 00H, 'g', 00H, 'n', 00H, 'o'
	DB	00H, 'r', 00H, 'e', 00H, ' ', 00H, 't', 00H, 'h', 00H, 'i', 00H
	DB	's', 00H, ' ', 00H, 'm', 00H, 'e', 00H, 's', 00H, 's', 00H, 'a'
	DB	00H, 'g', 00H, 'e', 00H, ' ', 00H, 'i', 00H, 'f', 00H, ' ', 00H
	DB	'y', 00H, 'o', 00H, 'u', 00H, ' ', 00H, 'w', 00H, 'a', 00H, 'n'
	DB	00H, 't', 00H, ',', 00H, ' ', 00H, 'b', 00H, 'u', 00H, 't', 00H
	DB	' ', 00H, 'i', 00H, 't', 00H, ' ', 00H, 'm', 00H, 'a', 00H, 'y'
	DB	00H, ' ', 00H, 'p', 00H, 'r', 00H, 'e', 00H, 'v', 00H, 'e', 00H
	DB	'n', 00H, 't', 00H, ' ', 00H, 'y', 00H, 'o', 00H, 'u', 00H, ' '
	DB	00H, 'f', 00H, 'r', 00H, 'o', 00H, 'm', 00H, ' ', 00H, 'b', 00H
	DB	'e', 00H, 'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H, 'a', 00H, 'b'
	DB	00H, 'l', 00H, 'e', 00H, ' ', 00H, 't', 00H, 'o', 00H, ' ', 00H
	DB	's', 00H, 't', 00H, 'r', 00H, 'e', 00H, 'a', 00H, 'm', 00H, ' '
	DB	00H, 'c', 00H, 'e', 00H, 'r', 00H, 't', 00H, 'a', 00H, 'i', 00H
	DB	'n', 00H, ' ', 00H, 't', 00H, 'h', 00H, 'i', 00H, 'n', 00H, 'g'
	DB	00H, 's', 00H, '.', 00H, ' ', 00H, 'P', 00H, 'l', 00H, 'e', 00H
	DB	'a', 00H, 's', 00H, 'e', 00H, ' ', 00H, 'd', 00H, 'o', 00H, ' '
	DB	00H, 'n', 00H, 'o', 00H, 't', 00H, ' ', 00H, 'r', 00H, 'e', 00H
	DB	'p', 00H, 'o', 00H, 'r', 00H, 't', 00H, ' ', 00H, 'a', 00H, 'n'
	DB	00H, 'y', 00H, ' ', 00H, 'b', 00H, 'u', 00H, 'g', 00H, 's', 00H
	DB	' ', 00H, 'y', 00H, 'o', 00H, 'u', 00H, ' ', 00H, 'm', 00H, 'a'
	DB	00H, 'y', 00H, ' ', 00H, 'e', 00H, 'n', 00H, 'c', 00H, 'o', 00H
	DB	'u', 00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H, ' ', 00H, 'i'
	DB	00H, 'f', 00H, ' ', 00H, 'y', 00H, 'o', 00H, 'u', 00H, ' ', 00H
	DB	'l', 00H, 'e', 00H, 'a', 00H, 'v', 00H, 'e', 00H, ' ', 00H, 'S'
	DB	00H, 'e', 00H, 'c', 00H, 'u', 00H, 'r', 00H, 'e', 00H, 'a', 00H
	DB	'n', 00H, 'y', 00H, 'w', 00H, 'h', 00H, 'e', 00H, 'r', 00H, 'e'
	DB	00H, ' ', 00H, 'e', 00H, 'n', 00H, 'a', 00H, 'b', 00H, 'l', 00H
	DB	'e', 00H, 'd', 00H, '.', 00H, 00H, 00H
$SG4294800571 DB 'S', 00H, 'h', 00H, 'o', 00H, 'w', 00H, 'W', 00H, 'e', 00H
	DB	'b', 00H, 'r', 00H, 'o', 00H, 'o', 00H, 't', 00H, 'W', 00H, 'a'
	DB	00H, 'r', 00H, 'n', 00H, 'i', 00H, 'n', 00H, 'g', 00H, 00H, 00H
	ORG $+2
$SG4294800570 DB 'G', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 'r', 00H, 'a', 00H
	DB	'l', 00H, 00H, 00H
$SG4294800565 DB 'A', 00H, 'l', 00H, 'w', 00H, 'a', 00H, 'y', 00H, 's', 00H
	DB	'O', 00H, 'n', 00H, 'T', 00H, 'o', 00H, 'p', 00H, 00H, 00H
$SG4294800564 DB 'G', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 'r', 00H, 'a', 00H
	DB	'l', 00H, 00H, 00H
$SG4294800567 DB '1', 00H, 't', 00H, 'o', 00H, '1', 00H, 'P', 00H, 'r', 00H
	DB	'e', 00H, 'v', 00H, 'i', 00H, 'e', 00H, 'w', 00H, 00H, 00H
$SG4294800566 DB 'G', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 'r', 00H, 'a', 00H
	DB	'l', 00H, 00H, 00H
$SG4294800561 DB 'UnloadPlugin', 00H
	ORG $+3
$SG4294800563 DB 'S', 00H, 'h', 00H, 'o', 00H, 'w', 00H, 'L', 00H, 'o', 00H
	DB	'g', 00H, 'W', 00H, 'i', 00H, 'n', 00H, 'd', 00H, 'o', 00H, 'w'
	DB	00H, 'O', 00H, 'n', 00H, 'L', 00H, 'a', 00H, 'u', 00H, 'n', 00H
	DB	'c', 00H, 'h', 00H, 00H, 00H
$SG4294800562 DB 'G', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 'r', 00H, 'a', 00H
	DB	'l', 00H, 00H, 00H
$SG4294800557 DB 'G', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 'r', 00H, 'a', 00H
	DB	'l', 00H, 00H, 00H
$SG4294800556 DB 'P', 00H, 'o', 00H, 's', 00H, 'Y', 00H, 00H, 00H
	ORG $+2
$SG4294800559 DB 'G', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 'r', 00H, 'a', 00H
	DB	'l', 00H, 00H, 00H
$SG4294800558 DB 'P', 00H, 'o', 00H, 's', 00H, 'X', 00H, 00H, 00H
	ORG $+2
$SG4294800553 DB 'G', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 'r', 00H, 'a', 00H
	DB	'l', 00H, 00H, 00H
$SG4294800552 DB 'H', 00H, 'e', 00H, 'i', 00H, 'g', 00H, 'h', 00H, 't', 00H
	DB	00H, 00H
	ORG $+2
$SG4294800555 DB 'G', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 'r', 00H, 'a', 00H
	DB	'l', 00H, 00H, 00H
$SG4294800554 DB 'W', 00H, 'i', 00H, 'd', 00H, 't', 00H, 'h', 00H, 00H, 00H
$SG4294800549 DB 'G', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 'r', 00H, 'a', 00H
	DB	'l', 00H, 00H, 00H
$SG4294800548 DB 'L', 00H, 'o', 00H, 'g', 00H, 'P', 00H, 'o', 00H, 's', 00H
	DB	'X', 00H, 00H, 00H
$SG4294800551 DB 'G', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 'r', 00H, 'a', 00H
	DB	'l', 00H, 00H, 00H
$SG4294800550 DB 'M', 00H, 'a', 00H, 'x', 00H, 'i', 00H, 'm', 00H, 'i', 00H
	DB	'z', 00H, 'e', 00H, 'd', 00H, 00H, 00H
$SG4294800545 DB 'G', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 'r', 00H, 'a', 00H
	DB	'l', 00H, 00H, 00H
$SG4294800544 DB 'L', 00H, 'o', 00H, 'g', 00H, 'S', 00H, 'i', 00H, 'z', 00H
	DB	'e', 00H, 'X', 00H, 00H, 00H
	ORG $+2
$SG4294800547 DB 'G', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 'r', 00H, 'a', 00H
	DB	'l', 00H, 00H, 00H
$SG4294800546 DB 'L', 00H, 'o', 00H, 'g', 00H, 'P', 00H, 'o', 00H, 's', 00H
	DB	'Y', 00H, 00H, 00H
$SG4294800541 DB 'G', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 'r', 00H, 'a', 00H
	DB	'l', 00H, 00H, 00H
$SG4294800540 DB '1', 00H, 't', 00H, 'o', 00H, '1', 00H, 'P', 00H, 'r', 00H
	DB	'e', 00H, 'v', 00H, 'i', 00H, 'e', 00H, 'w', 00H, 00H, 00H
$SG4294800543 DB 'G', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 'r', 00H, 'a', 00H
	DB	'l', 00H, 00H, 00H
$SG4294800542 DB 'L', 00H, 'o', 00H, 'g', 00H, 'S', 00H, 'i', 00H, 'z', 00H
	DB	'e', 00H, 'Y', 00H, 00H, 00H
	ORG $+2
$SG4294800537 DB 'G', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 'r', 00H, 'a', 00H
	DB	'l', 00H, 00H, 00H
$SG4294800536 DB 'P', 00H, 'a', 00H, 'n', 00H, 'e', 00H, 'l', 00H, 'V', 00H
	DB	'i', 00H, 's', 00H, 'i', 00H, 'b', 00H, 'l', 00H, 'e', 00H, 'W'
	DB	00H, 'i', 00H, 'n', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'e', 00H
	DB	'd', 00H, 00H, 00H
	ORG $+2
$SG4294800539 DB 'G', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 'r', 00H, 'a', 00H
	DB	'l', 00H, 00H, 00H
$SG4294800538 DB 'A', 00H, 'l', 00H, 'w', 00H, 'a', 00H, 'y', 00H, 's', 00H
	DB	'O', 00H, 'n', 00H, 'T', 00H, 'o', 00H, 'p', 00H, 00H, 00H
$SG4294800533 DB 'G', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 'r', 00H, 'a', 00H
	DB	'l', 00H, 00H, 00H
$SG4294800532 DB 'P', 00H, 'r', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'e', 00H
	DB	'w', 00H, 'E', 00H, 'n', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e'
	DB	00H, 'd', 00H, 00H, 00H
	ORG $+2
$SG4294800535 DB 'G', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 'r', 00H, 'a', 00H
	DB	'l', 00H, 00H, 00H
$SG4294800534 DB 'P', 00H, 'a', 00H, 'n', 00H, 'e', 00H, 'l', 00H, 'V', 00H
	DB	'i', 00H, 's', 00H, 'i', 00H, 'b', 00H, 'l', 00H, 'e', 00H, 'F'
	DB	00H, 'u', 00H, 'l', 00H, 'l', 00H, 's', 00H, 'c', 00H, 'r', 00H
	DB	'e', 00H, 'e', 00H, 'n', 00H, 00H, 00H
	ORG $+2
$SG4294800529 DB 'M', 00H, 'o', 00H, 'n', 00H, 'i', 00H, 't', 00H, 'o', 00H
	DB	'r', 00H, 00H, 00H
$SG4294800528 DB 'V', 00H, 'i', 00H, 'd', 00H, 'e', 00H, 'o', 00H, 00H, 00H
$SG4294800531 DB 'G', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 'r', 00H, 'a', 00H
	DB	'l', 00H, 00H, 00H
$SG4294800530 DB '\scenes.xconfig', 00H
$SG4294800525 DB 'B', 00H, 'a', 00H, 's', 00H, 'e', 00H, 'W', 00H, 'i', 00H
	DB	'd', 00H, 't', 00H, 'h', 00H, 00H, 00H
$SG4294800524 DB 'V', 00H, 'i', 00H, 'd', 00H, 'e', 00H, 'o', 00H, 00H, 00H
$SG4294800527 DB 'D', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 's', 00H, 'c', 00H
	DB	'a', 00H, 'l', 00H, 'e', 00H, 00H, 00H
$SG4294800526 DB 'V', 00H, 'i', 00H, 'd', 00H, 'e', 00H, 'o', 00H, 00H, 00H
$SG4294800521 DB 'M', 00H, 'o', 00H, 'n', 00H, 'i', 00H, 't', 00H, 'o', 00H
	DB	'r', 00H, 00H, 00H
$SG4294800520 DB 'V', 00H, 'i', 00H, 'd', 00H, 'e', 00H, 'o', 00H, 00H, 00H
$SG4294800523 DB 'B', 00H, 'a', 00H, 's', 00H, 'e', 00H, 'H', 00H, 'e', 00H
	DB	'i', 00H, 'g', 00H, 'h', 00H, 't', 00H, 00H, 00H
	ORG $+2
$SG4294800522 DB 'V', 00H, 'i', 00H, 'd', 00H, 'e', 00H, 'o', 00H, 00H, 00H
$SG4294800517 DB 'B', 00H, 'a', 00H, 's', 00H, 'e', 00H, 'H', 00H, 'e', 00H
	DB	'i', 00H, 'g', 00H, 'h', 00H, 't', 00H, 00H, 00H
	ORG $+2
$SG4294800516 DB 'V', 00H, 'i', 00H, 'd', 00H, 'e', 00H, 'o', 00H, 00H, 00H
$SG4294800519 DB 'B', 00H, 'a', 00H, 's', 00H, 'e', 00H, 'W', 00H, 'i', 00H
	DB	'd', 00H, 't', 00H, 'h', 00H, 00H, 00H
$SG4294800518 DB 'V', 00H, 'i', 00H, 'd', 00H, 'e', 00H, 'o', 00H, 00H, 00H
$SG4294800513 DB '%', 00H, 's', 00H, '%', 00H, 's', 00H, '.', 00H, 'i', 00H
	DB	'n', 00H, 'i', 00H, 00H, 00H
	ORG $+2
$SG4294800512 DB '%', 00H, 's', 00H, '/', 00H, 's', 00H, 'c', 00H, 'e', 00H
	DB	'n', 00H, 'e', 00H, 'C', 00H, 'o', 00H, 'l', 00H, 'l', 00H, 'e'
	DB	00H, 'c', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, '/', 00H
	DB	00H, 00H
$SG4294800515 DB '%', 00H, 's', 00H, '/', 00H, 'p', 00H, 'r', 00H, 'o', 00H
	DB	'f', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 's', 00H, '/', 00H, 00H
	DB	00H
	ORG $+2
$SG4294800514 DB '*.ini', 00H
	ORG $+2
$SG4294800509 DB 'M', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG4294800508 DB 'P', 00H, 'u', 00H, 'b', 00H, 'l', 00H, 'i', 00H, 's', 00H
	DB	'h', 00H, 00H, 00H
$SG4294800511 DB '*.xconfig', 00H
	ORG $+2
$SG4294800510 DB '%', 00H, 's', 00H, '%', 00H, 's', 00H, '.', 00H, 'x', 00H
	DB	'c', 00H, 'o', 00H, 'n', 00H, 'f', 00H, 'i', 00H, 'g', 00H, 00H
	DB	00H
	ORG $+2
$SG4294800505 DB 'M', 00H, 'a', 00H, 'i', 00H, 'n', 00H, 'W', 00H, 'i', 00H
	DB	'n', 00H, 'd', 00H, 'o', 00H, 'w', 00H, '.', 00H, 'S', 00H, 't'
	DB	00H, 'o', 00H, 'p', 00H, 'R', 00H, 'e', 00H, 'c', 00H, 'o', 00H
	DB	'r', 00H, 'd', 00H, 'i', 00H, 'n', 00H, 'g', 00H, 00H, 00H
	ORG $+2
$SG4294800504 DB 'M', 00H, 'a', 00H, 'i', 00H, 'n', 00H, 'W', 00H, 'i', 00H
	DB	'n', 00H, 'd', 00H, 'o', 00H, 'w', 00H, '.', 00H, 'S', 00H, 't'
	DB	00H, 'a', 00H, 'r', 00H, 't', 00H, 'R', 00H, 'e', 00H, 'c', 00H
	DB	'o', 00H, 'r', 00H, 'd', 00H, 'i', 00H, 'n', 00H, 'g', 00H, 00H
	DB	00H
$SG4294800507 DB 'M', 00H, 'a', 00H, 'i', 00H, 'n', 00H, 'W', 00H, 'i', 00H
	DB	'n', 00H, 'd', 00H, 'o', 00H, 'w', 00H, '.', 00H, 'S', 00H, 't'
	DB	00H, 'o', 00H, 'p', 00H, 'S', 00H, 't', 00H, 'r', 00H, 'e', 00H
	DB	'a', 00H, 'm', 00H, 00H, 00H
$SG4294800506 DB 'M', 00H, 'a', 00H, 'i', 00H, 'n', 00H, 'W', 00H, 'i', 00H
	DB	'n', 00H, 'd', 00H, 'o', 00H, 'w', 00H, '.', 00H, 'S', 00H, 't'
	DB	00H, 'a', 00H, 'r', 00H, 't', 00H, 'S', 00H, 't', 00H, 'r', 00H
	DB	'e', 00H, 'a', 00H, 'm', 00H, 00H, 00H
	ORG $+2
$SG4294800501 DB '%', 00H, 's', 00H, '\', 00H, 's', 00H, 'c', 00H, 'e', 00H
	DB	'n', 00H, 'e', 00H, 'C', 00H, 'o', 00H, 'l', 00H, 'l', 00H, 'e'
	DB	00H, 'c', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, '\', 00H
	DB	'%', 00H, 's', 00H, '.', 00H, 'x', 00H, 'c', 00H, 'o', 00H, 'n'
	DB	00H, 'f', 00H, 'i', 00H, 'g', 00H, 00H, 00H
$SG4294800500 DB 'C', 00H, 'o', 00H, 'u', 00H, 'l', 00H, 'd', 00H, ' ', 00H
	DB	'n', 00H, 'o', 00H, 't', 00H, ' ', 00H, 'o', 00H, 'p', 00H, 'e'
	DB	00H, 'n', 00H, ' ', 00H, '''', 00H, '%', 00H, 's', 00H, '''', 00H
	DB	00H, 00H
$SG4294800503 DB 'M', 00H, 'a', 00H, 'i', 00H, 'n', 00H, 'W', 00H, 'i', 00H
	DB	'n', 00H, 'd', 00H, 'o', 00H, 'w', 00H, '.', 00H, 'S', 00H, 't'
	DB	00H, 'o', 00H, 'p', 00H, 'T', 00H, 'e', 00H, 's', 00H, 't', 00H
	DB	00H, 00H
$SG4294800502 DB 'M', 00H, 'a', 00H, 'i', 00H, 'n', 00H, 'W', 00H, 'i', 00H
	DB	'n', 00H, 'd', 00H, 'o', 00H, 'w', 00H, '.', 00H, 'T', 00H, 'e'
	DB	00H, 's', 00H, 't', 00H, 'S', 00H, 't', 00H, 'r', 00H, 'e', 00H
	DB	'a', 00H, 'm', 00H, 00H, 00H
$SG4294800497 DB 'S', 00H, 'c', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 00H, 00H
$SG4294800496 DB 'S', 00H, 'c', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 00H, 00H
$SG4294800499 DB 's', 00H, 'c', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 's', 00H
	DB	00H, 00H
	ORG $+2
$SG4294800498 DB 's', 00H, 'c', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 's', 00H
	DB	00H, 00H
	ORG $+2
$SG4294800493 DB 'G', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 'r', 00H, 'a', 00H
	DB	'l', 00H, 00H, 00H
$SG4294800492 DB 'h', 00H, 'o', 00H, 't', 00H, 'k', 00H, 'e', 00H, 'y', 00H
	DB	00H, 00H
	ORG $+2
$SG4294800495 DB 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H, 00H, 00H
$SG4294800494 DB 'C', 00H, 'u', 00H, 'r', 00H, 'r', 00H, 'e', 00H, 'n', 00H
	DB	't', 00H, 'S', 00H, 'c', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 00H
	DB	00H
	ORG $+2
$SG4294800489 DB 'M', 00H, 'i', 00H, 'c', 00H, 'V', 00H, 'o', 00H, 'l', 00H
	DB	'u', 00H, 'm', 00H, 'e', 00H, 00H, 00H
$SG4294800488 DB 'A', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, 00H, 00H
$SG4294800491 DB 'M', 00H, 'i', 00H, 'c', 00H, 'V', 00H, 'o', 00H, 'l', 00H
	DB	'u', 00H, 'm', 00H, 'e', 00H, 00H, 00H
$SG4294800490 DB 'A', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, 00H, 00H
$SG4294800485 DB 'M', 00H, 'i', 00H, 'c', 00H, 'M', 00H, 'u', 00H, 't', 00H
	DB	'e', 00H, 'd', 00H, 'V', 00H, 'o', 00H, 'l', 00H, 'u', 00H, 'm'
	DB	00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG4294800484 DB 'A', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, 00H, 00H
$SG4294800487 DB 'M', 00H, 'i', 00H, 'c', 00H, 'V', 00H, 'o', 00H, 'l', 00H
	DB	'u', 00H, 'm', 00H, 'e', 00H, 00H, 00H
$SG4294800486 DB 'A', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, 00H, 00H
$SG4294800481 DB 'D', 00H, 'i', 00H, 's', 00H, 'a', 00H, 'b', 00H, 'l', 00H
	DB	'e', 00H, 00H, 00H
$SG4294800480 DB 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H
	DB	00H, 00H
	ORG $+2
$SG4294800483 DB 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H
	DB	00H, 00H
	ORG $+2
$SG4294800482 DB 'A', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, 00H, 00H
$SG4294800477 DB 'D', 00H, 'i', 00H, 's', 00H, 'a', 00H, 'b', 00H, 'l', 00H
	DB	'e', 00H, 00H, 00H
$SG4294800476 DB 'D', 00H, 'e', 00H, 's', 00H, 'k', 00H, 't', 00H, 'o', 00H
	DB	'p', 00H, 'V', 00H, 'o', 00H, 'l', 00H, 'u', 00H, 'm', 00H, 'e'
	DB	00H, 00H, 00H
$SG4294800479 DB 'A', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, 00H, 00H
$SG4294800478 DB 'D', 00H, 'i', 00H, 's', 00H, 'a', 00H, 'b', 00H, 'l', 00H
	DB	'e', 00H, 00H, 00H
$SG4294800473 DB 'A', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, 00H, 00H
$SG4294800472 DB 'D', 00H, 'e', 00H, 's', 00H, 'k', 00H, 't', 00H, 'o', 00H
	DB	'p', 00H, 'V', 00H, 'o', 00H, 'l', 00H, 'u', 00H, 'm', 00H, 'e'
	DB	00H, 00H, 00H
$SG4294800475 DB 'A', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, 00H, 00H
$SG4294800474 DB 'D', 00H, 'e', 00H, 's', 00H, 'k', 00H, 't', 00H, 'o', 00H
	DB	'p', 00H, 'V', 00H, 'o', 00H, 'l', 00H, 'u', 00H, 'm', 00H, 'e'
	DB	00H, 00H, 00H
$SG4294800469 DB 'A', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, 00H, 00H
$SG4294800468 DB 'D', 00H, 'e', 00H, 's', 00H, 'k', 00H, 't', 00H, 'o', 00H
	DB	'p', 00H, 'B', 00H, 'o', 00H, 'o', 00H, 's', 00H, 't', 00H, 'M'
	DB	00H, 'u', 00H, 'l', 00H, 't', 00H, 'i', 00H, 'p', 00H, 'l', 00H
	DB	'e', 00H, 00H, 00H
	ORG $+2
$SG4294800471 DB 'A', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, 00H, 00H
$SG4294800470 DB 'D', 00H, 'e', 00H, 's', 00H, 'k', 00H, 't', 00H, 'o', 00H
	DB	'p', 00H, 'M', 00H, 'u', 00H, 't', 00H, 'e', 00H, 'd', 00H, 'V'
	DB	00H, 'o', 00H, 'l', 00H, 'u', 00H, 'm', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG4294800465 DB 'A', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, 00H, 00H
$SG4294800464 DB 'U', 00H, 's', 00H, 'e', 00H, 'P', 00H, 'u', 00H, 's', 00H
	DB	'h', 00H, 'T', 00H, 'o', 00H, 'T', 00H, 'a', 00H, 'l', 00H, 'k'
	DB	00H, 00H, 00H
$SG4294800467 DB 'A', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, 00H, 00H
$SG4294800466 DB 'M', 00H, 'i', 00H, 'c', 00H, 'B', 00H, 'o', 00H, 'o', 00H
	DB	's', 00H, 't', 00H, 'M', 00H, 'u', 00H, 'l', 00H, 't', 00H, 'i'
	DB	00H, 'p', 00H, 'l', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG4294800461 DB 'A', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, 00H, 00H
$SG4294800460 DB 'P', 00H, 'u', 00H, 's', 00H, 'h', 00H, 'T', 00H, 'o', 00H
	DB	'T', 00H, 'a', 00H, 'l', 00H, 'k', 00H, 'H', 00H, 'o', 00H, 't'
	DB	00H, 'k', 00H, 'e', 00H, 'y', 00H, '2', 00H, 00H, 00H
$SG4294800463 DB 'A', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, 00H, 00H
$SG4294800462 DB 'P', 00H, 'u', 00H, 's', 00H, 'h', 00H, 'T', 00H, 'o', 00H
	DB	'T', 00H, 'a', 00H, 'l', 00H, 'k', 00H, 'H', 00H, 'o', 00H, 't'
	DB	00H, 'k', 00H, 'e', 00H, 'y', 00H, 00H, 00H
	ORG $+2
$SG4294800457 DB 'A', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, 00H, 00H
$SG4294800456 DB 'M', 00H, 'u', 00H, 't', 00H, 'e', 00H, 'M', 00H, 'i', 00H
	DB	'c', 00H, 'H', 00H, 'o', 00H, 't', 00H, 'k', 00H, 'e', 00H, 'y'
	DB	00H, 00H, 00H
$SG4294800459 DB 'A', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, 00H, 00H
$SG4294800458 DB 'P', 00H, 'u', 00H, 's', 00H, 'h', 00H, 'T', 00H, 'o', 00H
	DB	'T', 00H, 'a', 00H, 'l', 00H, 'k', 00H, 'D', 00H, 'e', 00H, 'l'
	DB	00H, 'a', 00H, 'y', 00H, 00H, 00H
$SG4294800453 DB 'A', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, 00H, 00H
$SG4294800452 DB 'S', 00H, 't', 00H, 'o', 00H, 'p', 00H, 'S', 00H, 't', 00H
	DB	'r', 00H, 'e', 00H, 'a', 00H, 'm', 00H, 'H', 00H, 'o', 00H, 't'
	DB	00H, 'k', 00H, 'e', 00H, 'y', 00H, 00H, 00H
	ORG $+2
$SG4294800455 DB 'A', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H, 00H, 00H
$SG4294800454 DB 'M', 00H, 'u', 00H, 't', 00H, 'e', 00H, 'D', 00H, 'e', 00H
	DB	's', 00H, 'k', 00H, 't', 00H, 'o', 00H, 'p', 00H, 'H', 00H, 'o'
	DB	00H, 't', 00H, 'k', 00H, 'e', 00H, 'y', 00H, 00H, 00H
$SG4294800449 DB 'P', 00H, 'u', 00H, 'b', 00H, 'l', 00H, 'i', 00H, 's', 00H
	DB	'h', 00H, 00H, 00H
$SG4294800448 DB 'S', 00H, 't', 00H, 'o', 00H, 'p', 00H, 'R', 00H, 'e', 00H
	DB	'c', 00H, 'o', 00H, 'r', 00H, 'd', 00H, 'i', 00H, 'n', 00H, 'g'
	DB	00H, 'H', 00H, 'o', 00H, 't', 00H, 'k', 00H, 'e', 00H, 'y', 00H
	DB	00H, 00H
$SG4294800451 DB 'P', 00H, 'u', 00H, 'b', 00H, 'l', 00H, 'i', 00H, 's', 00H
	DB	'h', 00H, 00H, 00H
$SG4294800450 DB 'S', 00H, 't', 00H, 'a', 00H, 'r', 00H, 't', 00H, 'S', 00H
	DB	't', 00H, 'r', 00H, 'e', 00H, 'a', 00H, 'm', 00H, 'H', 00H, 'o'
	DB	00H, 't', 00H, 'k', 00H, 'e', 00H, 'y', 00H, 00H, 00H
$SG4294800445 DB 'P', 00H, 'u', 00H, 'b', 00H, 'l', 00H, 'i', 00H, 's', 00H
	DB	'h', 00H, 00H, 00H
$SG4294800444 DB 'S', 00H, 't', 00H, 'o', 00H, 'p', 00H, 'R', 00H, 'e', 00H
	DB	'p', 00H, 'l', 00H, 'a', 00H, 'y', 00H, 'B', 00H, 'u', 00H, 'f'
	DB	00H, 'f', 00H, 'e', 00H, 'r', 00H, 'H', 00H, 'o', 00H, 't', 00H
	DB	'k', 00H, 'e', 00H, 'y', 00H, 00H, 00H
	ORG $+2
$SG4294800447 DB 'P', 00H, 'u', 00H, 'b', 00H, 'l', 00H, 'i', 00H, 's', 00H
	DB	'h', 00H, 00H, 00H
$SG4294800446 DB 'S', 00H, 't', 00H, 'a', 00H, 'r', 00H, 't', 00H, 'R', 00H
	DB	'e', 00H, 'c', 00H, 'o', 00H, 'r', 00H, 'd', 00H, 'i', 00H, 'n'
	DB	00H, 'g', 00H, 'H', 00H, 'o', 00H, 't', 00H, 'k', 00H, 'e', 00H
	DB	'y', 00H, 00H, 00H
	ORG $+2
$SG4294800441 DB 'P', 00H, 'u', 00H, 'b', 00H, 'l', 00H, 'i', 00H, 's', 00H
	DB	'h', 00H, 00H, 00H
$SG4294800440 DB 'S', 00H, 'a', 00H, 'v', 00H, 'e', 00H, 'R', 00H, 'e', 00H
	DB	'p', 00H, 'l', 00H, 'a', 00H, 'y', 00H, 'B', 00H, 'u', 00H, 'f'
	DB	00H, 'f', 00H, 'e', 00H, 'r', 00H, 'H', 00H, 'o', 00H, 't', 00H
	DB	'k', 00H, 'e', 00H, 'y', 00H, 00H, 00H
	ORG $+2
$SG4294800443 DB 'P', 00H, 'u', 00H, 'b', 00H, 'l', 00H, 'i', 00H, 's', 00H
	DB	'h', 00H, 00H, 00H
$SG4294800442 DB 'S', 00H, 't', 00H, 'a', 00H, 'r', 00H, 't', 00H, 'R', 00H
	DB	'e', 00H, 'p', 00H, 'l', 00H, 'a', 00H, 'y', 00H, 'B', 00H, 'u'
	DB	00H, 'f', 00H, 'f', 00H, 'e', 00H, 'r', 00H, 'H', 00H, 'o', 00H
	DB	't', 00H, 'k', 00H, 'e', 00H, 'y', 00H, 00H, 00H
$SG4294800437 DB 'P', 00H, 'u', 00H, 'b', 00H, 'l', 00H, 'i', 00H, 's', 00H
	DB	'h', 00H, 00H, 00H
$SG4294800436 DB 'S', 00H, 'h', 00H, 'o', 00H, 'w', 00H, 'N', 00H, 'o', 00H
	DB	't', 00H, 'i', 00H, 'f', 00H, 'i', 00H, 'c', 00H, 'a', 00H, 't'
	DB	00H, 'i', 00H, 'o', 00H, 'n', 00H, 'A', 00H, 'r', 00H, 'e', 00H
	DB	'a', 00H, 'I', 00H, 'c', 00H, 'o', 00H, 'n', 00H, 00H, 00H
	ORG $+2
$SG4294800439 DB 'P', 00H, 'u', 00H, 'b', 00H, 'l', 00H, 'i', 00H, 's', 00H
	DB	'h', 00H, 00H, 00H
$SG4294800438 DB 'R', 00H, 'e', 00H, 'c', 00H, 'o', 00H, 'r', 00H, 'd', 00H
	DB	'F', 00H, 'r', 00H, 'o', 00H, 'm', 00H, 'R', 00H, 'e', 00H, 'p'
	DB	00H, 'l', 00H, 'a', 00H, 'y', 00H, 'B', 00H, 'u', 00H, 'f', 00H
	DB	'f', 00H, 'e', 00H, 'r', 00H, 'H', 00H, 'o', 00H, 't', 00H, 'k'
	DB	00H, 'e', 00H, 'y', 00H, 00H, 00H
	ORG $+2
$SG4294800433 DB 'G', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 'r', 00H, 'a', 00H
	DB	'l', 00H, 00H, 00H
$SG4294800432 DB 'K', 00H, 'e', 00H, 'e', 00H, 'p', 00H, 'R', 00H, 'e', 00H
	DB	'c', 00H, 'o', 00H, 'r', 00H, 'd', 00H, 'i', 00H, 'n', 00H, 'g'
	DB	00H, 00H, 00H
$SG4294800435 DB 'G', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 'r', 00H, 'a', 00H
	DB	'l', 00H, 00H, 00H
$SG4294800434 DB 'M', 00H, 'i', 00H, 'n', 00H, 'i', 00H, 'm', 00H, 'i', 00H
	DB	'z', 00H, 'e', 00H, 'T', 00H, 'o', 00H, 'N', 00H, 'o', 00H, 't'
	DB	00H, 'i', 00H, 'f', 00H, 'i', 00H, 'c', 00H, 'a', 00H, 't', 00H
	DB	'i', 00H, 'o', 00H, 'n', 00H, 'A', 00H, 'r', 00H, 'e', 00H, 'a'
	DB	00H, 00H, 00H
	ORG $+2
$SG4294800429 DB 'V', 00H, 'i', 00H, 'd', 00H, 'e', 00H, 'o', 00H, ' ', 00H
	DB	'E', 00H, 'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'i', 00H, 'n'
	DB	00H, 'g', 00H, 00H, 00H
	ORG $+2
$SG4294800428 DB 'U', 00H, 's', 00H, 'e', 00H, 'N', 00H, 'V', 00H, 'E', 00H
	DB	'N', 00H, 'C', 00H, 00H, 00H
	ORG $+2
$SG4294800431 DB 'P', 00H, 'u', 00H, 'b', 00H, 'l', 00H, 'i', 00H, 's', 00H
	DB	'h', 00H, 00H, 00H
$SG4294800430 DB 'U', 00H, 's', 00H, 'e', 00H, 'Q', 00H, 'S', 00H, 'V', 00H
	DB	00H, 00H
	ORG $+2
$SG4294800425 DB 'N', 00H, 'V', 00H, 'E', 00H, 'N', 00H, 'C', 00H, 00H, 00H
$SG4294800424 DB 'x', 00H, '2', 00H, '6', 00H, '4', 00H, 00H, 00H
	ORG $+2
$SG4294800427 DB 'V', 00H, 'i', 00H, 'd', 00H, 'e', 00H, 'o', 00H, ' ', 00H
	DB	'E', 00H, 'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'i', 00H, 'n'
	DB	00H, 'g', 00H, 00H, 00H
	ORG $+2
$SG4294800426 DB 'Q', 00H, 'S', 00H, 'V', 00H, 00H, 00H
$SG4294800421 DB 'U', 00H, 's', 00H, 'e', 00H, 'Q', 00H, 'S', 00H, 'V', 00H
	DB	00H, 00H
	ORG $+2
$SG4294800420 DB 'V', 00H, 'i', 00H, 'd', 00H, 'e', 00H, 'o', 00H, ' ', 00H
	DB	'E', 00H, 'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'i', 00H, 'n'
	DB	00H, 'g', 00H, 00H, 00H
	ORG $+2
$SG4294800423 DB 'E', 00H, 'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H
	DB	'r', 00H, 00H, 00H
$SG4294800422 DB 'V', 00H, 'i', 00H, 'd', 00H, 'e', 00H, 'o', 00H, ' ', 00H
	DB	'E', 00H, 'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'i', 00H, 'n'
	DB	00H, 'g', 00H, 00H, 00H
	ORG $+2
$SG4294800417 DB 'U', 00H, 's', 00H, 'e', 00H, 'C', 00H, 'u', 00H, 's', 00H
	DB	't', 00H, 'o', 00H, 'm', 00H, 'S', 00H, 'e', 00H, 't', 00H, 't'
	DB	00H, 'i', 00H, 'n', 00H, 'g', 00H, 's', 00H, 00H, 00H
$SG4294800416 DB 'V', 00H, 'i', 00H, 'd', 00H, 'e', 00H, 'o', 00H, ' ', 00H
	DB	'E', 00H, 'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'i', 00H, 'n'
	DB	00H, 'g', 00H, 00H, 00H
	ORG $+2
$SG4294800419 DB 'U', 00H, 's', 00H, 'e', 00H, 'N', 00H, 'V', 00H, 'E', 00H
	DB	'N', 00H, 'C', 00H, 00H, 00H
	ORG $+2
$SG4294800418 DB 'V', 00H, 'i', 00H, 'd', 00H, 'e', 00H, 'o', 00H, ' ', 00H
	DB	'E', 00H, 'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'i', 00H, 'n'
	DB	00H, 'g', 00H, 00H, 00H
	ORG $+2
$SG4294800413 DB 'C', 00H, 'u', 00H, 's', 00H, 't', 00H, 'o', 00H, 'm', 00H
	DB	'S', 00H, 'e', 00H, 't', 00H, 't', 00H, 'i', 00H, 'n', 00H, 'g'
	DB	00H, 's', 00H, 00H, 00H
	ORG $+2
$SG4294800412 DB 'V', 00H, 'i', 00H, 'd', 00H, 'e', 00H, 'o', 00H, ' ', 00H
	DB	'E', 00H, 'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'i', 00H, 'n'
	DB	00H, 'g', 00H, 00H, 00H
	ORG $+2
$SG4294800415 DB 'Q', 00H, 'S', 00H, 'V', 00H, 'U', 00H, 's', 00H, 'e', 00H
	DB	'V', 00H, 'i', 00H, 'd', 00H, 'e', 00H, 'o', 00H, 'E', 00H, 'n'
	DB	00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'r', 00H, 'S', 00H
	DB	'e', 00H, 't', 00H, 't', 00H, 'i', 00H, 'n', 00H, 'g', 00H, 's'
	DB	00H, 00H, 00H
	ORG $+2
$SG4294800414 DB 'V', 00H, 'i', 00H, 'd', 00H, 'e', 00H, 'o', 00H, ' ', 00H
	DB	'E', 00H, 'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'i', 00H, 'n'
	DB	00H, 'g', 00H, 00H, 00H
	ORG $+2
$SG4294800409 DB 'k', 00H, 'b', 00H, '/', 00H, 's', 00H, 00H, 00H
	ORG $+2
$SG4294800408 DB 'M', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG4294800411 DB 'C', 00H, 'u', 00H, 's', 00H, 't', 00H, 'o', 00H, 'm', 00H
	DB	'Q', 00H, 'S', 00H, 'V', 00H, 'S', 00H, 'e', 00H, 't', 00H, 't'
	DB	00H, 'i', 00H, 'n', 00H, 'g', 00H, 's', 00H, 00H, 00H
$SG4294800410 DB 'V', 00H, 'i', 00H, 'd', 00H, 'e', 00H, 'o', 00H, ' ', 00H
	DB	'E', 00H, 'n', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'i', 00H, 'n'
	DB	00H, 'g', 00H, 00H, 00H
	ORG $+2
$SG4294800405 DB 'L', 00H, 'I', 00H, 'V', 00H, 'E', 00H, 00H, 00H
	ORG $+2
$SG4294800404 DB 'R', 00H, 'E', 00H, 'C', 00H, 00H, 00H
$SG4294800407 DB 'P', 00H, 'u', 00H, 'b', 00H, 'l', 00H, 'i', 00H, 's', 00H
	DB	'h', 00H, 00H, 00H
$SG4294800406 DB '%', 00H, 'u', 00H, ':', 00H, '%', 00H, '0', 00H, '2', 00H
	DB	'u', 00H, ':', 00H, '%', 00H, '0', 00H, '2', 00H, 'u', 00H, 00H
	DB	00H
	ORG $+2
$SG4294800401 DB ' ', 00H, '+', 00H, ' ', 00H, 00H, 00H
$SG4294800400 DB ' ', 00H, '(', 00H, '%', 00H, 's', 00H, ')', 00H, 00H, 00H
$SG4294800403 DB 'B', 00H, 'U', 00H, 'F', 00H, 00H, 00H
$SG4294800402 DB 'P', 00H, 'r', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'e', 00H
	DB	'w', 00H, 00H, 00H
$SG4294800397 DB 'F', 00H, 'P', 00H, 'S', 00H, ':', 00H, ' ', 00H, 00H, 00H
$SG4294800396 DB 's', 00H, 'o', 00H, 'u', 00H, 'r', 00H, 'c', 00H, 'e', 00H
	DB	's', 00H, 00H, 00H
$SG4294800399 DB 'M', 00H, 'a', 00H, 'i', 00H, 'n', 00H, 'W', 00H, 'i', 00H
	DB	'n', 00H, 'd', 00H, 'o', 00H, 'w', 00H, '.', 00H, 'D', 00H, 'r'
	DB	00H, 'o', 00H, 'p', 00H, 'p', 00H, 'e', 00H, 'd', 00H, 'F', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, 'e', 00H, 's', 00H, 00H, 00H
	ORG $+2
$SG4294800398 DB ' ', 00H, '%', 00H, 'u', 00H, ' ', 00H, '(', 00H, '%', 00H
	DB	'0', 00H, '.', 00H, '2', 00H, 'f', 00H, '%', 00H, '%', 00H, ')'
	DB	00H, 00H, 00H
$SG4294800393 DB 's', 00H, 'o', 00H, 'u', 00H, 'r', 00H, 'c', 00H, 'e', 00H
	DB	's', 00H, 00H, 00H
$SG4294800392 DB 'r', 00H, 'e', 00H, 'n', 00H, 'd', 00H, 'e', 00H, 'r', 00H
	DB	00H, 00H
	ORG $+2
$SG4294800395 DB 'r', 00H, 'e', 00H, 'n', 00H, 'd', 00H, 'e', 00H, 'r', 00H
	DB	00H, 00H
	ORG $+2
$SG4294800394 DB 'r', 00H, 'e', 00H, 'n', 00H, 'd', 00H, 'e', 00H, 'r', 00H
	DB	00H, 00H
	ORG $+2
$SG4294800391 DB 00H, 00H
	ORG $+2
$SG4294800389 DB 'U', 00H, 'n', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H
	DB	' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'g', 00H, 'e', 00H, 't'
	DB	00H, ' ', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'j', 00H, 'e', 00H
	DB	'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H, 'b', 00H, 'a'
	DB	00H, 'c', 00H, 'k', 00H, ' ', 00H, 'b', 00H, 'u', 00H, 'f', 00H
	DB	'f', 00H, 'e', 00H, 'r', 00H, 00H, 00H
$SG4294800388 DB 'U', 00H, 'n', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H
	DB	' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'g', 00H, 'e', 00H, 't'
	DB	00H, ' ', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 'd', 00H, 'e', 00H
	DB	'r', 00H, ' ', 00H, 'v', 00H, 'i', 00H, 'e', 00H, 'w', 00H, ' '
	DB	00H, 'f', 00H, 'r', 00H, 'o', 00H, 'm', 00H, ' ', 00H, 'p', 00H
	DB	'r', 00H, 'o', 00H, 'j', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o'
	DB	00H, 'r', 00H, ' ', 00H, 'b', 00H, 'a', 00H, 'c', 00H, 'k', 00H
	DB	' ', 00H, 'b', 00H, 'u', 00H, 'f', 00H, 'f', 00H, 'e', 00H, 'r'
	DB	00H, 00H, 00H
	ORG $+2
$SG4294800385 DB '//skin//btn_login_close.png', 00H
$SG4294800390 DB 'C', 00H, 'o', 00H, 'u', 00H, 'l', 00H, 'd', 00H, ' ', 00H
	DB	'n', 00H, 'o', 00H, 't', 00H, ' ', 00H, 'c', 00H, 'r', 00H, 'e'
	DB	00H, 'a', 00H, 't', 00H, 'e', 00H, ' ', 00H, 'p', 00H, 'r', 00H
	DB	'o', 00H, 'j', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, ' ', 00H, 's', 00H, 'w', 00H, 'a', 00H, 'p', 00H, ' ', 00H
	DB	'c', 00H, 'h', 00H, 'a', 00H, 'i', 00H, 'n', 00H, 00H, 00H
$SG4294800384 DB 00H, 00H
	ORG $+2
$SG4294800387 DB '//skin//staticbk.png', 00H
	ORG $+3
$SG4294800386 DB 08H, 'gIQ', 0f3H, 'wQ', 07fH, 0dcH, '~', 0d1H, 'y', 080H
	DB	'b', 09H, 'gP', 096H, 'lQ', 0f8H, 'S', 00H, 00H
$SG4294800381 DB '//skin//btn_main_plugin.png', 00H
$SG4294800380 DB 00H, 00H
	ORG $+2
$SG4294800383 DB '//skin//btn_login_min.png', 00H
	ORG $+2
$SG4294800382 DB 00H, 00H
	ORG $+2
$SG4294800377 DB '//skin//btn_main_sysSet.png', 00H
$SG4294800376 DB 0beH, 08bH, 'n', 07fH, 00H, 00H
	ORG $+2
$SG4294800379 DB '//skin//btn_main_video.png', 00H
	ORG $+1
$SG4294800378 DB 00H, 00H
	ORG $+2
$SG4294800373 DB '//skin//btn_bk.png', 00H
	ORG $+1
$SG4294800372 DB 'M', 00H, 'a', 00H, 'i', 00H, 'n', 00H, 'W', 00H, 'i', 00H
	DB	'n', 00H, 'd', 00H, 'o', 00H, 'w', 00H, '.', 00H, 'S', 00H, 't'
	DB	00H, 'a', 00H, 'r', 00H, 't', 00H, 'R', 00H, 'e', 00H, 'c', 00H
	DB	'o', 00H, 'r', 00H, 'd', 00H, 'i', 00H, 'n', 00H, 'g', 00H, 00H
	DB	00H
$SG4294800375 DB '//skin//btn_main_openLive.png', 00H
	ORG $+2
$SG4294800374 DB 'M', 00H, 'a', 00H, 'i', 00H, 'n', 00H, 'W', 00H, 'i', 00H
	DB	'n', 00H, 'd', 00H, 'o', 00H, 'w', 00H, '.', 00H, 'S', 00H, 't'
	DB	00H, 'a', 00H, 'r', 00H, 't', 00H, 'S', 00H, 't', 00H, 'r', 00H
	DB	'e', 00H, 'a', 00H, 'm', 00H, 00H, 00H
	ORG $+2
$SG4294800369 DB 'DeviceCapture', 00H
	ORG $+2
$SG4294800368 DB 's', 00H, 'o', 00H, 'u', 00H, 'r', 00H, 'c', 00H, 'e', 00H
	DB	's', 00H, 00H, 00H
$SG4294800371 DB '//skin//btn_bk.png', 00H
	ORG $+1
$SG4294800370 DB 'M', 00H, 'a', 00H, 'i', 00H, 'n', 00H, 'W', 00H, 'i', 00H
	DB	'n', 00H, 'd', 00H, 'o', 00H, 'w', 00H, '.', 00H, 'T', 00H, 'e'
	DB	00H, 's', 00H, 't', 00H, 'S', 00H, 't', 00H, 'r', 00H, 'e', 00H
	DB	'a', 00H, 'm', 00H, 00H, 00H
$SG4294800365 DB 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H
	DB	'C', 00H, 'a', 00H, 'p', 00H, 't', 00H, 'u', 00H, 'r', 00H, 'e'
	DB	00H, 00H, 00H
$SG4294800364 DB 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H, 00H, 00H
$SG4294800367 DB 's', 00H, 'o', 00H, 'u', 00H, 'r', 00H, 'c', 00H, 'e', 00H
	DB	's', 00H, 00H, 00H
$SG4294800366 DB 'r', 00H, 'e', 00H, 'n', 00H, 'd', 00H, 'e', 00H, 'r', 00H
	DB	00H, 00H
PUBLIC	?get_deleter@?$_Unique_ptr_base@XU?$ThreadTerminator@$0A@@@$00@std@@QAEAAU?$ThreadTerminator@$0A@@@XZ ; std::_Unique_ptr_base<void,ThreadTerminator<0>,1>::get_deleter
PUBLIC	??R?$ThreadTerminator@$0A@@@QBEXPAX@Z		; ThreadTerminator<0>::operator()
PUBLIC	??1?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@QAE@XZ ; std::unique_ptr<void,ThreadTerminator<0> >::~unique_ptr<void,ThreadTerminator<0> >
PUBLIC	??1?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@QAE@XZ ; std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>::~pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>
PUBLIC	??_G?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@QAEPAXI@Z ; std::unique_ptr<void,ThreadTerminator<0> >::`scalar deleting destructor'
PUBLIC	??_G?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@QAEPAXI@Z ; std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>::`scalar deleting destructor'
PUBLIC	??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@1@AAPAU21@@Z ; std::allocator<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> >::construct<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> *,std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> * &>
PUBLIC	??$construct@PAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@AAPAU12@@?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@QAEXPAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@AAPAU21@@Z ; std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> >::construct<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> *,std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> * &>
PUBLIC	??$destroy@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@QAEXPAV?$unique_ptr@XU?$ThreadTerminator@$0A@@@@1@@Z ; std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> >::destroy<std::unique_ptr<void,ThreadTerminator<0> > >
PUBLIC	??$destroy@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@1@@Z ; std::allocator<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> >::destroy<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >
PUBLIC	??$destroy@PAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@QAEXPAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@@Z ; std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> >::destroy<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> *>
PUBLIC	??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@1@@Z ; std::allocator<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> >::destroy<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> *>
PUBLIC	??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@1@AAPAU31@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> > >::construct<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> *,std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> * &>
PUBLIC	??$forward@AAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@0@AAPAU10@@Z ; std::forward<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> * &>
PUBLIC	??$construct@PAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@1@PAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@AAPAU31@@Z ; std::allocator_traits<std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> > >::construct<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> *,std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> * &>
PUBLIC	??$forward@AAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@YAAAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@0@AAPAU10@@Z ; std::forward<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> * &>
PUBLIC	??$destroy@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@?$allocator_traits@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@1@PAV?$unique_ptr@XU?$ThreadTerminator@$0A@@@@1@@Z ; std::allocator_traits<std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> > >::destroy<std::unique_ptr<void,ThreadTerminator<0> > >
PUBLIC	??$destroy@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@1@PAU?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@1@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> > >::destroy<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >
PUBLIC	??$_Move@AAD@std@@YA$$QADAAD@Z			; std::_Move<char &>
PUBLIC	??$destroy@PAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@1@PAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@@Z ; std::allocator_traits<std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> > >::destroy<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> *>
PUBLIC	??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@1@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> > >::destroy<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> *>
PUBLIC	??$_Allocate@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@YAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@0@IPAU10@@Z ; std::_Allocate<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> >
PUBLIC	??$_Allocate@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@YAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@0@IPAU10@@Z ; std::_Allocate<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> >
PUBLIC	??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@1@AAPAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> > >::construct<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> *,std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> * &>
PUBLIC	??$construct@PAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@AAPAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> > >::construct<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> *,std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> * &>
PUBLIC	??$destroy@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@QAEXPAV?$unique_ptr@XU?$ThreadTerminator@$0A@@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> > >::destroy<std::unique_ptr<void,ThreadTerminator<0> > >
PUBLIC	??$addressof@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@YAPAV?$unique_ptr@XU?$ThreadTerminator@$0A@@@@0@AAV10@@Z ; std::addressof<std::unique_ptr<void,ThreadTerminator<0> > >
PUBLIC	??$destroy@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> > >::destroy<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >
PUBLIC	??$addressof@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@YAPAU?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@AAU10@@Z ; std::addressof<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >
PUBLIC	??$swap@D@std@@YAXAAD0@Z			; std::swap<char>
PUBLIC	??$destroy@PAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> > >::destroy<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> *>
PUBLIC	??$addressof@PAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@YAPAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@0@AAPAU10@@Z ; std::addressof<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> *>
PUBLIC	??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> > >::destroy<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> *>
PUBLIC	??$addressof@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@0@AAPAU10@@Z ; std::addressof<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> *>
PUBLIC	?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@I@Z ; std::allocator<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> >::allocate
PUBLIC	?allocate@?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@QAEPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@I@Z ; std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> >::allocate
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> > >::allocate
PUBLIC	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >,std::_Iterator_base0>::operator++
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >,std::_Iterator_base0>
PUBLIC	??0?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@QAE@XZ ; std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> >::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> > >::allocate
PUBLIC	??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >
PUBLIC	??0?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@QAE@XZ ; std::allocator<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> >::allocator<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> >
PUBLIC	?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > > >::_Buyheadnode
PUBLIC	?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >,std::_Iterator_base0>::_Mynode
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > > >::operator++
PUBLIC	??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@1@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > > >
PUBLIC	?_Myval@?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@SAAAV?$unique_ptr@XU?$ThreadTerminator@$0A@@@@2@PAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@@Z ; std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > >::_Myval
PUBLIC	?deallocate@?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@QAEXPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@I@Z ; std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> >::deallocate
PUBLIC	??0?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> > >::_Wrap_alloc<std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> > >
PUBLIC	?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@@std@@QAEPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@PAU32@0@Z ; std::_List_alloc<0,std::_List_base_types<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > > >::_Buynode0
PUBLIC	?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Min
PUBLIC	?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Max
PUBLIC	?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAU?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@2@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Myval
PUBLIC	?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Isnil
PUBLIC	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Color
PUBLIC	?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@I@Z ; std::allocator<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> >::deallocate
PUBLIC	??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> > >
PUBLIC	??0?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@1@@Z ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > > >::_Tree_alloc<0,std::_Tree_base_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > > >
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::_Rrotate
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::_Root
PUBLIC	?_Rmost@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::_Rmost
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::_Lrotate
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::_Erase
PUBLIC	??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > > >::operator!=
PUBLIC	??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > > >::operator==
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > > >::operator++
PUBLIC	??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > > >
PUBLIC	?_Prevnode@?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@SAAAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@PAU32@@Z ; std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > >::_Prevnode
PUBLIC	?_Nextnode@?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@SAAAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@PAU32@@Z ; std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > >::_Nextnode
PUBLIC	??0?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@QAE@XZ ; std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > >::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > >
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> > >::deallocate
PUBLIC	?_Getal@?$_List_alloc@$0A@U?$_List_base_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@2@XZ ; std::_List_alloc<0,std::_List_base_types<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > > >::_Getal
PUBLIC	?_Buyheadnode@?$_List_alloc@$0A@U?$_List_base_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@@std@@QAEPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@XZ ; std::_List_alloc<0,std::_List_base_types<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > > >::_Buyheadnode
PUBLIC	?_Freenode@?$_List_buy@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAEXPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@@Z ; std::_List_buy<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >::_Freenode
PUBLIC	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Right
PUBLIC	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Parent
PUBLIC	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Left
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> > >::deallocate
PUBLIC	?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > > >::_Getal
PUBLIC	??0?$_Tree_buy@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@1@@Z ; std::_Tree_buy<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Tree_buy<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::_Lmost
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::clear
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::erase
PUBLIC	?_Freeheadnode@?$_List_alloc@$0A@U?$_List_base_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@@std@@QAEXPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@@Z ; std::_List_alloc<0,std::_List_base_types<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > > >::_Freeheadnode
PUBLIC	??0?$_List_alloc@$0A@U?$_List_base_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@1@@Z ; std::_List_alloc<0,std::_List_base_types<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > > >::_List_alloc<0,std::_List_base_types<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > > >
PUBLIC	?clear@?$list@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAEXXZ ; std::list<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >::clear
PUBLIC	?_Freeheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > > >::_Freeheadnode
PUBLIC	??0?$_Tree_comp@$0A@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@ABV?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@1@@Z ; std::_Tree_comp<0,std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::_Tree_comp<0,std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::erase
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::end
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::begin
PUBLIC	??0?$default_delete@VNetworkStream@@@std@@QAE@XZ ; std::default_delete<NetworkStream>::default_delete<NetworkStream>
PUBLIC	?_Local@?$_Func_class@X$$$V@std@@ABE_NXZ	; std::_Func_class<void>::_Local
PUBLIC	?_Set@?$_Func_class@X$$$V@std@@AAEXPAV?$_Func_base@X$$$V@2@@Z ; std::_Func_class<void>::_Set
PUBLIC	??1?$_List_alloc@$0A@U?$_List_base_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@@std@@QAE@XZ ; std::_List_alloc<0,std::_List_base_types<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > > >::~_List_alloc<0,std::_List_base_types<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > > >
PUBLIC	??0?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@QAE@XZ ; std::allocator<std::unique_ptr<void,ThreadTerminator<0> > >::allocator<std::unique_ptr<void,ThreadTerminator<0> > >
PUBLIC	??0?$_List_buy@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAE@ABV?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@1@@Z ; std::_List_buy<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >::_List_buy<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >
PUBLIC	?_Tidy@?$list@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAEXXZ ; std::list<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >::_Tidy
PUBLIC	?Clear@?$List@UPluginInfo@@@@QAEXXZ		; List<PluginInfo>::Clear
PUBLIC	?SetSize@?$List@UPluginInfo@@@@QAEHI@Z		; List<PluginInfo>::SetSize
PUBLIC	?SetSize@?$List@UFontInfo@@@@QAEHI@Z		; List<FontInfo>::SetSize
PUBLIC	?Add@?$List@UIconInfo@@@@QAEIABUIconInfo@@@Z	; List<IconInfo>::Add
PUBLIC	?Clear@?$List@UFrameAudio@@@@QAEXXZ		; List<FrameAudio>::Clear
PUBLIC	?Clear@?$List@UVideoSegment@@@@QAEXXZ		; List<VideoSegment>::Clear
PUBLIC	??1?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@@std@@QAE@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > > >::~_Tree_alloc<0,std::_Tree_base_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > > >
PUBLIC	??0?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@QAE@XZ ; std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::_Tidy
PUBLIC	??0?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@ABV?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >
PUBLIC	?Clear@?$List@PAVSettingsPane@@@@QAEXXZ		; List<SettingsPane *>::Clear
PUBLIC	?Clear@?$List@USceneHotkeyInfo@@@@QAEXXZ	; List<SceneHotkeyInfo>::Clear
PUBLIC	?Add@?$List@USceneHotkeyInfo@@@@QAEIABUSceneHotkeyInfo@@@Z ; List<SceneHotkeyInfo>::Add
PUBLIC	?Clear@?$List@PAVAudioSource@@@@QAEXXZ		; List<AudioSource *>::Clear
PUBLIC	?get_deleter@?$_Unique_ptr_base@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@$00@std@@QAEAAU?$default_delete@VNetworkStream@@@2@XZ ; std::_Unique_ptr_base<NetworkStream,std::default_delete<NetworkStream>,1>::get_deleter
PUBLIC	??0?$_Unique_ptr_base@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@$00@std@@QAE@PAVNetworkStream@@@Z ; std::_Unique_ptr_base<NetworkStream,std::default_delete<NetworkStream>,1>::_Unique_ptr_base<NetworkStream,std::default_delete<NetworkStream>,1>
PUBLIC	??R?$default_delete@VNetworkStream@@@std@@QBEXPAVNetworkStream@@@Z ; std::default_delete<NetworkStream>::operator()
PUBLIC	?_Tidy@?$_Func_class@X$$$V@std@@IAEXXZ		; std::_Func_class<void>::_Tidy
PUBLIC	?_Reset@?$_Func_class@X$$$V@std@@IAEXXZ		; std::_Func_class<void>::_Reset
PUBLIC	??1?$_Func_class@X$$$V@std@@QAE@XZ		; std::_Func_class<void>::~_Func_class<void>
PUBLIC	??0?$_Func_class@X$$$V@std@@QAE@XZ		; std::_Func_class<void>::_Func_class<void>
PUBLIC	?Add@?$List@UMonitorInfo@@@@QAEIABUMonitorInfo@@@Z ; List<MonitorInfo>::Add
PUBLIC	??1?$_Tree_buy@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@QAE@XZ ; std::_Tree_buy<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::~_Tree_buy<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >
PUBLIC	??1?$_List_buy@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAE@XZ ; std::_List_buy<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >::~_List_buy<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >
PUBLIC	??1?$_Tree_comp@$0A@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_comp<0,std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::~_Tree_comp<0,std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >
PUBLIC	??1?$list@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAE@XZ ; std::list<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >::~list<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >
PUBLIC	??0?$list@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAE@XZ ; std::list<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >::list<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >
PUBLIC	??A?$List@UPluginInfo@@@@QAEAAUPluginInfo@@I@Z	; List<PluginInfo>::operator[]
PUBLIC	?CreateNew@?$List@UPluginInfo@@@@QAEPAUPluginInfo@@XZ ; List<PluginInfo>::CreateNew
PUBLIC	??1?$List@UPluginInfo@@@@QAE@XZ			; List<PluginInfo>::~List<PluginInfo>
PUBLIC	??0?$List@UPluginInfo@@@@QAE@XZ			; List<PluginInfo>::List<PluginInfo>
PUBLIC	??1?$List@UStreamInfo@@@@QAE@XZ			; List<StreamInfo>::~List<StreamInfo>
PUBLIC	??0?$List@UStreamInfo@@@@QAE@XZ			; List<StreamInfo>::List<StreamInfo>
PUBLIC	??1?$List@UGlobalSourceInfo@@@@QAE@XZ		; List<GlobalSourceInfo>::~List<GlobalSourceInfo>
PUBLIC	??0?$List@UGlobalSourceInfo@@@@QAE@XZ		; List<GlobalSourceInfo>::List<GlobalSourceInfo>
PUBLIC	??1?$List@UClassInfo@@@@QAE@XZ			; List<ClassInfo>::~List<ClassInfo>
PUBLIC	??0?$List@UClassInfo@@@@QAE@XZ			; List<ClassInfo>::List<ClassInfo>
PUBLIC	??A?$List@UFontInfo@@@@QAEAAUFontInfo@@I@Z	; List<FontInfo>::operator[]
PUBLIC	?CreateNew@?$List@UFontInfo@@@@QAEPAUFontInfo@@XZ ; List<FontInfo>::CreateNew
PUBLIC	?Clear@?$List@UFontInfo@@@@QAEXXZ		; List<FontInfo>::Clear
PUBLIC	?Num@?$List@UFontInfo@@@@QBEIXZ			; List<FontInfo>::Num
PUBLIC	??1?$List@UFontInfo@@@@QAE@XZ			; List<FontInfo>::~List<FontInfo>
PUBLIC	??0?$List@UFontInfo@@@@QAE@XZ			; List<FontInfo>::List<FontInfo>
PUBLIC	??A?$List@UIconInfo@@@@QAEAAUIconInfo@@I@Z	; List<IconInfo>::operator[]
PUBLIC	??6?$List@UIconInfo@@@@QAEAAV0@ABUIconInfo@@@Z	; List<IconInfo>::operator<<
PUBLIC	?Clear@?$List@UIconInfo@@@@QAEXXZ		; List<IconInfo>::Clear
PUBLIC	?Num@?$List@UIconInfo@@@@QBEIXZ			; List<IconInfo>::Num
PUBLIC	??1?$List@UIconInfo@@@@QAE@XZ			; List<IconInfo>::~List<IconInfo>
PUBLIC	??0?$List@UIconInfo@@@@QAE@XZ			; List<IconInfo>::List<IconInfo>
PUBLIC	??1?$List@UFrameAudio@@@@QAE@XZ			; List<FrameAudio>::~List<FrameAudio>
PUBLIC	??0?$List@UFrameAudio@@@@QAE@XZ			; List<FrameAudio>::List<FrameAudio>
PUBLIC	??0?$CircularList@_K@@QAE@XZ			; CircularList<unsigned __int64>::CircularList<unsigned __int64>
PUBLIC	??1?$List@UVideoSegment@@@@QAE@XZ		; List<VideoSegment>::~List<VideoSegment>
PUBLIC	??0?$List@UVideoSegment@@@@QAE@XZ		; List<VideoSegment>::List<VideoSegment>
PUBLIC	??1?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::~_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >
PUBLIC	??0?$map@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@QAE@XZ ; std::map<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::map<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >
PUBLIC	??A?$List@PAVSettingsPane@@@@QAEAAPAVSettingsPane@@I@Z ; List<SettingsPane *>::operator[]
PUBLIC	?Num@?$List@PAVSettingsPane@@@@QBEIXZ		; List<SettingsPane *>::Num
PUBLIC	??1?$List@PAVSettingsPane@@@@QAE@XZ		; List<SettingsPane *>::~List<SettingsPane *>
PUBLIC	??0?$List@PAVSettingsPane@@@@QAE@XZ		; List<SettingsPane *>::List<SettingsPane *>
PUBLIC	??6?$List@USceneHotkeyInfo@@@@QAEAAV0@ABUSceneHotkeyInfo@@@Z ; List<SceneHotkeyInfo>::operator<<
PUBLIC	??1?$List@USceneHotkeyInfo@@@@QAE@XZ		; List<SceneHotkeyInfo>::~List<SceneHotkeyInfo>
PUBLIC	??0?$List@USceneHotkeyInfo@@@@QAE@XZ		; List<SceneHotkeyInfo>::List<SceneHotkeyInfo>
PUBLIC	??1?$List@PAVAudioSource@@@@QAE@XZ		; List<AudioSource *>::~List<AudioSource *>
PUBLIC	??0?$List@PAVAudioSource@@@@QAE@XZ		; List<AudioSource *>::List<AudioSource *>
PUBLIC	?reset@?$unique_ptr@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@@std@@QAEXPAVNetworkStream@@@Z ; std::unique_ptr<NetworkStream,std::default_delete<NetworkStream> >::reset
PUBLIC	??1?$unique_ptr@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@@std@@QAE@XZ ; std::unique_ptr<NetworkStream,std::default_delete<NetworkStream> >::~unique_ptr<NetworkStream,std::default_delete<NetworkStream> >
PUBLIC	??0?$unique_ptr@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@@std@@QAE@XZ ; std::unique_ptr<NetworkStream,std::default_delete<NetworkStream> >::unique_ptr<NetworkStream,std::default_delete<NetworkStream> >
PUBLIC	??1?$function@$$A6AXXZ@std@@QAE@XZ		; std::function<void __cdecl(void)>::~function<void __cdecl(void)>
PUBLIC	??0?$function@$$A6AXXZ@std@@QAE@XZ		; std::function<void __cdecl(void)>::function<void __cdecl(void)>
PUBLIC	??6?$List@UMonitorInfo@@@@QAEAAV0@ABUMonitorInfo@@@Z ; List<MonitorInfo>::operator<<
PUBLIC	??1?$List@UMonitorInfo@@@@QAE@XZ		; List<MonitorInfo>::~List<MonitorInfo>
PUBLIC	??0?$List@UMonitorInfo@@@@QAE@XZ		; List<MonitorInfo>::List<MonitorInfo>
PUBLIC	??A?$List@UAudioDeviceInfo@@@@QBEAAUAudioDeviceInfo@@I@Z ; List<AudioDeviceInfo>::operator[]
PUBLIC	??A?$List@UAudioDeviceInfo@@@@QAEAAUAudioDeviceInfo@@I@Z ; List<AudioDeviceInfo>::operator[]
PUBLIC	?Num@?$List@UAudioDeviceInfo@@@@QBEIXZ		; List<AudioDeviceInfo>::Num
PUBLIC	??1?$List@UAudioDeviceInfo@@@@QAE@XZ		; List<AudioDeviceInfo>::~List<AudioDeviceInfo>
PUBLIC	??0?$List@UAudioDeviceInfo@@@@QAE@XZ		; List<AudioDeviceInfo>::List<AudioDeviceInfo>
PUBLIC	?AddVideoCaptureDevice@OBS@@QAEXXZ		; OBS::AddVideoCaptureDevice
PUBLIC	?InitLayOut@OBS@@AAEXXZ				; OBS::InitLayOut
PUBLIC	?RestartNetwork@OBS@@AAEXXZ			; OBS::RestartNetwork
PUBLIC	?DisableProjector@OBS@@AAEXXZ			; OBS::DisableProjector
PUBLIC	?EnableProjector@OBS@@AAEXI@Z			; OBS::EnableProjector
PUBLIC	?ActuallyEnableProjector@OBS@@AAEXXZ		; OBS::ActuallyEnableProjector
PUBLIC	?HideNotificationAreaIcon@OBS@@QAEHXZ		; OBS::HideNotificationAreaIcon
PUBLIC	?ShowNotificationAreaIcon@OBS@@QAEHXZ		; OBS::ShowNotificationAreaIcon
PUBLIC	?SetNotificationAreaIcon@OBS@@AAEHKHABVString@@@Z ; OBS::SetNotificationAreaIcon
PUBLIC	?SetSourceRender@OBS@@AAEXPB_W_N@Z		; OBS::SetSourceRender
PUBLIC	?CheckSources@OBS@@AAEXXZ			; OBS::CheckSources
PUBLIC	?SelectSources@OBS@@AAEXXZ			; OBS::SelectSources
PUBLIC	?DrawStatusBar@OBS@@CAXAAUtagDRAWITEMSTRUCT@@@Z	; OBS::DrawStatusBar
PUBLIC	?SetStatusBarData@OBS@@AAEXXZ			; OBS::SetStatusBarData
PUBLIC	?GetFont@OBS@@UAEPAUHFONT__@@PB_WHH@Z		; OBS::GetFont
PUBLIC	?GetIcon@OBS@@UAEPAUHICON__@@PAUHINSTANCE__@@H@Z ; OBS::GetIcon
PUBLIC	?UpdateAudioMeters@OBS@@AAEXXZ			; OBS::UpdateAudioMeters
PUBLIC	??0AudioDeviceList@@QAE@XZ			; AudioDeviceList::AudioDeviceList
PUBLIC	?ReloadIniSettings@OBS@@AAEXXZ			; OBS::ReloadIniSettings
PUBLIC	?PostConfigureStreamButtons@OBS@@AAEXXZ		; OBS::PostConfigureStreamButtons
PUBLIC	?RefreshStreamButtons@OBS@@AAEX_N@Z		; OBS::RefreshStreamButtons
PUBLIC	?GetProfiles@OBS@@SAXAAVStringList@@@Z		; OBS::GetProfiles
PUBLIC	?ProcessPanelVisible@OBS@@AAEX_N@Z		; OBS::ProcessPanelVisible
PUBLIC	?SetFullscreenMode@OBS@@QAEX_N@Z		; OBS::SetFullscreenMode
PUBLIC	?ResizeRenderFrame@OBS@@AAEX_N@Z		; OBS::ResizeRenderFrame
PUBLIC	?UpdateRenderViewMessage@OBS@@AAEXXZ		; OBS::UpdateRenderViewMessage
PUBLIC	??1OBS@@UAE@XZ					; OBS::~OBS
PUBLIC	??1PendingStreams@OBS@@QAE@XZ			; OBS::PendingStreams::~PendingStreams
PUBLIC	??1?$CircularList@_K@@QAE@XZ			; CircularList<unsigned __int64>::~CircularList<unsigned __int64>
PUBLIC	??1?$map@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@QAE@XZ ; std::map<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::~map<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >
PUBLIC	??1StopInfo@OBS@@QAE@XZ				; OBS::StopInfo::~StopInfo
PUBLIC	??0StopInfo@OBS@@QAE@XZ				; OBS::StopInfo::StopInfo
PUBLIC	??_GOBS@@UAEPAXI@Z				; OBS::`scalar deleting destructor'
PUBLIC	?CheckPermissionsAndDiskSpace@@YAXXZ		; CheckPermissionsAndDiskSpace
PUBLIC	?IsWebrootLoaded@@YAHXZ				; IsWebrootLoaded
PUBLIC	??_GScene@@UAEPAXI@Z				; Scene::`scalar deleting destructor'
PUBLIC	?CreateNormalScene@@YGPAVScene@@PAVXElement@@@Z	; CreateNormalScene
PUBLIC	?MonitorInfoEnumProc@@YGHPAUHMONITOR__@@PAUHDC__@@PAUtagRECT@@AAV?$List@UMonitorInfo@@@@@Z ; MonitorInfoEnumProc
PUBLIC	??0PendingStreams@OBS@@QAE@XZ			; OBS::PendingStreams::PendingStreams
PUBLIC	?FreeData@ClassInfo@@QAEXXZ			; ClassInfo::FreeData
PUBLIC	??0MonitorInfo@@QAE@PAUHMONITOR__@@PAUtagRECT@@@Z ; MonitorInfo::MonitorInfo
PUBLIC	?HasID@AudioDeviceList@@QBE_NPB_W@Z		; AudioDeviceList::HasID
PUBLIC	?FreeData@AudioDeviceList@@QAEXXZ		; AudioDeviceList::FreeData
PUBLIC	??1AudioDeviceList@@QAE@XZ			; AudioDeviceList::~AudioDeviceList
PUBLIC	?FreeData@AudioDeviceInfo@@QAEXXZ		; AudioDeviceInfo::FreeData
PUBLIC	_CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY@4
PUBLIC	_IsolationAwareInitCommonControlsEx@4
PUBLIC	?LoadAllPlugins@OBS@@QAEXXZ			; OBS::LoadAllPlugins
PUBLIC	??0OBS@@QAE@XZ					; OBS::OBS
PUBLIC	?ConfigureStreamButtons@OBS@@AAEXXZ		; OBS::ConfigureStreamButtons
PUBLIC	?ResizeWindow@OBS@@QAEX_N@Z			; OBS::ResizeWindow
PUBLIC	?GetThreadHandles@OBS@@QAEXPAPAX0@Z		; OBS::GetThreadHandles
PUBLIC	?UpdateNotificationAreaIcon@OBS@@QAEHXZ		; OBS::UpdateNotificationAreaIcon
PUBLIC	?GetSceneCollection@OBS@@SAXAAVStringList@@@Z	; OBS::GetSceneCollection
PUBLIC	?GetBaseSize@OBS@@QBEXAAI0@Z			; OBS::GetBaseSize
PUBLIC	?ReloadSceneCollection@OBS@@AAEXXZ		; OBS::ReloadSceneCollection
EXTRN	??_EScene@@UAEPAXI@Z:PROC			; Scene::`vector deleting destructor'
EXTRN	??_EOBS@@UAEPAXI@Z:PROC				; OBS::`vector deleting destructor'
	ALIGN	4

__Tuple_alloc DB 01H DUP (?)
	ALIGN	4

_ignore	DB	01H DUP (?)
	ALIGN	4

_allocator_arg DB 01H DUP (?)
	ALIGN	4

_piecewise_construct DB 01H DUP (?)
_BSS	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__sehtable$_IsolationAwareInitCommonControlsEx@4 DD 0fffffffeH
	DD	00H
	DD	0ffffffb4H
	DD	00H
	DD	0fffffffeH
	DD	00H
	DD	FLAT:$LN21@IsolationA
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__sehtable$_CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY@4 DD 0fffffffeH
	DD	00H
	DD	0ffffffc4H
	DD	00H
	DD	0fffffffeH
	DD	00H
	DD	FLAT:$LN16@CommctrlIs
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@@std@@QAEPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@PAU32@0@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@@std@@QAEPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@PAU32@0@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@@std@@QAEPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@PAU32@0@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@@std@@QAEPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@PAU32@0@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@@std@@QAEPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@PAU32@0@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@@std@@QAEPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@PAU32@0@Z$2
__catchsym$?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@@std@@QAEPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@PAU32@0@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@@std@@QAEPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@PAU32@0@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@XZ
	DD	01H
	DD	FLAT:__tryblocktable$?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@XZ
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@XZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@XZ DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@XZ$2
__catchsym$?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@XZ$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@XZ$0
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
_ignore$initializer$ DD FLAT:??__Eignore@std@@YAXXZ
__Tuple_alloc$initializer$ DD FLAT:??__E_Tuple_alloc@std@@YAXXZ
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.cpp
;	COMDAT ?ReloadSceneCollection@OBS@@AAEXXZ
_TEXT	SEGMENT
_hotkeyInfo$1 = -76					; size = 12
_strScene$2 = -64					; size = 8
_strScenesConfig$ = -56					; size = 8
_scene$3 = -48						; size = 4
_scene$4 = -44						; size = 4
_collection$ = -40					; size = 4
_scene$5 = -36						; size = 4
_hotkey$6 = -32						; size = 4
_id$7 = -28						; size = 4
_this$ = -24						; size = 4
_i$8 = -20						; size = 4
_hwndTemp$ = -16					; size = 4
_i$9 = -12						; size = 4
_scenes$ = -8						; size = 4
_numScenes$ = -4					; size = 4
?ReloadSceneCollection@OBS@@AAEXXZ PROC			; OBS::ReloadSceneCollection, COMDAT
; _this$ = ecx

; 1457 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	mov	DWORD PTR _this$[ebp], ecx

; 1458 :     HWND hwndTemp;
; 1459 :     hwndTemp = GetDlgItem(hwndMain, ID_SCENES);

	push	5011					; 00001393H
	mov	eax, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	eax
	call	DWORD PTR __imp__GetDlgItem@8
	mov	DWORD PTR _hwndTemp$[ebp], eax

; 1460 : 
; 1461 :     CTSTR collection = GetCurrentSceneCollection();

	call	?GetCurrentSceneCollection@OBS@@SAPB_WXZ ; OBS::GetCurrentSceneCollection
	mov	DWORD PTR _collection$[ebp], eax

; 1462 :     String strScenesConfig = FormattedString(L"%s\\sceneCollection\\%s.xconfig", lpAppDataPath, collection);

	mov	ecx, DWORD PTR _collection$[ebp]
	push	ecx
	push	OFFSET ?lpAppDataPath@@3PA_WA		; lpAppDataPath
	push	OFFSET $SG4294800501
	lea	edx, DWORD PTR _strScenesConfig$[ebp]
	push	edx
	call	DWORD PTR __imp_?FormattedString@@YA?AVString@@PB_WZZ
	add	esp, 16					; 00000010H

; 1463 : 
; 1464 :     if (!scenesConfig.Open(strScenesConfig))

	lea	ecx, DWORD PTR _strScenesConfig$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 168				; 000000a8H
	call	DWORD PTR __imp_?Open@XConfig@@QAE_NPB_W@Z
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN13@ReloadScen

; 1465 :         CrashError(TEXT("Could not open '%s'"), strScenesConfig.Array());

	lea	ecx, DWORD PTR _strScenesConfig$[ebp]
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	push	OFFSET $SG4294800500
	call	DWORD PTR __imp_?CrashError@@YAXPB_WZZ
$LN13@ReloadScen:

; 1466 : 
; 1467 :     XElement *scenes = scenesConfig.GetElement(TEXT("scenes"));

	push	OFFSET $SG4294800499
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 168				; 000000a8H
	call	DWORD PTR __imp_?GetElement@XConfig@@QAEPAVXElement@@PB_W@Z
	mov	DWORD PTR _scenes$[ebp], eax

; 1468 : 
; 1469 :     if (!scenes)

	cmp	DWORD PTR _scenes$[ebp], 0
	jne	SHORT $LN12@ReloadScen

; 1470 :         scenes = scenesConfig.CreateElement(TEXT("scenes"));

	push	OFFSET $SG4294800498
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 168				; 000000a8H
	call	DWORD PTR __imp_?CreateElement@XConfig@@QAEPAVXElement@@PB_W@Z
	mov	DWORD PTR _scenes$[ebp], eax
$LN12@ReloadScen:

; 1471 : 
; 1472 :     SendMessage(hwndTemp, LB_RESETCONTENT, 0, 0);

	push	0
	push	0
	push	388					; 00000184H
	mov	ecx, DWORD PTR _hwndTemp$[ebp]
	push	ecx
	call	DWORD PTR __imp__SendMessageW@16

; 1473 : 
; 1474 :     App->sceneElement = NULL;

	mov	edx, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	DWORD PTR [edx+212], 0

; 1475 :     
; 1476 :     UINT numScenes = scenes->NumElements();

	push	0
	mov	ecx, DWORD PTR _scenes$[ebp]
	call	DWORD PTR __imp_?NumElements@XElement@@QAEKPB_W@Z
	mov	DWORD PTR _numScenes$[ebp], eax

; 1477 :     if (!numScenes)

	cmp	DWORD PTR _numScenes$[ebp], 0
	jne	SHORT $LN11@ReloadScen

; 1478 :     {
; 1479 :         XElement *scene = scenes->CreateElement(Str("Scene"));

	push	OFFSET $SG4294800497
	mov	eax, DWORD PTR __imp_?locale@@3PAVLocaleStringLookup@@A
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR __imp_?LookupString@LocaleStringLookup@@QAEPB_WPB_W@Z
	push	eax
	mov	ecx, DWORD PTR _scenes$[ebp]
	call	DWORD PTR __imp_?CreateElement@XElement@@QAEPAV1@PB_W@Z
	mov	DWORD PTR _scene$4[ebp], eax

; 1480 :         scene->SetString(TEXT("class"), TEXT("Scene"));

	push	OFFSET $SG4294800496
	push	OFFSET $SG4294800495
	mov	ecx, DWORD PTR _scene$4[ebp]
	call	DWORD PTR __imp_?SetString@XElement@@QAEXPB_W0@Z

; 1481 :         numScenes++;

	mov	ecx, DWORD PTR _numScenes$[ebp]
	add	ecx, 1
	mov	DWORD PTR _numScenes$[ebp], ecx
$LN11@ReloadScen:

; 1482 :     }
; 1483 : 
; 1484 :     for (UINT i = 0; i<numScenes; i++)

	mov	DWORD PTR _i$9[ebp], 0
	jmp	SHORT $LN10@ReloadScen
$LN9@ReloadScen:
	mov	edx, DWORD PTR _i$9[ebp]
	add	edx, 1
	mov	DWORD PTR _i$9[ebp], edx
$LN10@ReloadScen:
	mov	eax, DWORD PTR _i$9[ebp]
	cmp	eax, DWORD PTR _numScenes$[ebp]
	jae	SHORT $LN8@ReloadScen

; 1485 :     {
; 1486 :         XElement *scene = scenes->GetElementByID(i);

	mov	ecx, DWORD PTR _i$9[ebp]
	push	ecx
	mov	ecx, DWORD PTR _scenes$[ebp]
	call	DWORD PTR __imp_?GetElementByID@XElement@@QBEPAV1@K@Z
	mov	DWORD PTR _scene$3[ebp], eax

; 1487 :         SendMessage(hwndTemp, LB_ADDSTRING, 0, (LPARAM)scene->GetName());

	mov	ecx, DWORD PTR _scene$3[ebp]
	call	DWORD PTR __imp_?GetName@XBaseItem@@QBEPB_WXZ
	push	eax
	push	0
	push	384					; 00000180H
	mov	edx, DWORD PTR _hwndTemp$[ebp]
	push	edx
	call	DWORD PTR __imp__SendMessageW@16

; 1488 :     }

	jmp	SHORT $LN9@ReloadScen
$LN8@ReloadScen:

; 1489 :     //-----------------------------------------------------
; 1490 :     // populate sources
; 1491 : 
; 1492 :     if (numScenes)

	cmp	DWORD PTR _numScenes$[ebp], 0
	je	$LN7@ReloadScen

; 1493 :     {
; 1494 :         String strScene = AppConfig->GetString(TEXT("General"), TEXT("CurrentScene"));

	push	0
	push	OFFSET $SG4294800494
	push	OFFSET $SG4294800493
	lea	eax, DWORD PTR _strScene$2[ebp]
	push	eax
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetString@ConfigFile@@QAE?AVString@@PB_W00@Z

; 1495 :         int id = (int)SendMessage(hwndTemp, LB_FINDSTRINGEXACT, -1, (LPARAM)strScene.Array());

	lea	ecx, DWORD PTR _strScene$2[ebp]
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	push	-1
	push	418					; 000001a2H
	mov	ecx, DWORD PTR _hwndTemp$[ebp]
	push	ecx
	call	DWORD PTR __imp__SendMessageW@16
	mov	DWORD PTR _id$7[ebp], eax

; 1496 :         if (id == LB_ERR)

	cmp	DWORD PTR _id$7[ebp], -1
	jne	SHORT $LN6@ReloadScen

; 1497 :             id = 0;

	mov	DWORD PTR _id$7[ebp], 0
$LN6@ReloadScen:

; 1498 : 
; 1499 :         SendMessage(hwndTemp, LB_SETCURSEL, (WPARAM)id, 0);

	push	0
	mov	edx, DWORD PTR _id$7[ebp]
	push	edx
	push	390					; 00000186H
	mov	eax, DWORD PTR _hwndTemp$[ebp]
	push	eax
	call	DWORD PTR __imp__SendMessageW@16

; 1500 :         SendMessage(hwndMain, WM_COMMAND, MAKEWPARAM(ID_SCENES, LBN_SELCHANGE), (LPARAM)GetDlgItem(hwndMain, ID_SCENES));

	push	5011					; 00001393H
	mov	ecx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	ecx
	call	DWORD PTR __imp__GetDlgItem@8
	push	eax
	push	70547					; 00011393H
	push	273					; 00000111H
	mov	edx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	edx
	call	DWORD PTR __imp__SendMessageW@16

; 1501 :     }

	lea	ecx, DWORD PTR _strScene$2[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
$LN7@ReloadScen:

; 1502 : 
; 1503 :     //-----------------------------------------------------
; 1504 : 
; 1505 :     for (UINT i = 0; i<numScenes; i++)

	mov	DWORD PTR _i$8[ebp], 0
	jmp	SHORT $LN5@ReloadScen
$LN4@ReloadScen:
	mov	eax, DWORD PTR _i$8[ebp]
	add	eax, 1
	mov	DWORD PTR _i$8[ebp], eax
$LN5@ReloadScen:
	mov	ecx, DWORD PTR _i$8[ebp]
	cmp	ecx, DWORD PTR _numScenes$[ebp]
	jae	SHORT $LN3@ReloadScen

; 1506 :     {
; 1507 :         XElement *scene = scenes->GetElementByID(i);

	mov	edx, DWORD PTR _i$8[ebp]
	push	edx
	mov	ecx, DWORD PTR _scenes$[ebp]
	call	DWORD PTR __imp_?GetElementByID@XElement@@QBEPAV1@K@Z
	mov	DWORD PTR _scene$5[ebp], eax

; 1508 :         DWORD hotkey = scene->GetInt(TEXT("hotkey"));

	push	0
	push	OFFSET $SG4294800492
	mov	ecx, DWORD PTR _scene$5[ebp]
	call	DWORD PTR __imp_?GetInt@XElement@@QBEHPB_WH@Z
	mov	DWORD PTR _hotkey$6[ebp], eax

; 1509 :         if (hotkey)

	cmp	DWORD PTR _hotkey$6[ebp], 0
	je	SHORT $LN2@ReloadScen

; 1510 :         {
; 1511 :             SceneHotkeyInfo hotkeyInfo;
; 1512 :             hotkeyInfo.hotkey = hotkey;

	mov	eax, DWORD PTR _hotkey$6[ebp]
	mov	DWORD PTR _hotkeyInfo$1[ebp+4], eax

; 1513 :             hotkeyInfo.scene = scene;

	mov	ecx, DWORD PTR _scene$5[ebp]
	mov	DWORD PTR _hotkeyInfo$1[ebp+8], ecx

; 1514 :             hotkeyInfo.hotkeyID = API->CreateHotkey(hotkey, SceneHotkey, 0);

	push	0
	push	OFFSET ?SceneHotkey@@YGXKK_N@Z		; SceneHotkey
	mov	edx, DWORD PTR _hotkey$6[ebp]
	push	edx
	mov	eax, DWORD PTR __imp_?API@@3PAVAPIInterface@@A
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __imp_?API@@3PAVAPIInterface@@A
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR [eax+52]
	call	edx
	mov	DWORD PTR _hotkeyInfo$1[ebp], eax

; 1515 : 
; 1516 :             if (hotkeyInfo.hotkeyID)

	cmp	DWORD PTR _hotkeyInfo$1[ebp], 0
	je	SHORT $LN2@ReloadScen

; 1517 :                 sceneHotkeys << hotkeyInfo;

	lea	eax, DWORD PTR _hotkeyInfo$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 204				; 000000ccH
	call	??6?$List@USceneHotkeyInfo@@@@QAEAAV0@ABUSceneHotkeyInfo@@@Z ; List<SceneHotkeyInfo>::operator<<
$LN2@ReloadScen:

; 1518 :         }
; 1519 :     }

	jmp	$LN4@ReloadScen
$LN3@ReloadScen:

; 1520 : }

	lea	ecx, DWORD PTR _strScenesConfig$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
$LN15@ReloadScen:
	mov	esp, ebp
	pop	ebp
	ret	0
?ReloadSceneCollection@OBS@@AAEXXZ ENDP			; OBS::ReloadSceneCollection
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.cpp
;	COMDAT ?GetBaseSize@OBS@@QBEXAAI0@Z
_TEXT	SEGMENT
_defCY$1 = -20						; size = 4
_defCX$2 = -16						; size = 4
_monitorID$3 = -12					; size = 4
_screenRect$4 = -8					; size = 4
_this$ = -4						; size = 4
_width$ = 8						; size = 4
_height$ = 12						; size = 4
?GetBaseSize@OBS@@QBEXAAI0@Z PROC			; OBS::GetBaseSize, COMDAT
; _this$ = ecx

; 1200 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 1201 :     if(bRunning)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+622]
	test	ecx, ecx
	je	SHORT $LN3@GetBaseSiz

; 1202 :     {
; 1203 :         width = baseCX;

	mov	edx, DWORD PTR _width$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+856]
	mov	DWORD PTR [edx], ecx

; 1204 :         height = baseCY;

	mov	edx, DWORD PTR _height$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+860]
	mov	DWORD PTR [edx], ecx

; 1205 :     }
; 1206 :     else

	jmp	$LN4@GetBaseSiz
$LN3@GetBaseSiz:

; 1207 :     {
; 1208 :         int monitorID = AppConfig->GetInt(TEXT("Video"), TEXT("Monitor"));

	push	0
	push	OFFSET $SG4294800521
	push	OFFSET $SG4294800520
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	mov	DWORD PTR _monitorID$3[ebp], eax

; 1209 :         if(monitorID >= (int)monitors.Num())

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 156				; 0000009cH
	call	?Num@?$List@UMonitorInfo@@@@QBEIXZ	; List<MonitorInfo>::Num
	cmp	DWORD PTR _monitorID$3[ebp], eax
	jl	SHORT $LN1@GetBaseSiz

; 1210 :             monitorID = 0;

	mov	DWORD PTR _monitorID$3[ebp], 0
$LN1@GetBaseSiz:

; 1211 : 
; 1212 :         RECT &screenRect = monitors[monitorID].rect;

	mov	edx, DWORD PTR _monitorID$3[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 156				; 0000009cH
	call	??A?$List@UMonitorInfo@@@@QBEAAUMonitorInfo@@I@Z ; List<MonitorInfo>::operator[]
	add	eax, 4
	mov	DWORD PTR _screenRect$4[ebp], eax

; 1213 :         int defCX = screenRect.right  - screenRect.left;

	mov	eax, DWORD PTR _screenRect$4[ebp]
	mov	ecx, DWORD PTR _screenRect$4[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx]
	mov	DWORD PTR _defCX$2[ebp], edx

; 1214 :         int defCY = screenRect.bottom - screenRect.top;

	mov	eax, DWORD PTR _screenRect$4[ebp]
	mov	ecx, DWORD PTR _screenRect$4[ebp]
	mov	edx, DWORD PTR [eax+12]
	sub	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _defCY$1[ebp], edx

; 1215 : 
; 1216 :         width = AppConfig->GetInt(TEXT("Video"), TEXT("BaseWidth"),  defCX);

	mov	eax, DWORD PTR _defCX$2[ebp]
	push	eax
	push	OFFSET $SG4294800519
	push	OFFSET $SG4294800518
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	mov	ecx, DWORD PTR _width$[ebp]
	mov	DWORD PTR [ecx], eax

; 1217 :         height = AppConfig->GetInt(TEXT("Video"), TEXT("BaseHeight"), defCY);

	mov	edx, DWORD PTR _defCY$1[ebp]
	push	edx
	push	OFFSET $SG4294800517
	push	OFFSET $SG4294800516
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	mov	ecx, DWORD PTR _height$[ebp]
	mov	DWORD PTR [ecx], eax
$LN4@GetBaseSiz:

; 1218 :     }
; 1219 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetBaseSize@OBS@@QBEXAAI0@Z ENDP			; OBS::GetBaseSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.cpp
;	COMDAT ?GetSceneCollection@OBS@@SAXAAVStringList@@@Z
_TEXT	SEGMENT
$T1 = -576						; size = 8
_strSceneCollectionWildcard$ = -568			; size = 8
_sceneCollectionPath$2 = -560				; size = 8
_sceneCollectionDir$ = -552				; size = 8
_sceneCollection$3 = -544				; size = 8
_hFind$ = -536						; size = 4
_ofd$ = -532						; size = 528
__$ArrayPad$ = -4					; size = 4
_sceneCollectionList$ = 8				; size = 4
?GetSceneCollection@OBS@@SAXAAVStringList@@@Z PROC	; OBS::GetSceneCollection, COMDAT

; 1396 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 576				; 00000240H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1397 :     String strSceneCollectionWildcard;

	lea	ecx, DWORD PTR _strSceneCollectionWildcard$[ebp]
	call	DWORD PTR __imp_??0String@@QAE@XZ

; 1398 :     OSFindData ofd;
; 1399 :     HANDLE hFind;
; 1400 : 
; 1401 :     sceneCollectionList.Clear();

	mov	ecx, DWORD PTR _sceneCollectionList$[ebp]
	call	DWORD PTR __imp_?Clear@StringList@@QAEXXZ

; 1402 : 
; 1403 :     String sceneCollectionDir(FormattedString(L"%s/sceneCollection/", OBSGetAppDataPath()));

	call	DWORD PTR __imp_?OBSGetAppDataPath@@YAPB_WXZ
	push	eax
	push	OFFSET $SG4294800512
	lea	eax, DWORD PTR _sceneCollectionDir$[ebp]
	push	eax
	call	DWORD PTR __imp_?FormattedString@@YA?AVString@@PB_WZZ
	add	esp, 12					; 0000000cH

; 1404 :     strSceneCollectionWildcard << sceneCollectionDir << "*.xconfig";

	push	OFFSET $SG4294800511
	lea	ecx, DWORD PTR $T1[ebp]
	call	DWORD PTR __imp_??0String@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	lea	edx, DWORD PTR _sceneCollectionDir$[ebp]
	push	edx
	lea	ecx, DWORD PTR _strSceneCollectionWildcard$[ebp]
	call	DWORD PTR __imp_??6String@@QAEAAV0@ABV0@@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@ABV0@@Z
	lea	ecx, DWORD PTR $T1[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 1405 :     if (hFind = OSFindFirstFile(strSceneCollectionWildcard, ofd))

	lea	eax, DWORD PTR _ofd$[ebp]
	push	eax
	lea	ecx, DWORD PTR _strSceneCollectionWildcard$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	call	DWORD PTR __imp_?OSFindFirstFile@@YGPAXPB_WAAUOSFindData@@@Z
	mov	DWORD PTR _hFind$[ebp], eax
	cmp	DWORD PTR _hFind$[ebp], 0
	je	$LN6@GetSceneCo
$LN5@GetSceneCo:

; 1406 :     {
; 1407 :         do
; 1408 :         {
; 1409 :             String sceneCollection(GetPathWithoutExtension(ofd.fileName));

	lea	ecx, DWORD PTR _ofd$[ebp]
	push	ecx
	lea	edx, DWORD PTR _sceneCollection$3[ebp]
	push	edx
	call	DWORD PTR __imp_?GetPathWithoutExtension@@YA?AVString@@PB_W@Z
	add	esp, 8

; 1410 :             String sceneCollectionPath(FormattedString(L"%s%s.xconfig", sceneCollectionDir.Array(), sceneCollection.Array()));

	lea	ecx, DWORD PTR _sceneCollection$3[ebp]
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	lea	ecx, DWORD PTR _sceneCollectionDir$[ebp]
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	push	OFFSET $SG4294800510
	lea	eax, DWORD PTR _sceneCollectionPath$2[ebp]
	push	eax
	call	DWORD PTR __imp_?FormattedString@@YA?AVString@@PB_WZZ
	add	esp, 16					; 00000010H

; 1411 :             if (ofd.bDirectory || !OSFileExists(sceneCollectionPath) || sceneCollectionList.HasValue(sceneCollection)) continue;

	cmp	DWORD PTR _ofd$[ebp+520], 0
	jne	SHORT $LN1@GetSceneCo
	lea	ecx, DWORD PTR _sceneCollectionPath$2[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	call	DWORD PTR __imp_?OSFileExists@@YGHPB_W@Z
	test	eax, eax
	je	SHORT $LN1@GetSceneCo
	lea	ecx, DWORD PTR _sceneCollection$3[ebp]
	push	ecx
	mov	ecx, DWORD PTR _sceneCollectionList$[ebp]
	call	DWORD PTR __imp_?HasValue@?$List@VString@@@@QBEHABVString@@@Z
	test	eax, eax
	je	SHORT $LN2@GetSceneCo
$LN1@GetSceneCo:
	lea	ecx, DWORD PTR _sceneCollectionPath$2[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _sceneCollection$3[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	jmp	SHORT $LN4@GetSceneCo
$LN2@GetSceneCo:

; 1412 :             sceneCollectionList << sceneCollection;

	lea	edx, DWORD PTR _sceneCollection$3[ebp]
	push	edx
	mov	ecx, DWORD PTR _sceneCollectionList$[ebp]
	call	DWORD PTR __imp_??6StringList@@QAEAAV0@ABVString@@@Z

; 1413 :         } while (OSFindNextFile(hFind, ofd));

	lea	ecx, DWORD PTR _sceneCollectionPath$2[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _sceneCollection$3[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
$LN4@GetSceneCo:
	lea	eax, DWORD PTR _ofd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hFind$[ebp]
	push	ecx
	call	DWORD PTR __imp_?OSFindNextFile@@YGHPAXAAUOSFindData@@@Z
	test	eax, eax
	jne	$LN5@GetSceneCo

; 1414 :         OSFindClose(hFind);

	mov	edx, DWORD PTR _hFind$[ebp]
	push	edx
	call	DWORD PTR __imp_?OSFindClose@@YGXPAX@Z
$LN6@GetSceneCo:

; 1415 :     }
; 1416 : }

	lea	ecx, DWORD PTR _sceneCollectionDir$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strSceneCollectionWildcard$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSceneCollection@OBS@@SAXAAVStringList@@@Z ENDP	; OBS::GetSceneCollection
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.cpp
;	COMDAT ?UpdateNotificationAreaIcon@OBS@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?UpdateNotificationAreaIcon@OBS@@QAEHXZ PROC		; OBS::UpdateNotificationAreaIcon, COMDAT
; _this$ = ecx

; 2081 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2082 :     if (bNotificationAreaIcon)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+1324]
	test	ecx, ecx
	je	SHORT $LN1@UpdateNoti

; 2083 :         return ShowNotificationAreaIcon();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ShowNotificationAreaIcon@OBS@@QAEHXZ	; OBS::ShowNotificationAreaIcon
	jmp	SHORT $LN2@UpdateNoti
$LN1@UpdateNoti:

; 2084 :     return TRUE;

	mov	eax, 1
$LN2@UpdateNoti:

; 2085 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?UpdateNotificationAreaIcon@OBS@@QAEHXZ ENDP		; OBS::UpdateNotificationAreaIcon
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.cpp
;	COMDAT ?GetThreadHandles@OBS@@QAEXPAPAX0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_videoThread$ = 8					; size = 4
_encodeThread$ = 12					; size = 4
?GetThreadHandles@OBS@@QAEXPAPAX0@Z PROC		; OBS::GetThreadHandles, COMDAT
; _this$ = ecx

; 2192 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2193 :     if (hVideoThread)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+952], 0
	je	SHORT $LN2@GetThreadH

; 2194 :         *videoThread = hVideoThread;

	mov	ecx, DWORD PTR _videoThread$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+952]
	mov	DWORD PTR [ecx], eax
$LN2@GetThreadH:

; 2195 : 
; 2196 :     if (hEncodeThread)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+948], 0
	je	SHORT $LN3@GetThreadH

; 2197 :         *encodeThread = hEncodeThread;

	mov	edx, DWORD PTR _encodeThread$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+948]
	mov	DWORD PTR [edx], ecx
$LN3@GetThreadH:

; 2198 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetThreadHandles@OBS@@QAEXPAPAX0@Z ENDP		; OBS::GetThreadHandles
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.cpp
;	COMDAT ?ResizeWindow@OBS@@QAEX_N@Z
_TEXT	SEGMENT
_listControlHeight$ = -28				; size = 4
_xStart$ = -24						; size = 4
_yStart$ = -20						; size = 4
_flags$ = -16						; size = 4
_this$ = -12						; size = 4
_yPos$ = -8						; size = 4
_xPos$ = -4						; size = 4
_bRedrawRenderFrame$ = 8				; size = 1
?ResizeWindow@OBS@@QAEX_N@Z PROC			; OBS::ResizeWindow, COMDAT
; _this$ = ecx

; 1222 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 1223 :     //const int listControlHeight = totalControlAreaHeight - textControlHeight - controlHeight - controlPadding;
; 1224 : 
; 1225 :     ResizeRenderFrame(bRedrawRenderFrame);

	movzx	eax, BYTE PTR _bRedrawRenderFrame$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResizeRenderFrame@OBS@@AAEX_N@Z	; OBS::ResizeRenderFrame

; 1226 : 
; 1227 :     //-----------------------------------------------------
; 1228 : 
; 1229 :     DWORD flags = SWP_NOOWNERZORDER|SWP_SHOWWINDOW;

	mov	DWORD PTR _flags$[ebp], 576		; 00000240H

; 1230 : 
; 1231 :     int xStart = clientWidth/2 - totalControlAreaWidth/2 + (controlPadding/2 + 1);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+680]
	cdq
	sub	eax, edx
	sar	eax, 1
	sub	eax, 313				; 00000139H
	mov	DWORD PTR _xStart$[ebp], eax

; 1232 :     int yStart = clientHeight - totalBottomAreaHeight;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+684]
	sub	eax, 100				; 00000064H
	mov	DWORD PTR _yStart$[ebp], eax

; 1233 : 
; 1234 :     int xPos = xStart;

	mov	ecx, DWORD PTR _xStart$[ebp]
	mov	DWORD PTR _xPos$[ebp], ecx

; 1235 :     int yPos = yStart;

	mov	edx, DWORD PTR _yStart$[ebp]
	mov	DWORD PTR _yPos$[ebp], edx

; 1236 : 
; 1237 :     //-----------------------------------------------------
; 1238 : 
; 1239 : 	/*  HWND hwndTemp = GetDlgItem(hwndMain, ID_STATUS);
; 1240 : 
; 1241 : 
; 1242 : 	  SendMessage(hwndTemp, WM_SIZE, SIZE_RESTORED, 0);
; 1243 : 
; 1244 : 	  int parts[5];
; 1245 : 	  parts[4] = -1;
; 1246 : 	  parts[3] = clientWidth - 100;
; 1247 : 	  parts[2] = parts[3] - 60;
; 1248 : 	  parts[1] = parts[2] - 170;
; 1249 : 	  parts[0] = parts[1] - 170;
; 1250 : 	  SendMessage(hwndTemp, SB_SETPARTS, 5, (LPARAM)parts);
; 1251 : 
; 1252 : 	  int resetXPos = xStart + listControlWidth * 2;
; 1253 : 	  */
; 1254 : 	//---------------------------------------------------- -
; 1255 : 
; 1256 : 	//	UpdateRenderViewMessage();
; 1257 : 	//SetWindowPos(hwndRenderMessage, NULL, 0, renderFrameCtrlHeight / 2 - 10, renderFrameCtrlWidth, 50, flags & ~SWP_SHOWWINDOW);
; 1258 : 
; 1259 : 	//---------------------------------------------------- -
; 1260 : 
; 1261 : 	//	Don't waste time resizing invisible controls
; 1262 : 	if(!bPanelVisibleProcessed)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+691]
	test	ecx, ecx
	jne	SHORT $LN2@ResizeWind

; 1263 : 		ProcessPanelVisible(true);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ProcessPanelVisible@OBS@@AAEX_N@Z	; OBS::ProcessPanelVisible
$LN2@ResizeWind:

; 1264 : 	if (!bPanelVisible)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+690]
	test	eax, eax
	jne	SHORT $LN1@ResizeWind

; 1265 : 		return;

	jmp	$LN3@ResizeWind
$LN1@ResizeWind:

; 1266 : 
; 1267 : 	//xPos = resetXPos;
; 1268 : 	yPos = yStart;

	mov	ecx, DWORD PTR _yStart$[ebp]
	mov	DWORD PTR _yPos$[ebp], ecx

; 1269 : 	
; 1270 :     SetWindowPos(GetDlgItem(hwndMain, ID_MICVOLUME), NULL, 700,501,100,32, flags);

	mov	edx, DWORD PTR _flags$[ebp]
	push	edx
	push	32					; 00000020H
	push	100					; 00000064H
	push	501					; 000001f5H
	push	700					; 000002bcH
	push	0
	push	5007					; 0000138fH
	mov	eax, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	eax
	call	DWORD PTR __imp__GetDlgItem@8
	push	eax
	call	DWORD PTR __imp__SetWindowPos@28

; 1271 :     xPos += controlWidth;

	mov	ecx, DWORD PTR _xPos$[ebp]
	add	ecx, 145				; 00000091H
	mov	DWORD PTR _xPos$[ebp], ecx

; 1272 : 
; 1273 :     SetWindowPos(GetDlgItem(hwndMain, ID_DESKTOPVOLUME), NULL, 700, 535, 100, 32, flags);

	mov	edx, DWORD PTR _flags$[ebp]
	push	edx
	push	32					; 00000020H
	push	100					; 00000064H
	push	535					; 00000217H
	push	700					; 000002bcH
	push	0
	push	5006					; 0000138eH
	mov	eax, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	eax
	call	DWORD PTR __imp__GetDlgItem@8
	push	eax
	call	DWORD PTR __imp__SetWindowPos@28

; 1274 :     xPos += controlWidth;

	mov	ecx, DWORD PTR _xPos$[ebp]
	add	ecx, 145				; 00000091H
	mov	DWORD PTR _xPos$[ebp], ecx

; 1275 : 
; 1276 :     yPos += volControlHeight+controlPadding;

	mov	edx, DWORD PTR _yPos$[ebp]
	add	edx, 35					; 00000023H
	mov	DWORD PTR _yPos$[ebp], edx

; 1277 : 
; 1278 :     ////-----------------------------------------------------
; 1279 : 
; 1280 :     //xPos = resetXPos;
; 1281 : 
; 1282 :     ////SetWindowPos(GetDlgItem(hwndMain, ID_MICVOLUMEMETER), NULL, 200,53,100,10, flags);
; 1283 :     ////xPos += controlWidth;
; 1284 : 
; 1285 :     ////SetWindowPos(GetDlgItem(hwndMain, ID_DESKTOPVOLUMEMETER), NULL, 400,53,100,10,flags);
; 1286 :     //xPos += controlWidth;
; 1287 : 
; 1288 :     //yPos += volMeterHeight+controlPadding;
; 1289 : 
; 1290 :     ////-----------------------------------------------------
; 1291 : 
; 1292 :     //xPos = resetXPos;
; 1293 : 
; 1294 :     //SetWindowPos(GetDlgItem(hwndMain, ID_SETTINGS), NULL, xPos, yPos, controlWidth-controlPadding, controlHeight, flags);
; 1295 :     //xPos += controlWidth;
; 1296 : 
; 1297 :     //SetWindowPos(GetDlgItem(hwndMain, ID_STARTSTOP), NULL, xPos, yPos, controlWidth-controlPadding, controlHeight, flags);
; 1298 :     //xPos += controlWidth;
; 1299 : 
; 1300 :     //yPos += controlHeight+controlPadding;
; 1301 : 
; 1302 :     ////-----------------------------------------------------
; 1303 : 
; 1304 :     //xPos = resetXPos;
; 1305 : 
; 1306 :     //SetWindowPos(GetDlgItem(hwndMain, ID_SCENEEDITOR), NULL, xPos, yPos, controlWidth-controlPadding, controlHeight, flags);
; 1307 :     //xPos += controlWidth;
; 1308 : 
; 1309 :     //SetWindowPos(GetDlgItem(hwndMain, ID_TOGGLERECORDING), NULL, xPos, yPos, controlWidth-controlPadding, controlHeight, flags);
; 1310 :     //xPos += controlWidth;
; 1311 : 
; 1312 :     //yPos += controlHeight+controlPadding;
; 1313 : 
; 1314 :     ////-----------------------------------------------------
; 1315 : 
; 1316 :     //xPos = resetXPos;
; 1317 : 
; 1318 :     //SetWindowPos(GetDlgItem(hwndMain, ID_GLOBALSOURCES), NULL, xPos, yPos, controlWidth-controlPadding, controlHeight, flags);
; 1319 :     //xPos += controlWidth;
; 1320 : 
; 1321 :     //SetWindowPos(GetDlgItem(hwndMain, ID_TESTSTREAM), NULL, xPos, yPos, controlWidth-controlPadding, controlHeight, flags);
; 1322 :     //xPos += controlWidth;
; 1323 : 
; 1324 :     //yPos += controlHeight+controlPadding;
; 1325 : 
; 1326 :     ////-----------------------------------------------------
; 1327 : 
; 1328 :     //xPos = resetXPos;
; 1329 : 
; 1330 :     //SetWindowPos(GetDlgItem(hwndMain, ID_PLUGINS), NULL, xPos, yPos, controlWidth-controlPadding, controlHeight, flags);
; 1331 :     //xPos += controlWidth;
; 1332 : 
; 1333 :     //UpdateDashboardButton();
; 1334 :     //xPos += controlWidth;
; 1335 : 
; 1336 :     //yPos += controlHeight;
; 1337 : 
; 1338 :     //-----------------------------------------------------
; 1339 : 
; 1340 :     int listControlHeight = yPos-yStart-textControlHeight;

	mov	eax, DWORD PTR _yPos$[ebp]
	sub	eax, DWORD PTR _yStart$[ebp]
	sub	eax, 16					; 00000010H
	mov	DWORD PTR _listControlHeight$[ebp], eax

; 1341 : 
; 1342 :     xPos  = xStart;

	mov	ecx, DWORD PTR _xStart$[ebp]
	mov	DWORD PTR _xPos$[ebp], ecx

; 1343 :     yPos  = yStart;

	mov	edx, DWORD PTR _yStart$[ebp]
	mov	DWORD PTR _yPos$[ebp], edx

; 1344 : 
; 1345 : 
; 1346 : 
; 1347 : 
; 1348 : 	
; 1349 : 	SetWindowPos(GetDlgItem(hwndMain, ID_SCENES_TEXT), NULL, 800+7,3,191,25, flags);

	mov	eax, DWORD PTR _flags$[ebp]
	push	eax
	push	25					; 00000019H
	push	191					; 000000bfH
	push	3
	push	807					; 00000327H
	push	0
	push	5012					; 00001394H
	mov	ecx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	ecx
	call	DWORD PTR __imp__GetDlgItem@8
	push	eax
	call	DWORD PTR __imp__SetWindowPos@28

; 1350 :     xPos += listControlWidth;

	mov	edx, DWORD PTR _xPos$[ebp]
	add	edx, 170				; 000000aaH
	mov	DWORD PTR _xPos$[ebp], edx

; 1351 : 
; 1352 : 	SetWindowPos(GetDlgItem(hwndMain, ID_SOURCES_TEXT), NULL, 800+7,280,191,25, flags);

	mov	eax, DWORD PTR _flags$[ebp]
	push	eax
	push	25					; 00000019H
	push	191					; 000000bfH
	push	280					; 00000118H
	push	807					; 00000327H
	push	0
	push	5014					; 00001396H
	mov	ecx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	ecx
	call	DWORD PTR __imp__GetDlgItem@8
	push	eax
	call	DWORD PTR __imp__SetWindowPos@28

; 1353 :     xPos += listControlWidth;

	mov	edx, DWORD PTR _xPos$[ebp]
	add	edx, 170				; 000000aaH
	mov	DWORD PTR _xPos$[ebp], edx

; 1354 : 
; 1355 :     yPos += textControlHeight;

	mov	eax, DWORD PTR _yPos$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _yPos$[ebp], eax

; 1356 :     xPos  = xStart;

	mov	ecx, DWORD PTR _xStart$[ebp]
	mov	DWORD PTR _xPos$[ebp], ecx

; 1357 : 
; 1358 :     //-----------------------------------------------------
; 1359 : 
; 1360 : 
; 1361 : 
; 1362 : 	SetWindowPos(GetDlgItem(hwndMain, ID_SCENES), NULL, 800 + 6/*xPos*/, 29/*yPos*/, 191, 250, flags);

	mov	edx, DWORD PTR _flags$[ebp]
	push	edx
	push	250					; 000000faH
	push	191					; 000000bfH
	push	29					; 0000001dH
	push	806					; 00000326H
	push	0
	push	5011					; 00001393H
	mov	eax, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	eax
	call	DWORD PTR __imp__GetDlgItem@8
	push	eax
	call	DWORD PTR __imp__SetWindowPos@28

; 1363 :     xPos += listControlWidth;

	mov	ecx, DWORD PTR _xPos$[ebp]
	add	ecx, 170				; 000000aaH
	mov	DWORD PTR _xPos$[ebp], ecx

; 1364 : 
; 1365 : 	SetWindowPos(GetDlgItem(hwndMain, ID_SOURCES), NULL, 800 + 6, 306, 191, 270, flags);

	mov	edx, DWORD PTR _flags$[ebp]
	push	edx
	push	270					; 0000010eH
	push	191					; 000000bfH
	push	306					; 00000132H
	push	806					; 00000326H
	push	0
	push	5013					; 00001395H
	mov	eax, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	eax
	call	DWORD PTR __imp__GetDlgItem@8
	push	eax
	call	DWORD PTR __imp__SetWindowPos@28

; 1366 :     xPos += listControlWidth;

	mov	ecx, DWORD PTR _xPos$[ebp]
	add	ecx, 170				; 000000aaH
	mov	DWORD PTR _xPos$[ebp], ecx
$LN3@ResizeWind:

; 1367 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?ResizeWindow@OBS@@QAEX_N@Z ENDP			; OBS::ResizeWindow
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.cpp
;	COMDAT ?ConfigureStreamButtons@OBS@@AAEXXZ
_TEXT	SEGMENT
tv150 = -16						; size = 4
tv135 = -12						; size = 4
tv88 = -8						; size = 4
_this$ = -4						; size = 4
?ConfigureStreamButtons@OBS@@AAEXXZ PROC		; OBS::ConfigureStreamButtons, COMDAT
; _this$ = ecx

; 1439 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1440 :     if (bShuttingDown) return;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+1412]
	test	ecx, ecx
	je	SHORT $LN2@ConfigureS
	jmp	$LN3@ConfigureS
$LN2@ConfigureS:

; 1441 : 
; 1442 :     if (GetWindowThreadProcessId(hwndMain, nullptr) != GetCurrentThreadId())

	push	0
	mov	edx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	edx
	call	DWORD PTR __imp__GetWindowThreadProcessId@8
	mov	esi, eax
	call	DWORD PTR __imp__GetCurrentThreadId@0
	cmp	esi, eax
	je	SHORT $LN1@ConfigureS

; 1443 :         return PostConfigureStreamButtons();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?PostConfigureStreamButtons@OBS@@AAEXXZ	; OBS::PostConfigureStreamButtons
	jmp	$LN3@ConfigureS
$LN1@ConfigureS:

; 1444 : 
; 1445 :     RefreshStreamButtons();

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RefreshStreamButtons@OBS@@AAEX_N@Z	; OBS::RefreshStreamButtons

; 1446 :     SetWindowText(GetDlgItem(hwndMain, ID_STARTSTOP), (bStreaming && !bTestStream) ? Str("MainWindow.StopStream") : Str("MainWindow.StartStream"));

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+627]
	test	ecx, ecx
	je	SHORT $LN5@ConfigureS
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+620]
	test	eax, eax
	jne	SHORT $LN5@ConfigureS
	push	OFFSET $SG4294800507
	mov	ecx, DWORD PTR __imp_?locale@@3PAVLocaleStringLookup@@A
	mov	ecx, DWORD PTR [ecx]
	call	DWORD PTR __imp_?LookupString@LocaleStringLookup@@QAEPB_WPB_W@Z
	mov	DWORD PTR tv88[ebp], eax
	jmp	SHORT $LN6@ConfigureS
$LN5@ConfigureS:
	push	OFFSET $SG4294800506
	mov	edx, DWORD PTR __imp_?locale@@3PAVLocaleStringLookup@@A
	mov	ecx, DWORD PTR [edx]
	call	DWORD PTR __imp_?LookupString@LocaleStringLookup@@QAEPB_WPB_W@Z
	mov	DWORD PTR tv88[ebp], eax
$LN6@ConfigureS:
	mov	eax, DWORD PTR tv88[ebp]
	push	eax
	push	5003					; 0000138bH
	mov	ecx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	ecx
	call	DWORD PTR __imp__GetDlgItem@8
	push	eax
	call	DWORD PTR __imp__SetWindowTextW@8

; 1447 :     SetWindowText(GetDlgItem(hwndMain, ID_TOGGLERECORDING), bRecording ? Str("MainWindow.StopRecording") : Str("MainWindow.StartRecording"));

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+623]
	test	eax, eax
	je	SHORT $LN7@ConfigureS
	push	OFFSET $SG4294800505
	mov	ecx, DWORD PTR __imp_?locale@@3PAVLocaleStringLookup@@A
	mov	ecx, DWORD PTR [ecx]
	call	DWORD PTR __imp_?LookupString@LocaleStringLookup@@QAEPB_WPB_W@Z
	mov	DWORD PTR tv135[ebp], eax
	jmp	SHORT $LN8@ConfigureS
$LN7@ConfigureS:
	push	OFFSET $SG4294800504
	mov	edx, DWORD PTR __imp_?locale@@3PAVLocaleStringLookup@@A
	mov	ecx, DWORD PTR [edx]
	call	DWORD PTR __imp_?LookupString@LocaleStringLookup@@QAEPB_WPB_W@Z
	mov	DWORD PTR tv135[ebp], eax
$LN8@ConfigureS:
	mov	eax, DWORD PTR tv135[ebp]
	push	eax
	push	5002					; 0000138aH
	mov	ecx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	ecx
	call	DWORD PTR __imp__GetDlgItem@8
	push	eax
	call	DWORD PTR __imp__SetWindowTextW@8

; 1448 :     SetWindowText(GetDlgItem(hwndMain, ID_TESTSTREAM), bTestStream ? Str("MainWindow.StopTest") : Str("MainWindow.TestStream"));

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+620]
	test	eax, eax
	je	SHORT $LN9@ConfigureS
	push	OFFSET $SG4294800503
	mov	ecx, DWORD PTR __imp_?locale@@3PAVLocaleStringLookup@@A
	mov	ecx, DWORD PTR [ecx]
	call	DWORD PTR __imp_?LookupString@LocaleStringLookup@@QAEPB_WPB_W@Z
	mov	DWORD PTR tv150[ebp], eax
	jmp	SHORT $LN10@ConfigureS
$LN9@ConfigureS:
	push	OFFSET $SG4294800502
	mov	edx, DWORD PTR __imp_?locale@@3PAVLocaleStringLookup@@A
	mov	ecx, DWORD PTR [edx]
	call	DWORD PTR __imp_?LookupString@LocaleStringLookup@@QAEPB_WPB_W@Z
	mov	DWORD PTR tv150[ebp], eax
$LN10@ConfigureS:
	mov	eax, DWORD PTR tv150[ebp]
	push	eax
	push	5015					; 00001397H
	mov	ecx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	ecx
	call	DWORD PTR __imp__GetDlgItem@8
	push	eax
	call	DWORD PTR __imp__SetWindowTextW@8
$LN3@ConfigureS:

; 1449 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?ConfigureStreamButtons@OBS@@AAEXXZ ENDP		; OBS::ConfigureStreamButtons
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.cpp
;	COMDAT ??0OBS@@QAE@XZ
_TEXT	SEGMENT
_column$ = -936						; size = 44
$T1 = -892						; size = 8
$T2 = -884						; size = 8
$T3 = -876						; size = 8
$T4 = -868						; size = 8
$T5 = -860						; size = 8
$T6 = -852						; size = 8
$T7 = -844						; size = 8
$T8 = -836						; size = 8
_ecce$ = -828						; size = 8
_strScene$9 = -820					; size = 8
_systemTime$ = -812					; size = 8
_hotkeyInfo$10 = -804					; size = 12
_cy$ = -792						; size = 4
_cx$ = -788						; size = 4
tv1976 = -784						; size = 8
_scene$11 = -776					; size = 4
_scene$12 = -772					; size = 4
_lastUpdateTime$ = -768					; size = 8
_wc$ = -760						; size = 40
_strScenesConfig$ = -720				; size = 8
_logSizeX$ = -712					; size = 4
tv1507 = -708						; size = 4
tv1416 = -704						; size = 4
tv628 = -700						; size = 4
tv1112 = -696						; size = 4
_logSizeY$ = -692					; size = 4
tv619 = -688						; size = 4
tv1483 = -684						; size = 4
_maxCY$ = -680						; size = 4
_maxCX$ = -676						; size = 4
_hwndSources$ = -672					; size = 4
tv759 = -668						; size = 4
tv1527 = -664						; size = 4
tv1516 = -660						; size = 4
_scene$13 = -656					; size = 4
_posX$ = -652						; size = 4
_id$14 = -648						; size = 4
_fullscreenY$ = -644					; size = 4
_logPosY$ = -640					; size = 4
$T15 = -633						; size = 1
_posY$ = -632						; size = 4
_fullscreenX$ = -628					; size = 4
_logPosX$ = -624					; size = 4
_hotkey$16 = -620					; size = 4
_hFind$17 = -616					; size = 4
_i$18 = -612						; size = 4
_collection$ = -608					; size = 8
_i$19 = -600						; size = 4
_x$ = -596						; size = 4
_y$ = -592						; size = 4
_currentTime$ = -588					; size = 8
_scenes$ = -580						; size = 4
_numScenes$ = -576					; size = 4
_i$20 = -572						; size = 4
$T21 = -565						; size = 1
_i$22 = -564						; size = 4
_bInsideMonitors$ = -557				; size = 1
_hwndTemp$ = -556					; size = 4
_this$ = -552						; size = 4
_client$ = -548						; size = 16
_ofd$23 = -532						; size = 528
__$ArrayPad$ = -4					; size = 4
??0OBS@@QAE@XZ PROC					; OBS::OBS, COMDAT
; _this$ = ecx

; 261  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 936				; 000003a8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7OBS@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 76					; 0000004cH
	call	??0?$unique_ptr@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@@std@@QAE@XZ ; std::unique_ptr<NetworkStream,std::default_delete<NetworkStream> >::unique_ptr<NetworkStream,std::default_delete<NetworkStream> >
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 80					; 00000050H
	call	??0StopInfo@OBS@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 120				; 00000078H
	call	??0?$List@PAVAudioSource@@@@QAE@XZ	; List<AudioSource *>::List<AudioSource *>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 156				; 0000009cH
	call	??0?$List@UMonitorInfo@@@@QAE@XZ	; List<MonitorInfo>::List<MonitorInfo>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 168				; 000000a8H
	call	DWORD PTR __imp_??0XConfig@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 180				; 000000b4H
	call	DWORD PTR __imp_??0XConfig@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 192				; 000000c0H
	call	DWORD PTR __imp_??0XConfig@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 204				; 000000ccH
	call	??0?$List@USceneHotkeyInfo@@@@QAE@XZ	; List<SceneHotkeyInfo>::List<SceneHotkeyInfo>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 232				; 000000e8H
	call	??0?$List@PAVSettingsPane@@@@QAE@XZ	; List<SettingsPane *>::List<SettingsPane *>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 252				; 000000fcH
	call	??0COBSButton@@QAE@XZ			; COBSButton::COBSButton
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 292				; 00000124H
	call	??0COBSButton@@QAE@XZ			; COBSButton::COBSButton
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 332				; 0000014cH
	call	??0COBSButton@@QAE@XZ			; COBSButton::COBSButton
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 372				; 00000174H
	call	??0COBSButton@@QAE@XZ			; COBSButton::COBSButton
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 412				; 0000019cH
	call	??0COBSButton@@QAE@XZ			; COBSButton::COBSButton
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 452				; 000001c4H
	call	??0COBSButton@@QAE@XZ			; COBSButton::COBSButton
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 492				; 000001ecH
	call	??0COBSButton@@QAE@XZ			; COBSButton::COBSButton
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 532				; 00000214H
	call	??0COBSButton@@QAE@XZ			; COBSButton::COBSButton
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 572				; 0000023cH
	call	??0COBSButton@@QAE@XZ			; COBSButton::COBSButton
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 612				; 00000264H
	call	DWORD PTR __imp_??0String@@QAE@XZ

; 779  :     
; 780  :     //-----------------------------------------------------
; 781  :     // Add built-in settings panes   
; 782  : 

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+628], 1

; 261  : {

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 752				; 000002f0H
	call	DWORD PTR __imp_??0Vect2@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 760				; 000002f8H
	call	DWORD PTR __imp_??0Vect2@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 844				; 0000034cH
	call	??0?$map@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@QAE@XZ ; std::map<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::map<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 960				; 000003c0H
	call	??0?$List@UVideoSegment@@@@QAE@XZ	; List<VideoSegment>::List<VideoSegment>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 968				; 000003c8H
	call	??0?$CircularList@I@@QAE@XZ		; CircularList<unsigned int>::CircularList<unsigned int>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1028				; 00000404H
	call	??0?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@QAE@XZ ; std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> >::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> >
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1032				; 00000408H
	call	??0StopInfo@OBS@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1064				; 00000428H
	call	??0?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@QAE@XZ ; std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> >::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> >
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1072				; 00000430H
	call	??0StopInfo@OBS@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1128				; 00000468H
	call	??0?$CircularList@_K@@QAE@XZ		; CircularList<unsigned __int64>::CircularList<unsigned __int64>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1208				; 000004b8H
	call	??0?$List@UFrameAudio@@@@QAE@XZ		; List<FrameAudio>::List<FrameAudio>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1328				; 00000530H
	call	DWORD PTR __imp_??0String@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1336				; 00000538H
	call	DWORD PTR __imp_??0String@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1344				; 00000540H
	call	??0?$List@UIconInfo@@@@QAE@XZ		; List<IconInfo>::List<IconInfo>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1352				; 00000548H
	call	??0?$List@UFontInfo@@@@QAE@XZ		; List<FontInfo>::List<FontInfo>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1360				; 00000550H
	call	??0?$List@UClassInfo@@@@QAE@XZ		; List<ClassInfo>::List<ClassInfo>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1368				; 00000558H
	call	??0?$List@UClassInfo@@@@QAE@XZ		; List<ClassInfo>::List<ClassInfo>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1376				; 00000560H
	call	??0?$List@UGlobalSourceInfo@@@@QAE@XZ	; List<GlobalSourceInfo>::List<GlobalSourceInfo>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1388				; 0000056cH
	call	??0?$List@UStreamInfo@@@@QAE@XZ		; List<StreamInfo>::List<StreamInfo>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1404				; 0000057cH
	call	??0?$List@UPluginInfo@@@@QAE@XZ		; List<PluginInfo>::List<PluginInfo>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1416				; 00000588H
	call	??0PendingStreams@OBS@@QAE@XZ		; OBS::PendingStreams::PendingStreams

; 262  :     App = this;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR ?App@@3PAVOBS@@A, edx		; App

; 263  : 
; 264  :     performTransition = true;        //Default to true and don't set the conf. 

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+44], 1

; 265  :                                      //We don't want to let plugins disable standard behavior permanently.
; 266  :     hSceneMutex = OSCreateMutex();

	call	DWORD PTR __imp_?OSCreateMutex@@YGPAXXZ
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+956], eax

; 267  :     hAuxAudioMutex = OSCreateMutex();

	call	DWORD PTR __imp_?OSCreateMutex@@YGPAXXZ
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1228], eax

; 268  :     hVideoEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

	push	0
	push	0
	push	0
	push	0
	call	DWORD PTR __imp__CreateEventW@16
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1124], eax

; 269  : 	//
; 270  :     monitors.Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 156				; 0000009cH
	call	?Clear@?$List@UMonitorInfo@@@@QAEXXZ	; List<MonitorInfo>::Clear

; 271  :     EnumDisplayMonitors(NULL, NULL, (MONITORENUMPROC)MonitorInfoEnumProc, (LPARAM)&monitors);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 156				; 0000009cH
	push	edx
	push	OFFSET ?MonitorInfoEnumProc@@YGHPAUHMONITOR__@@PAUHDC__@@PAUtagRECT@@AAV?$List@UMonitorInfo@@@@@Z ; MonitorInfoEnumProc
	push	0
	push	0
	call	DWORD PTR __imp__EnumDisplayMonitors@16

; 272  : 
; 273  :     INITCOMMONCONTROLSEX ecce;
; 274  :     ecce.dwSize = sizeof(ecce);

	mov	DWORD PTR _ecce$[ebp], 8

; 275  :     ecce.dwICC = ICC_STANDARD_CLASSES;

	mov	DWORD PTR _ecce$[ebp+4], 16384		; 00004000H

; 276  :     if(!InitCommonControlsEx(&ecce))

	lea	eax, DWORD PTR _ecce$[ebp]
	push	eax
	call	_IsolationAwareInitCommonControlsEx@4
	test	eax, eax
	jne	SHORT $LN48@OBS

; 277  :         CrashError(TEXT("Could not initalize common shell controls"));

	push	OFFSET $SG4294800673
	call	DWORD PTR __imp_?CrashError@@YAXPB_WZZ
$LN48@OBS:

; 278  : 
; 279  :     InitHotkeyExControl(hinstMain);

	mov	ecx, DWORD PTR ?hinstMain@@3PAUHINSTANCE__@@A ; hinstMain
	push	ecx
	call	DWORD PTR __imp_?InitHotkeyExControl@@YAXPAUHINSTANCE__@@@Z
	add	esp, 4

; 280  :     InitColorControl(hinstMain);

	mov	edx, DWORD PTR ?hinstMain@@3PAUHINSTANCE__@@A ; hinstMain
	push	edx
	call	DWORD PTR __imp_?InitColorControl@@YAXPAUHINSTANCE__@@@Z
	add	esp, 4

; 281  :     InitVolumeControl(hinstMain);

	mov	eax, DWORD PTR ?hinstMain@@3PAUHINSTANCE__@@A ; hinstMain
	push	eax
	call	DWORD PTR __imp_?InitVolumeControl@@YAXPAUHINSTANCE__@@@Z
	add	esp, 4

; 282  :     InitVolumeMeter(hinstMain);

	mov	ecx, DWORD PTR ?hinstMain@@3PAUHINSTANCE__@@A ; hinstMain
	push	ecx
	call	DWORD PTR __imp_?InitVolumeMeter@@YAXPAUHINSTANCE__@@@Z
	add	esp, 4

; 283  : 
; 284  :     // still need this here for API
; 285  :     strLanguage = GlobalConfig->GetString(TEXT("General"), TEXT("Language"), TEXT("en"));

	push	OFFSET $SG4294800672
	push	OFFSET $SG4294800671
	push	OFFSET $SG4294800670
	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	mov	ecx, DWORD PTR ?GlobalConfig@@3PAVConfigFile@@A ; GlobalConfig
	call	DWORD PTR __imp_?GetString@ConfigFile@@QAE?AVString@@PB_W00@Z
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 612				; 00000264H
	call	DWORD PTR __imp_??4String@@QAEAAV0@ABV0@@Z
	lea	ecx, DWORD PTR $T4[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 286  : 
; 287  :     //-----------------------------------------------------
; 288  :     // load classes
; 289  : 
; 290  :     RegisterSceneClass(TEXT("Scene"), Str("Scene"), (OBSCREATEPROC)CreateNormalScene, NULL, false);

	push	0
	push	0
	push	OFFSET ?CreateNormalScene@@YGPAVScene@@PAVXElement@@@Z ; CreateNormalScene
	push	OFFSET $SG4294800669
	mov	eax, DWORD PTR __imp_?locale@@3PAVLocaleStringLookup@@A
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR __imp_?LookupString@LocaleStringLookup@@QAEPB_WPB_W@Z
	push	eax
	push	OFFSET $SG4294800668
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RegisterSceneClass@OBS@@UAEXPB_W0P6GPAXPAVXElement@@@ZP6G_N1_N@Z3@Z ; OBS::RegisterSceneClass

; 291  :     RegisterImageSourceClass(TEXT("DesktopImageSource"), Str("Sources.SoftwareCaptureSource"), (OBSCREATEPROC)CreateDesktopSource, (OBSCONFIGPROC)ConfigureDesktopSource, true);

	push	1
	push	OFFSET ?ConfigureDesktopSource@@YG_NPAVXElement@@_N@Z ; ConfigureDesktopSource
	push	OFFSET ?CreateDesktopSource@@YGPAVImageSource@@PAVXElement@@@Z ; CreateDesktopSource
	push	OFFSET $SG4294800667
	mov	ecx, DWORD PTR __imp_?locale@@3PAVLocaleStringLookup@@A
	mov	ecx, DWORD PTR [ecx]
	call	DWORD PTR __imp_?LookupString@LocaleStringLookup@@QAEPB_WPB_W@Z
	push	eax
	push	OFFSET $SG4294800666
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RegisterImageSourceClass@OBS@@UAEXPB_W0P6GPAXPAVXElement@@@ZP6G_N1_N@Z3@Z ; OBS::RegisterImageSourceClass

; 292  :     RegisterImageSourceClass(TEXT("WindowCaptureSource"), Str("Sources.SoftwareCaptureSource.WindowCapture"), (OBSCREATEPROC)CreateDesktopSource, (OBSCONFIGPROC)ConfigureWindowCaptureSource, false);

	push	0
	push	OFFSET ?ConfigureWindowCaptureSource@@YG_NPAVXElement@@_N@Z ; ConfigureWindowCaptureSource
	push	OFFSET ?CreateDesktopSource@@YGPAVImageSource@@PAVXElement@@@Z ; CreateDesktopSource
	push	OFFSET $SG4294800665
	mov	edx, DWORD PTR __imp_?locale@@3PAVLocaleStringLookup@@A
	mov	ecx, DWORD PTR [edx]
	call	DWORD PTR __imp_?LookupString@LocaleStringLookup@@QAEPB_WPB_W@Z
	push	eax
	push	OFFSET $SG4294800664
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RegisterImageSourceClass@OBS@@UAEXPB_W0P6GPAXPAVXElement@@@ZP6G_N1_N@Z3@Z ; OBS::RegisterImageSourceClass

; 293  :     RegisterImageSourceClass(TEXT("MonitorCaptureSource"), Str("Sources.SoftwareCaptureSource.MonitorCapture"), (OBSCREATEPROC)CreateDesktopSource, (OBSCONFIGPROC)ConfigureMonitorCaptureSource, false);

	push	0
	push	OFFSET ?ConfigureMonitorCaptureSource@@YG_NPAVXElement@@_N@Z ; ConfigureMonitorCaptureSource
	push	OFFSET ?CreateDesktopSource@@YGPAVImageSource@@PAVXElement@@@Z ; CreateDesktopSource
	push	OFFSET $SG4294800663
	mov	eax, DWORD PTR __imp_?locale@@3PAVLocaleStringLookup@@A
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR __imp_?LookupString@LocaleStringLookup@@QAEPB_WPB_W@Z
	push	eax
	push	OFFSET $SG4294800662
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RegisterImageSourceClass@OBS@@UAEXPB_W0P6GPAXPAVXElement@@@ZP6G_N1_N@Z3@Z ; OBS::RegisterImageSourceClass

; 294  :     RegisterImageSourceClass(TEXT("BitmapImageSource"), Str("Sources.BitmapSource"), (OBSCREATEPROC)CreateBitmapSource, (OBSCONFIGPROC)ConfigureBitmapSource, false);

	push	0
	push	OFFSET ?ConfigureBitmapSource@@YG_NPAVXElement@@_N@Z ; ConfigureBitmapSource
	push	OFFSET ?CreateBitmapSource@@YGPAVImageSource@@PAVXElement@@@Z ; CreateBitmapSource
	push	OFFSET $SG4294800661
	mov	ecx, DWORD PTR __imp_?locale@@3PAVLocaleStringLookup@@A
	mov	ecx, DWORD PTR [ecx]
	call	DWORD PTR __imp_?LookupString@LocaleStringLookup@@QAEPB_WPB_W@Z
	push	eax
	push	OFFSET $SG4294800660
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RegisterImageSourceClass@OBS@@UAEXPB_W0P6GPAXPAVXElement@@@ZP6G_N1_N@Z3@Z ; OBS::RegisterImageSourceClass

; 295  :     RegisterImageSourceClass(TEXT("BitmapTransitionSource"), Str("Sources.TransitionSource"), (OBSCREATEPROC)CreateBitmapTransitionSource, (OBSCONFIGPROC)ConfigureBitmapTransitionSource, false);

	push	0
	push	OFFSET ?ConfigureBitmapTransitionSource@@YG_NPAVXElement@@_N@Z ; ConfigureBitmapTransitionSource
	push	OFFSET ?CreateBitmapTransitionSource@@YGPAVImageSource@@PAVXElement@@@Z ; CreateBitmapTransitionSource
	push	OFFSET $SG4294800659
	mov	edx, DWORD PTR __imp_?locale@@3PAVLocaleStringLookup@@A
	mov	ecx, DWORD PTR [edx]
	call	DWORD PTR __imp_?LookupString@LocaleStringLookup@@QAEPB_WPB_W@Z
	push	eax
	push	OFFSET $SG4294800658
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RegisterImageSourceClass@OBS@@UAEXPB_W0P6GPAXPAVXElement@@@ZP6G_N1_N@Z3@Z ; OBS::RegisterImageSourceClass

; 296  :     RegisterImageSourceClass(TEXT("GlobalSource"), Str("Sources.GlobalSource"), (OBSCREATEPROC)CreateGlobalSource, (OBSCONFIGPROC)OBS::ConfigGlobalSource, false);

	push	0
	push	OFFSET ?ConfigGlobalSource@OBS@@CG_NPAVXElement@@_N@Z ; OBS::ConfigGlobalSource
	push	OFFSET ?CreateGlobalSource@@YGPAVImageSource@@PAVXElement@@@Z ; CreateGlobalSource
	push	OFFSET $SG4294800657
	mov	eax, DWORD PTR __imp_?locale@@3PAVLocaleStringLookup@@A
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR __imp_?LookupString@LocaleStringLookup@@QAEPB_WPB_W@Z
	push	eax
	push	OFFSET $SG4294800656
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RegisterImageSourceClass@OBS@@UAEXPB_W0P6GPAXPAVXElement@@@ZP6G_N1_N@Z3@Z ; OBS::RegisterImageSourceClass

; 297  :     RegisterImageSourceClass(TEXT("TextSource"), Str("Sources.TextSource"), (OBSCREATEPROC)CreateTextSource, (OBSCONFIGPROC)ConfigureTextSource, false);

	push	0
	push	OFFSET ?ConfigureTextSource@@YG_NPAVXElement@@_N@Z ; ConfigureTextSource
	push	OFFSET ?CreateTextSource@@YGPAVImageSource@@PAVXElement@@@Z ; CreateTextSource
	push	OFFSET $SG4294800655
	mov	ecx, DWORD PTR __imp_?locale@@3PAVLocaleStringLookup@@A
	mov	ecx, DWORD PTR [ecx]
	call	DWORD PTR __imp_?LookupString@LocaleStringLookup@@QAEPB_WPB_W@Z
	push	eax
	push	OFFSET $SG4294800654
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RegisterImageSourceClass@OBS@@UAEXPB_W0P6GPAXPAVXElement@@@ZP6G_N1_N@Z3@Z ; OBS::RegisterImageSourceClass

; 298  : 
; 299  :     //-----------------------------------------------------
; 300  :     // render frame class
; 301  :     WNDCLASS wc;
; 302  :     zero(&wc, sizeof(wc));

	push	40					; 00000028H
	lea	edx, DWORD PTR _wc$[ebp]
	push	edx
	call	?zero@@YGXPAXI@Z			; zero

; 303  :     wc.hInstance = hinstMain;

	mov	eax, DWORD PTR ?hinstMain@@3PAUHINSTANCE__@@A ; hinstMain
	mov	DWORD PTR _wc$[ebp+16], eax

; 304  :     wc.hCursor = LoadCursor(NULL, IDC_ARROW);

	push	32512					; 00007f00H
	push	0
	call	DWORD PTR __imp__LoadCursorW@8
	mov	DWORD PTR _wc$[ebp+24], eax

; 305  : 
; 306  :     wc.lpszClassName = OBS_RENDERFRAME_CLASS;

	mov	DWORD PTR _wc$[ebp+36], OFFSET $SG4294800653

; 307  :     wc.lpfnWndProc = (WNDPROC)OBS::RenderFrameProc;

	mov	DWORD PTR _wc$[ebp+4], OFFSET ?RenderFrameProc@OBS@@CGJPAUHWND__@@IIJ@Z ; OBS::RenderFrameProc

; 308  :    // wc.hbrBackground = GetSysColorBrush(COLOR_BTNFACE);
; 309  : 	// modify by songmm
; 310  : 	wc.hbrBackground = (HBRUSH)(GetStockObject(GRAY_BRUSH));

	push	2
	call	DWORD PTR __imp__GetStockObject@4
	mov	DWORD PTR _wc$[ebp+28], eax

; 311  : 	
; 312  :     if(!RegisterClass(&wc))

	lea	ecx, DWORD PTR _wc$[ebp]
	push	ecx
	call	_IsolationAwareRegisterClassW@4
	movzx	edx, ax
	test	edx, edx
	jne	SHORT $LN47@OBS

; 313  :         CrashError(TEXT("Could not register render frame class"));

	push	OFFSET $SG4294800652
	call	DWORD PTR __imp_?CrashError@@YAXPB_WZZ
$LN47@OBS:

; 314  : 
; 315  :     //-----------------------------------------------------
; 316  :     // projector frame class
; 317  :     wc.lpszClassName = OBS_PROJECTORFRAME_CLASS;

	mov	DWORD PTR _wc$[ebp+36], OFFSET $SG4294800651

; 318  :     wc.lpfnWndProc = (WNDPROC)OBS::ProjectorFrameProc;

	mov	DWORD PTR _wc$[ebp+4], OFFSET ?ProjectorFrameProc@OBS@@CGJPAUHWND__@@IIJ@Z ; OBS::ProjectorFrameProc

; 319  :     wc.hbrBackground = GetSysColorBrush(COLOR_BTNFACE);

	push	15					; 0000000fH
	call	DWORD PTR __imp__GetSysColorBrush@4
	mov	DWORD PTR _wc$[ebp+28], eax

; 320  : 
; 321  :     if(!RegisterClass(&wc))

	lea	eax, DWORD PTR _wc$[ebp]
	push	eax
	call	_IsolationAwareRegisterClassW@4
	movzx	ecx, ax
	test	ecx, ecx
	jne	SHORT $LN46@OBS

; 322  :         CrashError(TEXT("Could not register projector frame class"));

	push	OFFSET $SG4294800650
	call	DWORD PTR __imp_?CrashError@@YAXPB_WZZ
$LN46@OBS:

; 323  :     
; 324  :     //-----------------------------------------------------
; 325  :     // log window class
; 326  :     wc.lpszClassName = OBS_LOGWINDOW_CLASS;

	mov	DWORD PTR _wc$[ebp+36], OFFSET $SG4294800649

; 327  :     wc.lpfnWndProc = (WNDPROC)OBS::LogWindowProc;

	mov	DWORD PTR _wc$[ebp+4], OFFSET ?LogWindowProc@OBS@@CGJPAUHWND__@@IIJ@Z ; OBS::LogWindowProc

; 328  :     wc.hIcon = LoadIcon(hinstMain, MAKEINTRESOURCE(IDI_ICON1));

	push	109					; 0000006dH
	mov	edx, DWORD PTR ?hinstMain@@3PAUHINSTANCE__@@A ; hinstMain
	push	edx
	call	DWORD PTR __imp__LoadIconW@8
	mov	DWORD PTR _wc$[ebp+20], eax

; 329  :     wc.hbrBackground = (HBRUSH)COLOR_WINDOW;

	mov	DWORD PTR _wc$[ebp+28], 5

; 330  : 	
; 331  : 	
; 332  :     if(!RegisterClass(&wc))

	lea	eax, DWORD PTR _wc$[ebp]
	push	eax
	call	_IsolationAwareRegisterClassW@4
	movzx	ecx, ax
	test	ecx, ecx
	jne	SHORT $LN45@OBS

; 333  :         CrashError(TEXT("Could not register main window class"));

	push	OFFSET $SG4294800648
	call	DWORD PTR __imp_?CrashError@@YAXPB_WZZ
$LN45@OBS:

; 334  : 
; 335  : 	//-----------------------------------------------------
; 336  : 	////statu bar class
; 337  : 	//wc.lpszClassName = OBS_STATUS_CLASS;
; 338  : 	//wc.lpfnWndProc = (WNDPROC)OBS::OBSStatuBarProc;
; 339  : 	//wc.hIcon = LoadIcon(hinstMain, MAKEINTRESOURCE(IDI_ICON1));
; 340  : 	//wc.hbrBackground = (HBRUSH)(GetStockObject(GRAY_BRUSH));
; 341  : 
; 342  : 	//if (!RegisterClass(&wc))
; 343  : 	//	CrashError(TEXT("Could not register status bar class"));
; 344  : 	//-----------------------------------------------------
; 345  : 
; 346  :     // main window class
; 347  :     wc.lpszClassName = OBS_WINDOW_CLASS;

	mov	DWORD PTR _wc$[ebp+36], OFFSET $SG4294800647

; 348  :     wc.lpfnWndProc = (WNDPROC)OBSProc;

	mov	DWORD PTR _wc$[ebp+4], OFFSET ?OBSProc@OBS@@CGJPAUHWND__@@IIJ@Z ; OBS::OBSProc

; 349  : 	//note:
; 350  : 	wc.hbrBackground = (HBRUSH)(GetStockObject(BLACK_BRUSH));

	push	4
	call	DWORD PTR __imp__GetStockObject@4
	mov	DWORD PTR _wc$[ebp+28], eax

; 351  : 	wc.style = CS_VREDRAW | CS_HREDRAW | CS_OWNDC;

	mov	DWORD PTR _wc$[ebp], 35			; 00000023H

; 352  : 
; 353  : 	
; 354  :     if(!RegisterClass(&wc))

	lea	edx, DWORD PTR _wc$[ebp]
	push	edx
	call	_IsolationAwareRegisterClassW@4
	movzx	eax, ax
	test	eax, eax
	jne	SHORT $LN44@OBS

; 355  :         CrashError(TEXT("Could not register main window class"));

	push	OFFSET $SG4294800646
	call	DWORD PTR __imp_?CrashError@@YAXPB_WZZ
$LN44@OBS:

; 356  : 
; 357  :     //-----------------------------------------------------
; 358  :     // create main window
; 359  : 
; 360  :     int fullscreenX = GetSystemMetrics(SM_CXFULLSCREEN);

	push	16					; 00000010H
	call	DWORD PTR __imp__GetSystemMetrics@4
	mov	DWORD PTR _fullscreenX$[ebp], eax

; 361  :     int fullscreenY = GetSystemMetrics(SM_CYFULLSCREEN);

	push	17					; 00000011H
	call	DWORD PTR __imp__GetSystemMetrics@4
	mov	DWORD PTR _fullscreenY$[ebp], eax

; 362  : 
; 363  :     borderXSize = borderYSize = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+676], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+672], 0

; 364  : 
; 365  :     borderXSize += GetSystemMetrics(SM_CXSIZEFRAME)*2;

	push	32					; 00000020H
	call	DWORD PTR __imp__GetSystemMetrics@4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+672]
	lea	eax, DWORD PTR [edx+eax*2]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+672], eax

; 366  :     borderYSize += GetSystemMetrics(SM_CYSIZEFRAME)*2;

	push	33					; 00000021H
	call	DWORD PTR __imp__GetSystemMetrics@4
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+676]
	lea	edx, DWORD PTR [ecx+eax*2]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+676], edx

; 367  :     borderYSize += GetSystemMetrics(SM_CYMENU);

	push	15					; 0000000fH
	call	DWORD PTR __imp__GetSystemMetrics@4
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+676]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+676], eax

; 368  :     borderYSize += GetSystemMetrics(SM_CYCAPTION);

	push	4
	call	DWORD PTR __imp__GetSystemMetrics@4
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+676]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+676], eax

; 369  : 
; 370  :     clientWidth  = GlobalConfig->GetInt(TEXT("General"), TEXT("Width"),  defaultClientWidth);

	push	1000					; 000003e8H
	push	OFFSET $SG4294800645
	push	OFFSET $SG4294800644
	mov	ecx, DWORD PTR ?GlobalConfig@@3PAVConfigFile@@A ; GlobalConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+680], eax

; 371  :     clientHeight = GlobalConfig->GetInt(TEXT("General"), TEXT("Height"), defaultClientHeight);

	push	600					; 00000258H
	push	OFFSET $SG4294800643
	push	OFFSET $SG4294800642
	mov	ecx, DWORD PTR ?GlobalConfig@@3PAVConfigFile@@A ; GlobalConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+684], eax

; 372  : 
; 373  :     if(clientWidth < minClientWidth)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+680], 640		; 00000280H
	jge	SHORT $LN43@OBS

; 374  :         clientWidth = minClientWidth;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+680], 640		; 00000280H
$LN43@OBS:

; 375  :     if(clientHeight < minClientHeight)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+684], 275		; 00000113H
	jge	SHORT $LN42@OBS

; 376  :         clientHeight = minClientHeight;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+684], 275		; 00000113H
$LN42@OBS:

; 377  : 
; 378  :     int maxCX = fullscreenX-borderXSize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _fullscreenX$[ebp]
	sub	edx, DWORD PTR [ecx+672]
	mov	DWORD PTR _maxCX$[ebp], edx

; 379  :     int maxCY = fullscreenY-borderYSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _fullscreenY$[ebp]
	sub	ecx, DWORD PTR [eax+676]
	mov	DWORD PTR _maxCY$[ebp], ecx

; 380  : 	//
; 381  :     if(clientWidth > maxCX)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+680]
	cmp	eax, DWORD PTR _maxCX$[ebp]
	jle	SHORT $LN41@OBS

; 382  :         clientWidth = maxCX;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _maxCX$[ebp]
	mov	DWORD PTR [ecx+680], edx
$LN41@OBS:

; 383  :     if(clientHeight > maxCY)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+684]
	cmp	ecx, DWORD PTR _maxCY$[ebp]
	jle	SHORT $LN40@OBS

; 384  :         clientHeight = maxCY;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _maxCY$[ebp]
	mov	DWORD PTR [edx+684], eax
$LN40@OBS:

; 385  : 
; 386  :     int cx = clientWidth  + borderXSize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+680]
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+672]
	mov	DWORD PTR _cx$[ebp], edx

; 387  :     int cy = clientHeight + borderYSize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+684]
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+676]
	mov	DWORD PTR _cy$[ebp], edx

; 388  : 
; 389  :     int x = (fullscreenX/2)-(cx/2);

	mov	eax, DWORD PTR _fullscreenX$[ebp]
	cdq
	sub	eax, edx
	mov	ecx, eax
	sar	ecx, 1
	mov	eax, DWORD PTR _cx$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	sub	ecx, eax
	mov	DWORD PTR _x$[ebp], ecx

; 390  :     int y = (fullscreenY/2)-(cy/2);

	mov	eax, DWORD PTR _fullscreenY$[ebp]
	cdq
	sub	eax, edx
	mov	ecx, eax
	sar	ecx, 1
	mov	eax, DWORD PTR _cy$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	sub	ecx, eax
	mov	DWORD PTR _y$[ebp], ecx

; 391  : 
; 392  :     int posX = GlobalConfig->GetInt(TEXT("General"), TEXT("PosX"), -9999);

	push	-9999					; ffffd8f1H
	push	OFFSET $SG4294800641
	push	OFFSET $SG4294800640
	mov	ecx, DWORD PTR ?GlobalConfig@@3PAVConfigFile@@A ; GlobalConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	mov	DWORD PTR _posX$[ebp], eax

; 393  :     int posY = GlobalConfig->GetInt(TEXT("General"), TEXT("PosY"), -9999);

	push	-9999					; ffffd8f1H
	push	OFFSET $SG4294800639
	push	OFFSET $SG4294800638
	mov	ecx, DWORD PTR ?GlobalConfig@@3PAVConfigFile@@A ; GlobalConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	mov	DWORD PTR _posY$[ebp], eax

; 394  : 
; 395  :     bool bInsideMonitors = false;

	mov	BYTE PTR _bInsideMonitors$[ebp], 0

; 396  :     for(UINT i=0; i<monitors.Num(); i++)

	mov	DWORD PTR _i$20[ebp], 0
	jmp	SHORT $LN39@OBS
$LN38@OBS:
	mov	edx, DWORD PTR _i$20[ebp]
	add	edx, 1
	mov	DWORD PTR _i$20[ebp], edx
$LN39@OBS:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 156				; 0000009cH
	call	?Num@?$List@UMonitorInfo@@@@QBEIXZ	; List<MonitorInfo>::Num
	cmp	DWORD PTR _i$20[ebp], eax
	jae	$LN37@OBS

; 397  :     {
; 398  :         if( posX >= monitors[i].rect.left && posX < monitors[i].rect.right  &&
; 399  :             posY >= monitors[i].rect.top  && posY < monitors[i].rect.bottom )

	mov	eax, DWORD PTR _i$20[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 156				; 0000009cH
	call	??A?$List@UMonitorInfo@@@@QAEAAUMonitorInfo@@I@Z ; List<MonitorInfo>::operator[]
	mov	ecx, DWORD PTR _posX$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jl	SHORT $LN36@OBS
	mov	edx, DWORD PTR _i$20[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 156				; 0000009cH
	call	??A?$List@UMonitorInfo@@@@QAEAAUMonitorInfo@@I@Z ; List<MonitorInfo>::operator[]
	mov	ecx, DWORD PTR _posX$[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	jge	SHORT $LN36@OBS
	mov	edx, DWORD PTR _i$20[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 156				; 0000009cH
	call	??A?$List@UMonitorInfo@@@@QAEAAUMonitorInfo@@I@Z ; List<MonitorInfo>::operator[]
	mov	ecx, DWORD PTR _posY$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jl	SHORT $LN36@OBS
	mov	edx, DWORD PTR _i$20[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 156				; 0000009cH
	call	??A?$List@UMonitorInfo@@@@QAEAAUMonitorInfo@@I@Z ; List<MonitorInfo>::operator[]
	mov	ecx, DWORD PTR _posY$[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jge	SHORT $LN36@OBS

; 400  :         {
; 401  :             bInsideMonitors = true;

	mov	BYTE PTR _bInsideMonitors$[ebp], 1

; 402  :             break;

	jmp	SHORT $LN37@OBS
$LN36@OBS:

; 403  :         }
; 404  :     }

	jmp	$LN38@OBS
$LN37@OBS:

; 405  : 
; 406  :     if(bInsideMonitors)

	movzx	edx, BYTE PTR _bInsideMonitors$[ebp]
	test	edx, edx
	je	SHORT $LN35@OBS

; 407  :     {
; 408  :         x = posX;

	mov	eax, DWORD PTR _posX$[ebp]
	mov	DWORD PTR _x$[ebp], eax

; 409  :         y = posY;

	mov	ecx, DWORD PTR _posY$[ebp]
	mov	DWORD PTR _y$[ebp], ecx
$LN35@OBS:

; 410  :     }
; 411  : 
; 412  :     bPanelVisibleWindowed = GlobalConfig->GetInt(TEXT("General"), TEXT("PanelVisibleWindowed"), 1) != 0;

	push	1
	push	OFFSET $SG4294800637
	push	OFFSET $SG4294800636
	mov	ecx, DWORD PTR ?GlobalConfig@@3PAVConfigFile@@A ; GlobalConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	test	eax, eax
	je	SHORT $LN51@OBS
	mov	DWORD PTR tv619[ebp], 1
	jmp	SHORT $LN52@OBS
$LN51@OBS:
	mov	DWORD PTR tv619[ebp], 0
$LN52@OBS:
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR tv619[ebp]
	mov	BYTE PTR [edx+688], al

; 413  :     bPanelVisibleFullscreen = GlobalConfig->GetInt(TEXT("General"), TEXT("PanelVisibleFullscreen"), 0) != 0;

	push	0
	push	OFFSET $SG4294800635
	push	OFFSET $SG4294800634
	mov	ecx, DWORD PTR ?GlobalConfig@@3PAVConfigFile@@A ; GlobalConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	test	eax, eax
	je	SHORT $LN53@OBS
	mov	DWORD PTR tv628[ebp], 1
	jmp	SHORT $LN54@OBS
$LN53@OBS:
	mov	DWORD PTR tv628[ebp], 0
$LN54@OBS:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR tv628[ebp]
	mov	BYTE PTR [ecx+689], dl

; 414  :     bPanelVisible = bPanelVisibleWindowed; // Assuming OBS always starts windowed

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+688]
	mov	BYTE PTR [eax+690], dl

; 415  :     bPanelVisibleProcessed = false; // Force immediate process

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+691], 0

; 416  : 
; 417  :     bFullscreenMode = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+740], 0

; 418  : 	//WS_EX_TOOLWINDOW
; 419  : 	hwndMain = CreateWindowEx(0, OBS_WINDOW_CLASS, GetApplicationName(),
; 420  : 		WS_OVERLAPPED | WS_POPUP |WS_CLIPCHILDREN,
; 421  : 		x, y, defaultClientWidth, defaultClientHeight, NULL, NULL, hinstMain, NULL);

	push	0
	mov	edx, DWORD PTR ?hinstMain@@3PAUHINSTANCE__@@A ; hinstMain
	push	edx
	push	0
	push	0
	push	600					; 00000258H
	push	1000					; 000003e8H
	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	push	-2113929216				; 82000000H
	lea	edx, DWORD PTR $T7[ebp]
	push	edx
	call	?GetApplicationName@OBS@@CA?AVString@@XZ ; OBS::GetApplicationName
	add	esp, 4
	mov	ecx, eax
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	push	OFFSET $SG4294800633
	push	0
	call	_IsolationAwareCreateWindowExW@48
	mov	DWORD PTR ?hwndMain@@3PAUHWND__@@A, eax	; hwndMain
	lea	ecx, DWORD PTR $T7[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 422  : 
; 423  :     if(!hwndMain)

	cmp	DWORD PTR ?hwndMain@@3PAUHWND__@@A, 0	; hwndMain
	jne	SHORT $LN34@OBS

; 424  :         CrashError(TEXT("Could not create main window"));

	push	OFFSET $SG4294800632
	call	DWORD PTR __imp_?CrashError@@YAXPB_WZZ
$LN34@OBS:

; 425  : 
; 426  :     //-----------------------------------------------------
; 427  :     // render frame
; 428  : 
; 429  :     hwndRenderFrame = CreateWindow(OBS_RENDERFRAME_CLASS, NULL,
; 430  :         WS_CHILDWINDOW | WS_VISIBLE | WS_CLIPCHILDREN,
; 431  :         0, 0, 0, 0,
; 432  :         hwndMain, NULL, hinstMain, NULL);

	push	0
	mov	eax, DWORD PTR ?hinstMain@@3PAUHINSTANCE__@@A ; hinstMain
	push	eax
	push	0
	mov	ecx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	ecx
	push	0
	push	0
	push	0
	push	0
	push	1375731712				; 52000000H
	push	0
	push	OFFSET $SG4294800631
	push	0
	call	_IsolationAwareCreateWindowExW@48
	mov	DWORD PTR ?hwndRenderFrame@@3PAUHWND__@@A, eax ; hwndRenderFrame

; 433  :     if(!hwndRenderFrame)

	cmp	DWORD PTR ?hwndRenderFrame@@3PAUHWND__@@A, 0 ; hwndRenderFrame
	jne	SHORT $LN33@OBS

; 434  :         CrashError(TEXT("Could not create render frame"));

	push	OFFSET $SG4294800630
	call	DWORD PTR __imp_?CrashError@@YAXPB_WZZ
$LN33@OBS:

; 435  : 
; 436  :     //-----------------------------------------------------
; 437  :     // projector window
; 438  : 
; 439  :     hwndProjector = CreateWindow(OBS_PROJECTORFRAME_CLASS,
; 440  :         L"OBS Projector Window",
; 441  :         WS_POPUP, 0, 0, 0, 0,
; 442  :         NULL, NULL, hinstMain, NULL);

	push	0
	mov	edx, DWORD PTR ?hinstMain@@3PAUHINSTANCE__@@A ; hinstMain
	push	edx
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	-2147483648				; 80000000H
	push	OFFSET $SG4294800629
	push	OFFSET $SG4294800628
	push	0
	call	_IsolationAwareCreateWindowExW@48
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+732], eax

; 443  : 
; 444  :     //-----------------------------------------------------
; 445  :     // log window
; 446  : 
; 447  :     x = (fullscreenX/2)-(600/2);

	mov	eax, DWORD PTR _fullscreenX$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	sub	eax, 300				; 0000012cH
	mov	DWORD PTR _x$[ebp], eax

; 448  :     y = (fullscreenY/2)-(500/2);

	mov	eax, DWORD PTR _fullscreenY$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	sub	eax, 250				; 000000faH
	mov	DWORD PTR _y$[ebp], eax

; 449  : 
; 450  :     int logPosX  = GlobalConfig->GetInt(TEXT("General"), TEXT("LogPosX"), -9999);

	push	-9999					; ffffd8f1H
	push	OFFSET $SG4294800627
	push	OFFSET $SG4294800626
	mov	ecx, DWORD PTR ?GlobalConfig@@3PAVConfigFile@@A ; GlobalConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	mov	DWORD PTR _logPosX$[ebp], eax

; 451  :     int logPosY  = GlobalConfig->GetInt(TEXT("General"), TEXT("LogPosY"), -9999);

	push	-9999					; ffffd8f1H
	push	OFFSET $SG4294800625
	push	OFFSET $SG4294800624
	mov	ecx, DWORD PTR ?GlobalConfig@@3PAVConfigFile@@A ; GlobalConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	mov	DWORD PTR _logPosY$[ebp], eax

; 452  :     int logSizeX = GlobalConfig->GetInt(TEXT("General"), TEXT("LogSizeX"), 600);

	push	600					; 00000258H
	push	OFFSET $SG4294800623
	push	OFFSET $SG4294800622
	mov	ecx, DWORD PTR ?GlobalConfig@@3PAVConfigFile@@A ; GlobalConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	mov	DWORD PTR _logSizeX$[ebp], eax

; 453  :     int logSizeY = GlobalConfig->GetInt(TEXT("General"), TEXT("LogSizeY"), 500);

	push	500					; 000001f4H
	push	OFFSET $SG4294800621
	push	OFFSET $SG4294800620
	mov	ecx, DWORD PTR ?GlobalConfig@@3PAVConfigFile@@A ; GlobalConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	mov	DWORD PTR _logSizeY$[ebp], eax

; 454  : 
; 455  :     bInsideMonitors = false;

	mov	BYTE PTR _bInsideMonitors$[ebp], 0

; 456  :     for(UINT i=0; i<monitors.Num(); i++)

	mov	DWORD PTR _i$22[ebp], 0
	jmp	SHORT $LN32@OBS
$LN31@OBS:
	mov	edx, DWORD PTR _i$22[ebp]
	add	edx, 1
	mov	DWORD PTR _i$22[ebp], edx
$LN32@OBS:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 156				; 0000009cH
	call	?Num@?$List@UMonitorInfo@@@@QBEIXZ	; List<MonitorInfo>::Num
	cmp	DWORD PTR _i$22[ebp], eax
	jae	$LN30@OBS

; 457  :     {
; 458  :         if( logPosX >= monitors[i].rect.left && logPosX < monitors[i].rect.right  &&
; 459  :             logPosY >= monitors[i].rect.top  && logPosY < monitors[i].rect.bottom )

	mov	eax, DWORD PTR _i$22[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 156				; 0000009cH
	call	??A?$List@UMonitorInfo@@@@QAEAAUMonitorInfo@@I@Z ; List<MonitorInfo>::operator[]
	mov	ecx, DWORD PTR _logPosX$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jl	SHORT $LN29@OBS
	mov	edx, DWORD PTR _i$22[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 156				; 0000009cH
	call	??A?$List@UMonitorInfo@@@@QAEAAUMonitorInfo@@I@Z ; List<MonitorInfo>::operator[]
	mov	ecx, DWORD PTR _logPosX$[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	jge	SHORT $LN29@OBS
	mov	edx, DWORD PTR _i$22[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 156				; 0000009cH
	call	??A?$List@UMonitorInfo@@@@QAEAAUMonitorInfo@@I@Z ; List<MonitorInfo>::operator[]
	mov	ecx, DWORD PTR _logPosY$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jl	SHORT $LN29@OBS
	mov	edx, DWORD PTR _i$22[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 156				; 0000009cH
	call	??A?$List@UMonitorInfo@@@@QAEAAUMonitorInfo@@I@Z ; List<MonitorInfo>::operator[]
	mov	ecx, DWORD PTR _logPosY$[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jge	SHORT $LN29@OBS

; 460  :         {
; 461  :             bInsideMonitors = true;

	mov	BYTE PTR _bInsideMonitors$[ebp], 1

; 462  :             break;

	jmp	SHORT $LN30@OBS
$LN29@OBS:

; 463  :         }
; 464  :     }

	jmp	$LN31@OBS
$LN30@OBS:

; 465  : 
; 466  :     if(bInsideMonitors)

	movzx	edx, BYTE PTR _bInsideMonitors$[ebp]
	test	edx, edx
	je	SHORT $LN28@OBS

; 467  :     {
; 468  :         x = logPosX;

	mov	eax, DWORD PTR _logPosX$[ebp]
	mov	DWORD PTR _x$[ebp], eax

; 469  :         y = logPosY;

	mov	ecx, DWORD PTR _logPosY$[ebp]
	mov	DWORD PTR _y$[ebp], ecx

; 470  :     }
; 471  :     else

	jmp	SHORT $LN27@OBS
$LN28@OBS:

; 472  :     {
; 473  :         logSizeX = 600;

	mov	DWORD PTR _logSizeX$[ebp], 600		; 00000258H

; 474  :         logSizeY = 500;

	mov	DWORD PTR _logSizeY$[ebp], 500		; 000001f4H
$LN27@OBS:

; 475  :     }
; 476  : 
; 477  :     hwndLogWindow = CreateWindowEx(LocaleIsRTL() ? WS_EX_LAYOUTRTL | WS_EX_NOINHERITLAYOUT : 0, OBS_LOGWINDOW_CLASS, L"LogWindow", WS_OVERLAPPEDWINDOW, x, y, logSizeX, logSizeY, NULL, NULL, hinstMain, NULL);

	mov	edx, DWORD PTR __imp_?locale@@3PAVLocaleStringLookup@@A
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR __imp_?LocaleIsRTL@@YA_NPAVLocaleStringLookup@@@Z
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN55@OBS
	mov	DWORD PTR tv759[ebp], 5242880		; 00500000H
	jmp	SHORT $LN56@OBS
$LN55@OBS:
	mov	DWORD PTR tv759[ebp], 0
$LN56@OBS:
	push	0
	mov	edx, DWORD PTR ?hinstMain@@3PAUHINSTANCE__@@A ; hinstMain
	push	edx
	push	0
	push	0
	mov	eax, DWORD PTR _logSizeY$[ebp]
	push	eax
	mov	ecx, DWORD PTR _logSizeX$[ebp]
	push	ecx
	mov	edx, DWORD PTR _y$[ebp]
	push	edx
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	push	13565952				; 00cf0000H
	push	OFFSET $SG4294800619
	push	OFFSET $SG4294800618
	mov	ecx, DWORD PTR tv759[ebp]
	push	ecx
	call	_IsolationAwareCreateWindowExW@48
	mov	DWORD PTR ?hwndLogWindow@@3PAUHWND__@@A, eax ; hwndLogWindow

; 478  :     LocalizeWindow(hwndLogWindow);

	push	0
	mov	edx, DWORD PTR ?hwndLogWindow@@3PAUHWND__@@A ; hwndLogWindow
	push	edx
	call	DWORD PTR __imp_?LocalizeWindow@@YAXPAUHWND__@@PAVLocaleStringLookup@@@Z
	add	esp, 8

; 479  : 
; 480  :     RECT client;
; 481  :     GetClientRect(hwndLogWindow, &client);

	lea	eax, DWORD PTR _client$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?hwndLogWindow@@3PAUHWND__@@A ; hwndLogWindow
	push	ecx
	call	DWORD PTR __imp__GetClientRect@8

; 482  : 
; 483  :     hwndLog = CreateWindowEx(WS_EX_CLIENTEDGE, L"EDIT", L"",
; 484  :         ES_MULTILINE | WS_VISIBLE | WS_CHILD | WS_TABSTOP | WS_VSCROLL | WS_HSCROLL | ES_READONLY | ES_NOHIDESEL,
; 485  :         client.left, client.top, client.right, client.bottom, hwndLogWindow, (HMENU)ID_LOG_WINDOW, 0, 0);

	push	0
	push	0
	push	9025					; 00002341H
	mov	edx, DWORD PTR ?hwndLogWindow@@3PAUHWND__@@A ; hwndLogWindow
	push	edx
	mov	eax, DWORD PTR _client$[ebp+12]
	push	eax
	mov	ecx, DWORD PTR _client$[ebp+8]
	push	ecx
	mov	edx, DWORD PTR _client$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _client$[ebp]
	push	eax
	push	1345390852				; 50310904H
	push	OFFSET $SG4294800617
	push	OFFSET $SG4294800616
	push	512					; 00000200H
	call	_IsolationAwareCreateWindowExW@48
	mov	DWORD PTR ?hwndLog@@3PAUHWND__@@A, eax	; hwndLog

; 486  :     SendMessage(hwndLog, WM_SETFONT, (WPARAM)GetStockObject(DEFAULT_GUI_FONT), TRUE);

	push	1
	push	17					; 00000011H
	call	DWORD PTR __imp__GetStockObject@4
	push	eax
	push	48					; 00000030H
	mov	ecx, DWORD PTR ?hwndLog@@3PAUHWND__@@A	; hwndLog
	push	ecx
	call	DWORD PTR __imp__SendMessageW@16

; 487  :     SendMessage(hwndLog, EM_SETLIMITTEXT, 0, 0);

	push	0
	push	0
	push	197					; 000000c5H
	mov	edx, DWORD PTR ?hwndLog@@3PAUHWND__@@A	; hwndLog
	push	edx
	call	DWORD PTR __imp__SendMessageW@16

; 488  :     ShowWindow(hwndLog, SW_SHOW);

	push	5
	mov	eax, DWORD PTR ?hwndLog@@3PAUHWND__@@A	; hwndLog
	push	eax
	call	DWORD PTR __imp__ShowWindow@8

; 489  : 
; 490  :     ResetLogUpdateCallback([] { PostMessage(hwndLogWindow, WM_COMMAND, MAKEWPARAM(ID_LOG_WINDOW, 0), 0); });

	lea	ecx, DWORD PTR $T15[ebp]
	call	??B<lambda_67fe46cc64f8d1dcff1cc8a09bdee50b>@@QBEP6AXXZXZ ; <lambda_67fe46cc64f8d1dcff1cc8a09bdee50b>::operator void (__cdecl*)(void)
	push	eax
	call	DWORD PTR __imp_?ResetLogUpdateCallback@@YAXP6AXXZ@Z
	add	esp, 4

; 491  : 
; 492  :     //-----------------------------------------------------
; 493  :     // render frame text
; 494  : 
; 495  :     //hwndRenderMessage = CreateWindow(TEXT("STATIC"), Str("MainWindow.BeginMessage"),
; 496  :     //    WS_CHILDWINDOW|WS_VISIBLE|WS_CLIPSIBLINGS|SS_CENTER,
; 497  :     //    0, 0, 0, 0, hwndRenderFrame, NULL, hinstMain, NULL);
; 498  :     //SendMessage(hwndRenderMessage, WM_SETFONT, (WPARAM)GetStockObject(DEFAULT_GUI_FONT), TRUE);
; 499  : 
; 500  :     //-----------------------------------------------------
; 501  :     // scenes listbox
; 502  : 
; 503  :     HWND hwndTemp;
; 504  :     hwndTemp = CreateWindowEx(0/*WS_EX_CLIENTEDGE,*/, TEXT("LISTBOX"), NULL,
; 505  : 		WS_CHILDWINDOW | WS_VISIBLE | WS_TABSTOP | LBS_HASSTRINGS | /*WS_VSCROLL |*/ LBS_NOTIFY | LBS_NOINTEGRALHEIGHT | WS_CLIPSIBLINGS | LBS_OWNERDRAWFIXED,
; 506  :         0, 0, 0, 0, hwndMain, (HMENU)ID_SCENES, 0, 0);

	push	0
	push	0
	push	5011					; 00001393H
	mov	ecx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	ecx
	push	0
	push	0
	push	0
	push	0
	push	1409352017				; 54010151H
	push	0
	push	OFFSET $SG4294800615
	push	0
	call	_IsolationAwareCreateWindowExW@48
	mov	DWORD PTR _hwndTemp$[ebp], eax

; 507  :     SendMessage(hwndTemp, WM_SETFONT, (WPARAM)GetStockObject(DEFAULT_GUI_FONT), TRUE);

	push	1
	push	17					; 00000011H
	call	DWORD PTR __imp__GetStockObject@4
	push	eax
	push	48					; 00000030H
	mov	edx, DWORD PTR _hwndTemp$[ebp]
	push	edx
	call	DWORD PTR __imp__SendMessageW@16

; 508  : 
; 509  :     listboxProc = (WNDPROC)GetWindowLongPtr(hwndTemp, GWLP_WNDPROC);

	push	-4					; fffffffcH
	mov	eax, DWORD PTR _hwndTemp$[ebp]
	push	eax
	call	DWORD PTR __imp__GetWindowLongW@8
	mov	DWORD PTR ?listboxProc@@3P6GJPAUHWND__@@IIJ@ZA, eax ; listboxProc

; 510  :     SetWindowLongPtr(hwndTemp, GWLP_WNDPROC, (LONG_PTR)OBS::ListboxHook);

	push	OFFSET ?ListboxHook@OBS@@CGJPAUHWND__@@IIJ@Z ; OBS::ListboxHook
	push	-4					; fffffffcH
	mov	ecx, DWORD PTR _hwndTemp$[ebp]
	push	ecx
	call	DWORD PTR __imp__SetWindowLongW@12

; 511  :     //-----------------------------------------------------
; 512  :     // elements listview
; 513  : 
; 514  :     hwndTemp = CreateWindowEx(0/*WS_EX_CLIENTEDGE*/, WC_LISTVIEW, NULL,
; 515  :         WS_CHILDWINDOW|WS_VISIBLE|WS_TABSTOP|WS_VSCROLL|WS_CLIPSIBLINGS|LVS_REPORT|LVS_NOCOLUMNHEADER|
; 516  : 		LVS_SHOWSELALWAYS | LVS_ALIGNLEFT | LVS_NOLABELWRAP /*|LVS_OWNERDRAWFIXED*/,
; 517  :         0, 0, 0, 0, hwndMain, (HMENU)ID_SOURCES, 0, 0);

	push	0
	push	0
	push	5013					; 00001395H
	mov	edx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	edx
	push	0
	push	0
	push	0
	push	0
	push	1411467401				; 54214889H
	push	0
	push	OFFSET $SG4294800614
	push	0
	call	_IsolationAwareCreateWindowExW@48
	mov	DWORD PTR _hwndTemp$[ebp], eax

; 518  :     SendMessage(hwndTemp, WM_SETFONT, (WPARAM)GetStockObject(DEFAULT_GUI_FONT), TRUE);

	push	1
	push	17					; 00000011H
	call	DWORD PTR __imp__GetStockObject@4
	push	eax
	push	48					; 00000030H
	mov	eax, DWORD PTR _hwndTemp$[ebp]
	push	eax
	call	DWORD PTR __imp__SendMessageW@16

; 519  : 
; 520  :     ListView_SetExtendedListViewStyle(hwndTemp, LVS_EX_CHECKBOXES | LVS_EX_FULLROWSELECT | LVS_EX_DOUBLEBUFFER);

	push	65572					; 00010024H
	push	0
	push	4150					; 00001036H
	mov	ecx, DWORD PTR _hwndTemp$[ebp]
	push	ecx
	call	DWORD PTR __imp__SendMessageW@16

; 521  :     
; 522  :     //add single column needed for report style
; 523  :     LVCOLUMN column;    
; 524  :     column.mask = LVCF_TEXT;

	mov	DWORD PTR _column$[ebp], 4

; 525  :     column.fmt = LVCFMT_FIXED_WIDTH;

	mov	DWORD PTR _column$[ebp+4], 256		; 00000100H

; 526  :     column.cx = 0;

	mov	DWORD PTR _column$[ebp+8], 0

; 527  :     column.pszText = TEXT("");

	mov	DWORD PTR _column$[ebp+12], OFFSET $SG4294800613

; 528  : 
; 529  :     ListView_InsertColumn(hwndTemp, 0, &column);

	lea	edx, DWORD PTR _column$[ebp]
	push	edx
	push	0
	push	4193					; 00001061H
	mov	eax, DWORD PTR _hwndTemp$[ebp]
	push	eax
	call	DWORD PTR __imp__SendMessageW@16

; 530  :     ListView_InsertColumn(hwndTemp, 1, &column);

	lea	ecx, DWORD PTR _column$[ebp]
	push	ecx
	push	1
	push	4193					; 00001061H
	mov	edx, DWORD PTR _hwndTemp$[ebp]
	push	edx
	call	DWORD PTR __imp__SendMessageW@16

; 531  : 
; 532  :     listviewProc = (WNDPROC)GetWindowLongPtr(hwndTemp, GWLP_WNDPROC);

	push	-4					; fffffffcH
	mov	eax, DWORD PTR _hwndTemp$[ebp]
	push	eax
	call	DWORD PTR __imp__GetWindowLongW@8
	mov	DWORD PTR ?listviewProc@@3P6GJPAUHWND__@@IIJ@ZA, eax ; listviewProc

; 533  :     SetWindowLongPtr(hwndTemp, GWLP_WNDPROC, (LONG_PTR)OBS::ListboxHook);

	push	OFFSET ?ListboxHook@OBS@@CGJPAUHWND__@@IIJ@Z ; OBS::ListboxHook
	push	-4					; fffffffcH
	mov	ecx, DWORD PTR _hwndTemp$[ebp]
	push	ecx
	call	DWORD PTR __imp__SetWindowLongW@12

; 534  : 	SendMessage(hwndTemp, LVM_SETBKCOLOR, 0, RGB(34,36,40));

	push	2630690					; 00282422H
	push	0
	push	4097					; 00001001H
	mov	edx, DWORD PTR _hwndTemp$[ebp]
	push	edx
	call	DWORD PTR __imp__SendMessageW@16

; 535  :     HWND hwndSources = hwndTemp;

	mov	eax, DWORD PTR _hwndTemp$[ebp]
	mov	DWORD PTR _hwndSources$[ebp], eax

; 536  : 
; 537  :     //-----------------------------------------------------
; 538  :     // status control
; 539  : 
; 540  : 	//hwndTemp = CreateWindowEx(0, STATUSCLASSNAME, NULL,
; 541  : 	//	WS_CHILD | WS_VISIBLE | SBARS_SIZEGRIP | WS_CLIPSIBLINGS,
; 542  : 	//	0, 0, 0, 0, hwndMain, (HMENU)ID_STATUS, 0, 0);
; 543  : 	//SendMessage(hwndTemp, WM_SETFONT, (WPARAM)GetStockObject(DEFAULT_GUI_FONT), TRUE);
; 544  : 	
; 545  : 
; 546  :     //-----------------------------------------------------
; 547  :     // mic volume control
; 548  : 
; 549  :     hwndTemp = CreateWindow(VOLUME_CONTROL_CLASS, NULL,
; 550  :         WS_CHILDWINDOW|WS_VISIBLE|WS_CLIPSIBLINGS,
; 551  :         0, 0, 0, 0, hwndMain, (HMENU)ID_MICVOLUME, 0, 0);

	push	0
	push	0
	push	5007					; 0000138fH
	mov	ecx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	ecx
	push	0
	push	0
	push	0
	push	0
	push	1409286144				; 54000000H
	push	0
	push	OFFSET $SG4294800612
	push	0
	call	_IsolationAwareCreateWindowExW@48
	mov	DWORD PTR _hwndTemp$[ebp], eax

; 552  :    
; 553  : 	SetVolumeControlIcons(hwndTemp, GetIcon(hinstMain, IDI_SOUND_DESKTOP), GetIcon(hinstMain, IDI_SOUND_DESKTOP_MUTED));

	push	113					; 00000071H
	mov	edx, DWORD PTR ?hinstMain@@3PAUHINSTANCE__@@A ; hinstMain
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetIcon@OBS@@UAEPAUHICON__@@PAUHINSTANCE__@@H@Z ; OBS::GetIcon
	push	eax
	push	112					; 00000070H
	mov	eax, DWORD PTR ?hinstMain@@3PAUHINSTANCE__@@A ; hinstMain
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetIcon@OBS@@UAEPAUHICON__@@PAUHINSTANCE__@@H@Z ; OBS::GetIcon
	push	eax
	mov	ecx, DWORD PTR _hwndTemp$[ebp]
	push	ecx
	call	DWORD PTR __imp_?SetVolumeControlIcons@@YAXPAUHWND__@@PAUHICON__@@1@Z
	add	esp, 12					; 0000000cH

; 554  : 
; 555  :     //-----------------------------------------------------
; 556  :     // mic volume meter
; 557  : 
; 558  :     hwndTemp = CreateWindow(VOLUME_METER_CLASS, NULL,
; 559  :                             WS_CHILDWINDOW|WS_VISIBLE|WS_CLIPSIBLINGS,
; 560  :                             0, 0, 0, 0, hwndMain, (HMENU)ID_MICVOLUMEMETER, 0, 0);

	push	0
	push	0
	push	5009					; 00001391H
	mov	edx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	edx
	push	0
	push	0
	push	0
	push	0
	push	1409286144				; 54000000H
	push	0
	push	OFFSET $SG4294800611
	push	0
	call	_IsolationAwareCreateWindowExW@48
	mov	DWORD PTR _hwndTemp$[ebp], eax

; 561  : 
; 562  :     //-----------------------------------------------------
; 563  :     // desktop volume meter
; 564  : 
; 565  :     hwndTemp = CreateWindow(VOLUME_METER_CLASS, NULL,
; 566  :                             WS_CHILDWINDOW|WS_VISIBLE|WS_CLIPSIBLINGS,
; 567  :                             0, 0, 0, 0, hwndMain, (HMENU)ID_DESKTOPVOLUMEMETER, 0, 0);

	push	0
	push	0
	push	5008					; 00001390H
	mov	eax, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	eax
	push	0
	push	0
	push	0
	push	0
	push	1409286144				; 54000000H
	push	0
	push	OFFSET $SG4294800610
	push	0
	call	_IsolationAwareCreateWindowExW@48
	mov	DWORD PTR _hwndTemp$[ebp], eax

; 568  : 
; 569  :     //-----------------------------------------------------
; 570  :     // desktop volume control
; 571  : 
; 572  :     hwndTemp = CreateWindow(VOLUME_CONTROL_CLASS, NULL,
; 573  :         WS_CHILDWINDOW|WS_VISIBLE|WS_CLIPSIBLINGS,
; 574  :         0, 0, 0, 0, hwndMain, (HMENU)ID_DESKTOPVOLUME, 0, 0);

	push	0
	push	0
	push	5006					; 0000138eH
	mov	ecx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	ecx
	push	0
	push	0
	push	0
	push	0
	push	1409286144				; 54000000H
	push	0
	push	OFFSET $SG4294800609
	push	0
	call	_IsolationAwareCreateWindowExW@48
	mov	DWORD PTR _hwndTemp$[ebp], eax

; 575  :    
; 576  : 	SetVolumeControlIcons(hwndTemp, GetIcon(hinstMain, IDI_SOUND_MIC), GetIcon(hinstMain, IDI_SOUND_MIC_MUTED));

	push	111					; 0000006fH
	mov	edx, DWORD PTR ?hinstMain@@3PAUHINSTANCE__@@A ; hinstMain
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetIcon@OBS@@UAEPAUHICON__@@PAUHINSTANCE__@@H@Z ; OBS::GetIcon
	push	eax
	push	110					; 0000006eH
	mov	eax, DWORD PTR ?hinstMain@@3PAUHINSTANCE__@@A ; hinstMain
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetIcon@OBS@@UAEPAUHICON__@@PAUHINSTANCE__@@H@Z ; OBS::GetIcon
	push	eax
	mov	ecx, DWORD PTR _hwndTemp$[ebp]
	push	ecx
	call	DWORD PTR __imp_?SetVolumeControlIcons@@YAXPAUHWND__@@PAUHICON__@@1@Z
	add	esp, 12					; 0000000cH

; 577  :     //-----------------------------------------------------
; 578  :     // start/stop recording button
; 579  : 
; 580  :   /*  hwndTemp = CreateWindow(TEXT("BUTTON"), Str("MainWindow.StartRecording"),
; 581  :         WS_CHILDWINDOW|WS_VISIBLE|WS_TABSTOP|BS_TEXT|BS_SPLITBUTTON|WS_CLIPSIBLINGS,
; 582  :         0, 0, 0, 0, hwndMain, (HMENU)ID_TOGGLERECORDING, 0, 0);
; 583  :     SendMessage(hwndTemp, WM_SETFONT, (WPARAM)GetStockObject(DEFAULT_GUI_FONT), TRUE);*/
; 584  : 
; 585  :     //-----------------------------------------------------
; 586  :     // start/stop stream button
; 587  : 
; 588  :     //hwndTemp = CreateWindow(TEXT("BUTTON"), Str("MainWindow.StartStream"),
; 589  :     //    WS_CHILDWINDOW|WS_VISIBLE|WS_TABSTOP|BS_TEXT|BS_PUSHBUTTON|WS_CLIPSIBLINGS,
; 590  :     //    0, 0, 0, 0, hwndMain, (HMENU)ID_STARTSTOP, 0, 0);
; 591  :     //SendMessage(hwndTemp, WM_SETFONT, (WPARAM)GetStockObject(DEFAULT_GUI_FONT), TRUE);
; 592  : 
; 593  :     //-----------------------------------------------------
; 594  :     // edit scene button
; 595  : 
; 596  :     //hwndTemp = CreateWindow(TEXT("BUTTON"), Str("MainWindow.SceneEditor"),
; 597  :     //    WS_CHILDWINDOW|WS_VISIBLE|WS_TABSTOP|BS_TEXT|BS_AUTOCHECKBOX|BS_PUSHLIKE|WS_DISABLED|WS_CLIPSIBLINGS,
; 598  :     //    0, 0, 0, 0, hwndMain, (HMENU)ID_SCENEEDITOR, 0, 0);
; 599  :     //SendMessage(hwndTemp, WM_SETFONT, (WPARAM)GetStockObject(DEFAULT_GUI_FONT), TRUE);
; 600  : 
; 601  :     //-----------------------------------------------------
; 602  :     // global sources button
; 603  : 
; 604  :  /*   hwndTemp = CreateWindow(TEXT("BUTTON"), Str("GlobalSources"),
; 605  :         WS_CHILDWINDOW|WS_VISIBLE|WS_TABSTOP|BS_TEXT|BS_PUSHBUTTON|WS_CLIPSIBLINGS,
; 606  :         0, 0, 0, 0, hwndMain, (HMENU)ID_GLOBALSOURCES, 0, 0);
; 607  :     SendMessage(hwndTemp, WM_SETFONT, (WPARAM)GetStockObject(DEFAULT_GUI_FONT), TRUE);*/
; 608  : 
; 609  :     //-----------------------------------------------------
; 610  :     // test stream button
; 611  : 
; 612  :     //hwndTemp = CreateWindow(TEXT("BUTTON"), Str("MainWindow.TestStream"),
; 613  :     //    WS_CHILDWINDOW|WS_VISIBLE|WS_TABSTOP|BS_TEXT|BS_PUSHBUTTON|WS_CLIPSIBLINGS,
; 614  :     //    0, 0, 0, 0, hwndMain, (HMENU)ID_TESTSTREAM, 0, 0);
; 615  :     //SendMessage(hwndTemp, WM_SETFONT, (WPARAM)GetStockObject(DEFAULT_GUI_FONT), TRUE);
; 616  : 
; 617  :     //-----------------------------------------------------
; 618  :     // plugins button
; 619  : 
; 620  : 	/*   hwndTemp = CreateWindow(TEXT("BUTTON"), Str("MainWindow.Plugins"),
; 621  : 		   WS_CHILDWINDOW|WS_VISIBLE|WS_TABSTOP|BS_TEXT|BS_PUSHBUTTON|WS_CLIPSIBLINGS,
; 622  : 		   0, 0, 0, 0, hwndMain, (HMENU)ID_PLUGINS, 0, 0);
; 623  : 		   SendMessage(hwndTemp, WM_SETFONT, (WPARAM)GetStockObject(DEFAULT_GUI_FONT), TRUE);*/
; 624  : 
; 625  :     //-----------------------------------------------------
; 626  :     // dashboard button
; 627  : 
; 628  :     hwndTemp = CreateWindow(TEXT("BUTTON"), Str("MainWindow.Dashboard"),
; 629  :         WS_CHILDWINDOW|WS_VISIBLE|WS_TABSTOP|BS_TEXT|BS_PUSHBUTTON|WS_CLIPSIBLINGS,
; 630  :         0, 0, 0, 0, hwndMain, (HMENU)ID_DASHBOARD, 0, 0);

	push	0
	push	0
	push	5018					; 0000139aH
	mov	edx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	edx
	push	0
	push	0
	push	0
	push	0
	push	1409351680				; 54010000H
	push	OFFSET $SG4294800608
	mov	eax, DWORD PTR __imp_?locale@@3PAVLocaleStringLookup@@A
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR __imp_?LookupString@LocaleStringLookup@@QAEPB_WPB_W@Z
	push	eax
	push	OFFSET $SG4294800607
	push	0
	call	_IsolationAwareCreateWindowExW@48
	mov	DWORD PTR _hwndTemp$[ebp], eax

; 631  :     SendMessage(hwndTemp, WM_SETFONT, (WPARAM)GetStockObject(DEFAULT_GUI_FONT), TRUE);

	push	1
	push	17					; 00000011H
	call	DWORD PTR __imp__GetStockObject@4
	push	eax
	push	48					; 00000030H
	mov	ecx, DWORD PTR _hwndTemp$[ebp]
	push	ecx
	call	DWORD PTR __imp__SendMessageW@16

; 632  : 
; 633  :     //-----------------------------------------------------
; 634  :     // exit button
; 635  : 
; 636  :     //hwndTemp = CreateWindow(TEXT("BUTTON"), Str("MainWindow.Exit"),
; 637  :     //    WS_CHILDWINDOW|WS_VISIBLE|WS_TABSTOP|BS_TEXT|BS_PUSHBUTTON|WS_CLIPSIBLINGS,
; 638  :     //    0, 0, 0, 0, hwndMain, (HMENU)ID_EXIT, 0, 0);
; 639  :     //SendMessage(hwndTemp, WM_SETFONT, (WPARAM)GetStockObject(DEFAULT_GUI_FONT), TRUE);
; 640  : 
; 641  :     //-----------------------------------------------------
; 642  :     // scenes text
; 643  : 
; 644  : 	  hwndTemp = CreateWindow(TEXT("STATIC"), Str("MainWindow.Scenes"),
; 645  : 		  WS_CHILDWINDOW|WS_VISIBLE|WS_CLIPSIBLINGS,
; 646  : 		  0, 0, 0, 0, hwndMain, (HMENU)ID_SCENES_TEXT, 0, 0);

	push	0
	push	0
	push	5012					; 00001394H
	mov	edx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	edx
	push	0
	push	0
	push	0
	push	0
	push	1409286144				; 54000000H
	push	OFFSET $SG4294800606
	mov	eax, DWORD PTR __imp_?locale@@3PAVLocaleStringLookup@@A
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR __imp_?LookupString@LocaleStringLookup@@QAEPB_WPB_W@Z
	push	eax
	push	OFFSET $SG4294800605
	push	0
	call	_IsolationAwareCreateWindowExW@48
	mov	DWORD PTR _hwndTemp$[ebp], eax

; 647  : 		  SendMessage(hwndTemp, WM_SETFONT, (WPARAM)GetStockObject(DEFAULT_GUI_FONT), TRUE);

	push	1
	push	17					; 00000011H
	call	DWORD PTR __imp__GetStockObject@4
	push	eax
	push	48					; 00000030H
	mov	ecx, DWORD PTR _hwndTemp$[ebp]
	push	ecx
	call	DWORD PTR __imp__SendMessageW@16

; 648  : 		 // SourceStaticProc = (WNDPROC)GetWindowLongPtr(hwndTemp, GWLP_WNDPROC);
; 649  : 		  SetWindowLongPtr(hwndTemp, GWLP_WNDPROC, (LONG_PTR)OBS::OBSStaticProc);

	push	OFFSET ?OBSStaticProc@OBS@@CGJPAUHWND__@@IIJ@Z ; OBS::OBSStaticProc
	push	-4					; fffffffcH
	mov	edx, DWORD PTR _hwndTemp$[ebp]
	push	edx
	call	DWORD PTR __imp__SetWindowLongW@12

; 650  :     //-----------------------------------------------------
; 651  :     // source text
; 652  : 
; 653  :     hwndTemp = CreateWindow(TEXT("STATIC"), Str("MainWindow.Sources"),
; 654  :         WS_CHILDWINDOW|WS_VISIBLE|WS_CLIPSIBLINGS,
; 655  :         0, 0, 0, 0, hwndMain, (HMENU)ID_SOURCES_TEXT, 0, 0);

	push	0
	push	0
	push	5014					; 00001396H
	mov	eax, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	eax
	push	0
	push	0
	push	0
	push	0
	push	1409286144				; 54000000H
	push	OFFSET $SG4294800604
	mov	ecx, DWORD PTR __imp_?locale@@3PAVLocaleStringLookup@@A
	mov	ecx, DWORD PTR [ecx]
	call	DWORD PTR __imp_?LookupString@LocaleStringLookup@@QAEPB_WPB_W@Z
	push	eax
	push	OFFSET $SG4294800603
	push	0
	call	_IsolationAwareCreateWindowExW@48
	mov	DWORD PTR _hwndTemp$[ebp], eax

; 656  :     SendMessage(hwndTemp, WM_SETFONT, (WPARAM)GetStockObject(DEFAULT_GUI_FONT), TRUE);

	push	1
	push	17					; 00000011H
	call	DWORD PTR __imp__GetStockObject@4
	push	eax
	push	48					; 00000030H
	mov	edx, DWORD PTR _hwndTemp$[ebp]
	push	edx
	call	DWORD PTR __imp__SendMessageW@16

; 657  : 	SourceStaticProc = (WNDPROC)GetWindowLongPtr(hwndTemp, GWLP_WNDPROC);

	push	-4					; fffffffcH
	mov	eax, DWORD PTR _hwndTemp$[ebp]
	push	eax
	call	DWORD PTR __imp__GetWindowLongW@8
	mov	DWORD PTR ?SourceStaticProc@@3P6GJPAUHWND__@@IIJ@ZA, eax ; SourceStaticProc

; 658  : 	SetWindowLongPtr(hwndTemp, GWLP_WNDPROC, (LONG_PTR)OBS::OBSStaticProc);

	push	OFFSET ?OBSStaticProc@OBS@@CGJPAUHWND__@@IIJ@Z ; OBS::OBSStaticProc
	push	-4					; fffffffcH
	mov	ecx, DWORD PTR _hwndTemp$[ebp]
	push	ecx
	call	DWORD PTR __imp__SetWindowLongW@12

; 659  :     //-----------------------------------------------------
; 660  :     // notification area
; 661  : 
; 662  :     bNotificationAreaIcon = false;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1324], 0

; 663  :     wmExplorerRestarted = RegisterWindowMessage(TEXT("TaskbarCreated"));

	push	OFFSET $SG4294800602
	call	DWORD PTR __imp__RegisterWindowMessageW@4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1320], eax

; 664  :     if (AppConfig->GetInt(TEXT("General"), TEXT("ShowNotificationAreaIcon"), 0) != 0)

	push	0
	push	OFFSET $SG4294800601
	push	OFFSET $SG4294800600
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	test	eax, eax
	je	SHORT $LN26@OBS

; 665  :     {
; 666  :         ShowNotificationAreaIcon();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ShowNotificationAreaIcon@OBS@@QAEHXZ	; OBS::ShowNotificationAreaIcon
$LN26@OBS:

; 667  :     }
; 668  : 
; 669  :     //-----------------------------------------------------
; 670  :     // populate scenes
; 671  : 
; 672  :     hwndTemp = GetDlgItem(hwndMain, ID_SCENES);

	push	5011					; 00001393H
	mov	edx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	edx
	call	DWORD PTR __imp__GetDlgItem@8
	mov	DWORD PTR _hwndTemp$[ebp], eax

; 673  : 	// get current collection sence
; 674  :     String collection = GetCurrentSceneCollection();

	call	?GetCurrentSceneCollection@OBS@@SAPB_WXZ ; OBS::GetCurrentSceneCollection
	push	eax
	lea	ecx, DWORD PTR _collection$[ebp]
	call	DWORD PTR __imp_??0String@@QAE@PB_W@Z

; 675  : 
; 676  :     if (!OSFileExists(String() << lpAppDataPath << L"\\sceneCollection\\" << collection << L".xconfig"))

	push	OFFSET $SG4294800598
	lea	eax, DWORD PTR _collection$[ebp]
	push	eax
	push	OFFSET $SG4294800599
	push	OFFSET ?lpAppDataPath@@3PA_WA		; lpAppDataPath
	lea	ecx, DWORD PTR $T6[ebp]
	call	DWORD PTR __imp_??0String@@QAE@XZ
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@ABV0@@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	call	DWORD PTR __imp_?OSFileExists@@YGHPB_W@Z
	test	eax, eax
	jne	SHORT $LN57@OBS
	mov	DWORD PTR tv1112[ebp], 1
	jmp	SHORT $LN58@OBS
$LN57@OBS:
	mov	DWORD PTR tv1112[ebp], 0
$LN58@OBS:
	mov	cl, BYTE PTR tv1112[ebp]
	mov	BYTE PTR $T21[ebp], cl
	lea	ecx, DWORD PTR $T6[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	movzx	edx, BYTE PTR $T21[ebp]
	test	edx, edx
	je	SHORT $LN25@OBS

; 677  :         collection.Clear();

	lea	ecx, DWORD PTR _collection$[ebp]
	call	DWORD PTR __imp_?Clear@String@@QAEAAV1@XZ
$LN25@OBS:

; 678  : 	// if not exist collection file use default scenes.xconfig and copy to //sceneCollection dir
; 679  :     if (collection.IsEmpty())

	lea	ecx, DWORD PTR _collection$[ebp]
	call	DWORD PTR __imp_?IsEmpty@String@@QBEHXZ
	test	eax, eax
	je	$LN24@OBS

; 680  :     {
; 681  :         OSFindData ofd;
; 682  :         HANDLE hFind = OSFindFirstFile(String() << lpAppDataPath << L"\\sceneCollection\\*.xconfig", ofd);

	lea	eax, DWORD PTR _ofd$23[ebp]
	push	eax
	push	OFFSET $SG4294800597
	push	OFFSET ?lpAppDataPath@@3PA_WA		; lpAppDataPath
	lea	ecx, DWORD PTR $T8[ebp]
	call	DWORD PTR __imp_??0String@@QAE@XZ
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	call	DWORD PTR __imp_?OSFindFirstFile@@YGPAXPB_WAAUOSFindData@@@Z
	mov	DWORD PTR _hFind$17[ebp], eax
	lea	ecx, DWORD PTR $T8[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 683  :         if (hFind)

	cmp	DWORD PTR _hFind$17[ebp], 0
	je	SHORT $LN23@OBS
$LN22@OBS:

; 684  :         {
; 685  :             do
; 686  :             {
; 687  :                 if (!ofd.bDirectory)

	cmp	DWORD PTR _ofd$23[ebp+520], 0
	jne	SHORT $LN21@OBS

; 688  :                 {
; 689  :                     collection = GetPathWithoutExtension(ofd.fileName);

	lea	ecx, DWORD PTR _ofd$23[ebp]
	push	ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	call	DWORD PTR __imp_?GetPathWithoutExtension@@YA?AVString@@PB_W@Z
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _collection$[ebp]
	call	DWORD PTR __imp_??4String@@QAEAAV0@ABV0@@Z
	lea	ecx, DWORD PTR $T2[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 690  :                     break;

	jmp	SHORT $LN20@OBS
$LN21@OBS:

; 691  :                 }
; 692  :             } while (OSFindNextFile(hFind, ofd));

	lea	eax, DWORD PTR _ofd$23[ebp]
	push	eax
	mov	ecx, DWORD PTR _hFind$17[ebp]
	push	ecx
	call	DWORD PTR __imp_?OSFindNextFile@@YGHPAXAAUOSFindData@@@Z
	test	eax, eax
	jne	SHORT $LN22@OBS
$LN20@OBS:

; 693  :             OSFindClose(hFind);

	mov	edx, DWORD PTR _hFind$17[ebp]
	push	edx
	call	DWORD PTR __imp_?OSFindClose@@YGXPAX@Z
$LN23@OBS:

; 694  :         }
; 695  : 
; 696  :         if (collection.IsEmpty())

	lea	ecx, DWORD PTR _collection$[ebp]
	call	DWORD PTR __imp_?IsEmpty@String@@QBEHXZ
	test	eax, eax
	je	$LN24@OBS

; 697  :         {
; 698  :             CopyFile(String() << lpAppDataPath << L"\\scenes.xconfig", String() << lpAppDataPath << L"\\sceneCollection\\scenes.xconfig", true);

	push	1
	push	OFFSET $SG4294800596
	push	OFFSET ?lpAppDataPath@@3PA_WA		; lpAppDataPath
	lea	ecx, DWORD PTR $T5[ebp]
	call	DWORD PTR __imp_??0String@@QAE@XZ
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	push	OFFSET $SG4294800595
	push	OFFSET ?lpAppDataPath@@3PA_WA		; lpAppDataPath
	lea	ecx, DWORD PTR $T3[ebp]
	call	DWORD PTR __imp_??0String@@QAE@XZ
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	call	DWORD PTR __imp__CopyFileW@12
	lea	ecx, DWORD PTR $T3[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR $T5[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 699  :             collection = L"scenes";

	push	OFFSET $SG4294800594
	lea	ecx, DWORD PTR _collection$[ebp]
	call	DWORD PTR __imp_??4String@@QAEAAV0@PB_W@Z

; 700  :             GlobalConfig->SetString(L"General", L"SceneCollection", collection);

	lea	ecx, DWORD PTR _collection$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	push	OFFSET $SG4294800593
	push	OFFSET $SG4294800592
	mov	ecx, DWORD PTR ?GlobalConfig@@3PAVConfigFile@@A ; GlobalConfig
	call	DWORD PTR __imp_?SetString@ConfigFile@@QAEXPB_W00@Z
$LN24@OBS:

; 701  :         }
; 702  :     }
; 703  : 
; 704  :     String strScenesConfig;

	lea	ecx, DWORD PTR _strScenesConfig$[ebp]
	call	DWORD PTR __imp_??0String@@QAE@XZ

; 705  :     strScenesConfig = FormattedString(L"%s\\sceneCollection\\%s.xconfig", lpAppDataPath, collection.Array());

	lea	ecx, DWORD PTR _collection$[ebp]
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	push	OFFSET ?lpAppDataPath@@3PA_WA		; lpAppDataPath
	push	OFFSET $SG4294800591
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	DWORD PTR __imp_?FormattedString@@YA?AVString@@PB_WZZ
	add	esp, 16					; 00000010H
	push	eax
	lea	ecx, DWORD PTR _strScenesConfig$[ebp]
	call	DWORD PTR __imp_??4String@@QAEAAV0@ABV0@@Z
	lea	ecx, DWORD PTR $T1[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 706  : 
; 707  :     if(!scenesConfig.Open(strScenesConfig))

	lea	ecx, DWORD PTR _strScenesConfig$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 168				; 000000a8H
	call	DWORD PTR __imp_?Open@XConfig@@QAE_NPB_W@Z
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN17@OBS

; 708  :         CrashError(TEXT("Could not open '%s'"), strScenesConfig.Array());

	lea	ecx, DWORD PTR _strScenesConfig$[ebp]
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	push	OFFSET $SG4294800590
	call	DWORD PTR __imp_?CrashError@@YAXPB_WZZ
$LN17@OBS:

; 709  : 	// get root node scenes
; 710  :     XElement *scenes = scenesConfig.GetElement(TEXT("scenes"));

	push	OFFSET $SG4294800589
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 168				; 000000a8H
	call	DWORD PTR __imp_?GetElement@XConfig@@QAEPAVXElement@@PB_W@Z
	mov	DWORD PTR _scenes$[ebp], eax

; 711  :     if(!scenes)

	cmp	DWORD PTR _scenes$[ebp], 0
	jne	SHORT $LN16@OBS

; 712  :         scenes = scenesConfig.CreateElement(TEXT("scenes"));

	push	OFFSET $SG4294800588
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 168				; 000000a8H
	call	DWORD PTR __imp_?CreateElement@XConfig@@QAEPAVXElement@@PB_W@Z
	mov	DWORD PTR _scenes$[ebp], eax
$LN16@OBS:

; 713  : 
; 714  :     UINT numScenes = scenes->NumElements();

	push	0
	mov	ecx, DWORD PTR _scenes$[ebp]
	call	DWORD PTR __imp_?NumElements@XElement@@QAEKPB_W@Z
	mov	DWORD PTR _numScenes$[ebp], eax

; 715  :     if(!numScenes)

	cmp	DWORD PTR _numScenes$[ebp], 0
	jne	SHORT $LN15@OBS

; 716  :     {
; 717  :         XElement *scene = scenes->CreateElement(Str("Scene"));

	push	OFFSET $SG4294800587
	mov	edx, DWORD PTR __imp_?locale@@3PAVLocaleStringLookup@@A
	mov	ecx, DWORD PTR [edx]
	call	DWORD PTR __imp_?LookupString@LocaleStringLookup@@QAEPB_WPB_W@Z
	push	eax
	mov	ecx, DWORD PTR _scenes$[ebp]
	call	DWORD PTR __imp_?CreateElement@XElement@@QAEPAV1@PB_W@Z
	mov	DWORD PTR _scene$12[ebp], eax

; 718  :         scene->SetString(TEXT("class"), TEXT("Scene"));

	push	OFFSET $SG4294800586
	push	OFFSET $SG4294800585
	mov	ecx, DWORD PTR _scene$12[ebp]
	call	DWORD PTR __imp_?SetString@XElement@@QAEXPB_W0@Z

; 719  :         numScenes++;

	mov	eax, DWORD PTR _numScenes$[ebp]
	add	eax, 1
	mov	DWORD PTR _numScenes$[ebp], eax
$LN15@OBS:

; 720  :     }
; 721  : 
; 722  :     for(UINT i=0; i<numScenes; i++)

	mov	DWORD PTR _i$18[ebp], 0
	jmp	SHORT $LN14@OBS
$LN13@OBS:
	mov	ecx, DWORD PTR _i$18[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$18[ebp], ecx
$LN14@OBS:
	mov	edx, DWORD PTR _i$18[ebp]
	cmp	edx, DWORD PTR _numScenes$[ebp]
	jae	SHORT $LN12@OBS

; 723  :     {
; 724  :         XElement *scene = scenes->GetElementByID(i);

	mov	eax, DWORD PTR _i$18[ebp]
	push	eax
	mov	ecx, DWORD PTR _scenes$[ebp]
	call	DWORD PTR __imp_?GetElementByID@XElement@@QBEPAV1@K@Z
	mov	DWORD PTR _scene$11[ebp], eax

; 725  :         SendMessage(hwndTemp, LB_ADDSTRING, 0, (LPARAM)scene->GetName());

	mov	ecx, DWORD PTR _scene$11[ebp]
	call	DWORD PTR __imp_?GetName@XBaseItem@@QBEPB_WXZ
	push	eax
	push	0
	push	384					; 00000180H
	mov	ecx, DWORD PTR _hwndTemp$[ebp]
	push	ecx
	call	DWORD PTR __imp__SendMessageW@16

; 726  :     }

	jmp	SHORT $LN13@OBS
$LN12@OBS:

; 727  : 
; 728  :     //-----------------------------------------------------
; 729  :     // populate sources
; 730  : 
; 731  :     if(numScenes)

	cmp	DWORD PTR _numScenes$[ebp], 0
	je	$LN11@OBS

; 732  :     {
; 733  :         String strScene = AppConfig->GetString(TEXT("General"), TEXT("CurrentScene"));

	push	0
	push	OFFSET $SG4294800584
	push	OFFSET $SG4294800583
	lea	edx, DWORD PTR _strScene$9[ebp]
	push	edx
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetString@ConfigFile@@QAE?AVString@@PB_W00@Z

; 734  :         int id = (int)SendMessage(hwndTemp, LB_FINDSTRINGEXACT, -1, (LPARAM)strScene.Array());

	lea	ecx, DWORD PTR _strScene$9[ebp]
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	push	-1
	push	418					; 000001a2H
	mov	eax, DWORD PTR _hwndTemp$[ebp]
	push	eax
	call	DWORD PTR __imp__SendMessageW@16
	mov	DWORD PTR _id$14[ebp], eax

; 735  :         if(id == LB_ERR)

	cmp	DWORD PTR _id$14[ebp], -1
	jne	SHORT $LN10@OBS

; 736  :             id = 0;

	mov	DWORD PTR _id$14[ebp], 0
$LN10@OBS:

; 737  : 
; 738  :         SendMessage(hwndTemp, LB_SETCURSEL, (WPARAM)id, 0);

	push	0
	mov	ecx, DWORD PTR _id$14[ebp]
	push	ecx
	push	390					; 00000186H
	mov	edx, DWORD PTR _hwndTemp$[ebp]
	push	edx
	call	DWORD PTR __imp__SendMessageW@16

; 739  : 		// over message to populate sources info
; 740  :         SendMessage(hwndMain, WM_COMMAND, MAKEWPARAM(ID_SCENES, LBN_SELCHANGE), (LPARAM)GetDlgItem(hwndMain, ID_SCENES));

	push	5011					; 00001393H
	mov	eax, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	eax
	call	DWORD PTR __imp__GetDlgItem@8
	push	eax
	push	70547					; 00011393H
	push	273					; 00000111H
	mov	ecx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	ecx
	call	DWORD PTR __imp__SendMessageW@16

; 741  :     }

	lea	ecx, DWORD PTR _strScene$9[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
$LN11@OBS:

; 742  : 
; 743  : 
; 744  :     //-----------------------------------------------------
; 745  : 
; 746  :     hHotkeyMutex = OSCreateMutex();

	call	DWORD PTR __imp_?OSCreateMutex@@YGPAXXZ
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1232], eax

; 747  :     hInfoMutex = OSCreateMutex();

	call	DWORD PTR __imp_?OSCreateMutex@@YGPAXXZ
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1384], eax

; 748  :     hStartupShutdownMutex = OSCreateMutex();

	call	DWORD PTR __imp_?OSCreateMutex@@YGPAXXZ
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1400], eax

; 749  : 
; 750  :     //-----------------------------------------------------
; 751  : 	//OBSAPI.CPPzh  
; 752  :     API = CreateOBSApiInterface();

	call	?CreateOBSApiInterface@@YAPAVAPIInterface@@XZ ; CreateOBSApiInterface
	mov	ecx, DWORD PTR __imp_?API@@3PAVAPIInterface@@A
	mov	DWORD PTR [ecx], eax

; 753  : 
; 754  :     bDragResize = false;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+692], 0

; 755  : 
; 756  : 	//
; 757  :     //if(GlobalConfig->GetInt(TEXT("General"), TEXT("Maximized")))
; 758  :     //{ // Window was maximized last session
; 759  :     //    SendMessage(hwndMain, WM_SYSCOMMAND, SC_MAXIMIZE, 0);
; 760  :     //}
; 761  : 
; 762  :     //-----------------------------------------------------
; 763  : 
; 764  :     for(UINT i=0; i<numScenes; i++)

	mov	DWORD PTR _i$19[ebp], 0
	jmp	SHORT $LN9@OBS
$LN8@OBS:
	mov	eax, DWORD PTR _i$19[ebp]
	add	eax, 1
	mov	DWORD PTR _i$19[ebp], eax
$LN9@OBS:
	mov	ecx, DWORD PTR _i$19[ebp]
	cmp	ecx, DWORD PTR _numScenes$[ebp]
	jae	$LN7@OBS

; 765  :     {
; 766  :         XElement *scene = scenes->GetElementByID(i);

	mov	edx, DWORD PTR _i$19[ebp]
	push	edx
	mov	ecx, DWORD PTR _scenes$[ebp]
	call	DWORD PTR __imp_?GetElementByID@XElement@@QBEPAV1@K@Z
	mov	DWORD PTR _scene$13[ebp], eax

; 767  :         DWORD hotkey = scene->GetInt(TEXT("hotkey"));

	push	0
	push	OFFSET $SG4294800582
	mov	ecx, DWORD PTR _scene$13[ebp]
	call	DWORD PTR __imp_?GetInt@XElement@@QBEHPB_WH@Z
	mov	DWORD PTR _hotkey$16[ebp], eax

; 768  :         if(hotkey)

	cmp	DWORD PTR _hotkey$16[ebp], 0
	je	SHORT $LN6@OBS

; 769  :         {
; 770  :             SceneHotkeyInfo hotkeyInfo;
; 771  :             hotkeyInfo.hotkey = hotkey;

	mov	eax, DWORD PTR _hotkey$16[ebp]
	mov	DWORD PTR _hotkeyInfo$10[ebp+4], eax

; 772  :             hotkeyInfo.scene = scene;

	mov	ecx, DWORD PTR _scene$13[ebp]
	mov	DWORD PTR _hotkeyInfo$10[ebp+8], ecx

; 773  :             hotkeyInfo.hotkeyID = API->CreateHotkey(hotkey, SceneHotkey, 0);

	push	0
	push	OFFSET ?SceneHotkey@@YGXKK_N@Z		; SceneHotkey
	mov	edx, DWORD PTR _hotkey$16[ebp]
	push	edx
	mov	eax, DWORD PTR __imp_?API@@3PAVAPIInterface@@A
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __imp_?API@@3PAVAPIInterface@@A
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR [eax+52]
	call	edx
	mov	DWORD PTR _hotkeyInfo$10[ebp], eax

; 774  : 
; 775  :             if(hotkeyInfo.hotkeyID)

	cmp	DWORD PTR _hotkeyInfo$10[ebp], 0
	je	SHORT $LN6@OBS

; 776  :                 sceneHotkeys << hotkeyInfo;

	lea	eax, DWORD PTR _hotkeyInfo$10[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 204				; 000000ccH
	call	??6?$List@USceneHotkeyInfo@@@@QAEAAV0@ABUSceneHotkeyInfo@@@Z ; List<SceneHotkeyInfo>::operator<<
$LN6@OBS:

; 777  :         }
; 778  :     }

	jmp	$LN8@OBS
$LN7@OBS:

; 783  :     currentSettingsPane = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+240], 0

; 784  :     AddBuiltInSettingsPanes();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddBuiltInSettingsPanes@OBS@@AAEXXZ	; OBS::AddBuiltInSettingsPanes

; 785  :     AddEncoderSettingsPanes();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddEncoderSettingsPanes@OBS@@AAEXXZ	; OBS::AddEncoderSettingsPanes

; 786  : 
; 787  :     //-----------------------------------------------------
; 788  : 
; 789  :     ReloadIniSettings();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReloadIniSettings@OBS@@AAEXXZ		; OBS::ReloadIniSettings

; 790  :     //ResetProfileMenu();
; 791  :     //ResetSceneCollectionMenu();
; 792  :     //ResetLogUploadMenu();
; 793  : 
; 794  :     //-----------------------------------------------------
; 795  : 
; 796  :     bAutoReconnect = AppConfig->GetInt(TEXT("Publish"), TEXT("AutoReconnect"), 1) != 0;

	push	1
	push	OFFSET $SG4294800581
	push	OFFSET $SG4294800580
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	test	eax, eax
	je	SHORT $LN59@OBS
	mov	DWORD PTR tv1416[ebp], 1
	jmp	SHORT $LN60@OBS
$LN59@OBS:
	mov	DWORD PTR tv1416[ebp], 0
$LN60@OBS:
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR tv1416[ebp]
	mov	BYTE PTR [edx+695], al

; 797  :     reconnectTimeout = AppConfig->GetInt(TEXT("Publish"), TEXT("AutoReconnectTimeout"), 10);

	push	10					; 0000000aH
	push	OFFSET $SG4294800579
	push	OFFSET $SG4294800578
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+700], eax

; 798  : 
; 799  :     hHotkeyThread = OSCreateThread((XTHREAD)HotkeyThread, NULL);

	push	0
	push	OFFSET ?HotkeyThread@OBS@@CGKPAX@Z	; OBS::HotkeyThread
	call	DWORD PTR __imp_?OSCreateThread@@YGPAXP6GKPAX@Z0@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1236], eax

; 800  : 
; 801  : #ifndef OBS_DISABLE_AUTOUPDATE
; 802  :     ULARGE_INTEGER lastUpdateTime;
; 803  :     ULARGE_INTEGER currentTime;
; 804  :     FILETIME systemTime;
; 805  : 
; 806  :     lastUpdateTime.QuadPart = GlobalConfig->GetInt(TEXT("General"), OBS_CONFIG_UPDATE_KEY, 0);

	push	0
	push	OFFSET $SG4294800577
	push	OFFSET $SG4294800576
	mov	ecx, DWORD PTR ?GlobalConfig@@3PAVConfigFile@@A ; GlobalConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	cdq
	mov	DWORD PTR _lastUpdateTime$[ebp], eax
	mov	DWORD PTR _lastUpdateTime$[ebp+4], edx

; 807  : 
; 808  :     GetSystemTimeAsFileTime(&systemTime);

	lea	eax, DWORD PTR _systemTime$[ebp]
	push	eax
	call	DWORD PTR __imp__GetSystemTimeAsFileTime@4

; 809  :     currentTime.LowPart = systemTime.dwLowDateTime;

	mov	ecx, DWORD PTR _systemTime$[ebp]
	mov	DWORD PTR _currentTime$[ebp], ecx

; 810  :     currentTime.HighPart = systemTime.dwHighDateTime;

	mov	edx, DWORD PTR _systemTime$[ebp+4]
	mov	DWORD PTR _currentTime$[ebp+4], edx

; 811  : 
; 812  :     //OBS doesn't support 64 bit ints in the config file, so we have to normalize it to a 32 bit int
; 813  :     currentTime.QuadPart /= 10000000;

	push	0
	push	10000000				; 00989680H
	mov	eax, DWORD PTR _currentTime$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _currentTime$[ebp]
	push	ecx
	call	__aulldiv
	mov	DWORD PTR _currentTime$[ebp], eax
	mov	DWORD PTR _currentTime$[ebp+4], edx

; 814  :     currentTime.QuadPart -= 13000000000;

	mov	edx, DWORD PTR _currentTime$[ebp]
	sub	edx, 115098112				; 06dc4200H
	mov	eax, DWORD PTR _currentTime$[ebp+4]
	sbb	eax, 3
	mov	DWORD PTR _currentTime$[ebp], edx
	mov	DWORD PTR _currentTime$[ebp+4], eax

; 815  : 
; 816  :     if (currentTime.QuadPart - lastUpdateTime.QuadPart >= 3600)

	mov	ecx, DWORD PTR _currentTime$[ebp]
	sub	ecx, DWORD PTR _lastUpdateTime$[ebp]
	mov	edx, DWORD PTR _currentTime$[ebp+4]
	sbb	edx, DWORD PTR _lastUpdateTime$[ebp+4]
	mov	DWORD PTR tv1976[ebp], ecx
	mov	DWORD PTR tv1976[ebp+4], edx
	cmp	DWORD PTR tv1976[ebp+4], 0
	ja	SHORT $LN69@OBS
	cmp	DWORD PTR tv1976[ebp], 3600		; 00000e10H
	jb	SHORT $LN4@OBS
$LN69@OBS:

; 817  :     {
; 818  :         GlobalConfig->SetInt(TEXT("General"), OBS_CONFIG_UPDATE_KEY, (int)currentTime.QuadPart);

	mov	eax, DWORD PTR _currentTime$[ebp]
	push	eax
	push	OFFSET $SG4294800575
	push	OFFSET $SG4294800574
	mov	ecx, DWORD PTR ?GlobalConfig@@3PAVConfigFile@@A ; GlobalConfig
	call	DWORD PTR __imp_?SetInt@ConfigFile@@QAEXPB_W0H@Z
$LN4@OBS:

; 819  :       //  OSCloseThread(OSCreateThread((XTHREAD)CheckUpdateThread, (LPVOID)0));
; 820  :     }
; 821  : #endif
; 822  : 
; 823  :     // TODO: Should these be stored in the config file?
; 824  :     bRenderViewEnabled = GlobalConfig->GetInt(TEXT("General"), TEXT("PreviewEnabled"), 1) != 0;

	push	1
	push	OFFSET $SG4294800573
	push	OFFSET $SG4294800572
	mov	ecx, DWORD PTR ?GlobalConfig@@3PAVConfigFile@@A ; GlobalConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	test	eax, eax
	je	SHORT $LN61@OBS
	mov	DWORD PTR tv1483[ebp], 1
	jmp	SHORT $LN62@OBS
$LN61@OBS:
	mov	DWORD PTR tv1483[ebp], 0
$LN62@OBS:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR tv1483[ebp]
	mov	BYTE PTR [ecx+742], dl

; 825  : 	
; 826  :     bForceRenderViewErase = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+743], 0

; 827  :     renderFrameIn1To1Mode = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+668], 0

; 828  : 
; 829  :     if(GlobalConfig->GetInt(TEXT("General"), TEXT("ShowWebrootWarning"), TRUE) && IsWebrootLoaded())

	push	1
	push	OFFSET $SG4294800571
	push	OFFSET $SG4294800570
	mov	ecx, DWORD PTR ?GlobalConfig@@3PAVConfigFile@@A ; GlobalConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	test	eax, eax
	je	SHORT $LN3@OBS
	call	?IsWebrootLoaded@@YAHXZ			; IsWebrootLoaded
	test	eax, eax
	je	SHORT $LN3@OBS

; 830  :         OBSMessageBox(hwndMain, TEXT("Webroot Secureanywhere appears to be active.  This product will cause problems with OBS as the security features block OBS from accessing Windows GDI functions.  It is highly recommended that you disable Secureanywhere and restart OBS.\r\n\r\nOf course you can always just ignore this message if you want, but it may prevent you from being able to stream certain things. Please do not report any bugs you may encounter if you leave Secureanywhere enabled."), TEXT("Just a slight issue you might want to be aware of"), MB_OK);

	push	0
	push	OFFSET $SG4294800569
	push	OFFSET $SG4294800568
	mov	edx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	edx
	call	DWORD PTR __imp_?OBSMessageBox@@YAHPAUHWND__@@PB_W1I@Z
	add	esp, 16					; 00000010H
$LN3@OBS:

; 831  : 
; 832  :     CheckPermissionsAndDiskSpace();

	call	?CheckPermissionsAndDiskSpace@@YAXXZ	; CheckPermissionsAndDiskSpace

; 833  : 
; 834  : 	//
; 835  : 	InitLayOut();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?InitLayOut@OBS@@AAEXXZ			; OBS::InitLayOut

; 836  :  
; 837  : 
; 838  :     renderFrameIn1To1Mode = !!GlobalConfig->GetInt(L"General", L"1to1Preview", false);

	push	0
	push	OFFSET $SG4294800567
	push	OFFSET $SG4294800566
	mov	ecx, DWORD PTR ?GlobalConfig@@3PAVConfigFile@@A ; GlobalConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	test	eax, eax
	je	SHORT $LN63@OBS
	mov	DWORD PTR tv1507[ebp], 1
	jmp	SHORT $LN64@OBS
$LN63@OBS:
	mov	DWORD PTR tv1507[ebp], 0
$LN64@OBS:
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR tv1507[ebp]
	mov	BYTE PTR [eax+668], cl

; 839  : 
; 840  :     App->bAlwaysOnTop = !!GlobalConfig->GetInt(L"General", L"AlwaysOnTop");

	push	0
	push	OFFSET $SG4294800565
	push	OFFSET $SG4294800564
	mov	ecx, DWORD PTR ?GlobalConfig@@3PAVConfigFile@@A ; GlobalConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	test	eax, eax
	je	SHORT $LN65@OBS
	mov	DWORD PTR tv1516[ebp], 1
	jmp	SHORT $LN66@OBS
$LN65@OBS:
	mov	DWORD PTR tv1516[ebp], 0
$LN66@OBS:
	mov	edx, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	al, BYTE PTR tv1516[ebp]
	mov	BYTE PTR [edx+706], al

; 841  :     //CheckMenuItem(GetMenu(hwndMain), ID_ALWAYSONTOP, (App->bAlwaysOnTop) ? MF_CHECKED : MF_UNCHECKED);
; 842  :     SetWindowPos(hwndMain, (App->bAlwaysOnTop) ? HWND_TOPMOST : HWND_NOTOPMOST, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE);

	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	movzx	edx, BYTE PTR [ecx+706]
	test	edx, edx
	je	SHORT $LN67@OBS
	mov	DWORD PTR tv1527[ebp], -1
	jmp	SHORT $LN68@OBS
$LN67@OBS:
	mov	DWORD PTR tv1527[ebp], -2		; fffffffeH
$LN68@OBS:
	push	3
	push	0
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR tv1527[ebp]
	push	eax
	mov	ecx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	ecx
	call	DWORD PTR __imp__SetWindowPos@28

; 843  : 
; 844  :     // make sure sources listview column widths are as expected after obs window is shown
; 845  : 
; 846  :     ListView_SetColumnWidth(hwndSources,0,LVSCW_AUTOSIZE_USEHEADER);

	push	65534					; 0000fffeH
	push	0
	push	4126					; 0000101eH
	mov	edx, DWORD PTR _hwndSources$[ebp]
	push	edx
	call	DWORD PTR __imp__SendMessageW@16

; 847  :     ListView_SetColumnWidth(hwndSources,1,LVSCW_AUTOSIZE_USEHEADER);

	push	65534					; 0000fffeH
	push	1
	push	4126					; 0000101eH
	mov	eax, DWORD PTR _hwndSources$[ebp]
	push	eax
	call	DWORD PTR __imp__SendMessageW@16

; 848  : 
; 849  : 	// show log window
; 850  :     if (GlobalConfig->GetInt(L"General", L"ShowLogWindowOnLaunch") != 0)

	push	0
	push	OFFSET $SG4294800563
	push	OFFSET $SG4294800562
	mov	ecx, DWORD PTR ?GlobalConfig@@3PAVConfigFile@@A ; GlobalConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	test	eax, eax
	je	SHORT $LN2@OBS

; 851  :         PostMessage(hwndMain, WM_COMMAND, MAKEWPARAM(ID_SHOWLOG, 0), 0);

	push	0
	push	40067					; 00009c83H
	push	273					; 00000111H
	mov	ecx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	ecx
	call	DWORD PTR __imp__PostMessageW@16
$LN2@OBS:

; 852  : 
; 853  : 	if (bStreamOnStart){

	movzx	edx, BYTE PTR ?bStreamOnStart@@3_NA	; bStreamOnStart
	test	edx, edx
	je	SHORT $LN1@OBS

; 854  : 		SendMessage(hwndMain, WM_COMMAND, MAKEWPARAM(ID_STARTSTOP, 0), NULL);

	push	0
	push	5003					; 0000138bH
	push	273					; 00000111H
	mov	eax, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	eax
	call	DWORD PTR __imp__SendMessageW@16
$LN1@OBS:

; 855  : 	} 
; 856  : 	
; 857  : }

	lea	ecx, DWORD PTR _strScenesConfig$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _collection$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
$LN50@OBS:
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
??0OBS@@QAE@XZ ENDP					; OBS::OBS
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.cpp
;	COMDAT ?LoadAllPlugins@OBS@@QAEXXZ
_TEXT	SEGMENT
_message$1 = -584					; size = 8
_this$ = -576						; size = 4
_strLocation$2 = -572					; size = 8
_loadPluginEx$3 = -564					; size = 4
tv128 = -560						; size = 4
_err$4 = -556						; size = 4
_loadPlugin$5 = -552					; size = 4
_hFind$ = -548						; size = 4
_bLoaded$6 = -541					; size = 1
_pluginInfo$7 = -540					; size = 4
_hPlugin$8 = -536					; size = 4
_ofd$ = -532						; size = 528
__$ArrayPad$ = -4					; size = 4
?LoadAllPlugins@OBS@@QAEXXZ PROC			; OBS::LoadAllPlugins, COMDAT
; _this$ = ecx

; 166  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 584				; 00000248H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 167  :     //-----------------------------------------------------
; 168  :     // load plugins
; 169  : 
; 170  :     OSFindData ofd;
; 171  :     HANDLE hFind = OSFindFirstFile(TEXT("plugins/*.dll"), ofd);

	lea	eax, DWORD PTR _ofd$[ebp]
	push	eax
	push	OFFSET $SG4294800701
	call	DWORD PTR __imp_?OSFindFirstFile@@YGPAXPB_WAAUOSFindData@@@Z
	mov	DWORD PTR _hFind$[ebp], eax

; 172  :     if (hFind)

	cmp	DWORD PTR _hFind$[ebp], 0
	je	$LN13@LoadAllPlu
$LN11@LoadAllPlu:

; 173  :     {
; 174  :         do
; 175  :         {
; 176  :             if (!ofd.bDirectory) //why would someone give a directory a .dll extension in the first place?  pranksters.

	cmp	DWORD PTR _ofd$[ebp+520], 0
	jne	$LN10@LoadAllPlu

; 177  :             {
; 178  :                 String strLocation;

	lea	ecx, DWORD PTR _strLocation$2[ebp]
	call	DWORD PTR __imp_??0String@@QAE@XZ

; 179  :                 strLocation << TEXT("plugins/") << ofd.fileName;

	lea	ecx, DWORD PTR _ofd$[ebp]
	push	ecx
	push	OFFSET $SG4294800700
	lea	ecx, DWORD PTR _strLocation$2[ebp]
	call	DWORD PTR __imp_??6String@@QAEAAV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@PB_W@Z

; 180  : 
; 181  :                 HMODULE hPlugin = LoadLibrary(strLocation);

	lea	ecx, DWORD PTR _strLocation$2[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	call	_IsolationAwareLoadLibraryW@4
	mov	DWORD PTR _hPlugin$8[ebp], eax

; 182  :                 if (hPlugin)

	cmp	DWORD PTR _hPlugin$8[ebp], 0
	je	$LN7@LoadAllPlu

; 183  :                 {
; 184  :                     bool bLoaded = false;

	mov	BYTE PTR _bLoaded$6[ebp], 0

; 185  : 
; 186  :                     //slightly redundant I suppose seeing as both these things are being added at the same time
; 187  :                     LOADPLUGINEXPROC loadPluginEx = (LOADPLUGINEXPROC)GetProcAddress(hPlugin, "LoadPluginEx");

	push	OFFSET $SG4294800699
	mov	edx, DWORD PTR _hPlugin$8[ebp]
	push	edx
	call	DWORD PTR __imp__GetProcAddress@8
	mov	DWORD PTR _loadPluginEx$3[ebp], eax

; 188  :                     if (loadPluginEx) {

	cmp	DWORD PTR _loadPluginEx$3[ebp], 0
	je	SHORT $LN6@LoadAllPlu

; 189  :                         bLoaded = loadPluginEx(OBSGetAPIVersion());

	call	DWORD PTR __imp_?OBSGetAPIVersion@@YAIXZ
	push	eax
	call	DWORD PTR _loadPluginEx$3[ebp]
	add	esp, 4
	mov	BYTE PTR _bLoaded$6[ebp], al

; 190  :                     }
; 191  :                     else {

	jmp	SHORT $LN5@LoadAllPlu
$LN6@LoadAllPlu:

; 192  :                         LOADPLUGINPROC loadPlugin = (LOADPLUGINPROC)GetProcAddress(hPlugin, "LoadPlugin");

	push	OFFSET $SG4294800698
	mov	eax, DWORD PTR _hPlugin$8[ebp]
	push	eax
	call	DWORD PTR __imp__GetProcAddress@8
	mov	DWORD PTR _loadPlugin$5[ebp], eax

; 193  :                         bLoaded = loadPlugin && loadPlugin();

	cmp	DWORD PTR _loadPlugin$5[ebp], 0
	je	SHORT $LN15@LoadAllPlu
	call	DWORD PTR _loadPlugin$5[ebp]
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN15@LoadAllPlu
	mov	DWORD PTR tv128[ebp], 1
	jmp	SHORT $LN16@LoadAllPlu
$LN15@LoadAllPlu:
	mov	DWORD PTR tv128[ebp], 0
$LN16@LoadAllPlu:
	mov	dl, BYTE PTR tv128[ebp]
	mov	BYTE PTR _bLoaded$6[ebp], dl
$LN5@LoadAllPlu:

; 194  :                     }
; 195  : 
; 196  :                     if (bLoaded) {

	movzx	eax, BYTE PTR _bLoaded$6[ebp]
	test	eax, eax
	je	$LN4@LoadAllPlu

; 197  :                         PluginInfo *pluginInfo = plugins.CreateNew();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1404				; 0000057cH
	call	?CreateNew@?$List@UPluginInfo@@@@QAEPAUPluginInfo@@XZ ; List<PluginInfo>::CreateNew
	mov	DWORD PTR _pluginInfo$7[ebp], eax

; 198  :                         pluginInfo->hModule = hPlugin;

	mov	ecx, DWORD PTR _pluginInfo$7[ebp]
	mov	edx, DWORD PTR _hPlugin$8[ebp]
	mov	DWORD PTR [ecx+8], edx

; 199  :                         pluginInfo->strFile = ofd.fileName;

	lea	eax, DWORD PTR _ofd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pluginInfo$7[ebp]
	call	DWORD PTR __imp_??4String@@QAEAAV0@PB_W@Z

; 200  : 
; 201  :                         /* get event callbacks for the plugin */
; 202  :                         pluginInfo->startStreamCallback = (OBS_CALLBACK)GetProcAddress(hPlugin, "OnStartStream");

	push	OFFSET $SG4294800697
	mov	ecx, DWORD PTR _hPlugin$8[ebp]
	push	ecx
	call	DWORD PTR __imp__GetProcAddress@8
	mov	edx, DWORD PTR _pluginInfo$7[ebp]
	mov	DWORD PTR [edx+12], eax

; 203  :                         pluginInfo->stopStreamCallback = (OBS_CALLBACK)GetProcAddress(hPlugin, "OnStopStream");

	push	OFFSET $SG4294800696
	mov	eax, DWORD PTR _hPlugin$8[ebp]
	push	eax
	call	DWORD PTR __imp__GetProcAddress@8
	mov	ecx, DWORD PTR _pluginInfo$7[ebp]
	mov	DWORD PTR [ecx+16], eax

; 204  :                         pluginInfo->startStreamingCallback = (OBS_CALLBACK)GetProcAddress(hPlugin, "OnStartStreaming");

	push	OFFSET $SG4294800695
	mov	edx, DWORD PTR _hPlugin$8[ebp]
	push	edx
	call	DWORD PTR __imp__GetProcAddress@8
	mov	ecx, DWORD PTR _pluginInfo$7[ebp]
	mov	DWORD PTR [ecx+20], eax

; 205  :                         pluginInfo->stopStreamingCallback = (OBS_CALLBACK)GetProcAddress(hPlugin, "OnStopStreaming");

	push	OFFSET $SG4294800694
	mov	edx, DWORD PTR _hPlugin$8[ebp]
	push	edx
	call	DWORD PTR __imp__GetProcAddress@8
	mov	ecx, DWORD PTR _pluginInfo$7[ebp]
	mov	DWORD PTR [ecx+24], eax

; 206  :                         pluginInfo->startRecordingCallback = (OBS_CALLBACK)GetProcAddress(hPlugin, "OnStartRecording");

	push	OFFSET $SG4294800693
	mov	edx, DWORD PTR _hPlugin$8[ebp]
	push	edx
	call	DWORD PTR __imp__GetProcAddress@8
	mov	ecx, DWORD PTR _pluginInfo$7[ebp]
	mov	DWORD PTR [ecx+28], eax

; 207  :                         pluginInfo->stopRecordingCallback = (OBS_CALLBACK)GetProcAddress(hPlugin, "OnStopRecording");

	push	OFFSET $SG4294800692
	mov	edx, DWORD PTR _hPlugin$8[ebp]
	push	edx
	call	DWORD PTR __imp__GetProcAddress@8
	mov	ecx, DWORD PTR _pluginInfo$7[ebp]
	mov	DWORD PTR [ecx+32], eax

; 208  :                         pluginInfo->statusCallback = (OBS_STATUS_CALLBACK)GetProcAddress(hPlugin, "OnOBSStatus");

	push	OFFSET $SG4294800691
	mov	edx, DWORD PTR _hPlugin$8[ebp]
	push	edx
	call	DWORD PTR __imp__GetProcAddress@8
	mov	ecx, DWORD PTR _pluginInfo$7[ebp]
	mov	DWORD PTR [ecx+48], eax

; 209  :                         pluginInfo->streamStatusCallback = (OBS_STREAM_STATUS_CALLBACK)GetProcAddress(hPlugin, "OnStreamStatus");

	push	OFFSET $SG4294800690
	mov	edx, DWORD PTR _hPlugin$8[ebp]
	push	edx
	call	DWORD PTR __imp__GetProcAddress@8
	mov	ecx, DWORD PTR _pluginInfo$7[ebp]
	mov	DWORD PTR [ecx+52], eax

; 210  :                         pluginInfo->sceneSwitchCallback = (OBS_SCENE_SWITCH_CALLBACK)GetProcAddress(hPlugin, "OnSceneSwitch");

	push	OFFSET $SG4294800689
	mov	edx, DWORD PTR _hPlugin$8[ebp]
	push	edx
	call	DWORD PTR __imp__GetProcAddress@8
	mov	ecx, DWORD PTR _pluginInfo$7[ebp]
	mov	DWORD PTR [ecx+56], eax

; 211  :                         pluginInfo->sceneCollectionSwitchCallback = (OBS_SCENE_SWITCH_CALLBACK)GetProcAddress(hPlugin, "OnSceneCollectionSwitch");

	push	OFFSET $SG4294800688
	mov	edx, DWORD PTR _hPlugin$8[ebp]
	push	edx
	call	DWORD PTR __imp__GetProcAddress@8
	mov	ecx, DWORD PTR _pluginInfo$7[ebp]
	mov	DWORD PTR [ecx+60], eax

; 212  :                         pluginInfo->scenesChangedCallback = (OBS_CALLBACK)GetProcAddress(hPlugin, "OnScenesChanged");

	push	OFFSET $SG4294800687
	mov	edx, DWORD PTR _hPlugin$8[ebp]
	push	edx
	call	DWORD PTR __imp__GetProcAddress@8
	mov	ecx, DWORD PTR _pluginInfo$7[ebp]
	mov	DWORD PTR [ecx+64], eax

; 213  :                         pluginInfo->sceneCollectionsChangedCallback = (OBS_CALLBACK)GetProcAddress(hPlugin, "OnSceneCollectionsChanged");

	push	OFFSET $SG4294800686
	mov	edx, DWORD PTR _hPlugin$8[ebp]
	push	edx
	call	DWORD PTR __imp__GetProcAddress@8
	mov	ecx, DWORD PTR _pluginInfo$7[ebp]
	mov	DWORD PTR [ecx+68], eax

; 214  :                         pluginInfo->sourceOrderChangedCallback = (OBS_CALLBACK)GetProcAddress(hPlugin, "OnSourceOrderChanged");

	push	OFFSET $SG4294800685
	mov	edx, DWORD PTR _hPlugin$8[ebp]
	push	edx
	call	DWORD PTR __imp__GetProcAddress@8
	mov	ecx, DWORD PTR _pluginInfo$7[ebp]
	mov	DWORD PTR [ecx+72], eax

; 215  :                         pluginInfo->sourceChangedCallback = (OBS_SOURCE_CHANGED_CALLBACK)GetProcAddress(hPlugin, "OnSourceChanged");

	push	OFFSET $SG4294800684
	mov	edx, DWORD PTR _hPlugin$8[ebp]
	push	edx
	call	DWORD PTR __imp__GetProcAddress@8
	mov	ecx, DWORD PTR _pluginInfo$7[ebp]
	mov	DWORD PTR [ecx+76], eax

; 216  :                         pluginInfo->sourcesAddedOrRemovedCallback = (OBS_CALLBACK)GetProcAddress(hPlugin, "OnSourcesAddedOrRemoved");

	push	OFFSET $SG4294800683
	mov	edx, DWORD PTR _hPlugin$8[ebp]
	push	edx
	call	DWORD PTR __imp__GetProcAddress@8
	mov	ecx, DWORD PTR _pluginInfo$7[ebp]
	mov	DWORD PTR [ecx+80], eax

; 217  :                         pluginInfo->micVolumeChangeCallback = (OBS_VOLUME_CHANGED_CALLBACK)GetProcAddress(hPlugin, "OnMicVolumeChanged");

	push	OFFSET $SG4294800682
	mov	edx, DWORD PTR _hPlugin$8[ebp]
	push	edx
	call	DWORD PTR __imp__GetProcAddress@8
	mov	ecx, DWORD PTR _pluginInfo$7[ebp]
	mov	DWORD PTR [ecx+84], eax

; 218  :                         pluginInfo->desktopVolumeChangeCallback = (OBS_VOLUME_CHANGED_CALLBACK)GetProcAddress(hPlugin, "OnDesktopVolumeChanged");

	push	OFFSET $SG4294800681
	mov	edx, DWORD PTR _hPlugin$8[ebp]
	push	edx
	call	DWORD PTR __imp__GetProcAddress@8
	mov	ecx, DWORD PTR _pluginInfo$7[ebp]
	mov	DWORD PTR [ecx+88], eax

; 219  :                         pluginInfo->logUpdateCallback = (OBS_LOG_UPDATE_CALLBACK)GetProcAddress(hPlugin, "OnLogUpdate");

	push	OFFSET $SG4294800680
	mov	edx, DWORD PTR _hPlugin$8[ebp]
	push	edx
	call	DWORD PTR __imp__GetProcAddress@8
	mov	ecx, DWORD PTR _pluginInfo$7[ebp]
	mov	DWORD PTR [ecx+92], eax

; 220  :                         pluginInfo->startRecordingReplayBufferCallback = (OBS_CALLBACK)GetProcAddress(hPlugin, "OnStartRecordingReplayBuffer");

	push	OFFSET $SG4294800679
	mov	edx, DWORD PTR _hPlugin$8[ebp]
	push	edx
	call	DWORD PTR __imp__GetProcAddress@8
	mov	ecx, DWORD PTR _pluginInfo$7[ebp]
	mov	DWORD PTR [ecx+36], eax

; 221  :                         pluginInfo->stopRecordingReplayBufferCallback = (OBS_CALLBACK)GetProcAddress(hPlugin, "OnStopRecordingReplayBuffer");

	push	OFFSET $SG4294800678
	mov	edx, DWORD PTR _hPlugin$8[ebp]
	push	edx
	call	DWORD PTR __imp__GetProcAddress@8
	mov	ecx, DWORD PTR _pluginInfo$7[ebp]
	mov	DWORD PTR [ecx+40], eax

; 222  :                         pluginInfo->replayBufferSavedCallback = (OBS_REPLAY_BUFFER_SAVED_CALLBACK)GetProcAddress(hPlugin, "OnReplayBufferSaved");

	push	OFFSET $SG4294800677
	mov	edx, DWORD PTR _hPlugin$8[ebp]
	push	edx
	call	DWORD PTR __imp__GetProcAddress@8
	mov	ecx, DWORD PTR _pluginInfo$7[ebp]
	mov	DWORD PTR [ecx+44], eax

; 223  : 
; 224  :                         //GETPLUGINNAMEPROC getName = (GETPLUGINNAMEPROC)GetProcAddress(hPlugin, "GetPluginName");
; 225  : 
; 226  :                         //CTSTR lpName = (getName) ? getName() : TEXT("<unknown>");
; 227  : 
; 228  :                         //FIXME: TODO: log this somewhere else, it comes before the OBS version info and looks weird.
; 229  :                         //Log(TEXT("Loaded plugin '%s', %s"), lpName, strLocation);
; 230  :                     }
; 231  :                     else

	jmp	SHORT $LN3@LoadAllPlu
$LN4@LoadAllPlu:

; 232  :                     {
; 233  :                         Log(TEXT("Failed to initialize plugin %s"), strLocation.Array());

	lea	ecx, DWORD PTR _strLocation$2[ebp]
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	push	OFFSET $SG4294800676
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 8

; 234  :                         FreeLibrary(hPlugin);

	mov	edx, DWORD PTR _hPlugin$8[ebp]
	push	edx
	call	DWORD PTR __imp__FreeLibrary@4
$LN3@LoadAllPlu:

; 235  :                     }
; 236  :                 }
; 237  :                 else

	jmp	$LN2@LoadAllPlu
$LN7@LoadAllPlu:

; 238  :                 {
; 239  :                     DWORD err = GetLastError();

	call	DWORD PTR __imp__GetLastError@0
	mov	DWORD PTR _err$4[ebp], eax

; 240  :                     Log(TEXT("Failed to load plugin %s, %d"), strLocation.Array(), err);

	mov	eax, DWORD PTR _err$4[ebp]
	push	eax
	lea	ecx, DWORD PTR _strLocation$2[ebp]
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	push	OFFSET $SG4294800675
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 12					; 0000000cH

; 241  : #ifndef _DEBUG
; 242  :                     if (err == 193)

	cmp	DWORD PTR _err$4[ebp], 193		; 000000c1H
	jne	SHORT $LN2@LoadAllPlu

; 243  :                     {
; 244  : #ifdef _M_X64
; 245  :                         String message = FormattedString(Str("Plugins.InvalidVersion"), ofd.fileName, 32);
; 246  : #else
; 247  :                         String message = FormattedString(Str("Plugins.InvalidVersion"), ofd.fileName, 64);

	push	64					; 00000040H
	lea	ecx, DWORD PTR _ofd$[ebp]
	push	ecx
	push	OFFSET $SG4294800674
	mov	edx, DWORD PTR __imp_?locale@@3PAVLocaleStringLookup@@A
	mov	ecx, DWORD PTR [edx]
	call	DWORD PTR __imp_?LookupString@LocaleStringLookup@@QAEPB_WPB_W@Z
	push	eax
	lea	eax, DWORD PTR _message$1[ebp]
	push	eax
	call	DWORD PTR __imp_?FormattedString@@YA?AVString@@PB_WZZ
	add	esp, 16					; 00000010H

; 248  : #endif
; 249  :                         OBSMessageBox(hwndMain, message.Array(), NULL, MB_ICONEXCLAMATION);

	push	48					; 00000030H
	push	0
	lea	ecx, DWORD PTR _message$1[ebp]
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	mov	ecx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	ecx
	call	DWORD PTR __imp_?OBSMessageBox@@YAHPAUHWND__@@PB_W1I@Z
	add	esp, 16					; 00000010H

; 250  :                     }

	lea	ecx, DWORD PTR _message$1[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
$LN2@LoadAllPlu:

; 251  : #endif
; 252  :                 }
; 253  :             }

	lea	ecx, DWORD PTR _strLocation$2[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
$LN10@LoadAllPlu:

; 254  :         } while (OSFindNextFile(hFind, ofd));

	lea	edx, DWORD PTR _ofd$[ebp]
	push	edx
	mov	eax, DWORD PTR _hFind$[ebp]
	push	eax
	call	DWORD PTR __imp_?OSFindNextFile@@YGHPAXAAUOSFindData@@@Z
	test	eax, eax
	jne	$LN11@LoadAllPlu

; 255  : 
; 256  :         OSFindClose(hFind);

	mov	ecx, DWORD PTR _hFind$[ebp]
	push	ecx
	call	DWORD PTR __imp_?OSFindClose@@YGXPAX@Z
$LN13@LoadAllPlu:

; 257  :     }
; 258  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?LoadAllPlugins@OBS@@QAEXXZ ENDP			; OBS::LoadAllPlugins
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\8.1\include\um\commctrl.inl
;	COMDAT _IsolationAwareInitCommonControlsEx@4
_TEXT	SEGMENT
_dwLastError$2 = -60					; size = 4
_fActivateActCtxSuccess$ = -56				; size = 4
_fPreserveLastError$3 = -52				; size = 4
_ulpCookie$ = -48					; size = 4
tv81 = -44						; size = 4
tv78 = -40						; size = 4
tv68 = -36						; size = 4
_fResult$ = -32						; size = 4
___IsolationAware_pfn$ = -28				; size = 4
__$SEHRec$ = -24					; size = 24
_picce$ = 8						; size = 4
_IsolationAwareInitCommonControlsEx@4 PROC		; COMDAT

; 269  : {

	push	ebp
	mov	ebp, esp
	push	-2					; fffffffeH
	push	OFFSET __sehtable$_IsolationAwareInitCommonControlsEx@4
	push	OFFSET __except_handler4
	mov	eax, DWORD PTR fs:0
	push	eax
	add	esp, -44				; ffffffd4H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	DWORD PTR __$SEHRec$[ebp+16], eax
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$SEHRec$[ebp+8]
	mov	DWORD PTR fs:0, eax

; 270  :     BOOL fResult = FALSE;

	mov	DWORD PTR _fResult$[ebp], 0

; 271  :     typedef BOOL (WINAPI* PFN)(_In_ const INITCOMMONCONTROLSEX*picce);
; 272  :     static PFN s_pfn;
; 273  :     PFN __IsolationAware_pfn = s_pfn;

	mov	eax, DWORD PTR ?s_pfn@?1??IsolationAwareInitCommonControlsEx@@9@4@4P6GHPBUtagINITCOMMONCONTROLSEX@@@ZA ; `IsolationAwareInitCommonControlsEx'::`2'::s_pfn
	mov	DWORD PTR ___IsolationAware_pfn$[ebp], eax

; 274  :     ULONG_PTR ulpCookie = 0;

	mov	DWORD PTR _ulpCookie$[ebp], 0

; 275  :     const BOOL fActivateActCtxSuccess =
; 276  : #ifdef _M_IX86
; 277  :         IsolationAwarePrivateT_SqbjaYRiRY ||
; 278  : #endif
; 279  :         IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);

	cmp	DWORD PTR _IsolationAwarePrivateT_SqbjaYRiRY, 0
	jne	SHORT $LN9@IsolationA
	lea	ecx, DWORD PTR _ulpCookie$[ebp]
	push	ecx
	call	_IsolationAwarePrivatenPgViNgRzlnPgpgk@4
	test	eax, eax
	jne	SHORT $LN9@IsolationA
	mov	DWORD PTR tv68[ebp], 0
	jmp	SHORT $LN10@IsolationA
$LN9@IsolationA:
	mov	DWORD PTR tv68[ebp], 1
$LN10@IsolationA:
	mov	edx, DWORD PTR tv68[ebp]
	mov	DWORD PTR _fActivateActCtxSuccess$[ebp], edx

; 280  :     if (!fActivateActCtxSuccess)

	cmp	DWORD PTR _fActivateActCtxSuccess$[ebp], 0
	jne	SHORT $LN6@IsolationA

; 281  :         return fResult;

	mov	eax, DWORD PTR _fResult$[ebp]
	jmp	$LN15@IsolationA
$LN6@IsolationA:

; 282  :     __try

	mov	DWORD PTR __$SEHRec$[ebp+20], 0

; 283  :     {
; 284  :         if (__IsolationAware_pfn == NULL)

	cmp	DWORD PTR ___IsolationAware_pfn$[ebp], 0
	jne	SHORT $LN4@IsolationA

; 285  :         {
; 286  :             __IsolationAware_pfn = (PFN) CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY("InitCommonControlsEx");

	push	OFFSET ??_C@_0BF@IABGBOLM@InitCommonControlsEx?$AA@
	call	_CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY@4
	mov	DWORD PTR ___IsolationAware_pfn$[ebp], eax

; 287  :             if (__IsolationAware_pfn == NULL)

	cmp	DWORD PTR ___IsolationAware_pfn$[ebp], 0
	jne	SHORT $LN3@IsolationA

; 288  :                 __leave;

	jmp	SHORT $LN5@IsolationA
$LN3@IsolationA:

; 289  :             s_pfn = __IsolationAware_pfn;

	mov	eax, DWORD PTR ___IsolationAware_pfn$[ebp]
	mov	DWORD PTR ?s_pfn@?1??IsolationAwareInitCommonControlsEx@@9@4@4P6GHPBUtagINITCOMMONCONTROLSEX@@@ZA, eax ; `IsolationAwareInitCommonControlsEx'::`2'::s_pfn
$LN4@IsolationA:

; 290  :         }
; 291  :         fResult = __IsolationAware_pfn(picce);

	mov	ecx, DWORD PTR _picce$[ebp]
	push	ecx
	call	DWORD PTR ___IsolationAware_pfn$[ebp]
	mov	DWORD PTR _fResult$[ebp], eax
$LN5@IsolationA:

; 292  :     }
; 293  :     __finally

	mov	DWORD PTR __$SEHRec$[ebp+20], -2	; fffffffeH
	call	$LN18@IsolationA
	jmp	SHORT $LN19@IsolationA
$LN16@IsolationA:
$LN21@IsolationA:
$LN18@IsolationA:

; 294  :     {
; 295  : #ifdef _M_IX86
; 296  :         if (!IsolationAwarePrivateT_SqbjaYRiRY)

	cmp	DWORD PTR _IsolationAwarePrivateT_SqbjaYRiRY, 0
	jne	SHORT $LN17@IsolationA

; 297  : #endif
; 298  :         {
; 299  :             const BOOL fPreserveLastError = (fResult == FALSE);

	cmp	DWORD PTR _fResult$[ebp], 0
	jne	SHORT $LN11@IsolationA
	mov	DWORD PTR tv78[ebp], 1
	jmp	SHORT $LN12@IsolationA
$LN11@IsolationA:
	mov	DWORD PTR tv78[ebp], 0
$LN12@IsolationA:
	mov	edx, DWORD PTR tv78[ebp]
	mov	DWORD PTR _fPreserveLastError$3[ebp], edx

; 300  :             const DWORD dwLastError = fPreserveLastError ? GetLastError() : NO_ERROR;

	cmp	DWORD PTR _fPreserveLastError$3[ebp], 0
	je	SHORT $LN13@IsolationA
	call	DWORD PTR __imp__GetLastError@0
	mov	DWORD PTR tv81[ebp], eax
	jmp	SHORT $LN14@IsolationA
$LN13@IsolationA:
	mov	DWORD PTR tv81[ebp], 0
$LN14@IsolationA:
	mov	eax, DWORD PTR tv81[ebp]
	mov	DWORD PTR _dwLastError$2[ebp], eax

; 301  :             (void)IsolationAwareDeactivateActCtx(0, ulpCookie);

	mov	ecx, DWORD PTR _ulpCookie$[ebp]
	push	ecx
	push	0
	call	_IsolationAwareDeactivateActCtx@8

; 302  :             if (fPreserveLastError)

	cmp	DWORD PTR _fPreserveLastError$3[ebp], 0
	je	SHORT $LN17@IsolationA

; 303  :                 SetLastError(dwLastError);

	mov	edx, DWORD PTR _dwLastError$2[ebp]
	push	edx
	call	DWORD PTR __imp__SetLastError@4
$LN17@IsolationA:
$LN20@IsolationA:
	ret	0
$LN19@IsolationA:

; 304  :         }
; 305  :     }
; 306  :     return fResult;

	mov	eax, DWORD PTR _fResult$[ebp]
$LN15@IsolationA:

; 307  : }

	mov	ecx, DWORD PTR __$SEHRec$[ebp+8]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_IsolationAwareInitCommonControlsEx@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\8.1\include\um\commctrl.inl
;	COMDAT _CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY@4
_TEXT	SEGMENT
_dwLastError$2 = -44					; size = 4
_ulpCookie$ = -40					; size = 4
tv76 = -36						; size = 4
_fActivateActCtxSuccess$ = -32				; size = 4
_proc$ = -28						; size = 4
__$SEHRec$ = -24					; size = 24
_pszProcName$ = 8					; size = 4
_CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY@4 PROC ; COMDAT

; 4566 : {

	push	ebp
	mov	ebp, esp
	push	-2					; fffffffeH
	push	OFFSET __sehtable$_CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY@4
	push	OFFSET __except_handler4
	mov	eax, DWORD PTR fs:0
	push	eax
	add	esp, -28				; ffffffe4H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	DWORD PTR __$SEHRec$[ebp+16], eax
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$SEHRec$[ebp+8]
	mov	DWORD PTR fs:0, eax

; 4567 :     FARPROC proc = NULL;

	mov	DWORD PTR _proc$[ebp], 0

; 4568 :     static HMODULE s_module;
; 4569 :     BOOL fActivateActCtxSuccess = FALSE;

	mov	DWORD PTR _fActivateActCtxSuccess$[ebp], 0

; 4570 :     ULONG_PTR ulpCookie = 0;

	mov	DWORD PTR _ulpCookie$[ebp], 0

; 4571 : #ifndef _M_CEE_PURE
; 4572 :     const static IsolationAwarePrivatepBAFGnAG_zBqHyr_vAsB
; 4573 :         c = { IsolationAwarePrivatezlybNQyVOeNelJ, L"Comctl32.dll"
; 4574 : #ifdef _M_IX86
; 4575 :              , IsolationAwarePrivatezlybNQyVOeNeln, "Comctl32.dll"
; 4576 : #endif
; 4577 :     };
; 4578 : #else
; 4579 :     static IsolationAwarePrivatepBAFGnAG_zBqHyr_vAsB c;
; 4580 :     c.WinbaseIsolationAwarePrivateybNQJ = IsolationAwarePrivatezlybNQyVOeNelJ;
; 4581 :     c.WinbaseIsolationAwarePrivateANZRJ = L"Comctl32.dll";
; 4582 : #ifdef _M_IX86
; 4583 :     c.WinbaseIsolationAwarePrivateybNQn = IsolationAwarePrivatezlybNQyVOeNeln;
; 4584 :     c.WinbaseIsolationAwarePrivateANZRn = "Comctl32.dll";
; 4585 : #endif
; 4586 : #endif
; 4587 :     static IsolationAwarePrivatezHGnoyr_zBqHyr_vAsB m;
; 4588 : 
; 4589 :     __try

	mov	DWORD PTR __$SEHRec$[ebp+20], 0

; 4590 :     {
; 4591 : #ifdef _M_IX86
; 4592 :         if (!IsolationAwarePrivateT_SqbjaYRiRY)

	cmp	DWORD PTR _IsolationAwarePrivateT_SqbjaYRiRY, 0
	jne	SHORT $LN4@CommctrlIs

; 4593 : #endif
; 4594 :         {
; 4595 :             fActivateActCtxSuccess = IsolationAwarePrivatenPgViNgRzlnPgpgk(&ulpCookie);

	lea	eax, DWORD PTR _ulpCookie$[ebp]
	push	eax
	call	_IsolationAwarePrivatenPgViNgRzlnPgpgk@4
	mov	DWORD PTR _fActivateActCtxSuccess$[ebp], eax

; 4596 :             if (!fActivateActCtxSuccess)

	cmp	DWORD PTR _fActivateActCtxSuccess$[ebp], 0
	jne	SHORT $LN4@CommctrlIs

; 4597 :                 __leave;

	jmp	SHORT $LN5@CommctrlIs
$LN4@CommctrlIs:

; 4598 :         }
; 4599 :         proc = IsolationAwarePrivatezltRgCebPnQQeRff(&c, &m, pszProcName);

	mov	ecx, DWORD PTR _pszProcName$[ebp]
	push	ecx
	push	OFFSET ?m@?1??CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY@@9@4@4UIsolationAwarePrivate_zHGnoyr_zBqHyr_vAsB@@A ; `CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY'::`2'::m
	push	OFFSET ?c@?1??CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY@@9@4@4UIsolationAwarePrivate_pBAFGnAG_zBqHyr_vAsB@@B ; `CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY'::`2'::c
	call	_IsolationAwarePrivatezltRgCebPnQQeRff@12
	mov	DWORD PTR _proc$[ebp], eax
$LN5@CommctrlIs:

; 4600 :     }
; 4601 :     __finally

	mov	DWORD PTR __$SEHRec$[ebp+20], -2	; fffffffeH
	call	$LN13@CommctrlIs
	jmp	SHORT $LN14@CommctrlIs
$LN11@CommctrlIs:
$LN16@CommctrlIs:
$LN13@CommctrlIs:

; 4602 :     {
; 4603 :         if (
; 4604 : #ifdef _M_IX86
; 4605 :             !IsolationAwarePrivateT_SqbjaYRiRY &&
; 4606 : #endif
; 4607 :             fActivateActCtxSuccess)

	cmp	DWORD PTR _IsolationAwarePrivateT_SqbjaYRiRY, 0
	jne	SHORT $LN12@CommctrlIs
	cmp	DWORD PTR _fActivateActCtxSuccess$[ebp], 0
	je	SHORT $LN12@CommctrlIs

; 4608 :         {
; 4609 :             const DWORD dwLastError = (proc == NULL) ? GetLastError() : NO_ERROR;

	cmp	DWORD PTR _proc$[ebp], 0
	jne	SHORT $LN8@CommctrlIs
	call	DWORD PTR __imp__GetLastError@0
	mov	DWORD PTR tv76[ebp], eax
	jmp	SHORT $LN9@CommctrlIs
$LN8@CommctrlIs:
	mov	DWORD PTR tv76[ebp], 0
$LN9@CommctrlIs:
	mov	edx, DWORD PTR tv76[ebp]
	mov	DWORD PTR _dwLastError$2[ebp], edx

; 4610 :             (void)IsolationAwareDeactivateActCtx(0, ulpCookie);

	mov	eax, DWORD PTR _ulpCookie$[ebp]
	push	eax
	push	0
	call	_IsolationAwareDeactivateActCtx@8

; 4611 :             if (proc == NULL)

	cmp	DWORD PTR _proc$[ebp], 0
	jne	SHORT $LN12@CommctrlIs

; 4612 :                 SetLastError(dwLastError);

	mov	ecx, DWORD PTR _dwLastError$2[ebp]
	push	ecx
	call	DWORD PTR __imp__SetLastError@4
$LN12@CommctrlIs:
$LN15@CommctrlIs:
	ret	0
$LN14@CommctrlIs:

; 4613 :         }
; 4614 :     }
; 4615 :     return proc;

	mov	eax, DWORD PTR _proc$[ebp]

; 4616 : }

	mov	ecx, DWORD PTR __$SEHRec$[ebp+8]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_CommctrlIsolationAwarePrivatetRgCebPnQQeRff_pbZPgYQP_QYY@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$di	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 70   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$di	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$di	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3451 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$di	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\tuple
;	COMDAT ??__Eignore@std@@YAXXZ
text$di	SEGMENT
??__Eignore@std@@YAXXZ PROC				; std::`dynamic initializer for 'ignore'', COMDAT

; 59   : const _Ignore ignore;

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET _ignore
	call	??0_Ignore@std@@QAE@XZ			; std::_Ignore::_Ignore
	pop	ebp
	ret	0
??__Eignore@std@@YAXXZ ENDP				; std::`dynamic initializer for 'ignore''
text$di	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\tuple
;	COMDAT ??__E_Tuple_alloc@std@@YAXXZ
text$di	SEGMENT
$T1 = -1						; size = 1
??__E_Tuple_alloc@std@@YAXXZ PROC			; std::`dynamic initializer for '_Tuple_alloc'', COMDAT

; 66   : const _Tuple_alloc_t _Tuple_alloc = _Tuple_alloc_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__E_Tuple_alloc@std@@YAXXZ ENDP			; std::`dynamic initializer for '_Tuple_alloc''
text$di	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.h
;	COMDAT ?FreeData@AudioDeviceInfo@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?FreeData@AudioDeviceInfo@@QAEXXZ PROC			; AudioDeviceInfo::FreeData, COMDAT
; _this$ = ecx

; 48   :     inline void FreeData() {strID.Clear(); strName.Clear();}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_?Clear@String@@QAEAAV1@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	DWORD PTR __imp_?Clear@String@@QAEAAV1@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
?FreeData@AudioDeviceInfo@@QAEXXZ ENDP			; AudioDeviceInfo::FreeData
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.h
;	COMDAT ??1AudioDeviceList@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1AudioDeviceList@@QAE@XZ PROC				; AudioDeviceList::~AudioDeviceList, COMDAT
; _this$ = ecx

; 56   :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 57   :         FreeData();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FreeData@AudioDeviceList@@QAEXXZ	; AudioDeviceList::FreeData

; 58   :     }

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$List@UAudioDeviceInfo@@@@QAE@XZ	; List<AudioDeviceInfo>::~List<AudioDeviceInfo>
	mov	esp, ebp
	pop	ebp
	ret	0
??1AudioDeviceList@@QAE@XZ ENDP				; AudioDeviceList::~AudioDeviceList
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.h
;	COMDAT ?FreeData@AudioDeviceList@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$1 = -4						; size = 4
?FreeData@AudioDeviceList@@QAEXXZ PROC			; AudioDeviceList::FreeData, COMDAT
; _this$ = ecx

; 61   :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 62   :         for(UINT i=0; i<devices.Num(); i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN3@FreeData
$LN2@FreeData:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN3@FreeData:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Num@?$List@UAudioDeviceInfo@@@@QBEIXZ	; List<AudioDeviceInfo>::Num
	cmp	DWORD PTR _i$1[ebp], eax
	jae	SHORT $LN1@FreeData

; 63   :             devices[i].FreeData();

	mov	ecx, DWORD PTR _i$1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UAudioDeviceInfo@@@@QAEAAUAudioDeviceInfo@@I@Z ; List<AudioDeviceInfo>::operator[]
	mov	ecx, eax
	call	?FreeData@AudioDeviceInfo@@QAEXXZ	; AudioDeviceInfo::FreeData
	jmp	SHORT $LN2@FreeData
$LN1@FreeData:

; 64   :         devices.Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$List@UAudioDeviceInfo@@@@QAEXXZ ; List<AudioDeviceInfo>::Clear

; 65   :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?FreeData@AudioDeviceList@@QAEXXZ ENDP			; AudioDeviceList::FreeData
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.h
;	COMDAT ?HasID@AudioDeviceList@@QBE_NPB_W@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$1 = -4						; size = 4
_lpID$ = 8						; size = 4
?HasID@AudioDeviceList@@QBE_NPB_W@Z PROC		; AudioDeviceList::HasID, COMDAT
; _this$ = ecx

; 68   :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 69   :         for(UINT i=0; i<devices.Num(); i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@HasID
$LN3@HasID:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@HasID:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Num@?$List@UAudioDeviceInfo@@@@QBEIXZ	; List<AudioDeviceInfo>::Num
	cmp	DWORD PTR _i$1[ebp], eax
	jae	SHORT $LN2@HasID

; 70   :         {
; 71   :             if(devices[i].strID == lpID)

	mov	ecx, DWORD PTR _lpID$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$List@UAudioDeviceInfo@@@@QBEAAUAudioDeviceInfo@@I@Z ; List<AudioDeviceInfo>::operator[]
	mov	ecx, eax
	call	DWORD PTR __imp_??8String@@QBEHPB_W@Z
	test	eax, eax
	je	SHORT $LN1@HasID

; 72   :                 return true;

	mov	al, 1
	jmp	SHORT $LN5@HasID
$LN1@HasID:

; 73   :         }

	jmp	SHORT $LN3@HasID
$LN2@HasID:

; 74   : 
; 75   :         return false;

	xor	al, al
$LN5@HasID:

; 76   :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?HasID@AudioDeviceList@@QBE_NPB_W@Z ENDP		; AudioDeviceList::HasID
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.h
;	COMDAT ??0MonitorInfo@@QAE@PAUHMONITOR__@@PAUtagRECT@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_hMonitor$ = 8						; size = 4
_lpRect$ = 12						; size = 4
??0MonitorInfo@@QAE@PAUHMONITOR__@@PAUtagRECT@@@Z PROC	; MonitorInfo::MonitorInfo, COMDAT
; _this$ = ecx

; 210  :     inline MonitorInfo(HMONITOR hMonitor, RECT *lpRect)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 211  :     {
; 212  :         this->hMonitor = hMonitor;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _hMonitor$[ebp]
	mov	DWORD PTR [eax], ecx

; 213  :         mcpy(&this->rect, lpRect, sizeof(rect));

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 4
	mov	eax, DWORD PTR _lpRect$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], ecx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+12], eax

; 214  :     }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0MonitorInfo@@QAE@PAUHMONITOR__@@PAUtagRECT@@@Z ENDP	; MonitorInfo::MonitorInfo
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.h
;	COMDAT ?FreeData@ClassInfo@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?FreeData@ClassInfo@@QAEXXZ PROC			; ClassInfo::FreeData, COMDAT
; _this$ = ecx

; 291  :     inline void FreeData() {strClass.Clear(); strName.Clear();}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_?Clear@String@@QAEAAV1@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	DWORD PTR __imp_?Clear@String@@QAEAAV1@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
?FreeData@ClassInfo@@QAEXXZ ENDP			; ClassInfo::FreeData
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.h
;	COMDAT ??0PendingStreams@OBS@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0PendingStreams@OBS@@QAE@XZ PROC			; OBS::PendingStreams::PendingStreams, COMDAT
; _this$ = ecx

; 1343 :         PendingStreams() : mutex(OSCreateMutex()) {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$list@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAE@XZ ; std::list<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >::list<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >
	call	DWORD PTR __imp_?OSCreateMutex@@YGPAXXZ
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$unique_ptr@XUMutexDeleter@@@std@@QAE@PAX@Z ; std::unique_ptr<void,MutexDeleter>::unique_ptr<void,MutexDeleter>
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0PendingStreams@OBS@@QAE@XZ ENDP			; OBS::PendingStreams::PendingStreams
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.cpp
;	COMDAT ?MonitorInfoEnumProc@@YGHPAUHMONITOR__@@PAUHDC__@@PAUtagRECT@@AAV?$List@UMonitorInfo@@@@@Z
_TEXT	SEGMENT
$T1 = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
_hMonitor$ = 8						; size = 4
_hdcMonitor$ = 12					; size = 4
_lprcMonitor$ = 16					; size = 4
_monitors$ = 20						; size = 4
?MonitorInfoEnumProc@@YGHPAUHMONITOR__@@PAUHDC__@@PAUtagRECT@@AAV?$List@UMonitorInfo@@@@@Z PROC ; MonitorInfoEnumProc, COMDAT

; 73   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 74   :     monitors << MonitorInfo(hMonitor, lprcMonitor);

	mov	eax, DWORD PTR _lprcMonitor$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hMonitor$[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0MonitorInfo@@QAE@PAUHMONITOR__@@PAUtagRECT@@@Z ; MonitorInfo::MonitorInfo
	push	eax
	mov	ecx, DWORD PTR _monitors$[ebp]
	call	??6?$List@UMonitorInfo@@@@QAEAAV0@ABUMonitorInfo@@@Z ; List<MonitorInfo>::operator<<

; 75   :     return TRUE;

	mov	eax, 1

; 76   : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?MonitorInfoEnumProc@@YGHPAUHMONITOR__@@PAUHDC__@@PAUtagRECT@@AAV?$List@UMonitorInfo@@@@@Z ENDP ; MonitorInfoEnumProc
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.cpp
;	COMDAT ?CreateNormalScene@@YGPAVScene@@PAVXElement@@@Z
_TEXT	SEGMENT
tv68 = -8						; size = 4
$T1 = -4						; size = 4
_data$ = 8						; size = 4
?CreateNormalScene@@YGPAVScene@@PAVXElement@@@Z PROC	; CreateNormalScene, COMDAT

; 94   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 95   :     return new Scene;

	push	24					; 00000018H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 0
	je	SHORT $LN3@CreateNorm
	mov	ecx, DWORD PTR $T1[ebp]
	call	DWORD PTR __imp_??0Scene@@QAE@XZ
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR [eax], OFFSET ??_SScene@@6B@
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR tv68[ebp], ecx
	jmp	SHORT $LN4@CreateNorm
$LN3@CreateNorm:
	mov	DWORD PTR tv68[ebp], 0
$LN4@CreateNorm:
	mov	eax, DWORD PTR tv68[ebp]

; 96   : }

	mov	esp, ebp
	pop	ebp
	ret	4
?CreateNormalScene@@YGPAVScene@@PAVXElement@@@Z ENDP	; CreateNormalScene
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GScene@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GScene@@UAEPAXI@Z PROC				; Scene::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1Scene@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GScene@@UAEPAXI@Z ENDP				; Scene::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.cpp
;	COMDAT ?IsWebrootLoaded@@YAHXZ
_TEXT	SEGMENT
$T1 = -40						; size = 8
_moduleList$ = -32					; size = 8
$T2 = -24						; size = 4
$T3 = -20						; size = 4
_ret$ = -16						; size = 4
_msIMG$ = -12						; size = 4
_alphaBlend$4 = -8					; size = 4
_opCode$5 = -1						; size = 1
?IsWebrootLoaded@@YAHXZ PROC				; IsWebrootLoaded, COMDAT

; 99   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 100  :     BOOL ret = FALSE;

	mov	DWORD PTR _ret$[ebp], 0

; 101  :     StringList moduleList;

	lea	ecx, DWORD PTR _moduleList$[ebp]
	call	DWORD PTR __imp_??0StringList@@QAE@XZ

; 102  : 
; 103  :     OSGetLoadedModuleList (GetCurrentProcess(), moduleList);

	lea	eax, DWORD PTR _moduleList$[ebp]
	push	eax
	call	DWORD PTR __imp__GetCurrentProcess@0
	push	eax
	call	DWORD PTR __imp_?OSGetLoadedModuleList@@YGHPAXAAVStringList@@@Z

; 104  : 
; 105  :     HMODULE msIMG = GetModuleHandle(TEXT("MSIMG32"));

	push	OFFSET $SG4294800707
	call	DWORD PTR __imp__GetModuleHandleW@4
	mov	DWORD PTR _msIMG$[ebp], eax

; 106  :     if (msIMG)

	cmp	DWORD PTR _msIMG$[ebp], 0
	je	SHORT $LN5@IsWebrootL

; 107  :     {
; 108  :         FARPROC alphaBlend = GetProcAddress(msIMG, "AlphaBlend");

	push	OFFSET $SG4294800706
	mov	ecx, DWORD PTR _msIMG$[ebp]
	push	ecx
	call	DWORD PTR __imp__GetProcAddress@8
	mov	DWORD PTR _alphaBlend$4[ebp], eax

; 109  :         if (alphaBlend)

	cmp	DWORD PTR _alphaBlend$4[ebp], 0
	je	SHORT $LN5@IsWebrootL

; 110  :         {
; 111  :             if (!IsBadReadPtr(alphaBlend, 5))

	push	5
	mov	edx, DWORD PTR _alphaBlend$4[ebp]
	push	edx
	call	DWORD PTR __imp__IsBadReadPtr@8
	test	eax, eax
	jne	SHORT $LN5@IsWebrootL

; 112  :             {
; 113  :                 BYTE opCode = *(BYTE *)alphaBlend;

	mov	eax, DWORD PTR _alphaBlend$4[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _opCode$5[ebp], cl

; 114  : 
; 115  :                 if (opCode == 0xE9)

	movzx	edx, BYTE PTR _opCode$5[ebp]
	cmp	edx, 233				; 000000e9H
	jne	SHORT $LN5@IsWebrootL

; 116  :                 {
; 117  :                     if (moduleList.HasValue(TEXT("wrusr.dll")))

	push	OFFSET $SG4294800705
	lea	ecx, DWORD PTR $T1[ebp]
	call	DWORD PTR __imp_??0String@@QAE@PB_W@Z
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	lea	ecx, DWORD PTR _moduleList$[ebp]
	call	DWORD PTR __imp_?HasValue@?$List@VString@@@@QBEHABVString@@@Z
	mov	DWORD PTR $T3[ebp], eax
	lea	ecx, DWORD PTR $T1[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN5@IsWebrootL

; 118  :                         ret = TRUE;

	mov	DWORD PTR _ret$[ebp], 1
$LN5@IsWebrootL:

; 119  :                 }
; 120  :             }
; 121  :         }
; 122  :     }
; 123  : 
; 124  :     return ret;

	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR $T2[ebp], ecx
	lea	ecx, DWORD PTR _moduleList$[ebp]
	call	DWORD PTR __imp_??1StringList@@QAE@XZ
	mov	eax, DWORD PTR $T2[ebp]

; 125  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsWebrootLoaded@@YAHXZ ENDP				; IsWebrootLoaded
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.cpp
;	COMDAT ?CheckPermissionsAndDiskSpace@@YAXXZ
_TEXT	SEGMENT
_freeSpace$ = -24					; size = 8
_testPath$ = -16					; size = 8
_tempFile$ = -8						; size = 4
_err$1 = -4						; size = 4
?CheckPermissionsAndDiskSpace@@YAXXZ PROC		; CheckPermissionsAndDiskSpace, COMDAT

; 129  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 130  :     ULARGE_INTEGER   freeSpace;
; 131  : 
; 132  :     if (GetDiskFreeSpaceEx (lpAppDataPath, &freeSpace, NULL, NULL))

	push	0
	push	0
	lea	eax, DWORD PTR _freeSpace$[ebp]
	push	eax
	push	OFFSET ?lpAppDataPath@@3PA_WA		; lpAppDataPath
	call	DWORD PTR __imp__GetDiskFreeSpaceExW@16
	test	eax, eax
	je	SHORT $LN6@CheckPermi

; 133  :     {
; 134  :         // 1MB ought to be enough for anybody...
; 135  :         if (freeSpace.QuadPart < 1048576)

	cmp	DWORD PTR _freeSpace$[ebp+4], 0
	ja	SHORT $LN6@CheckPermi
	jb	SHORT $LN9@CheckPermi
	cmp	DWORD PTR _freeSpace$[ebp], 1048576	; 00100000H
	jae	SHORT $LN6@CheckPermi
$LN9@CheckPermi:

; 136  :         {
; 137  :             OBSMessageBox(OBSGetMainWindow(), Str("DiskFull"), NULL, MB_ICONERROR);

	push	16					; 00000010H
	push	0
	push	OFFSET $SG4294800704
	mov	ecx, DWORD PTR __imp_?locale@@3PAVLocaleStringLookup@@A
	mov	ecx, DWORD PTR [ecx]
	call	DWORD PTR __imp_?LookupString@LocaleStringLookup@@QAEPB_WPB_W@Z
	push	eax
	call	DWORD PTR __imp_?OBSGetMainWindow@@YAPAUHWND__@@XZ
	push	eax
	call	DWORD PTR __imp_?OBSMessageBox@@YAHPAUHWND__@@PB_W1I@Z
	add	esp, 16					; 00000010H
$LN6@CheckPermi:

; 138  :         }
; 139  :     }
; 140  : 
; 141  :     HANDLE tempFile;
; 142  :     String testPath;

	lea	ecx, DWORD PTR _testPath$[ebp]
	call	DWORD PTR __imp_??0String@@QAE@XZ

; 143  : 
; 144  :     testPath = lpAppDataPath;

	push	OFFSET ?lpAppDataPath@@3PA_WA		; lpAppDataPath
	lea	ecx, DWORD PTR _testPath$[ebp]
	call	DWORD PTR __imp_??4String@@QAEAAV0@PB_W@Z

; 145  :     testPath += TEXT("\\.test");

	push	OFFSET $SG4294800703
	lea	ecx, DWORD PTR _testPath$[ebp]
	call	DWORD PTR __imp_??YString@@QAEAAV0@PB_W@Z

; 146  : 
; 147  :     tempFile = CreateFile(testPath.Array(), GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL | FILE_ATTRIBUTE_TEMPORARY | FILE_FLAG_DELETE_ON_CLOSE, NULL);

	push	0
	push	67109248				; 04000180H
	push	2
	push	0
	push	0
	push	1073741824				; 40000000H
	lea	ecx, DWORD PTR _testPath$[ebp]
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	call	DWORD PTR __imp__CreateFileW@28
	mov	DWORD PTR _tempFile$[ebp], eax

; 148  :     if (tempFile == INVALID_HANDLE_VALUE)

	cmp	DWORD PTR _tempFile$[ebp], -1
	jne	SHORT $LN4@CheckPermi

; 149  :     {
; 150  :         DWORD err = GetLastError();

	call	DWORD PTR __imp__GetLastError@0
	mov	DWORD PTR _err$1[ebp], eax

; 151  :         if (err == ERROR_ACCESS_DENIED || err == ERROR_FILE_READ_ONLY)

	cmp	DWORD PTR _err$1[ebp], 5
	je	SHORT $LN2@CheckPermi
	cmp	DWORD PTR _err$1[ebp], 6009		; 00001779H
	jne	SHORT $LN3@CheckPermi
$LN2@CheckPermi:

; 152  :             OBSMessageBox(OBSGetMainWindow(), Str("BadAppDataPermissions"), NULL, MB_ICONERROR);

	push	16					; 00000010H
	push	0
	push	OFFSET $SG4294800702
	mov	edx, DWORD PTR __imp_?locale@@3PAVLocaleStringLookup@@A
	mov	ecx, DWORD PTR [edx]
	call	DWORD PTR __imp_?LookupString@LocaleStringLookup@@QAEPB_WPB_W@Z
	push	eax
	call	DWORD PTR __imp_?OBSGetMainWindow@@YAPAUHWND__@@XZ
	push	eax
	call	DWORD PTR __imp_?OBSMessageBox@@YAHPAUHWND__@@PB_W1I@Z
	add	esp, 16					; 00000010H
$LN3@CheckPermi:

; 153  : 
; 154  :         // TODO: extra handling for unknown errors (maybe some av returns weird codes?)
; 155  :     }
; 156  :     else

	jmp	SHORT $LN1@CheckPermi
$LN4@CheckPermi:

; 157  :     {
; 158  :         CloseHandle(tempFile);

	mov	eax, DWORD PTR _tempFile$[ebp]
	push	eax
	call	DWORD PTR __imp__CloseHandle@4
$LN1@CheckPermi:

; 159  :     }
; 160  : }

	lea	ecx, DWORD PTR _testPath$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
?CheckPermissionsAndDiskSpace@@YAXXZ ENDP		; CheckPermissionsAndDiskSpace
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.cpp
;	COMDAT ?<helper_func_cdecl>@<lambda_67fe46cc64f8d1dcff1cc8a09bdee50b>@@CAXXZ
_TEXT	SEGMENT
?<helper_func_cdecl>@<lambda_67fe46cc64f8d1dcff1cc8a09bdee50b>@@CAXXZ PROC ; <lambda_67fe46cc64f8d1dcff1cc8a09bdee50b>::<helper_func_cdecl>, COMDAT

; 490  :     ResetLogUpdateCallback([] { PostMessage(hwndLogWindow, WM_COMMAND, MAKEWPARAM(ID_LOG_WINDOW, 0), 0); });

	push	ebp
	mov	ebp, esp
	push	0
	push	9025					; 00002341H
	push	273					; 00000111H
	mov	eax, DWORD PTR ?hwndLogWindow@@3PAUHWND__@@A ; hwndLogWindow
	push	eax
	call	DWORD PTR __imp__PostMessageW@16
	pop	ebp
	ret	0
?<helper_func_cdecl>@<lambda_67fe46cc64f8d1dcff1cc8a09bdee50b>@@CAXXZ ENDP ; <lambda_67fe46cc64f8d1dcff1cc8a09bdee50b>::<helper_func_cdecl>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.cpp
;	COMDAT ??B<lambda_67fe46cc64f8d1dcff1cc8a09bdee50b>@@QBEP6AXXZXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??B<lambda_67fe46cc64f8d1dcff1cc8a09bdee50b>@@QBEP6AXXZXZ PROC ; <lambda_67fe46cc64f8d1dcff1cc8a09bdee50b>::operator void (__cdecl*)(void), COMDAT
; _this$ = ecx

; 490  :     ResetLogUpdateCallback([] { PostMessage(hwndLogWindow, WM_COMMAND, MAKEWPARAM(ID_LOG_WINDOW, 0), 0); });

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET ?<helper_func_cdecl>@<lambda_67fe46cc64f8d1dcff1cc8a09bdee50b>@@CAXXZ ; <lambda_67fe46cc64f8d1dcff1cc8a09bdee50b>::<helper_func_cdecl>
	mov	esp, ebp
	pop	ebp
	ret	0
??B<lambda_67fe46cc64f8d1dcff1cc8a09bdee50b>@@QBEP6AXXZXZ ENDP ; <lambda_67fe46cc64f8d1dcff1cc8a09bdee50b>::operator void (__cdecl*)(void)
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.cpp
;	COMDAT ?<helper_func_stdcall>@<lambda_67fe46cc64f8d1dcff1cc8a09bdee50b>@@CGXXZ
_TEXT	SEGMENT
?<helper_func_stdcall>@<lambda_67fe46cc64f8d1dcff1cc8a09bdee50b>@@CGXXZ PROC ; <lambda_67fe46cc64f8d1dcff1cc8a09bdee50b>::<helper_func_stdcall>, COMDAT

; 490  :     ResetLogUpdateCallback([] { PostMessage(hwndLogWindow, WM_COMMAND, MAKEWPARAM(ID_LOG_WINDOW, 0), 0); });

	push	ebp
	mov	ebp, esp
	push	0
	push	9025					; 00002341H
	push	273					; 00000111H
	mov	eax, DWORD PTR ?hwndLogWindow@@3PAUHWND__@@A ; hwndLogWindow
	push	eax
	call	DWORD PTR __imp__PostMessageW@16
	pop	ebp
	ret	0
?<helper_func_stdcall>@<lambda_67fe46cc64f8d1dcff1cc8a09bdee50b>@@CGXXZ ENDP ; <lambda_67fe46cc64f8d1dcff1cc8a09bdee50b>::<helper_func_stdcall>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.cpp
;	COMDAT ?<helper_func_fastcall>@<lambda_67fe46cc64f8d1dcff1cc8a09bdee50b>@@CIXXZ
_TEXT	SEGMENT
?<helper_func_fastcall>@<lambda_67fe46cc64f8d1dcff1cc8a09bdee50b>@@CIXXZ PROC ; <lambda_67fe46cc64f8d1dcff1cc8a09bdee50b>::<helper_func_fastcall>, COMDAT

; 490  :     ResetLogUpdateCallback([] { PostMessage(hwndLogWindow, WM_COMMAND, MAKEWPARAM(ID_LOG_WINDOW, 0), 0); });

	push	ebp
	mov	ebp, esp
	push	0
	push	9025					; 00002341H
	push	273					; 00000111H
	mov	eax, DWORD PTR ?hwndLogWindow@@3PAUHWND__@@A ; hwndLogWindow
	push	eax
	call	DWORD PTR __imp__PostMessageW@16
	pop	ebp
	ret	0
?<helper_func_fastcall>@<lambda_67fe46cc64f8d1dcff1cc8a09bdee50b>@@CIXXZ ENDP ; <lambda_67fe46cc64f8d1dcff1cc8a09bdee50b>::<helper_func_fastcall>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.cpp
;	COMDAT ?<helper_func_vectorcall>@<lambda_67fe46cc64f8d1dcff1cc8a09bdee50b>@@CQXXZ
_TEXT	SEGMENT
?<helper_func_vectorcall>@<lambda_67fe46cc64f8d1dcff1cc8a09bdee50b>@@CQXXZ PROC ; <lambda_67fe46cc64f8d1dcff1cc8a09bdee50b>::<helper_func_vectorcall>, COMDAT

; 490  :     ResetLogUpdateCallback([] { PostMessage(hwndLogWindow, WM_COMMAND, MAKEWPARAM(ID_LOG_WINDOW, 0), 0); });

	push	ebp
	mov	ebp, esp
	push	0
	push	9025					; 00002341H
	push	273					; 00000111H
	mov	eax, DWORD PTR ?hwndLogWindow@@3PAUHWND__@@A ; hwndLogWindow
	push	eax
	call	DWORD PTR __imp__PostMessageW@16
	pop	ebp
	ret	0
?<helper_func_vectorcall>@<lambda_67fe46cc64f8d1dcff1cc8a09bdee50b>@@CQXXZ ENDP ; <lambda_67fe46cc64f8d1dcff1cc8a09bdee50b>::<helper_func_vectorcall>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GOBS@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GOBS@@UAEPAXI@Z PROC					; OBS::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1OBS@@UAE@XZ				; OBS::~OBS
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GOBS@@UAEPAXI@Z ENDP					; OBS::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0StopInfo@OBS@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0StopInfo@OBS@@QAE@XZ PROC				; OBS::StopInfo::StopInfo, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], -1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$function@$$A6AXXZ@std@@QAE@XZ	; std::function<void __cdecl(void)>::function<void __cdecl(void)>
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0StopInfo@OBS@@QAE@XZ ENDP				; OBS::StopInfo::StopInfo
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1StopInfo@OBS@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1StopInfo@OBS@@QAE@XZ PROC				; OBS::StopInfo::~StopInfo, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??1?$function@$$A6AXXZ@std@@QAE@XZ	; std::function<void __cdecl(void)>::~function<void __cdecl(void)>
	mov	esp, ebp
	pop	ebp
	ret	0
??1StopInfo@OBS@@QAE@XZ ENDP				; OBS::StopInfo::~StopInfo
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$map@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$map@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@QAE@XZ PROC ; std::map<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::~map<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::~_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$map@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@QAE@XZ ENDP ; std::map<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::~map<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$CircularList@_K@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CircularList@_K@@QAE@XZ PROC			; CircularList<unsigned __int64>::~CircularList<unsigned __int64>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$List@_K@@QAE@XZ			; List<unsigned __int64>::~List<unsigned __int64>
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CircularList@_K@@QAE@XZ ENDP			; CircularList<unsigned __int64>::~CircularList<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1PendingStreams@OBS@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1PendingStreams@OBS@@QAE@XZ PROC			; OBS::PendingStreams::~PendingStreams, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??1?$unique_ptr@XUMutexDeleter@@@std@@QAE@XZ ; std::unique_ptr<void,MutexDeleter>::~unique_ptr<void,MutexDeleter>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$list@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAE@XZ ; std::list<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >::~list<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >
	mov	esp, ebp
	pop	ebp
	ret	0
??1PendingStreams@OBS@@QAE@XZ ENDP			; OBS::PendingStreams::~PendingStreams
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.cpp
;	COMDAT ??1OBS@@UAE@XZ
_TEXT	SEGMENT
$T1 = -156						; size = 8
$T2 = -148						; size = 8
tv454 = -140						; size = 4
tv438 = -136						; size = 4
$T3 = -132						; size = 4
$T4 = -128						; size = 4
_unloadPlugin$5 = -124					; size = 4
tv294 = -120						; size = 4
tv302 = -116						; size = 4
tv310 = -112						; size = 4
tv254 = -108						; size = 4
$T6 = -104						; size = 4
$T7 = -100						; size = 4
_pluginInfo$8 = -96					; size = 4
_i$9 = -92						; size = 4
_i$10 = -88						; size = 4
_i$11 = -84						; size = 4
_i$12 = -80						; size = 4
_i$13 = -76						; size = 4
_i$14 = -72						; size = 4
_this$ = -68						; size = 4
_placement$ = -64					; size = 44
_rect$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
??1OBS@@UAE@XZ PROC					; OBS::~OBS, COMDAT
; _this$ = ecx

; 861  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 156				; 0000009cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7OBS@@6B@

; 862  :     Stop(true, true);

	push	1
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Stop@OBS@@AAEX_N0@Z			; OBS::Stop

; 863  : 
; 864  :     bShuttingDown = true;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+1412], 1

; 865  : 
; 866  :     OSTerminateThread(hHotkeyThread, 2500);

	push	2500					; 000009c4H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1236]
	push	eax
	call	DWORD PTR __imp_?OSTerminateThread@@YGHPAXK@Z

; 867  : 
; 868  :     ClosePendingStreams();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClosePendingStreams@OBS@@QAEXXZ	; OBS::ClosePendingStreams

; 869  : 
; 870  :     for(UINT i=0; i<plugins.Num(); i++)

	mov	DWORD PTR _i$10[ebp], 0
	jmp	SHORT $LN26@OBS
$LN25@OBS:
	mov	ecx, DWORD PTR _i$10[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$10[ebp], ecx
$LN26@OBS:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1404				; 0000057cH
	call	?Num@?$List@UPluginInfo@@@@QBEIXZ	; List<PluginInfo>::Num
	cmp	DWORD PTR _i$10[ebp], eax
	jae	SHORT $LN24@OBS

; 871  :     {
; 872  :         PluginInfo &pluginInfo = plugins[i];

	mov	edx, DWORD PTR _i$10[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1404				; 0000057cH
	call	??A?$List@UPluginInfo@@@@QAEAAUPluginInfo@@I@Z ; List<PluginInfo>::operator[]
	mov	DWORD PTR _pluginInfo$8[ebp], eax

; 873  : 
; 874  :         UNLOADPLUGINPROC unloadPlugin = (UNLOADPLUGINPROC)GetProcAddress(pluginInfo.hModule, "UnloadPlugin");

	push	OFFSET $SG4294800561
	mov	eax, DWORD PTR _pluginInfo$8[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	DWORD PTR __imp__GetProcAddress@8
	mov	DWORD PTR _unloadPlugin$5[ebp], eax

; 875  :         if(unloadPlugin)

	cmp	DWORD PTR _unloadPlugin$5[ebp], 0
	je	SHORT $LN23@OBS

; 876  :             unloadPlugin();

	call	DWORD PTR _unloadPlugin$5[ebp]
$LN23@OBS:

; 877  : 
; 878  :         FreeLibrary(pluginInfo.hModule);

	mov	edx, DWORD PTR _pluginInfo$8[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	DWORD PTR __imp__FreeLibrary@4

; 879  :         pluginInfo.strFile.Clear();

	mov	ecx, DWORD PTR _pluginInfo$8[ebp]
	call	DWORD PTR __imp_?Clear@String@@QAEAAV1@XZ

; 880  : 
; 881  :         ZeroMemory(&pluginInfo, sizeof(pluginInfo));

	push	96					; 00000060H
	push	0
	mov	ecx, DWORD PTR _pluginInfo$8[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 882  :     }

	jmp	SHORT $LN25@OBS
$LN24@OBS:

; 883  : 
; 884  :     if (AppConfig->GetInt(TEXT("General"), TEXT("ShowNotificationAreaIcon"), 0) != 0)

	push	0
	push	OFFSET $SG4294800560
	push	OFFSET $SG4294800559
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	test	eax, eax
	je	SHORT $LN22@OBS

; 885  :     {
; 886  :         App->HideNotificationAreaIcon();

	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	call	?HideNotificationAreaIcon@OBS@@QAEHXZ	; OBS::HideNotificationAreaIcon
$LN22@OBS:

; 887  :     }
; 888  : 
; 889  :     if (logDirectoryMonitor)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+840], 0
	je	SHORT $LN21@OBS

; 890  :         OSMonitorDirectoryCallbackStop(logDirectoryMonitor);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+840]
	push	ecx
	call	DWORD PTR __imp_?OSMonitorDirectoryCallbackStop@@YAXPAUOSDirectoryMonitorData@@@Z
	add	esp, 4
$LN21@OBS:

; 891  : 
; 892  :     //DestroyWindow(hwndMain);
; 893  : 
; 894  :     // Remember window state for next launch
; 895  :     WINDOWPLACEMENT placement;
; 896  :     placement.length = sizeof(placement);

	mov	DWORD PTR _placement$[ebp], 44		; 0000002cH

; 897  :     GetWindowPlacement(hwndMain, &placement);

	lea	edx, DWORD PTR _placement$[ebp]
	push	edx
	mov	eax, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	eax
	call	DWORD PTR __imp__GetWindowPlacement@8

; 898  :     RECT rect = { 0 };

	mov	DWORD PTR _rect$[ebp], 0
	xor	ecx, ecx
	mov	DWORD PTR _rect$[ebp+4], ecx
	mov	DWORD PTR _rect$[ebp+8], ecx
	mov	DWORD PTR _rect$[ebp+12], ecx

; 899  :     GetWindowRect(hwndMain, &rect);

	lea	edx, DWORD PTR _rect$[ebp]
	push	edx
	mov	eax, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	eax
	call	DWORD PTR __imp__GetWindowRect@8

; 900  :     GlobalConfig->SetInt(TEXT("General"), TEXT("PosX"), rect.left);

	mov	ecx, DWORD PTR _rect$[ebp]
	push	ecx
	push	OFFSET $SG4294800558
	push	OFFSET $SG4294800557
	mov	ecx, DWORD PTR ?GlobalConfig@@3PAVConfigFile@@A ; GlobalConfig
	call	DWORD PTR __imp_?SetInt@ConfigFile@@QAEXPB_W0H@Z

; 901  :     GlobalConfig->SetInt(TEXT("General"), TEXT("PosY"), rect.top);

	mov	edx, DWORD PTR _rect$[ebp+4]
	push	edx
	push	OFFSET $SG4294800556
	push	OFFSET $SG4294800555
	mov	ecx, DWORD PTR ?GlobalConfig@@3PAVConfigFile@@A ; GlobalConfig
	call	DWORD PTR __imp_?SetInt@ConfigFile@@QAEXPB_W0H@Z

; 902  : 	// modify by songmm on 2016-3-2 16:54
; 903  : 	GlobalConfig->SetInt(TEXT("General"), TEXT("Width"),
; 904  : 		rect.right - rect.left -
; 905  : 		GetSystemMetrics(SM_CXSIZEFRAME) * 2);

	mov	esi, DWORD PTR _rect$[ebp+8]
	sub	esi, DWORD PTR _rect$[ebp]
	push	32					; 00000020H
	call	DWORD PTR __imp__GetSystemMetrics@4
	shl	eax, 1
	sub	esi, eax
	push	esi
	push	OFFSET $SG4294800554
	push	OFFSET $SG4294800553
	mov	ecx, DWORD PTR ?GlobalConfig@@3PAVConfigFile@@A ; GlobalConfig
	call	DWORD PTR __imp_?SetInt@ConfigFile@@QAEXPB_W0H@Z

; 906  : 	GlobalConfig->SetInt(TEXT("General"), TEXT("Height"),
; 907  : 		rect.bottom - rect.top -
; 908  : 		GetSystemMetrics(SM_CYSIZEFRAME) * 2 - GetSystemMetrics(SM_CYCAPTION) - GetSystemMetrics(SM_CYMENU));

	mov	esi, DWORD PTR _rect$[ebp+12]
	sub	esi, DWORD PTR _rect$[ebp+4]
	push	33					; 00000021H
	call	DWORD PTR __imp__GetSystemMetrics@4
	shl	eax, 1
	sub	esi, eax
	push	4
	call	DWORD PTR __imp__GetSystemMetrics@4
	sub	esi, eax
	push	15					; 0000000fH
	call	DWORD PTR __imp__GetSystemMetrics@4
	sub	esi, eax
	push	esi
	push	OFFSET $SG4294800552
	push	OFFSET $SG4294800551
	mov	ecx, DWORD PTR ?GlobalConfig@@3PAVConfigFile@@A ; GlobalConfig
	call	DWORD PTR __imp_?SetInt@ConfigFile@@QAEXPB_W0H@Z

; 909  :     GlobalConfig->SetInt(TEXT("General"), TEXT("Maximized"), placement.showCmd == SW_SHOWMAXIMIZED ? 1 : 0);

	cmp	DWORD PTR _placement$[ebp+8], 3
	jne	SHORT $LN29@OBS
	mov	DWORD PTR tv254[ebp], 1
	jmp	SHORT $LN30@OBS
$LN29@OBS:
	mov	DWORD PTR tv254[ebp], 0
$LN30@OBS:
	mov	eax, DWORD PTR tv254[ebp]
	push	eax
	push	OFFSET $SG4294800550
	push	OFFSET $SG4294800549
	mov	ecx, DWORD PTR ?GlobalConfig@@3PAVConfigFile@@A ; GlobalConfig
	call	DWORD PTR __imp_?SetInt@ConfigFile@@QAEXPB_W0H@Z

; 910  : 
; 911  : 	GetWindowRect(hwndLogWindow, &rect);

	lea	ecx, DWORD PTR _rect$[ebp]
	push	ecx
	mov	edx, DWORD PTR ?hwndLogWindow@@3PAUHWND__@@A ; hwndLogWindow
	push	edx
	call	DWORD PTR __imp__GetWindowRect@8

; 912  :     GlobalConfig->SetInt(TEXT("General"), TEXT("LogPosX"), rect.left);

	mov	eax, DWORD PTR _rect$[ebp]
	push	eax
	push	OFFSET $SG4294800548
	push	OFFSET $SG4294800547
	mov	ecx, DWORD PTR ?GlobalConfig@@3PAVConfigFile@@A ; GlobalConfig
	call	DWORD PTR __imp_?SetInt@ConfigFile@@QAEXPB_W0H@Z

; 913  :     GlobalConfig->SetInt(TEXT("General"), TEXT("LogPosY"), rect.top);

	mov	ecx, DWORD PTR _rect$[ebp+4]
	push	ecx
	push	OFFSET $SG4294800546
	push	OFFSET $SG4294800545
	mov	ecx, DWORD PTR ?GlobalConfig@@3PAVConfigFile@@A ; GlobalConfig
	call	DWORD PTR __imp_?SetInt@ConfigFile@@QAEXPB_W0H@Z

; 914  :     GlobalConfig->SetInt(TEXT("General"), TEXT("LogSizeX"), rect.right - rect.left);

	mov	edx, DWORD PTR _rect$[ebp+8]
	sub	edx, DWORD PTR _rect$[ebp]
	push	edx
	push	OFFSET $SG4294800544
	push	OFFSET $SG4294800543
	mov	ecx, DWORD PTR ?GlobalConfig@@3PAVConfigFile@@A ; GlobalConfig
	call	DWORD PTR __imp_?SetInt@ConfigFile@@QAEXPB_W0H@Z

; 915  :     GlobalConfig->SetInt(TEXT("General"), TEXT("LogSizeY"), rect.bottom - rect.top);

	mov	eax, DWORD PTR _rect$[ebp+12]
	sub	eax, DWORD PTR _rect$[ebp+4]
	push	eax
	push	OFFSET $SG4294800542
	push	OFFSET $SG4294800541
	mov	ecx, DWORD PTR ?GlobalConfig@@3PAVConfigFile@@A ; GlobalConfig
	call	DWORD PTR __imp_?SetInt@ConfigFile@@QAEXPB_W0H@Z

; 916  : 
; 917  :     GlobalConfig->SetInt(L"General", L"1to1Preview", renderFrameIn1To1Mode);

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+668]
	push	edx
	push	OFFSET $SG4294800540
	push	OFFSET $SG4294800539
	mov	ecx, DWORD PTR ?GlobalConfig@@3PAVConfigFile@@A ; GlobalConfig
	call	DWORD PTR __imp_?SetInt@ConfigFile@@QAEXPB_W0H@Z

; 918  :     GlobalConfig->SetInt(L"General", L"AlwaysOnTop", App->bAlwaysOnTop);

	mov	eax, DWORD PTR ?App@@3PAVOBS@@A		; App
	movzx	ecx, BYTE PTR [eax+706]
	push	ecx
	push	OFFSET $SG4294800538
	push	OFFSET $SG4294800537
	mov	ecx, DWORD PTR ?GlobalConfig@@3PAVConfigFile@@A ; GlobalConfig
	call	DWORD PTR __imp_?SetInt@ConfigFile@@QAEXPB_W0H@Z

; 919  :     
; 920  :     // Save control panel visibility
; 921  :     GlobalConfig->SetInt(TEXT("General"), TEXT("PanelVisibleWindowed"), bPanelVisibleWindowed ? 1 : 0);

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+688]
	test	eax, eax
	je	SHORT $LN31@OBS
	mov	DWORD PTR tv294[ebp], 1
	jmp	SHORT $LN32@OBS
$LN31@OBS:
	mov	DWORD PTR tv294[ebp], 0
$LN32@OBS:
	mov	ecx, DWORD PTR tv294[ebp]
	push	ecx
	push	OFFSET $SG4294800536
	push	OFFSET $SG4294800535
	mov	ecx, DWORD PTR ?GlobalConfig@@3PAVConfigFile@@A ; GlobalConfig
	call	DWORD PTR __imp_?SetInt@ConfigFile@@QAEXPB_W0H@Z

; 922  :     GlobalConfig->SetInt(TEXT("General"), TEXT("PanelVisibleFullscreen"), bPanelVisibleFullscreen ? 1 : 0);

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+689]
	test	eax, eax
	je	SHORT $LN33@OBS
	mov	DWORD PTR tv302[ebp], 1
	jmp	SHORT $LN34@OBS
$LN33@OBS:
	mov	DWORD PTR tv302[ebp], 0
$LN34@OBS:
	mov	ecx, DWORD PTR tv302[ebp]
	push	ecx
	push	OFFSET $SG4294800534
	push	OFFSET $SG4294800533
	mov	ecx, DWORD PTR ?GlobalConfig@@3PAVConfigFile@@A ; GlobalConfig
	call	DWORD PTR __imp_?SetInt@ConfigFile@@QAEXPB_W0H@Z

; 923  : 
; 924  :     // Save preview enabled/disabled state
; 925  :     GlobalConfig->SetInt(TEXT("General"), TEXT("PreviewEnabled"), bRenderViewEnabled ? 1 : 0);

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+742]
	test	eax, eax
	je	SHORT $LN35@OBS
	mov	DWORD PTR tv310[ebp], 1
	jmp	SHORT $LN36@OBS
$LN35@OBS:
	mov	DWORD PTR tv310[ebp], 0
$LN36@OBS:
	mov	ecx, DWORD PTR tv310[ebp]
	push	ecx
	push	OFFSET $SG4294800532
	push	OFFSET $SG4294800531
	mov	ecx, DWORD PTR ?GlobalConfig@@3PAVConfigFile@@A ; GlobalConfig
	call	DWORD PTR __imp_?SetInt@ConfigFile@@QAEXPB_W0H@Z

; 926  : 
; 927  :     scenesConfig.SaveTo(String() << lpAppDataPath << "\\scenes.xconfig");

	push	OFFSET $SG4294800530
	lea	ecx, DWORD PTR $T2[ebp]
	call	DWORD PTR __imp_??0String@@QAE@PBD@Z
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	push	OFFSET ?lpAppDataPath@@3PA_WA		; lpAppDataPath
	lea	ecx, DWORD PTR $T1[ebp]
	call	DWORD PTR __imp_??0String@@QAE@XZ
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@ABV0@@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 168				; 000000a8H
	call	DWORD PTR __imp_?SaveTo@XConfig@@QAEXPB_W@Z
	lea	ecx, DWORD PTR $T1[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR $T2[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 928  :     scenesConfig.Close(true);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 168				; 000000a8H
	call	DWORD PTR __imp_?Close@XConfig@@QAEX_N@Z

; 929  : 
; 930  :     for(UINT i=0; i<Icons.Num(); i++)

	mov	DWORD PTR _i$11[ebp], 0
	jmp	SHORT $LN20@OBS
$LN19@OBS:
	mov	eax, DWORD PTR _i$11[ebp]
	add	eax, 1
	mov	DWORD PTR _i$11[ebp], eax
$LN20@OBS:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1344				; 00000540H
	call	?Num@?$List@UIconInfo@@@@QBEIXZ		; List<IconInfo>::Num
	cmp	DWORD PTR _i$11[ebp], eax
	jae	SHORT $LN18@OBS

; 931  :         DeleteObject(Icons[i].hIcon);

	mov	ecx, DWORD PTR _i$11[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1344				; 00000540H
	call	??A?$List@UIconInfo@@@@QAEAAUIconInfo@@I@Z ; List<IconInfo>::operator[]
	mov	edx, DWORD PTR [eax+4]
	push	edx
	call	DWORD PTR __imp__DeleteObject@4
	jmp	SHORT $LN19@OBS
$LN18@OBS:

; 932  :     Icons.Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1344				; 00000540H
	call	?Clear@?$List@UIconInfo@@@@QAEXXZ	; List<IconInfo>::Clear

; 933  : 
; 934  :     for(UINT i=0; i<Fonts.Num(); i++)

	mov	DWORD PTR _i$14[ebp], 0
	jmp	SHORT $LN17@OBS
$LN16@OBS:
	mov	eax, DWORD PTR _i$14[ebp]
	add	eax, 1
	mov	DWORD PTR _i$14[ebp], eax
$LN17@OBS:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1352				; 00000548H
	call	?Num@?$List@UFontInfo@@@@QBEIXZ		; List<FontInfo>::Num
	cmp	DWORD PTR _i$14[ebp], eax
	jae	SHORT $LN15@OBS

; 935  :     {
; 936  :         DeleteObject(Fonts[i].hFont);

	mov	ecx, DWORD PTR _i$14[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1352				; 00000548H
	call	??A?$List@UFontInfo@@@@QAEAAUFontInfo@@I@Z ; List<FontInfo>::operator[]
	mov	edx, DWORD PTR [eax]
	push	edx
	call	DWORD PTR __imp__DeleteObject@4

; 937  :         Fonts[i].strFontFace.Clear();

	mov	eax, DWORD PTR _i$14[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1352				; 00000548H
	call	??A?$List@UFontInfo@@@@QAEAAUFontInfo@@I@Z ; List<FontInfo>::operator[]
	add	eax, 4
	mov	ecx, eax
	call	DWORD PTR __imp_?Clear@String@@QAEAAV1@XZ

; 938  :     }

	jmp	SHORT $LN16@OBS
$LN15@OBS:

; 939  :     Fonts.Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1352				; 00000548H
	call	?Clear@?$List@UFontInfo@@@@QAEXXZ	; List<FontInfo>::Clear

; 940  : 
; 941  :     for(UINT i=0; i<sceneClasses.Num(); i++)

	mov	DWORD PTR _i$13[ebp], 0
	jmp	SHORT $LN14@OBS
$LN13@OBS:
	mov	ecx, DWORD PTR _i$13[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$13[ebp], ecx
$LN14@OBS:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1360				; 00000550H
	call	?Num@?$List@UClassInfo@@@@QBEIXZ	; List<ClassInfo>::Num
	cmp	DWORD PTR _i$13[ebp], eax
	jae	SHORT $LN12@OBS

; 942  :         sceneClasses[i].FreeData();

	mov	edx, DWORD PTR _i$13[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1360				; 00000550H
	call	??A?$List@UClassInfo@@@@QAEAAUClassInfo@@I@Z ; List<ClassInfo>::operator[]
	mov	ecx, eax
	call	?FreeData@ClassInfo@@QAEXXZ		; ClassInfo::FreeData
	jmp	SHORT $LN13@OBS
$LN12@OBS:

; 943  :     for(UINT i=0; i<imageSourceClasses.Num(); i++)

	mov	DWORD PTR _i$9[ebp], 0
	jmp	SHORT $LN11@OBS
$LN10@OBS:
	mov	eax, DWORD PTR _i$9[ebp]
	add	eax, 1
	mov	DWORD PTR _i$9[ebp], eax
$LN11@OBS:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1368				; 00000558H
	call	?Num@?$List@UClassInfo@@@@QBEIXZ	; List<ClassInfo>::Num
	cmp	DWORD PTR _i$9[ebp], eax
	jae	SHORT $LN9@OBS

; 944  :         imageSourceClasses[i].FreeData();

	mov	ecx, DWORD PTR _i$9[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1368				; 00000558H
	call	??A?$List@UClassInfo@@@@QAEAAUClassInfo@@I@Z ; List<ClassInfo>::operator[]
	mov	ecx, eax
	call	?FreeData@ClassInfo@@QAEXXZ		; ClassInfo::FreeData
	jmp	SHORT $LN10@OBS
$LN9@OBS:

; 945  : 
; 946  :     if (hVideoEvent)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1124], 0
	je	SHORT $LN8@OBS

; 947  :         CloseHandle(hVideoEvent);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1124]
	push	ecx
	call	DWORD PTR __imp__CloseHandle@4
$LN8@OBS:

; 948  : 
; 949  :     if(hSceneMutex)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+956], 0
	je	SHORT $LN7@OBS

; 950  :         OSCloseMutex(hSceneMutex);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+956]
	push	ecx
	call	DWORD PTR __imp_?OSCloseMutex@@YGXPAX@Z
$LN7@OBS:

; 951  : 
; 952  :     if(hAuxAudioMutex)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1228], 0
	je	SHORT $LN6@OBS

; 953  :         OSCloseMutex(hAuxAudioMutex);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1228]
	push	ecx
	call	DWORD PTR __imp_?OSCloseMutex@@YGXPAX@Z
$LN6@OBS:

; 954  : 
; 955  :     delete API;

	mov	edx, DWORD PTR __imp_?API@@3PAVAPIInterface@@A
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T3[ebp], eax
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR $T7[ebp], ecx
	cmp	DWORD PTR $T7[ebp], 0
	je	SHORT $LN37@OBS
	push	1
	mov	edx, DWORD PTR $T7[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR $T7[ebp]
	mov	edx, DWORD PTR [eax+4]
	call	edx
	mov	DWORD PTR tv438[ebp], eax
	jmp	SHORT $LN38@OBS
$LN37@OBS:
	mov	DWORD PTR tv438[ebp], 0
$LN38@OBS:

; 956  :     API = NULL;

	mov	eax, DWORD PTR __imp_?API@@3PAVAPIInterface@@A
	mov	DWORD PTR [eax], 0

; 957  : 
; 958  :     for (UINT i=0; i<settingsPanes.Num(); i++)

	mov	DWORD PTR _i$12[ebp], 0
	jmp	SHORT $LN5@OBS
$LN4@OBS:
	mov	ecx, DWORD PTR _i$12[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$12[ebp], ecx
$LN5@OBS:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 232				; 000000e8H
	call	?Num@?$List@PAVSettingsPane@@@@QBEIXZ	; List<SettingsPane *>::Num
	cmp	DWORD PTR _i$12[ebp], eax
	jae	SHORT $LN3@OBS

; 959  :         delete settingsPanes[i];

	mov	edx, DWORD PTR _i$12[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 232				; 000000e8H
	call	??A?$List@PAVSettingsPane@@@@QAEAAPAVSettingsPane@@I@Z ; List<SettingsPane *>::operator[]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR $T4[ebp], eax
	mov	ecx, DWORD PTR $T4[ebp]
	mov	DWORD PTR $T6[ebp], ecx
	cmp	DWORD PTR $T6[ebp], 0
	je	SHORT $LN39@OBS
	push	1
	mov	edx, DWORD PTR $T6[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR $T6[ebp]
	mov	edx, DWORD PTR [eax]
	call	edx
	mov	DWORD PTR tv454[ebp], eax
	jmp	SHORT $LN40@OBS
$LN39@OBS:
	mov	DWORD PTR tv454[ebp], 0
$LN40@OBS:
	jmp	SHORT $LN4@OBS
$LN3@OBS:

; 960  : 
; 961  :     if(hInfoMutex)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1384], 0
	je	SHORT $LN2@OBS

; 962  :         OSCloseMutex(hInfoMutex);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1384]
	push	edx
	call	DWORD PTR __imp_?OSCloseMutex@@YGXPAX@Z
$LN2@OBS:

; 963  :     if(hHotkeyMutex)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1232], 0
	je	SHORT $LN1@OBS

; 964  :         OSCloseMutex(hHotkeyMutex);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1232]
	push	edx
	call	DWORD PTR __imp_?OSCloseMutex@@YGXPAX@Z
$LN1@OBS:

; 965  : 
; 966  :     App = NULL;

	mov	DWORD PTR ?App@@3PAVOBS@@A, 0		; App

; 967  : }

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1416				; 00000588H
	call	??1PendingStreams@OBS@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1404				; 0000057cH
	call	??1?$List@UPluginInfo@@@@QAE@XZ		; List<PluginInfo>::~List<PluginInfo>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1388				; 0000056cH
	call	??1?$List@UStreamInfo@@@@QAE@XZ		; List<StreamInfo>::~List<StreamInfo>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1376				; 00000560H
	call	??1?$List@UGlobalSourceInfo@@@@QAE@XZ	; List<GlobalSourceInfo>::~List<GlobalSourceInfo>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1368				; 00000558H
	call	??1?$List@UClassInfo@@@@QAE@XZ		; List<ClassInfo>::~List<ClassInfo>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1360				; 00000550H
	call	??1?$List@UClassInfo@@@@QAE@XZ		; List<ClassInfo>::~List<ClassInfo>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1352				; 00000548H
	call	??1?$List@UFontInfo@@@@QAE@XZ		; List<FontInfo>::~List<FontInfo>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1344				; 00000540H
	call	??1?$List@UIconInfo@@@@QAE@XZ		; List<IconInfo>::~List<IconInfo>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1336				; 00000538H
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1328				; 00000530H
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1208				; 000004b8H
	call	??1?$List@UFrameAudio@@@@QAE@XZ		; List<FrameAudio>::~List<FrameAudio>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1128				; 00000468H
	call	??1?$CircularList@_K@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1072				; 00000430H
	call	??1StopInfo@OBS@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1064				; 00000428H
	call	??1?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@QAE@XZ ; std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> >::~unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> >
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1032				; 00000408H
	call	??1StopInfo@OBS@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1028				; 00000404H
	call	??1?$unique_ptr@VVideoFileStream@@U?$default_delete@VVideoFileStream@@@std@@@std@@QAE@XZ ; std::unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> >::~unique_ptr<VideoFileStream,std::default_delete<VideoFileStream> >
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 968				; 000003c8H
	call	??1?$CircularList@I@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 960				; 000003c0H
	call	??1?$List@UVideoSegment@@@@QAE@XZ	; List<VideoSegment>::~List<VideoSegment>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 844				; 0000034cH
	call	??1?$map@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 612				; 00000264H
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 572				; 0000023cH
	call	??1COBSButton@@QAE@XZ			; COBSButton::~COBSButton
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 532				; 00000214H
	call	??1COBSButton@@QAE@XZ			; COBSButton::~COBSButton
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 492				; 000001ecH
	call	??1COBSButton@@QAE@XZ			; COBSButton::~COBSButton
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 452				; 000001c4H
	call	??1COBSButton@@QAE@XZ			; COBSButton::~COBSButton
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 412				; 0000019cH
	call	??1COBSButton@@QAE@XZ			; COBSButton::~COBSButton
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 372				; 00000174H
	call	??1COBSButton@@QAE@XZ			; COBSButton::~COBSButton
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 332				; 0000014cH
	call	??1COBSButton@@QAE@XZ			; COBSButton::~COBSButton
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 292				; 00000124H
	call	??1COBSButton@@QAE@XZ			; COBSButton::~COBSButton
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 252				; 000000fcH
	call	??1COBSButton@@QAE@XZ			; COBSButton::~COBSButton
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 232				; 000000e8H
	call	??1?$List@PAVSettingsPane@@@@QAE@XZ	; List<SettingsPane *>::~List<SettingsPane *>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 204				; 000000ccH
	call	??1?$List@USceneHotkeyInfo@@@@QAE@XZ	; List<SceneHotkeyInfo>::~List<SceneHotkeyInfo>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 192				; 000000c0H
	call	DWORD PTR __imp_??1XConfig@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 180				; 000000b4H
	call	DWORD PTR __imp_??1XConfig@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 168				; 000000a8H
	call	DWORD PTR __imp_??1XConfig@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 156				; 0000009cH
	call	??1?$List@UMonitorInfo@@@@QAE@XZ	; List<MonitorInfo>::~List<MonitorInfo>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 120				; 00000078H
	call	??1?$List@PAVAudioSource@@@@QAE@XZ	; List<AudioSource *>::~List<AudioSource *>
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 80					; 00000050H
	call	??1StopInfo@OBS@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 76					; 0000004cH
	call	??1?$unique_ptr@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@@std@@QAE@XZ ; std::unique_ptr<NetworkStream,std::default_delete<NetworkStream> >::~unique_ptr<NetworkStream,std::default_delete<NetworkStream> >
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
??1OBS@@UAE@XZ ENDP					; OBS::~OBS
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.cpp
;	COMDAT ?UpdateRenderViewMessage@OBS@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?UpdateRenderViewMessage@OBS@@AAEXXZ PROC		; OBS::UpdateRenderViewMessage, COMDAT
; _this$ = ecx

; 973  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 974  :     //if(bRunning)
; 975  :     //{
; 976  :     //    if(bRenderViewEnabled)
; 977  :     //    {
; 978  :     //        // Message should be invisible
; 979  :     //        ShowWindow(hwndRenderMessage, SW_HIDE);
; 980  :     //    }
; 981  :     //    else
; 982  :     //    {
; 983  :     //        ShowWindow(hwndRenderMessage, SW_SHOW);
; 984  :     //        SetWindowText(hwndRenderMessage, Str("MainWindow.PreviewDisabled"));
; 985  :     //    }
; 986  :     //}
; 987  :     //else
; 988  :     //{
; 989  :     //    ShowWindow(hwndRenderMessage, SW_SHOW);
; 990  :     //    SetWindowText(hwndRenderMessage, Str("MainWindow.BeginMessage"));
; 991  :     //}
; 992  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?UpdateRenderViewMessage@OBS@@AAEXXZ ENDP		; OBS::UpdateRenderViewMessage
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.cpp
;	COMDAT ?ResizeRenderFrame@OBS@@AAEX_N@Z
_TEXT	SEGMENT
tv343 = -144						; size = 8
tv319 = -136						; size = 8
tv333 = -128						; size = 8
tv310 = -120						; size = 8
_defCY$1 = -112						; size = 4
_renderAspect$2 = -108					; size = 4
_defCX$3 = -104						; size = 4
_scale$4 = -100						; size = 4
tv315 = -96						; size = 4
tv140 = -92						; size = 4
tv143 = -88						; size = 4
tv146 = -84						; size = 4
tv306 = -80						; size = 4
tv339 = -76						; size = 4
tv329 = -72						; size = 4
tv149 = -68						; size = 4
_newRenderFrameHeight$ = -64				; size = 4
tv144 = -60						; size = 4
_newRenderFrameWidth$ = -56				; size = 4
tv150 = -52						; size = 4
_monitorID$5 = -48					; size = 4
_y$ = -44						; size = 4
_x$ = -40						; size = 4
_mainAspect$ = -36					; size = 4
_screenRect$6 = -32					; size = 4
_renderSize$7 = -28					; size = 8
_controlHeight$ = -20					; size = 4
_controlWidth$ = -16					; size = 4
_curCX$ = -12						; size = 4
_curCY$ = -8						; size = 4
_this$ = -4						; size = 4
_bRedrawRenderFrame$ = 8				; size = 1
?ResizeRenderFrame@OBS@@AAEX_N@Z PROC			; OBS::ResizeRenderFrame, COMDAT
; _this$ = ecx

; 995  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 144				; 00000090H
	mov	DWORD PTR _this$[ebp], ecx

; 996  : 	//
; 997  :     // Get output steam size and aspect ratio
; 998  :     int curCX, curCY;
; 999  :     float mainAspect;
; 1000 :     if(bRunning)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+622]
	test	ecx, ecx
	je	SHORT $LN11@ResizeRend

; 1001 :     {
; 1002 :         curCX = outputCX;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+872]
	mov	DWORD PTR _curCX$[ebp], eax

; 1003 :         curCY = outputCY;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+876]
	mov	DWORD PTR _curCY$[ebp], edx

; 1004 :         mainAspect = float(curCX)/float(curCY);

	cvtsi2ss xmm0, DWORD PTR _curCX$[ebp]
	cvtsi2ss xmm1, DWORD PTR _curCY$[ebp]
	divss	xmm0, xmm1
	movss	DWORD PTR _mainAspect$[ebp], xmm0

; 1005 :     }
; 1006 :     else

	jmp	$LN10@ResizeRend
$LN11@ResizeRend:

; 1007 :     {
; 1008 :         // Default to the monitor's resolution if the base size is undefined
; 1009 :         int monitorID = AppConfig->GetInt(TEXT("Video"), TEXT("Monitor"));

	push	0
	push	OFFSET $SG4294800529
	push	OFFSET $SG4294800528
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	mov	DWORD PTR _monitorID$5[ebp], eax

; 1010 :         if(monitorID >= (int)monitors.Num())

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 156				; 0000009cH
	call	?Num@?$List@UMonitorInfo@@@@QBEIXZ	; List<MonitorInfo>::Num
	cmp	DWORD PTR _monitorID$5[ebp], eax
	jl	SHORT $LN9@ResizeRend

; 1011 :             monitorID = 0;

	mov	DWORD PTR _monitorID$5[ebp], 0
$LN9@ResizeRend:

; 1012 :         RECT &screenRect = monitors[monitorID].rect;

	mov	eax, DWORD PTR _monitorID$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 156				; 0000009cH
	call	??A?$List@UMonitorInfo@@@@QAEAAUMonitorInfo@@I@Z ; List<MonitorInfo>::operator[]
	add	eax, 4
	mov	DWORD PTR _screenRect$6[ebp], eax

; 1013 :         int defCX = screenRect.right  - screenRect.left;

	mov	ecx, DWORD PTR _screenRect$6[ebp]
	mov	edx, DWORD PTR _screenRect$6[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx]
	mov	DWORD PTR _defCX$3[ebp], eax

; 1014 :         int defCY = screenRect.bottom - screenRect.top;

	mov	ecx, DWORD PTR _screenRect$6[ebp]
	mov	edx, DWORD PTR _screenRect$6[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _defCY$1[ebp], eax

; 1015 : 
; 1016 :         // Calculate output size using the same algorithm that's in OBS::Start()
; 1017 :         float scale = AppConfig->GetFloat(TEXT("Video"), TEXT("Downscale"), 1.0f);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG4294800527
	push	OFFSET $SG4294800526
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetFloat@ConfigFile@@QAEMPB_W0M@Z
	fstp	DWORD PTR _scale$4[ebp]

; 1018 :         curCX = AppConfig->GetInt(TEXT("Video"), TEXT("BaseWidth"),  defCX);

	mov	ecx, DWORD PTR _defCX$3[ebp]
	push	ecx
	push	OFFSET $SG4294800525
	push	OFFSET $SG4294800524
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	mov	DWORD PTR _curCX$[ebp], eax

; 1019 :         curCY = AppConfig->GetInt(TEXT("Video"), TEXT("BaseHeight"), defCY);

	mov	edx, DWORD PTR _defCY$1[ebp]
	push	edx
	push	OFFSET $SG4294800523
	push	OFFSET $SG4294800522
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	mov	DWORD PTR _curCY$[ebp], eax

; 1020 :         curCX = MIN(MAX(curCX, 128), 4096);

	cmp	DWORD PTR _curCX$[ebp], 128		; 00000080H
	jle	SHORT $LN14@ResizeRend
	mov	eax, DWORD PTR _curCX$[ebp]
	mov	DWORD PTR tv140[ebp], eax
	jmp	SHORT $LN15@ResizeRend
$LN14@ResizeRend:
	mov	DWORD PTR tv140[ebp], 128		; 00000080H
$LN15@ResizeRend:
	cmp	DWORD PTR tv140[ebp], 4096		; 00001000H
	jge	SHORT $LN18@ResizeRend
	cmp	DWORD PTR _curCX$[ebp], 128		; 00000080H
	jle	SHORT $LN16@ResizeRend
	mov	ecx, DWORD PTR _curCX$[ebp]
	mov	DWORD PTR tv143[ebp], ecx
	jmp	SHORT $LN17@ResizeRend
$LN16@ResizeRend:
	mov	DWORD PTR tv143[ebp], 128		; 00000080H
$LN17@ResizeRend:
	mov	edx, DWORD PTR tv143[ebp]
	mov	DWORD PTR tv144[ebp], edx
	jmp	SHORT $LN19@ResizeRend
$LN18@ResizeRend:
	mov	DWORD PTR tv144[ebp], 4096		; 00001000H
$LN19@ResizeRend:
	mov	eax, DWORD PTR tv144[ebp]
	mov	DWORD PTR _curCX$[ebp], eax

; 1021 :         curCY = MIN(MAX(curCY, 128), 4096);

	cmp	DWORD PTR _curCY$[ebp], 128		; 00000080H
	jle	SHORT $LN20@ResizeRend
	mov	ecx, DWORD PTR _curCY$[ebp]
	mov	DWORD PTR tv146[ebp], ecx
	jmp	SHORT $LN21@ResizeRend
$LN20@ResizeRend:
	mov	DWORD PTR tv146[ebp], 128		; 00000080H
$LN21@ResizeRend:
	cmp	DWORD PTR tv146[ebp], 4096		; 00001000H
	jge	SHORT $LN24@ResizeRend
	cmp	DWORD PTR _curCY$[ebp], 128		; 00000080H
	jle	SHORT $LN22@ResizeRend
	mov	edx, DWORD PTR _curCY$[ebp]
	mov	DWORD PTR tv149[ebp], edx
	jmp	SHORT $LN23@ResizeRend
$LN22@ResizeRend:
	mov	DWORD PTR tv149[ebp], 128		; 00000080H
$LN23@ResizeRend:
	mov	eax, DWORD PTR tv149[ebp]
	mov	DWORD PTR tv150[ebp], eax
	jmp	SHORT $LN25@ResizeRend
$LN24@ResizeRend:
	mov	DWORD PTR tv150[ebp], 4096		; 00001000H
$LN25@ResizeRend:
	mov	ecx, DWORD PTR tv150[ebp]
	mov	DWORD PTR _curCY$[ebp], ecx

; 1022 :         curCX = UINT(double(curCX) / double(scale));

	cvtsi2sd xmm0, DWORD PTR _curCX$[ebp]
	cvtss2sd xmm1, DWORD PTR _scale$4[ebp]
	divsd	xmm0, xmm1
	call	__dtoui3
	mov	DWORD PTR _curCX$[ebp], eax

; 1023 :         curCY = UINT(double(curCY) / double(scale));

	cvtsi2sd xmm0, DWORD PTR _curCY$[ebp]
	cvtss2sd xmm1, DWORD PTR _scale$4[ebp]
	divsd	xmm0, xmm1
	call	__dtoui3
	mov	DWORD PTR _curCY$[ebp], eax

; 1024 :         curCX = curCX & 0xFFFFFFFC; // Align width to 128bit for fast SSE YUV4:2:0 conversion

	mov	edx, DWORD PTR _curCX$[ebp]
	and	edx, -4					; fffffffcH
	mov	DWORD PTR _curCX$[ebp], edx

; 1025 :         curCY = curCY & 0xFFFFFFFE;

	mov	eax, DWORD PTR _curCY$[ebp]
	and	eax, -2					; fffffffeH
	mov	DWORD PTR _curCY$[ebp], eax

; 1026 : 
; 1027 :         mainAspect = float(curCX)/float(curCY);

	cvtsi2ss xmm0, DWORD PTR _curCX$[ebp]
	cvtsi2ss xmm1, DWORD PTR _curCY$[ebp]
	divss	xmm0, xmm1
	movss	DWORD PTR _mainAspect$[ebp], xmm0
$LN10@ResizeRend:

; 1028 :     }
; 1029 : 
; 1030 :     // Get area to render in
; 1031 :     int x, y;
; 1032 :     UINT controlWidth  = clientWidth;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+680]
	mov	DWORD PTR _controlWidth$[ebp], edx

; 1033 :     UINT controlHeight = clientHeight;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+684]
	mov	DWORD PTR _controlHeight$[ebp], ecx

; 1034 : 	if (bPanelVisible) {

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+690]
	test	eax, eax
	je	SHORT $LN8@ResizeRend

; 1035 : 		controlHeight -= totalHeaderAreaHegiht +totalBottomAreaHeight+ controlPadding;

	mov	ecx, DWORD PTR _controlHeight$[ebp]
	sub	ecx, 183				; 000000b7H
	mov	DWORD PTR _controlHeight$[ebp], ecx

; 1036 : 		controlWidth-=TabControlAreaWidth+controlPadding;

	mov	edx, DWORD PTR _controlWidth$[ebp]
	sub	edx, 203				; 000000cbH
	mov	DWORD PTR _controlWidth$[ebp], edx
$LN8@ResizeRend:

; 1037 : 	}
; 1038 :  
; 1039 :     UINT newRenderFrameWidth, newRenderFrameHeight;
; 1040 :     if(renderFrameIn1To1Mode)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+668]
	test	ecx, ecx
	je	SHORT $LN7@ResizeRend

; 1041 :     {
; 1042 :         newRenderFrameWidth  = (UINT)curCX;

	mov	edx, DWORD PTR _curCX$[ebp]
	mov	DWORD PTR _newRenderFrameWidth$[ebp], edx

; 1043 :         newRenderFrameHeight = (UINT)curCY;

	mov	eax, DWORD PTR _curCY$[ebp]
	mov	DWORD PTR _newRenderFrameHeight$[ebp], eax

; 1044 :         x = (int)controlWidth / 2 - curCX / 2;

	mov	eax, DWORD PTR _controlWidth$[ebp]
	cdq
	sub	eax, edx
	mov	ecx, eax
	sar	ecx, 1
	mov	eax, DWORD PTR _curCX$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	sub	ecx, eax
	mov	DWORD PTR _x$[ebp], ecx

; 1045 :         y = (int)controlHeight / 2 - curCY / 2;

	mov	eax, DWORD PTR _controlHeight$[ebp]
	cdq
	sub	eax, edx
	mov	ecx, eax
	sar	ecx, 1
	mov	eax, DWORD PTR _curCY$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	sub	ecx, eax
	mov	DWORD PTR _y$[ebp], ecx

; 1046 :     }
; 1047 :     else

	jmp	$LN6@ResizeRend
$LN7@ResizeRend:

; 1048 :     { // Scale to fit
; 1049 :         Vect2 renderSize = Vect2(float(controlWidth), float(controlHeight));

	mov	edx, DWORD PTR _controlHeight$[ebp]
	mov	DWORD PTR tv306[ebp], edx
	cvtsi2sd xmm0, DWORD PTR tv306[ebp]
	mov	eax, DWORD PTR tv306[ebp]
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	movsd	QWORD PTR tv310[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv310[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _controlWidth$[ebp]
	mov	DWORD PTR tv315[ebp], ecx
	cvtsi2sd xmm0, DWORD PTR tv315[ebp]
	mov	edx, DWORD PTR tv315[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	movsd	QWORD PTR tv319[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv319[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _renderSize$7[ebp]
	call	DWORD PTR __imp_??0Vect2@@QAE@MM@Z

; 1050 :         float renderAspect = renderSize.x/renderSize.y;

	movss	xmm0, DWORD PTR _renderSize$7[ebp]
	divss	xmm0, DWORD PTR _renderSize$7[ebp+4]
	movss	DWORD PTR _renderAspect$2[ebp], xmm0

; 1051 : 
; 1052 :         if(renderAspect > mainAspect)

	movss	xmm0, DWORD PTR _renderAspect$2[ebp]
	comiss	xmm0, DWORD PTR _mainAspect$[ebp]
	jbe	SHORT $LN5@ResizeRend

; 1053 :         {
; 1054 :             renderSize.x = renderSize.y*mainAspect;

	movss	xmm0, DWORD PTR _renderSize$7[ebp+4]
	mulss	xmm0, DWORD PTR _mainAspect$[ebp]
	movss	DWORD PTR _renderSize$7[ebp], xmm0

; 1055 :             x = int((float(controlWidth)-renderSize.x)*0.5f);

	mov	eax, DWORD PTR _controlWidth$[ebp]
	mov	DWORD PTR tv329[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv329[ebp]
	mov	ecx, DWORD PTR tv329[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	movsd	QWORD PTR tv333[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv333[ebp]
	subss	xmm0, DWORD PTR _renderSize$7[ebp]
	mulss	xmm0, DWORD PTR __real@3f000000
	cvttss2si edx, xmm0
	mov	DWORD PTR _x$[ebp], edx

; 1056 :             y = 0;

	mov	DWORD PTR _y$[ebp], 0

; 1057 :         }
; 1058 :         else

	jmp	SHORT $LN4@ResizeRend
$LN5@ResizeRend:

; 1059 :         {
; 1060 :             renderSize.y = renderSize.x/mainAspect;

	movss	xmm0, DWORD PTR _renderSize$7[ebp]
	divss	xmm0, DWORD PTR _mainAspect$[ebp]
	movss	DWORD PTR _renderSize$7[ebp+4], xmm0

; 1061 :             x = 0;

	mov	DWORD PTR _x$[ebp], 0

; 1062 :             y = int((float(controlHeight)-renderSize.y)*0.5f);

	mov	eax, DWORD PTR _controlHeight$[ebp]
	mov	DWORD PTR tv339[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv339[ebp]
	mov	ecx, DWORD PTR tv339[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	movsd	QWORD PTR tv343[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv343[ebp]
	subss	xmm0, DWORD PTR _renderSize$7[ebp+4]
	mulss	xmm0, DWORD PTR __real@3f000000
	cvttss2si edx, xmm0
	mov	DWORD PTR _y$[ebp], edx
$LN4@ResizeRend:

; 1063 :         }
; 1064 : 
; 1065 :         // Round and ensure even size
; 1066 :         newRenderFrameWidth  = int(renderSize.x+0.5f)&0xFFFFFFFE;

	movss	xmm0, DWORD PTR _renderSize$7[ebp]
	addss	xmm0, DWORD PTR __real@3f000000
	cvttss2si eax, xmm0
	and	eax, -2					; fffffffeH
	mov	DWORD PTR _newRenderFrameWidth$[ebp], eax

; 1067 :         newRenderFrameHeight = int(renderSize.y+0.5f)&0xFFFFFFFE;

	movss	xmm0, DWORD PTR _renderSize$7[ebp+4]
	addss	xmm0, DWORD PTR __real@3f000000
	cvttss2si ecx, xmm0
	and	ecx, -2					; fffffffeH
	mov	DWORD PTR _newRenderFrameHeight$[ebp], ecx
$LN6@ResizeRend:

; 1068 :     }
; 1069 : 
; 1070 :     // Fill the majority of the window with the 3D scene. We'll render everything in DirectX
; 1071 : 	SetWindowPos(hwndRenderFrame, NULL, controlPadding, totalHeaderAreaHegiht + controlPadding, controlWidth, controlHeight, SWP_NOOWNERZORDER);

	push	512					; 00000200H
	mov	edx, DWORD PTR _controlHeight$[ebp]
	push	edx
	mov	eax, DWORD PTR _controlWidth$[ebp]
	push	eax
	push	83					; 00000053H
	push	3
	push	0
	mov	ecx, DWORD PTR ?hwndRenderFrame@@3PAUHWND__@@A ; hwndRenderFrame
	push	ecx
	call	DWORD PTR __imp__SetWindowPos@28

; 1072 : 
; 1073 :     //----------------------------------------------
; 1074 : 
; 1075 :     renderFrameX = x;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _x$[ebp]
	mov	DWORD PTR [edx+644], eax

; 1076 :     renderFrameY = y;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _y$[ebp]
	mov	DWORD PTR [ecx+648], edx

; 1077 :     renderFrameWidth  = newRenderFrameWidth;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newRenderFrameWidth$[ebp]
	mov	DWORD PTR [eax+636], ecx

; 1078 :     renderFrameHeight = newRenderFrameHeight;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _newRenderFrameHeight$[ebp]
	mov	DWORD PTR [edx+640], eax

; 1079 :     renderFrameCtrlWidth  = controlWidth;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _controlWidth$[ebp]
	mov	DWORD PTR [ecx+652], edx

; 1080 :     renderFrameCtrlHeight = controlHeight;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _controlHeight$[ebp]
	mov	DWORD PTR [eax+656], ecx

; 1081 :     if(!bRunning)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+622]
	test	eax, eax
	jne	SHORT $LN3@ResizeRend

; 1082 :     {
; 1083 :         oldRenderFrameCtrlWidth = renderFrameCtrlWidth;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+652]
	mov	DWORD PTR [ecx+660], eax

; 1084 :         oldRenderFrameCtrlHeight = renderFrameCtrlHeight;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+656]
	mov	DWORD PTR [ecx+664], eax
	jmp	SHORT $LN1@ResizeRend
$LN3@ResizeRend:

; 1085 :        // InvalidateRect(hwndRenderMessage, NULL, true); // Repaint text
; 1086 :     }
; 1087 :     else if(bRunning && bRedrawRenderFrame)

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+622]
	test	edx, edx
	je	SHORT $LN1@ResizeRend
	movzx	eax, BYTE PTR _bRedrawRenderFrame$[ebp]
	test	eax, eax
	je	SHORT $LN1@ResizeRend

; 1088 :     {
; 1089 :         oldRenderFrameCtrlWidth = renderFrameCtrlWidth;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+652]
	mov	DWORD PTR [ecx+660], eax

; 1090 :         oldRenderFrameCtrlHeight = renderFrameCtrlHeight;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+656]
	mov	DWORD PTR [ecx+664], eax

; 1091 :         bResizeRenderView = true;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+694], 1
$LN1@ResizeRend:

; 1092 :     }
; 1093 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?ResizeRenderFrame@OBS@@AAEX_N@Z ENDP			; OBS::ResizeRenderFrame
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.cpp
;	COMDAT ?SetFullscreenMode@OBS@@QAEX_N@Z
_TEXT	SEGMENT
_monitorForWidow$1 = -80				; size = 4
_style$2 = -76						; size = 4
_style$3 = -72						; size = 4
_cx$4 = -68						; size = 4
_x$5 = -64						; size = 4
_y$6 = -60						; size = 4
_cy$7 = -56						; size = 4
tv178 = -52						; size = 4
_this$ = -48						; size = 4
_monitorInfo$8 = -44					; size = 40
__$ArrayPad$ = -4					; size = 4
_fullscreen$ = 8					; size = 1
?SetFullscreenMode@OBS@@QAEX_N@Z PROC			; OBS::SetFullscreenMode, COMDAT
; _this$ = ecx

; 1096 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 1097 :     if(App->bFullscreenMode == fullscreen)

	mov	eax, DWORD PTR ?App@@3PAVOBS@@A		; App
	movzx	ecx, BYTE PTR [eax+740]
	movzx	edx, BYTE PTR _fullscreen$[ebp]
	cmp	ecx, edx
	jne	SHORT $LN5@SetFullscr

; 1098 :         return; // Nothing to do

	jmp	$LN6@SetFullscr
$LN5@SetFullscr:

; 1099 : 
; 1100 :     App->bFullscreenMode = fullscreen;

	mov	eax, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	cl, BYTE PTR _fullscreen$[ebp]
	mov	BYTE PTR [eax+740], cl

; 1101 :     if(fullscreen)

	movzx	edx, BYTE PTR _fullscreen$[ebp]
	test	edx, edx
	je	$LN4@SetFullscr

; 1102 :     {
; 1103 :         // Remember current window placement
; 1104 :         fullscreenPrevPlacement.length = sizeof(fullscreenPrevPlacement);

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+780], 44			; 0000002cH

; 1105 :         GetWindowPlacement(hwndMain, &fullscreenPrevPlacement);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 780				; 0000030cH
	push	ecx
	mov	edx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	edx
	call	DWORD PTR __imp__GetWindowPlacement@8

; 1106 : 
; 1107 :         // Update panel visibility if required
; 1108 :         if(bPanelVisible != bPanelVisibleFullscreen) {

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+690]
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+689]
	cmp	ecx, eax
	je	SHORT $LN3@SetFullscr

; 1109 :             bPanelVisible = bPanelVisibleFullscreen;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+689]
	mov	BYTE PTR [ecx+690], al

; 1110 :             bPanelVisibleProcessed = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+691], 0
$LN3@SetFullscr:

; 1111 :         }
; 1112 : 
; 1113 :         // Hide borders
; 1114 :         LONG style = GetWindowLong(hwndMain, GWL_STYLE);

	push	-16					; fffffff0H
	mov	edx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	edx
	call	DWORD PTR __imp__GetWindowLongW@8
	mov	DWORD PTR _style$2[ebp], eax

; 1115 :         SetWindowLong(hwndMain, GWL_STYLE, style & ~(WS_CAPTION | WS_THICKFRAME));

	mov	eax, DWORD PTR _style$2[ebp]
	and	eax, -12845057				; ff3bffffH
	push	eax
	push	-16					; fffffff0H
	mov	ecx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	ecx
	call	DWORD PTR __imp__SetWindowLongW@12

; 1116 : 
; 1117 :         // Hide menu and status bar
; 1118 :         SetMenu(hwndMain, NULL);

	push	0
	mov	edx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	edx
	call	DWORD PTR __imp__SetMenu@8

; 1119 : 
; 1120 :         // Fill entire screen
; 1121 :         HMONITOR monitorForWidow = MonitorFromWindow(hwndMain, MONITOR_DEFAULTTONEAREST);

	push	2
	mov	eax, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	eax
	call	DWORD PTR __imp__MonitorFromWindow@8
	mov	DWORD PTR _monitorForWidow$1[ebp], eax

; 1122 :         MONITORINFO monitorInfo;
; 1123 :         monitorInfo.cbSize = sizeof(monitorInfo);

	mov	DWORD PTR _monitorInfo$8[ebp], 40	; 00000028H

; 1124 :         GetMonitorInfo(monitorForWidow, &monitorInfo);

	lea	ecx, DWORD PTR _monitorInfo$8[ebp]
	push	ecx
	mov	edx, DWORD PTR _monitorForWidow$1[ebp]
	push	edx
	call	DWORD PTR __imp__GetMonitorInfoW@8

; 1125 :         int x = monitorInfo.rcMonitor.left;

	mov	eax, DWORD PTR _monitorInfo$8[ebp+4]
	mov	DWORD PTR _x$5[ebp], eax

; 1126 :         int y = monitorInfo.rcMonitor.top;

	mov	ecx, DWORD PTR _monitorInfo$8[ebp+8]
	mov	DWORD PTR _y$6[ebp], ecx

; 1127 :         int cx = monitorInfo.rcMonitor.right - monitorInfo.rcMonitor.left;

	mov	edx, DWORD PTR _monitorInfo$8[ebp+12]
	sub	edx, DWORD PTR _monitorInfo$8[ebp+4]
	mov	DWORD PTR _cx$4[ebp], edx

; 1128 :         int cy = monitorInfo.rcMonitor.bottom - monitorInfo.rcMonitor.top;

	mov	eax, DWORD PTR _monitorInfo$8[ebp+16]
	sub	eax, DWORD PTR _monitorInfo$8[ebp+8]
	mov	DWORD PTR _cy$7[ebp], eax

; 1129 :         SetWindowPos(hwndMain, HWND_TOPMOST, x, y, cx, cy, SWP_FRAMECHANGED);

	push	32					; 00000020H
	mov	ecx, DWORD PTR _cy$7[ebp]
	push	ecx
	mov	edx, DWORD PTR _cx$4[ebp]
	push	edx
	mov	eax, DWORD PTR _y$6[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$5[ebp]
	push	ecx
	push	-1
	mov	edx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	edx
	call	DWORD PTR __imp__SetWindowPos@28

; 1130 : 
; 1131 :         // Update menu checkboxes
; 1132 :         CheckMenuItem(hmenuMain, ID_FULLSCREENMODE, MF_CHECKED);

	push	8
	push	40046					; 00009c6eH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+776]
	push	ecx
	call	DWORD PTR __imp__CheckMenuItem@12

; 1133 :     }
; 1134 :     else

	jmp	$LN2@SetFullscr
$LN4@SetFullscr:

; 1135 :     {
; 1136 :         // Show borders
; 1137 :         LONG style = GetWindowLong(hwndMain, GWL_STYLE);

	push	-16					; fffffff0H
	mov	edx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	edx
	call	DWORD PTR __imp__GetWindowLongW@8
	mov	DWORD PTR _style$3[ebp], eax

; 1138 :         SetWindowLong(hwndMain, GWL_STYLE, style | WS_CAPTION | WS_THICKFRAME);

	mov	eax, DWORD PTR _style$3[ebp]
	or	eax, 12582912				; 00c00000H
	or	eax, 262144				; 00040000H
	push	eax
	push	-16					; fffffff0H
	mov	ecx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	ecx
	call	DWORD PTR __imp__SetWindowLongW@12

; 1139 : 
; 1140 :         // Show menu and status bar
; 1141 :         SetMenu(hwndMain, hmenuMain);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+776]
	push	eax
	mov	ecx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	ecx
	call	DWORD PTR __imp__SetMenu@8

; 1142 : 
; 1143 :         // Restore control panel visible state if required
; 1144 :         if(bPanelVisible != bPanelVisibleWindowed) {

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+690]
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+688]
	cmp	eax, edx
	je	SHORT $LN1@SetFullscr

; 1145 :             bPanelVisible = bPanelVisibleWindowed;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+688]
	mov	BYTE PTR [eax+690], dl

; 1146 :             bPanelVisibleProcessed = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+691], 0
$LN1@SetFullscr:

; 1147 :         }
; 1148 : 
; 1149 :         // Restore original window size
; 1150 :         SetWindowPlacement(hwndMain, &fullscreenPrevPlacement);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 780				; 0000030cH
	push	ecx
	mov	edx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	edx
	call	DWORD PTR __imp__SetWindowPlacement@8

; 1151 : 
; 1152 :         // Update menu checkboxes
; 1153 :         CheckMenuItem(hmenuMain, ID_FULLSCREENMODE, MF_UNCHECKED);

	push	0
	push	40046					; 00009c6eH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+776]
	push	ecx
	call	DWORD PTR __imp__CheckMenuItem@12

; 1154 : 
; 1155 :         // Disable always-on-top if needed
; 1156 :         SetWindowPos(hwndMain, (App->bAlwaysOnTop)?HWND_TOPMOST:HWND_NOTOPMOST, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE);

	mov	edx, DWORD PTR ?App@@3PAVOBS@@A		; App
	movzx	eax, BYTE PTR [edx+706]
	test	eax, eax
	je	SHORT $LN8@SetFullscr
	mov	DWORD PTR tv178[ebp], -1
	jmp	SHORT $LN9@SetFullscr
$LN8@SetFullscr:
	mov	DWORD PTR tv178[ebp], -2		; fffffffeH
$LN9@SetFullscr:
	push	3
	push	0
	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR tv178[ebp]
	push	ecx
	mov	edx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	edx
	call	DWORD PTR __imp__SetWindowPos@28
$LN2@SetFullscr:

; 1157 :     }
; 1158 : 
; 1159 :     // Workaround: If the window is maximized, resize isn't called, so do it manually
; 1160 :     // Also, when going into fullscreen, this can prevent pixelation
; 1161 :     ResizeWindow(true);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResizeWindow@OBS@@QAEX_N@Z		; OBS::ResizeWindow
$LN6@SetFullscr:

; 1162 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
?SetFullscreenMode@OBS@@QAEX_N@Z ENDP			; OBS::SetFullscreenMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.cpp
;	COMDAT ?ProcessPanelVisible@OBS@@AAEX_N@Z
_TEXT	SEGMENT
tv70 = -12						; size = 4
_this$ = -8						; size = 4
_visible$ = -4						; size = 4
_fromResizeWindow$ = 8					; size = 1
?ProcessPanelVisible@OBS@@AAEX_N@Z PROC			; OBS::ProcessPanelVisible, COMDAT
; _this$ = ecx

; 1168 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1169 :     if(bPanelVisibleProcessed)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+691]
	test	ecx, ecx
	je	SHORT $LN3@ProcessPan

; 1170 :         return; // Already done

	jmp	$LN4@ProcessPan
$LN3@ProcessPan:

; 1171 : 
; 1172 :     const int visible = bPanelVisible ? SW_SHOW : SW_HIDE;

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+690]
	test	eax, eax
	je	SHORT $LN6@ProcessPan
	mov	DWORD PTR tv70[ebp], 5
	jmp	SHORT $LN7@ProcessPan
$LN6@ProcessPan:
	mov	DWORD PTR tv70[ebp], 0
$LN7@ProcessPan:
	mov	ecx, DWORD PTR tv70[ebp]
	mov	DWORD PTR _visible$[ebp], ecx

; 1173 : 
; 1174 :     ShowWindow(GetDlgItem(hwndMain, ID_MICVOLUME), visible);

	mov	edx, DWORD PTR _visible$[ebp]
	push	edx
	push	5007					; 0000138fH
	mov	eax, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	eax
	call	DWORD PTR __imp__GetDlgItem@8
	push	eax
	call	DWORD PTR __imp__ShowWindow@8

; 1175 :     ShowWindow(GetDlgItem(hwndMain, ID_DESKTOPVOLUME), visible);

	mov	ecx, DWORD PTR _visible$[ebp]
	push	ecx
	push	5006					; 0000138eH
	mov	edx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	edx
	call	DWORD PTR __imp__GetDlgItem@8
	push	eax
	call	DWORD PTR __imp__ShowWindow@8

; 1176 :     ShowWindow(GetDlgItem(hwndMain, ID_MICVOLUMEMETER), visible);

	mov	eax, DWORD PTR _visible$[ebp]
	push	eax
	push	5009					; 00001391H
	mov	ecx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	ecx
	call	DWORD PTR __imp__GetDlgItem@8
	push	eax
	call	DWORD PTR __imp__ShowWindow@8

; 1177 :     ShowWindow(GetDlgItem(hwndMain, ID_DESKTOPVOLUMEMETER), visible);

	mov	edx, DWORD PTR _visible$[ebp]
	push	edx
	push	5008					; 00001390H
	mov	eax, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	eax
	call	DWORD PTR __imp__GetDlgItem@8
	push	eax
	call	DWORD PTR __imp__ShowWindow@8

; 1178 :     ShowWindow(GetDlgItem(hwndMain, ID_SETTINGS), visible);

	mov	ecx, DWORD PTR _visible$[ebp]
	push	ecx
	push	5000					; 00001388H
	mov	edx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	edx
	call	DWORD PTR __imp__GetDlgItem@8
	push	eax
	call	DWORD PTR __imp__ShowWindow@8

; 1179 :     ShowWindow(GetDlgItem(hwndMain, ID_TOGGLERECORDING), visible);

	mov	eax, DWORD PTR _visible$[ebp]
	push	eax
	push	5002					; 0000138aH
	mov	ecx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	ecx
	call	DWORD PTR __imp__GetDlgItem@8
	push	eax
	call	DWORD PTR __imp__ShowWindow@8

; 1180 :     ShowWindow(GetDlgItem(hwndMain, ID_STARTSTOP), visible);

	mov	edx, DWORD PTR _visible$[ebp]
	push	edx
	push	5003					; 0000138bH
	mov	eax, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	eax
	call	DWORD PTR __imp__GetDlgItem@8
	push	eax
	call	DWORD PTR __imp__ShowWindow@8

; 1181 :   //  ShowWindow(GetDlgItem(hwndMain, ID_SCENEEDITOR), visible);
; 1182 :     ShowWindow(GetDlgItem(hwndMain, ID_TESTSTREAM), visible);

	mov	ecx, DWORD PTR _visible$[ebp]
	push	ecx
	push	5015					; 00001397H
	mov	edx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	edx
	call	DWORD PTR __imp__GetDlgItem@8
	push	eax
	call	DWORD PTR __imp__ShowWindow@8

; 1183 :     ShowWindow(GetDlgItem(hwndMain, ID_GLOBALSOURCES), visible);

	mov	eax, DWORD PTR _visible$[ebp]
	push	eax
	push	5016					; 00001398H
	mov	ecx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	ecx
	call	DWORD PTR __imp__GetDlgItem@8
	push	eax
	call	DWORD PTR __imp__ShowWindow@8

; 1184 :     ShowWindow(GetDlgItem(hwndMain, ID_PLUGINS), visible);

	mov	edx, DWORD PTR _visible$[ebp]
	push	edx
	push	5017					; 00001399H
	mov	eax, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	eax
	call	DWORD PTR __imp__GetDlgItem@8
	push	eax
	call	DWORD PTR __imp__ShowWindow@8

; 1185 :     if(!bPanelVisible) ShowWindow(GetDlgItem(hwndMain, ID_DASHBOARD), SW_HIDE);

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+690]
	test	edx, edx
	jne	SHORT $LN2@ProcessPan
	push	0
	push	5018					; 0000139aH
	mov	eax, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	eax
	call	DWORD PTR __imp__GetDlgItem@8
	push	eax
	call	DWORD PTR __imp__ShowWindow@8
$LN2@ProcessPan:

; 1186 :    // ShowWindow(GetDlgItem(hwndMain, ID_EXIT), visible);
; 1187 :     ShowWindow(GetDlgItem(hwndMain, ID_SCENES_TEXT), visible);

	mov	ecx, DWORD PTR _visible$[ebp]
	push	ecx
	push	5012					; 00001394H
	mov	edx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	edx
	call	DWORD PTR __imp__GetDlgItem@8
	push	eax
	call	DWORD PTR __imp__ShowWindow@8

; 1188 :     ShowWindow(GetDlgItem(hwndMain, ID_SOURCES_TEXT), visible);

	mov	eax, DWORD PTR _visible$[ebp]
	push	eax
	push	5014					; 00001396H
	mov	ecx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	ecx
	call	DWORD PTR __imp__GetDlgItem@8
	push	eax
	call	DWORD PTR __imp__ShowWindow@8

; 1189 :     ShowWindow(GetDlgItem(hwndMain, ID_SCENES), visible);

	mov	edx, DWORD PTR _visible$[ebp]
	push	edx
	push	5011					; 00001393H
	mov	eax, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	eax
	call	DWORD PTR __imp__GetDlgItem@8
	push	eax
	call	DWORD PTR __imp__ShowWindow@8

; 1190 :     ShowWindow(GetDlgItem(hwndMain, ID_SOURCES), visible);

	mov	ecx, DWORD PTR _visible$[ebp]
	push	ecx
	push	5013					; 00001395H
	mov	edx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	edx
	call	DWORD PTR __imp__GetDlgItem@8
	push	eax
	call	DWORD PTR __imp__ShowWindow@8

; 1191 : 
; 1192 :     bPanelVisibleProcessed = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+691], 1

; 1193 : 
; 1194 :     // HACK: Force resize to fix dashboard button. The setting should not be calculated every resize
; 1195 :     if(bPanelVisible && !fromResizeWindow)

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+690]
	test	edx, edx
	je	SHORT $LN4@ProcessPan
	movzx	eax, BYTE PTR _fromResizeWindow$[ebp]
	test	eax, eax
	jne	SHORT $LN4@ProcessPan

; 1196 :         ResizeWindow(false);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResizeWindow@OBS@@QAEX_N@Z		; OBS::ResizeWindow
$LN4@ProcessPan:

; 1197 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?ProcessPanelVisible@OBS@@AAEX_N@Z ENDP			; OBS::ProcessPanelVisible
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.cpp
;	COMDAT ?GetProfiles@OBS@@SAXAAVStringList@@@Z
_TEXT	SEGMENT
$T1 = -576						; size = 8
_strProfilesWildcard$ = -568				; size = 8
_profilePath$2 = -560					; size = 8
_profileDir$ = -552					; size = 8
_profile$3 = -544					; size = 8
_hFind$ = -536						; size = 4
_ofd$ = -532						; size = 528
__$ArrayPad$ = -4					; size = 4
_profileList$ = 8					; size = 4
?GetProfiles@OBS@@SAXAAVStringList@@@Z PROC		; OBS::GetProfiles, COMDAT

; 1370 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 576				; 00000240H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1371 :     String strProfilesWildcard;

	lea	ecx, DWORD PTR _strProfilesWildcard$[ebp]
	call	DWORD PTR __imp_??0String@@QAE@XZ

; 1372 :     OSFindData ofd;
; 1373 :     HANDLE hFind;
; 1374 : 
; 1375 :     profileList.Clear();

	mov	ecx, DWORD PTR _profileList$[ebp]
	call	DWORD PTR __imp_?Clear@StringList@@QAEXXZ

; 1376 : 
; 1377 :     String profileDir(FormattedString(L"%s/profiles/", OBSGetAppDataPath()));

	call	DWORD PTR __imp_?OBSGetAppDataPath@@YAPB_WXZ
	push	eax
	push	OFFSET $SG4294800515
	lea	eax, DWORD PTR _profileDir$[ebp]
	push	eax
	call	DWORD PTR __imp_?FormattedString@@YA?AVString@@PB_WZZ
	add	esp, 12					; 0000000cH

; 1378 : 
; 1379 :     strProfilesWildcard << profileDir << "*.ini";

	push	OFFSET $SG4294800514
	lea	ecx, DWORD PTR $T1[ebp]
	call	DWORD PTR __imp_??0String@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	lea	edx, DWORD PTR _profileDir$[ebp]
	push	edx
	lea	ecx, DWORD PTR _strProfilesWildcard$[ebp]
	call	DWORD PTR __imp_??6String@@QAEAAV0@ABV0@@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@ABV0@@Z
	lea	ecx, DWORD PTR $T1[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 1380 : 
; 1381 :     if(hFind = OSFindFirstFile(strProfilesWildcard, ofd))

	lea	eax, DWORD PTR _ofd$[ebp]
	push	eax
	lea	ecx, DWORD PTR _strProfilesWildcard$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	call	DWORD PTR __imp_?OSFindFirstFile@@YGPAXPB_WAAUOSFindData@@@Z
	mov	DWORD PTR _hFind$[ebp], eax
	cmp	DWORD PTR _hFind$[ebp], 0
	je	$LN6@GetProfile
$LN5@GetProfile:

; 1382 :     {
; 1383 :         do
; 1384 :         {
; 1385 :             String profile(GetPathWithoutExtension(ofd.fileName));

	lea	ecx, DWORD PTR _ofd$[ebp]
	push	ecx
	lea	edx, DWORD PTR _profile$3[ebp]
	push	edx
	call	DWORD PTR __imp_?GetPathWithoutExtension@@YA?AVString@@PB_W@Z
	add	esp, 8

; 1386 :             String profilePath(FormattedString(L"%s%s.ini", profileDir.Array(), profile.Array()));

	lea	ecx, DWORD PTR _profile$3[ebp]
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	lea	ecx, DWORD PTR _profileDir$[ebp]
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	push	OFFSET $SG4294800513
	lea	eax, DWORD PTR _profilePath$2[ebp]
	push	eax
	call	DWORD PTR __imp_?FormattedString@@YA?AVString@@PB_WZZ
	add	esp, 16					; 00000010H

; 1387 :             if(ofd.bDirectory || !OSFileExists(profilePath) || profileList.HasValue(profile)) continue;

	cmp	DWORD PTR _ofd$[ebp+520], 0
	jne	SHORT $LN1@GetProfile
	lea	ecx, DWORD PTR _profilePath$2[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	call	DWORD PTR __imp_?OSFileExists@@YGHPB_W@Z
	test	eax, eax
	je	SHORT $LN1@GetProfile
	lea	ecx, DWORD PTR _profile$3[ebp]
	push	ecx
	mov	ecx, DWORD PTR _profileList$[ebp]
	call	DWORD PTR __imp_?HasValue@?$List@VString@@@@QBEHABVString@@@Z
	test	eax, eax
	je	SHORT $LN2@GetProfile
$LN1@GetProfile:
	lea	ecx, DWORD PTR _profilePath$2[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _profile$3[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	jmp	SHORT $LN4@GetProfile
$LN2@GetProfile:

; 1388 :             profileList << profile;

	lea	edx, DWORD PTR _profile$3[ebp]
	push	edx
	mov	ecx, DWORD PTR _profileList$[ebp]
	call	DWORD PTR __imp_??6StringList@@QAEAAV0@ABVString@@@Z

; 1389 :         } while(OSFindNextFile(hFind, ofd));

	lea	ecx, DWORD PTR _profilePath$2[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _profile$3[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
$LN4@GetProfile:
	lea	eax, DWORD PTR _ofd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hFind$[ebp]
	push	ecx
	call	DWORD PTR __imp_?OSFindNextFile@@YGHPAXAAUOSFindData@@@Z
	test	eax, eax
	jne	$LN5@GetProfile

; 1390 : 
; 1391 :         OSFindClose(hFind);

	mov	edx, DWORD PTR _hFind$[ebp]
	push	edx
	call	DWORD PTR __imp_?OSFindClose@@YGXPAX@Z
$LN6@GetProfile:

; 1392 :     }
; 1393 : }

	lea	ecx, DWORD PTR _profileDir$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _strProfilesWildcard$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?GetProfiles@OBS@@SAXAAVStringList@@@Z ENDP		; OBS::GetProfiles
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.cpp
;	COMDAT ?RefreshStreamButtons@OBS@@AAEX_N@Z
_TEXT	SEGMENT
tv135 = -32						; size = 4
tv89 = -28						; size = 4
tv83 = -24						; size = 4
_networkMode$ = -20					; size = 4
tv74 = -16						; size = 4
_this$ = -12						; size = 4
_canTest$ = -5						; size = 1
_canStream$ = -4					; size = 1
tv160 = -3						; size = 1
tv152 = -2						; size = 1
tv143 = -1						; size = 1
_disable$ = 8						; size = 1
?RefreshStreamButtons@OBS@@AAEX_N@Z PROC		; OBS::RefreshStreamButtons, COMDAT
; _this$ = ecx

; 1419 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 1420 :     if (bShuttingDown) return;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+1412]
	test	ecx, ecx
	je	SHORT $LN1@RefreshStr
	jmp	$LN2@RefreshStr
$LN1@RefreshStr:

; 1421 :     int networkMode = AppConfig->GetInt(TEXT("Publish"), TEXT("Mode"), 2);

	push	2
	push	OFFSET $SG4294800509
	push	OFFSET $SG4294800508
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	mov	DWORD PTR _networkMode$[ebp], eax

; 1422 :     bRecordingOnly = (networkMode == 1);

	cmp	DWORD PTR _networkMode$[ebp], 1
	jne	SHORT $LN4@RefreshStr
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN5@RefreshStr
$LN4@RefreshStr:
	mov	DWORD PTR tv74[ebp], 0
$LN5@RefreshStr:
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR tv74[ebp]
	mov	BYTE PTR [edx+625], al

; 1423 :     bool canStream = networkMode == 0 && !bTestStream && bStreamFlushed;

	cmp	DWORD PTR _networkMode$[ebp], 0
	jne	SHORT $LN6@RefreshStr
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+620]
	test	edx, edx
	jne	SHORT $LN6@RefreshStr
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+628]
	test	ecx, ecx
	je	SHORT $LN6@RefreshStr
	mov	DWORD PTR tv83[ebp], 1
	jmp	SHORT $LN7@RefreshStr
$LN6@RefreshStr:
	mov	DWORD PTR tv83[ebp], 0
$LN7@RefreshStr:
	mov	dl, BYTE PTR tv83[ebp]
	mov	BYTE PTR _canStream$[ebp], dl

; 1424 :     canRecord = !bTestStream;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+620]
	test	ecx, ecx
	jne	SHORT $LN8@RefreshStr
	mov	DWORD PTR tv89[ebp], 1
	jmp	SHORT $LN9@RefreshStr
$LN8@RefreshStr:
	mov	DWORD PTR tv89[ebp], 0
$LN9@RefreshStr:
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR tv89[ebp]
	mov	BYTE PTR [edx+630], al

; 1425 :     bool canTest = !bRecordingReplayBuffer && !bRecording && (!bStreaming || bTestStream);

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+624]
	test	edx, edx
	jne	SHORT $LN10@RefreshStr
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+623]
	test	ecx, ecx
	jne	SHORT $LN10@RefreshStr
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+627]
	test	eax, eax
	je	SHORT $LN11@RefreshStr
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+620]
	test	edx, edx
	je	SHORT $LN10@RefreshStr
$LN11@RefreshStr:
	mov	DWORD PTR tv135[ebp], 1
	jmp	SHORT $LN12@RefreshStr
$LN10@RefreshStr:
	mov	DWORD PTR tv135[ebp], 0
$LN12@RefreshStr:
	mov	al, BYTE PTR tv135[ebp]
	mov	BYTE PTR _canTest$[ebp], al

; 1426 : 
; 1427 : 	btnPlayLive.EnableButton(!disable && canStream);

	movzx	ecx, BYTE PTR _disable$[ebp]
	test	ecx, ecx
	jne	SHORT $LN13@RefreshStr
	movzx	edx, BYTE PTR _canStream$[ebp]
	test	edx, edx
	je	SHORT $LN13@RefreshStr
	mov	BYTE PTR tv143[ebp], 1
	jmp	SHORT $LN14@RefreshStr
$LN13@RefreshStr:
	mov	BYTE PTR tv143[ebp], 0
$LN14@RefreshStr:
	movzx	eax, BYTE PTR tv143[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 492				; 000001ecH
	call	?EnableButton@COBSButton@@QAEX_N@Z	; COBSButton::EnableButton

; 1428 : 	btnRecord.EnableButton(!disable && canRecord);

	movzx	ecx, BYTE PTR _disable$[ebp]
	test	ecx, ecx
	jne	SHORT $LN15@RefreshStr
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+630]
	test	eax, eax
	je	SHORT $LN15@RefreshStr
	mov	BYTE PTR tv152[ebp], 1
	jmp	SHORT $LN16@RefreshStr
$LN15@RefreshStr:
	mov	BYTE PTR tv152[ebp], 0
$LN16@RefreshStr:
	movzx	ecx, BYTE PTR tv152[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 532				; 00000214H
	call	?EnableButton@COBSButton@@QAEX_N@Z	; COBSButton::EnableButton

; 1429 : 	btnPreView.EnableButton(!disable && canTest);

	movzx	edx, BYTE PTR _disable$[ebp]
	test	edx, edx
	jne	SHORT $LN17@RefreshStr
	movzx	eax, BYTE PTR _canTest$[ebp]
	test	eax, eax
	je	SHORT $LN17@RefreshStr
	mov	BYTE PTR tv160[ebp], 1
	jmp	SHORT $LN18@RefreshStr
$LN17@RefreshStr:
	mov	BYTE PTR tv160[ebp], 0
$LN18@RefreshStr:
	movzx	ecx, BYTE PTR tv160[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 572				; 0000023cH
	call	?EnableButton@COBSButton@@QAEX_N@Z	; COBSButton::EnableButton
$LN2@RefreshStr:

; 1430 :     //EnableWindow(GetDlgItem(hwndMain, ID_STARTSTOP), !disable && canStream);
; 1431 :     //EnableWindow(GetDlgItem(hwndMain, ID_TOGGLERECORDING), !disable && canRecord);
; 1432 :     //EnableWindow(GetDlgItem(hwndMain, ID_TESTSTREAM), !disable && canTest);
; 1433 : 
; 1434 : 	/*  HMENU fileMenu = GetSubMenu(GetMenu(hwndMain), 0);
; 1435 : 	  EnableMenuItem(fileMenu, 2, (canRecord ? MF_ENABLED : MF_DISABLED) | MF_BYPOSITION);*/
; 1436 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?RefreshStreamButtons@OBS@@AAEX_N@Z ENDP		; OBS::RefreshStreamButtons
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.cpp
;	COMDAT ?PostConfigureStreamButtons@OBS@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?PostConfigureStreamButtons@OBS@@AAEXXZ PROC		; OBS::PostConfigureStreamButtons, COMDAT
; _this$ = ecx

; 1452 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1453 :     if (hwndMain) PostMessage(hwndMain, OBS_CONFIGURE_STREAM_BUTTONS, 0, 0);

	cmp	DWORD PTR ?hwndMain@@3PAUHWND__@@A, 0	; hwndMain
	je	SHORT $LN2@PostConfig
	push	0
	push	0
	push	1034					; 0000040aH
	mov	eax, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	eax
	call	DWORD PTR __imp__PostMessageW@16
$LN2@PostConfig:

; 1454 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PostConfigureStreamButtons@OBS@@AAEXXZ ENDP		; OBS::PostConfigureStreamButtons
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.cpp
;	COMDAT ?ReloadIniSettings@OBS@@AAEXXZ
_TEXT	SEGMENT
$T1 = -124						; size = 8
tv784 = -116						; size = 8
tv773 = -108						; size = 8
_audioDevices$ = -100					; size = 8
_strDevice$ = -92					; size = 8
_customQSV$2 = -84					; size = 4
_custom$3 = -80						; size = 4
tv664 = -76						; size = 4
tv663 = -72						; size = 4
_nvenc$ = -68						; size = 4
_qsv$ = -64						; size = 4
tv606 = -60						; size = 4
tv586 = -56						; size = 4
tv578 = -52						; size = 4
_hotkey2$ = -48						; size = 4
tv333 = -44						; size = 4
tv331 = -40						; size = 4
tv780 = -36						; size = 4
tv769 = -32						; size = 4
tv158 = -28						; size = 4
_micBoostMultiple$ = -24				; size = 4
_desktopBoostMultiple$ = -20				; size = 4
_hwndTemp$ = -16					; size = 4
_hotkey$ = -12						; size = 4
_this$ = -8						; size = 4
_showIcon$ = -2						; size = 1
_minimizeToIcon$ = -1					; size = 1
?ReloadIniSettings@OBS@@AAEXXZ PROC			; OBS::ReloadIniSettings, COMDAT
; _this$ = ecx

; 1523 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH
	mov	DWORD PTR _this$[ebp], ecx

; 1524 :     HWND hwndTemp;
; 1525 : 
; 1526 :     //-------------------------------------------
; 1527 :     // mic volume data
; 1528 :     hwndTemp = GetDlgItem(hwndMain, ID_MICVOLUME);

	push	5007					; 0000138fH
	mov	eax, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	eax
	call	DWORD PTR __imp__GetDlgItem@8
	mov	DWORD PTR _hwndTemp$[ebp], eax

; 1529 : 
; 1530 :     if(!AppConfig->HasKey(TEXT("Audio"), TEXT("MicVolume")))

	push	OFFSET $SG4294800491
	push	OFFSET $SG4294800490
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?HasKey@ConfigFile@@QAEHPB_W0@Z
	test	eax, eax
	jne	SHORT $LN41@ReloadIniS

; 1531 :         AppConfig->SetFloat(TEXT("Audio"), TEXT("MicVolume"), 1.0f);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG4294800489
	push	OFFSET $SG4294800488
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?SetFloat@ConfigFile@@QAEXPB_W0M@Z
$LN41@ReloadIniS:

; 1532 :     SetVolumeControlValue(hwndTemp, AppConfig->GetFloat(TEXT("Audio"), TEXT("MicVolume"), 1.0f));

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG4294800487
	push	OFFSET $SG4294800486
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetFloat@ConfigFile@@QAEMPB_W0M@Z
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _hwndTemp$[ebp]
	push	ecx
	call	DWORD PTR __imp_?SetVolumeControlValue@@YAMPAUHWND__@@M@Z
	fstp	ST(0)

; 1533 :     SetVolumeControlMutedVal(hwndTemp, AppConfig->GetFloat(TEXT("Audio"), TEXT("MicMutedVolume"), 1.0f));

	add	esp, 4
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG4294800485
	push	OFFSET $SG4294800484
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetFloat@ConfigFile@@QAEMPB_W0M@Z
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _hwndTemp$[ebp]
	push	edx
	call	DWORD PTR __imp_?SetVolumeControlMutedVal@@YAXPAUHWND__@@M@Z
	add	esp, 8

; 1534 : 
; 1535 :     AudioDeviceList audioDevices;

	lea	ecx, DWORD PTR _audioDevices$[ebp]
	call	??0AudioDeviceList@@QAE@XZ

; 1536 :     GetAudioDevices(audioDevices, ADT_RECORDING, false, true);

	push	1
	push	0
	push	1
	lea	eax, DWORD PTR _audioDevices$[ebp]
	push	eax
	call	?GetAudioDevices@@YAXAAUAudioDeviceList@@W4AudioDeviceType@@_N2@Z ; GetAudioDevices
	add	esp, 16					; 00000010H

; 1537 : 
; 1538 :     String strDevice = AppConfig->GetString(TEXT("Audio"), TEXT("Device"), NULL);

	push	0
	push	OFFSET $SG4294800483
	push	OFFSET $SG4294800482
	lea	ecx, DWORD PTR _strDevice$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetString@ConfigFile@@QAE?AVString@@PB_W00@Z

; 1539 :     if(strDevice.IsEmpty() || !audioDevices.HasID(strDevice))

	lea	ecx, DWORD PTR _strDevice$[ebp]
	call	DWORD PTR __imp_?IsEmpty@String@@QBEHXZ
	test	eax, eax
	jne	SHORT $LN39@ReloadIniS
	lea	ecx, DWORD PTR _strDevice$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	lea	ecx, DWORD PTR _audioDevices$[ebp]
	call	?HasID@AudioDeviceList@@QBE_NPB_W@Z	; AudioDeviceList::HasID
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN40@ReloadIniS
$LN39@ReloadIniS:

; 1540 :     {
; 1541 :         AppConfig->SetString(TEXT("Audio"), TEXT("Device"), TEXT("Disable"));

	push	OFFSET $SG4294800481
	push	OFFSET $SG4294800480
	push	OFFSET $SG4294800479
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?SetString@ConfigFile@@QAEXPB_W00@Z

; 1542 :         strDevice = TEXT("Disable");

	push	OFFSET $SG4294800478
	lea	ecx, DWORD PTR _strDevice$[ebp]
	call	DWORD PTR __imp_??4String@@QAEAAV0@PB_W@Z
$LN40@ReloadIniS:

; 1543 :     }
; 1544 : 
; 1545 :     audioDevices.FreeData();

	lea	ecx, DWORD PTR _audioDevices$[ebp]
	call	?FreeData@AudioDeviceList@@QAEXXZ	; AudioDeviceList::FreeData

; 1546 : 
; 1547 :     EnableWindow(hwndTemp, !strDevice.CompareI(TEXT("Disable")));

	push	OFFSET $SG4294800477
	lea	ecx, DWORD PTR _strDevice$[ebp]
	call	DWORD PTR __imp_?CompareI@String@@QBEHPB_W@Z
	test	eax, eax
	jne	SHORT $LN44@ReloadIniS
	mov	DWORD PTR tv158[ebp], 1
	jmp	SHORT $LN45@ReloadIniS
$LN44@ReloadIniS:
	mov	DWORD PTR tv158[ebp], 0
$LN45@ReloadIniS:
	mov	eax, DWORD PTR tv158[ebp]
	push	eax
	mov	ecx, DWORD PTR _hwndTemp$[ebp]
	push	ecx
	call	DWORD PTR __imp__EnableWindow@8

; 1548 : 
; 1549 :     //-------------------------------------------
; 1550 :     // desktop volume
; 1551 :     hwndTemp = GetDlgItem(hwndMain, ID_DESKTOPVOLUME);

	push	5006					; 0000138eH
	mov	edx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	edx
	call	DWORD PTR __imp__GetDlgItem@8
	mov	DWORD PTR _hwndTemp$[ebp], eax

; 1552 : 
; 1553 :     if(!AppConfig->HasKey(TEXT("Audio"), TEXT("DesktopVolume")))

	push	OFFSET $SG4294800476
	push	OFFSET $SG4294800475
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?HasKey@ConfigFile@@QAEHPB_W0@Z
	test	eax, eax
	jne	SHORT $LN38@ReloadIniS

; 1554 :         AppConfig->SetFloat(TEXT("Audio"), TEXT("DesktopVolume"), 1.0f);

	push	ecx
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG4294800474
	push	OFFSET $SG4294800473
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?SetFloat@ConfigFile@@QAEXPB_W0M@Z
$LN38@ReloadIniS:

; 1555 :     SetVolumeControlValue(hwndTemp, AppConfig->GetFloat(TEXT("Audio"), TEXT("DesktopVolume"), 0.0f));

	push	ecx
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG4294800472
	push	OFFSET $SG4294800471
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetFloat@ConfigFile@@QAEMPB_W0M@Z
	push	ecx
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _hwndTemp$[ebp]
	push	eax
	call	DWORD PTR __imp_?SetVolumeControlValue@@YAMPAUHWND__@@M@Z
	fstp	ST(0)

; 1556 :     SetVolumeControlMutedVal(hwndTemp, AppConfig->GetFloat(TEXT("Audio"), TEXT("DesktopMutedVolume"), 1.0f));

	add	esp, 4
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	push	OFFSET $SG4294800470
	push	OFFSET $SG4294800469
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetFloat@ConfigFile@@QAEMPB_W0M@Z
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _hwndTemp$[ebp]
	push	ecx
	call	DWORD PTR __imp_?SetVolumeControlMutedVal@@YAXPAUHWND__@@M@Z
	add	esp, 8

; 1557 : 
; 1558 :     //-------------------------------------------
; 1559 :     // desktop boost
; 1560 :     DWORD desktopBoostMultiple = GlobalConfig->GetInt(TEXT("Audio"), TEXT("DesktopBoostMultiple"), 1);

	push	1
	push	OFFSET $SG4294800468
	push	OFFSET $SG4294800467
	mov	ecx, DWORD PTR ?GlobalConfig@@3PAVConfigFile@@A ; GlobalConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	mov	DWORD PTR _desktopBoostMultiple$[ebp], eax

; 1561 :     if(desktopBoostMultiple < 1)

	cmp	DWORD PTR _desktopBoostMultiple$[ebp], 1
	jae	SHORT $LN37@ReloadIniS

; 1562 :         desktopBoostMultiple = 1;

	mov	DWORD PTR _desktopBoostMultiple$[ebp], 1
	jmp	SHORT $LN35@ReloadIniS
$LN37@ReloadIniS:

; 1563 :     else if(desktopBoostMultiple > 20)

	cmp	DWORD PTR _desktopBoostMultiple$[ebp], 20 ; 00000014H
	jbe	SHORT $LN35@ReloadIniS

; 1564 :         desktopBoostMultiple = 20;

	mov	DWORD PTR _desktopBoostMultiple$[ebp], 20 ; 00000014H
$LN35@ReloadIniS:

; 1565 :     desktopBoost = float(desktopBoostMultiple);

	mov	edx, DWORD PTR _desktopBoostMultiple$[ebp]
	mov	DWORD PTR tv769[ebp], edx
	cvtsi2sd xmm0, DWORD PTR tv769[ebp]
	mov	eax, DWORD PTR tv769[ebp]
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	movsd	QWORD PTR tv773[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv773[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+1220], xmm0

; 1566 : 
; 1567 :     //-------------------------------------------
; 1568 :     // mic boost
; 1569 :     DWORD micBoostMultiple = AppConfig->GetInt(TEXT("Audio"), TEXT("MicBoostMultiple"), 1);

	push	1
	push	OFFSET $SG4294800466
	push	OFFSET $SG4294800465
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	mov	DWORD PTR _micBoostMultiple$[ebp], eax

; 1570 :     if(micBoostMultiple < 1)

	cmp	DWORD PTR _micBoostMultiple$[ebp], 1
	jae	SHORT $LN34@ReloadIniS

; 1571 :         micBoostMultiple = 1;

	mov	DWORD PTR _micBoostMultiple$[ebp], 1
	jmp	SHORT $LN32@ReloadIniS
$LN34@ReloadIniS:

; 1572 :     else if(micBoostMultiple > 20)

	cmp	DWORD PTR _micBoostMultiple$[ebp], 20	; 00000014H
	jbe	SHORT $LN32@ReloadIniS

; 1573 :         micBoostMultiple = 20;

	mov	DWORD PTR _micBoostMultiple$[ebp], 20	; 00000014H
$LN32@ReloadIniS:

; 1574 :     micBoost = float(micBoostMultiple);

	mov	edx, DWORD PTR _micBoostMultiple$[ebp]
	mov	DWORD PTR tv780[ebp], edx
	cvtsi2sd xmm0, DWORD PTR tv780[ebp]
	mov	eax, DWORD PTR tv780[ebp]
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	movsd	QWORD PTR tv784[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv784[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movss	DWORD PTR [ecx+1224], xmm0

; 1575 : 
; 1576 :     //-------------------------------------------
; 1577 :     // dashboard
; 1578 :     /*
; 1579 :     strDashboard = AppConfig->GetString(TEXT("Publish"), TEXT("Dashboard"));
; 1580 :     strDashboard.KillSpaces();
; 1581 :     UpdateDashboardButton();
; 1582 :     */
; 1583 : 
; 1584 :     //-------------------------------------------
; 1585 :     // hotkeys
; 1586 :     QuickClearHotkey(pushToTalkHotkeyID);

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1264], 0
	je	SHORT $LN31@ReloadIniS
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1264]
	push	ecx
	mov	edx, DWORD PTR __imp_?API@@3PAVAPIInterface@@A
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR __imp_?API@@3PAVAPIInterface@@A
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+56]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1264], 0
$LN31@ReloadIniS:

; 1587 :     QuickClearHotkey(pushToTalkHotkey2ID);

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1268], 0
	je	SHORT $LN30@ReloadIniS
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1268]
	push	ecx
	mov	edx, DWORD PTR __imp_?API@@3PAVAPIInterface@@A
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR __imp_?API@@3PAVAPIInterface@@A
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+56]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1268], 0
$LN30@ReloadIniS:

; 1588 :     QuickClearHotkey(muteMicHotkeyID);

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1272], 0
	je	SHORT $LN29@ReloadIniS
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1272]
	push	ecx
	mov	edx, DWORD PTR __imp_?API@@3PAVAPIInterface@@A
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR __imp_?API@@3PAVAPIInterface@@A
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+56]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1272], 0
$LN29@ReloadIniS:

; 1589 :     QuickClearHotkey(muteDesktopHotkeyID);

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1276], 0
	je	SHORT $LN28@ReloadIniS
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1276]
	push	ecx
	mov	edx, DWORD PTR __imp_?API@@3PAVAPIInterface@@A
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR __imp_?API@@3PAVAPIInterface@@A
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+56]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1276], 0
$LN28@ReloadIniS:

; 1590 :     QuickClearHotkey(stopStreamHotkeyID);

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1284], 0
	je	SHORT $LN27@ReloadIniS
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1284]
	push	ecx
	mov	edx, DWORD PTR __imp_?API@@3PAVAPIInterface@@A
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR __imp_?API@@3PAVAPIInterface@@A
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+56]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1284], 0
$LN27@ReloadIniS:

; 1591 :     QuickClearHotkey(startStreamHotkeyID);

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1280], 0
	je	SHORT $LN26@ReloadIniS
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1280]
	push	ecx
	mov	edx, DWORD PTR __imp_?API@@3PAVAPIInterface@@A
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR __imp_?API@@3PAVAPIInterface@@A
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+56]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1280], 0
$LN26@ReloadIniS:

; 1592 :     QuickClearHotkey(stopRecordingHotkeyID);

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1292], 0
	je	SHORT $LN25@ReloadIniS
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1292]
	push	ecx
	mov	edx, DWORD PTR __imp_?API@@3PAVAPIInterface@@A
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR __imp_?API@@3PAVAPIInterface@@A
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+56]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1292], 0
$LN25@ReloadIniS:

; 1593 :     QuickClearHotkey(startRecordingHotkeyID);

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1288], 0
	je	SHORT $LN24@ReloadIniS
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1288]
	push	ecx
	mov	edx, DWORD PTR __imp_?API@@3PAVAPIInterface@@A
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR __imp_?API@@3PAVAPIInterface@@A
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+56]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1288], 0
$LN24@ReloadIniS:

; 1594 :     QuickClearHotkey(stopReplayBufferHotkeyID);

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1300], 0
	je	SHORT $LN23@ReloadIniS
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1300]
	push	ecx
	mov	edx, DWORD PTR __imp_?API@@3PAVAPIInterface@@A
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR __imp_?API@@3PAVAPIInterface@@A
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+56]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1300], 0
$LN23@ReloadIniS:

; 1595 :     QuickClearHotkey(startReplayBufferHotkeyID);

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1296], 0
	je	SHORT $LN22@ReloadIniS
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1296]
	push	ecx
	mov	edx, DWORD PTR __imp_?API@@3PAVAPIInterface@@A
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR __imp_?API@@3PAVAPIInterface@@A
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+56]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1296], 0
$LN22@ReloadIniS:

; 1596 :     QuickClearHotkey(saveReplayBufferHotkeyID);

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1304], 0
	je	SHORT $LN21@ReloadIniS
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1304]
	push	ecx
	mov	edx, DWORD PTR __imp_?API@@3PAVAPIInterface@@A
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR __imp_?API@@3PAVAPIInterface@@A
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+56]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1304], 0
$LN21@ReloadIniS:

; 1597 :     QuickClearHotkey(recordFromReplayBufferHotkeyID);

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1308], 0
	je	SHORT $LN20@ReloadIniS
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1308]
	push	ecx
	mov	edx, DWORD PTR __imp_?API@@3PAVAPIInterface@@A
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR __imp_?API@@3PAVAPIInterface@@A
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+56]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1308], 0
$LN20@ReloadIniS:

; 1598 : 
; 1599 :     bUsingPushToTalk = !!AppConfig->GetInt(L"Audio", L"UsePushToTalk") != 0;

	push	0
	push	OFFSET $SG4294800464
	push	OFFSET $SG4294800463
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	test	eax, eax
	je	SHORT $LN46@ReloadIniS
	mov	DWORD PTR tv331[ebp], 1
	jmp	SHORT $LN47@ReloadIniS
$LN46@ReloadIniS:
	mov	DWORD PTR tv331[ebp], 0
$LN47@ReloadIniS:
	cmp	DWORD PTR tv331[ebp], 0
	je	SHORT $LN48@ReloadIniS
	mov	DWORD PTR tv333[ebp], 1
	jmp	SHORT $LN49@ReloadIniS
$LN48@ReloadIniS:
	mov	DWORD PTR tv333[ebp], 0
$LN49@ReloadIniS:
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR tv333[ebp]
	mov	BYTE PTR [edx+1244], al

; 1600 :     DWORD hotkey = AppConfig->GetInt(TEXT("Audio"), TEXT("PushToTalkHotkey"));

	push	0
	push	OFFSET $SG4294800462
	push	OFFSET $SG4294800461
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	mov	DWORD PTR _hotkey$[ebp], eax

; 1601 :     DWORD hotkey2 = AppConfig->GetInt(TEXT("Audio"), TEXT("PushToTalkHotkey2"));

	push	0
	push	OFFSET $SG4294800460
	push	OFFSET $SG4294800459
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	mov	DWORD PTR _hotkey2$[ebp], eax

; 1602 :     pushToTalkDelay = AppConfig->GetInt(TEXT("Audio"), TEXT("PushToTalkDelay"), 200);

	push	200					; 000000c8H
	push	OFFSET $SG4294800458
	push	OFFSET $SG4294800457
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	cdq
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1248], eax
	mov	DWORD PTR [ecx+1252], edx

; 1603 : 
; 1604 :     if(bUsingPushToTalk && hotkey)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+1244]
	test	eax, eax
	je	SHORT $LN19@ReloadIniS
	cmp	DWORD PTR _hotkey$[ebp], 0
	je	SHORT $LN19@ReloadIniS

; 1605 :         pushToTalkHotkeyID = API->CreateHotkey(hotkey, OBS::PushToTalkHotkey, NULL);

	push	0
	push	OFFSET ?PushToTalkHotkey@OBS@@CGXKK_N@Z	; OBS::PushToTalkHotkey
	mov	ecx, DWORD PTR _hotkey$[ebp]
	push	ecx
	mov	edx, DWORD PTR __imp_?API@@3PAVAPIInterface@@A
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR __imp_?API@@3PAVAPIInterface@@A
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+52]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1264], eax
$LN19@ReloadIniS:

; 1606 :     if(bUsingPushToTalk && hotkey2)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+1244]
	test	eax, eax
	je	SHORT $LN18@ReloadIniS
	cmp	DWORD PTR _hotkey2$[ebp], 0
	je	SHORT $LN18@ReloadIniS

; 1607 :         pushToTalkHotkey2ID = API->CreateHotkey(hotkey2, OBS::PushToTalkHotkey, NULL);

	push	0
	push	OFFSET ?PushToTalkHotkey@OBS@@CGXKK_N@Z	; OBS::PushToTalkHotkey
	mov	ecx, DWORD PTR _hotkey2$[ebp]
	push	ecx
	mov	edx, DWORD PTR __imp_?API@@3PAVAPIInterface@@A
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR __imp_?API@@3PAVAPIInterface@@A
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+52]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1268], eax
$LN18@ReloadIniS:

; 1608 : 
; 1609 :     hotkey = AppConfig->GetInt(TEXT("Audio"), TEXT("MuteMicHotkey"));

	push	0
	push	OFFSET $SG4294800456
	push	OFFSET $SG4294800455
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	mov	DWORD PTR _hotkey$[ebp], eax

; 1610 :     if(hotkey)

	cmp	DWORD PTR _hotkey$[ebp], 0
	je	SHORT $LN17@ReloadIniS

; 1611 :         muteMicHotkeyID = API->CreateHotkey(hotkey, OBS::MuteMicHotkey, NULL);

	push	0
	push	OFFSET ?MuteMicHotkey@OBS@@CGXKK_N@Z	; OBS::MuteMicHotkey
	mov	edx, DWORD PTR _hotkey$[ebp]
	push	edx
	mov	eax, DWORD PTR __imp_?API@@3PAVAPIInterface@@A
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __imp_?API@@3PAVAPIInterface@@A
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR [eax+52]
	call	edx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1272], eax
$LN17@ReloadIniS:

; 1612 : 
; 1613 :     hotkey = AppConfig->GetInt(TEXT("Audio"), TEXT("MuteDesktopHotkey"));

	push	0
	push	OFFSET $SG4294800454
	push	OFFSET $SG4294800453
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	mov	DWORD PTR _hotkey$[ebp], eax

; 1614 :     if(hotkey)

	cmp	DWORD PTR _hotkey$[ebp], 0
	je	SHORT $LN16@ReloadIniS

; 1615 :         muteDesktopHotkeyID = API->CreateHotkey(hotkey, OBS::MuteDesktopHotkey, NULL);

	push	0
	push	OFFSET ?MuteDesktopHotkey@OBS@@CGXKK_N@Z ; OBS::MuteDesktopHotkey
	mov	edx, DWORD PTR _hotkey$[ebp]
	push	edx
	mov	eax, DWORD PTR __imp_?API@@3PAVAPIInterface@@A
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __imp_?API@@3PAVAPIInterface@@A
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR [eax+52]
	call	edx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1276], eax
$LN16@ReloadIniS:

; 1616 : 
; 1617 :     hotkey = AppConfig->GetInt(TEXT("Publish"), TEXT("StopStreamHotkey"));

	push	0
	push	OFFSET $SG4294800452
	push	OFFSET $SG4294800451
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	mov	DWORD PTR _hotkey$[ebp], eax

; 1618 :     if (hotkey)

	cmp	DWORD PTR _hotkey$[ebp], 0
	je	SHORT $LN15@ReloadIniS

; 1619 :         stopStreamHotkeyID = API->CreateHotkey(hotkey, OBS::StopStreamHotkey, NULL);

	push	0
	push	OFFSET ?StopStreamHotkey@OBS@@CGXKK_N@Z	; OBS::StopStreamHotkey
	mov	edx, DWORD PTR _hotkey$[ebp]
	push	edx
	mov	eax, DWORD PTR __imp_?API@@3PAVAPIInterface@@A
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __imp_?API@@3PAVAPIInterface@@A
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR [eax+52]
	call	edx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1284], eax
$LN15@ReloadIniS:

; 1620 : 
; 1621 :     hotkey = AppConfig->GetInt(TEXT("Publish"), TEXT("StartStreamHotkey"));

	push	0
	push	OFFSET $SG4294800450
	push	OFFSET $SG4294800449
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	mov	DWORD PTR _hotkey$[ebp], eax

; 1622 :     if (hotkey)

	cmp	DWORD PTR _hotkey$[ebp], 0
	je	SHORT $LN14@ReloadIniS

; 1623 :         startStreamHotkeyID = API->CreateHotkey(hotkey, OBS::StartStreamHotkey, NULL);

	push	0
	push	OFFSET ?StartStreamHotkey@OBS@@CGXKK_N@Z ; OBS::StartStreamHotkey
	mov	edx, DWORD PTR _hotkey$[ebp]
	push	edx
	mov	eax, DWORD PTR __imp_?API@@3PAVAPIInterface@@A
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __imp_?API@@3PAVAPIInterface@@A
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR [eax+52]
	call	edx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1280], eax
$LN14@ReloadIniS:

; 1624 : 
; 1625 :     hotkey = AppConfig->GetInt(TEXT("Publish"), TEXT("StopRecordingHotkey"));

	push	0
	push	OFFSET $SG4294800448
	push	OFFSET $SG4294800447
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	mov	DWORD PTR _hotkey$[ebp], eax

; 1626 :     if (hotkey)

	cmp	DWORD PTR _hotkey$[ebp], 0
	je	SHORT $LN13@ReloadIniS

; 1627 :         stopRecordingHotkeyID = API->CreateHotkey(hotkey, OBS::StopRecordingHotkey, NULL);

	push	0
	push	OFFSET ?StopRecordingHotkey@OBS@@CGXKK_N@Z ; OBS::StopRecordingHotkey
	mov	edx, DWORD PTR _hotkey$[ebp]
	push	edx
	mov	eax, DWORD PTR __imp_?API@@3PAVAPIInterface@@A
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __imp_?API@@3PAVAPIInterface@@A
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR [eax+52]
	call	edx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1292], eax
$LN13@ReloadIniS:

; 1628 : 
; 1629 :     hotkey = AppConfig->GetInt(TEXT("Publish"), TEXT("StartRecordingHotkey"));

	push	0
	push	OFFSET $SG4294800446
	push	OFFSET $SG4294800445
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	mov	DWORD PTR _hotkey$[ebp], eax

; 1630 :     if (hotkey)

	cmp	DWORD PTR _hotkey$[ebp], 0
	je	SHORT $LN12@ReloadIniS

; 1631 :         startRecordingHotkeyID = API->CreateHotkey(hotkey, OBS::StartRecordingHotkey, NULL);

	push	0
	push	OFFSET ?StartRecordingHotkey@OBS@@CGXKK_N@Z ; OBS::StartRecordingHotkey
	mov	edx, DWORD PTR _hotkey$[ebp]
	push	edx
	mov	eax, DWORD PTR __imp_?API@@3PAVAPIInterface@@A
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __imp_?API@@3PAVAPIInterface@@A
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR [eax+52]
	call	edx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1288], eax
$LN12@ReloadIniS:

; 1632 : 
; 1633 :     hotkey = AppConfig->GetInt(L"Publish", L"StopReplayBufferHotkey");

	push	0
	push	OFFSET $SG4294800444
	push	OFFSET $SG4294800443
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	mov	DWORD PTR _hotkey$[ebp], eax

; 1634 :     if (hotkey)

	cmp	DWORD PTR _hotkey$[ebp], 0
	je	SHORT $LN11@ReloadIniS

; 1635 :         stopReplayBufferHotkeyID = API->CreateHotkey(hotkey, OBS::StopReplayBufferHotkey, NULL);

	push	0
	push	OFFSET ?StopReplayBufferHotkey@OBS@@CGXKK_N@Z ; OBS::StopReplayBufferHotkey
	mov	edx, DWORD PTR _hotkey$[ebp]
	push	edx
	mov	eax, DWORD PTR __imp_?API@@3PAVAPIInterface@@A
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __imp_?API@@3PAVAPIInterface@@A
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR [eax+52]
	call	edx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1300], eax
$LN11@ReloadIniS:

; 1636 : 
; 1637 :     hotkey = AppConfig->GetInt(L"Publish", L"StartReplayBufferHotkey");

	push	0
	push	OFFSET $SG4294800442
	push	OFFSET $SG4294800441
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	mov	DWORD PTR _hotkey$[ebp], eax

; 1638 :     if (hotkey)

	cmp	DWORD PTR _hotkey$[ebp], 0
	je	SHORT $LN10@ReloadIniS

; 1639 :         startReplayBufferHotkeyID = API->CreateHotkey(hotkey, OBS::StartReplayBufferHotkey, NULL);

	push	0
	push	OFFSET ?StartReplayBufferHotkey@OBS@@CGXKK_N@Z ; OBS::StartReplayBufferHotkey
	mov	edx, DWORD PTR _hotkey$[ebp]
	push	edx
	mov	eax, DWORD PTR __imp_?API@@3PAVAPIInterface@@A
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __imp_?API@@3PAVAPIInterface@@A
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR [eax+52]
	call	edx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1296], eax
$LN10@ReloadIniS:

; 1640 : 
; 1641 :     hotkey = AppConfig->GetInt(L"Publish", L"SaveReplayBufferHotkey");

	push	0
	push	OFFSET $SG4294800440
	push	OFFSET $SG4294800439
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	mov	DWORD PTR _hotkey$[ebp], eax

; 1642 :     if (hotkey)

	cmp	DWORD PTR _hotkey$[ebp], 0
	je	SHORT $LN9@ReloadIniS

; 1643 :         saveReplayBufferHotkeyID = API->CreateHotkey(hotkey, OBS::SaveReplayBufferHotkey, NULL);

	push	0
	push	OFFSET ?SaveReplayBufferHotkey@OBS@@CGXKK_N@Z ; OBS::SaveReplayBufferHotkey
	mov	edx, DWORD PTR _hotkey$[ebp]
	push	edx
	mov	eax, DWORD PTR __imp_?API@@3PAVAPIInterface@@A
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __imp_?API@@3PAVAPIInterface@@A
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR [eax+52]
	call	edx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1304], eax
$LN9@ReloadIniS:

; 1644 : 
; 1645 :     hotkey = AppConfig->GetInt(L"Publish", L"RecordFromReplayBufferHotkey");

	push	0
	push	OFFSET $SG4294800438
	push	OFFSET $SG4294800437
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	mov	DWORD PTR _hotkey$[ebp], eax

; 1646 :     if (hotkey)

	cmp	DWORD PTR _hotkey$[ebp], 0
	je	SHORT $LN8@ReloadIniS

; 1647 :         recordFromReplayBufferHotkeyID = API->CreateHotkey(hotkey, OBS::RecordFromReplayBufferHotkey, NULL);

	push	0
	push	OFFSET ?RecordFromReplayBufferHotkey@OBS@@CGXKK_N@Z ; OBS::RecordFromReplayBufferHotkey
	mov	edx, DWORD PTR _hotkey$[ebp]
	push	edx
	mov	eax, DWORD PTR __imp_?API@@3PAVAPIInterface@@A
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __imp_?API@@3PAVAPIInterface@@A
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR [eax+52]
	call	edx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1308], eax
$LN8@ReloadIniS:

; 1648 : 
; 1649 :     //-------------------------------------------
; 1650 :     // Notification Area icon
; 1651 :     bool showIcon = AppConfig->GetInt(TEXT("General"), TEXT("ShowNotificationAreaIcon"), 0) != 0;

	push	0
	push	OFFSET $SG4294800436
	push	OFFSET $SG4294800435
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	test	eax, eax
	je	SHORT $LN50@ReloadIniS
	mov	DWORD PTR tv578[ebp], 1
	jmp	SHORT $LN51@ReloadIniS
$LN50@ReloadIniS:
	mov	DWORD PTR tv578[ebp], 0
$LN51@ReloadIniS:
	mov	dl, BYTE PTR tv578[ebp]
	mov	BYTE PTR _showIcon$[ebp], dl

; 1652 :     bool minimizeToIcon = AppConfig->GetInt(TEXT("General"), TEXT("MinimizeToNotificationArea"), 0) != 0;

	push	0
	push	OFFSET $SG4294800434
	push	OFFSET $SG4294800433
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	test	eax, eax
	je	SHORT $LN52@ReloadIniS
	mov	DWORD PTR tv586[ebp], 1
	jmp	SHORT $LN53@ReloadIniS
$LN52@ReloadIniS:
	mov	DWORD PTR tv586[ebp], 0
$LN53@ReloadIniS:
	mov	al, BYTE PTR tv586[ebp]
	mov	BYTE PTR _minimizeToIcon$[ebp], al

; 1653 :     if (showIcon)

	movzx	ecx, BYTE PTR _showIcon$[ebp]
	test	ecx, ecx
	je	SHORT $LN7@ReloadIniS

; 1654 :     {
; 1655 :         ShowNotificationAreaIcon();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ShowNotificationAreaIcon@OBS@@QAEHXZ	; OBS::ShowNotificationAreaIcon

; 1656 :         if (minimizeToIcon && IsIconic(hwndMain))

	movzx	edx, BYTE PTR _minimizeToIcon$[ebp]
	test	edx, edx
	je	SHORT $LN6@ReloadIniS
	mov	eax, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	eax
	call	DWORD PTR __imp__IsIconic@4
	test	eax, eax
	je	SHORT $LN6@ReloadIniS

; 1657 :             ShowWindow(hwndMain, SW_HIDE);

	push	0
	mov	ecx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	ecx
	call	DWORD PTR __imp__ShowWindow@8
$LN6@ReloadIniS:

; 1658 :     }
; 1659 :     else

	jmp	SHORT $LN5@ReloadIniS
$LN7@ReloadIniS:

; 1660 :         HideNotificationAreaIcon();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?HideNotificationAreaIcon@OBS@@QAEHXZ	; OBS::HideNotificationAreaIcon
$LN5@ReloadIniS:

; 1661 : 
; 1662 :     bKeepRecording = AppConfig->GetInt(TEXT("Publish"), TEXT("KeepRecording")) != 0;

	push	0
	push	OFFSET $SG4294800432
	push	OFFSET $SG4294800431
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	test	eax, eax
	je	SHORT $LN54@ReloadIniS
	mov	DWORD PTR tv606[ebp], 1
	jmp	SHORT $LN55@ReloadIniS
$LN54@ReloadIniS:
	mov	DWORD PTR tv606[ebp], 0
$LN55@ReloadIniS:
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR tv606[ebp]
	mov	BYTE PTR [edx+629], al

; 1663 : 
; 1664 :     if (!minimizeToIcon && !IsWindowVisible(hwndMain))

	movzx	ecx, BYTE PTR _minimizeToIcon$[ebp]
	test	ecx, ecx
	jne	SHORT $LN4@ReloadIniS
	mov	edx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	edx
	call	DWORD PTR __imp__IsWindowVisible@4
	test	eax, eax
	jne	SHORT $LN4@ReloadIniS

; 1665 :         ShowWindow(hwndMain, SW_SHOW);

	push	5
	mov	eax, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	eax
	call	DWORD PTR __imp__ShowWindow@8
$LN4@ReloadIniS:

; 1666 : 
; 1667 :     ConfigureStreamButtons();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ConfigureStreamButtons@OBS@@AAEXXZ	; OBS::ConfigureStreamButtons

; 1668 : 
; 1669 :     //--------------------------------------------
; 1670 :     // Update old config, transition old encoder selection
; 1671 :     int qsv = AppConfig->GetInt(L"Video Encoding", L"UseQSV", -1);

	push	-1
	push	OFFSET $SG4294800430
	push	OFFSET $SG4294800429
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	mov	DWORD PTR _qsv$[ebp], eax

; 1672 :     int nvenc = AppConfig->GetInt(L"Video Encoding", L"UseNVENC", -1);

	push	-1
	push	OFFSET $SG4294800428
	push	OFFSET $SG4294800427
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	mov	DWORD PTR _nvenc$[ebp], eax

; 1673 :     if (qsv != -1 || nvenc != -1)

	cmp	DWORD PTR _qsv$[ebp], -1
	jne	SHORT $LN2@ReloadIniS
	cmp	DWORD PTR _nvenc$[ebp], -1
	je	$LN1@ReloadIniS
$LN2@ReloadIniS:

; 1674 :     {
; 1675 :         AppConfig->SetString(L"Video Encoding", L"Encoder", (qsv > 0) ? L"QSV" : (nvenc > 0) ? L"NVENC" : L"x264");

	cmp	DWORD PTR _qsv$[ebp], 0
	jle	SHORT $LN58@ReloadIniS
	mov	DWORD PTR tv664[ebp], OFFSET $SG4294800426
	jmp	SHORT $LN59@ReloadIniS
$LN58@ReloadIniS:
	cmp	DWORD PTR _nvenc$[ebp], 0
	jle	SHORT $LN56@ReloadIniS
	mov	DWORD PTR tv663[ebp], OFFSET $SG4294800425
	jmp	SHORT $LN57@ReloadIniS
$LN56@ReloadIniS:
	mov	DWORD PTR tv663[ebp], OFFSET $SG4294800424
$LN57@ReloadIniS:
	mov	ecx, DWORD PTR tv663[ebp]
	mov	DWORD PTR tv664[ebp], ecx
$LN59@ReloadIniS:
	mov	edx, DWORD PTR tv664[ebp]
	push	edx
	push	OFFSET $SG4294800423
	push	OFFSET $SG4294800422
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?SetString@ConfigFile@@QAEXPB_W00@Z

; 1676 :         AppConfig->Remove(L"Video Encoding", L"UseQSV");

	push	OFFSET $SG4294800421
	push	OFFSET $SG4294800420
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?Remove@ConfigFile@@QAEXPB_W0@Z

; 1677 :         AppConfig->Remove(L"Video Encoding", L"UseNVENC");

	push	OFFSET $SG4294800419
	push	OFFSET $SG4294800418
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?Remove@ConfigFile@@QAEXPB_W0@Z

; 1678 : 
; 1679 :         int custom = AppConfig->GetInt(L"Video Encoding", L"UseCustomSettings", -1);

	push	-1
	push	OFFSET $SG4294800417
	push	OFFSET $SG4294800416
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	mov	DWORD PTR _custom$3[ebp], eax

; 1680 :         int customQSV = AppConfig->GetInt(L"Video Encoding", L"QSVUseVideoEncoderSettings", -1);

	push	-1
	push	OFFSET $SG4294800415
	push	OFFSET $SG4294800414
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	mov	DWORD PTR _customQSV$2[ebp], eax

; 1681 :         if (custom > 0 && customQSV > 0)

	cmp	DWORD PTR _custom$3[ebp], 0
	jle	SHORT $LN1@ReloadIniS
	cmp	DWORD PTR _customQSV$2[ebp], 0
	jle	SHORT $LN1@ReloadIniS

; 1682 :             AppConfig->SetString(L"Video Encoding", L"CustomQSVSettings", AppConfig->GetString(L"Video Encoding", L"CustomSettings"));

	push	0
	push	OFFSET $SG4294800413
	push	OFFSET $SG4294800412
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetString@ConfigFile@@QAE?AVString@@PB_W00@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	push	OFFSET $SG4294800411
	push	OFFSET $SG4294800410
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?SetString@ConfigFile@@QAEXPB_W00@Z
	lea	ecx, DWORD PTR $T1[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
$LN1@ReloadIniS:

; 1683 :     }
; 1684 : }

	lea	ecx, DWORD PTR _strDevice$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR _audioDevices$[ebp]
	call	??1AudioDeviceList@@QAE@XZ		; AudioDeviceList::~AudioDeviceList
	mov	esp, ebp
	pop	ebp
	ret	0
?ReloadIniSettings@OBS@@AAEXXZ ENDP			; OBS::ReloadIniSettings
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0AudioDeviceList@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0AudioDeviceList@@QAE@XZ PROC				; AudioDeviceList::AudioDeviceList, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$List@UAudioDeviceInfo@@@@QAE@XZ	; List<AudioDeviceInfo>::List<AudioDeviceInfo>
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0AudioDeviceList@@QAE@XZ ENDP				; AudioDeviceList::AudioDeviceList
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.cpp
;	COMDAT ?UpdateAudioMeters@OBS@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?UpdateAudioMeters@OBS@@AAEXXZ PROC			; OBS::UpdateAudioMeters, COMDAT
; _this$ = ecx

; 1687 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1688 :     SetVolumeMeterValue(GetDlgItem(hwndMain, ID_DESKTOPVOLUMEMETER), desktopMag, desktopMax, desktopPeak);

	push	ecx
	movss	xmm0, DWORD PTR __real@00800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00800000
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+1184]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+1192]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+1200]
	movss	DWORD PTR [esp], xmm0
	push	5008					; 00001390H
	mov	eax, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	eax
	call	DWORD PTR __imp__GetDlgItem@8
	push	eax
	call	DWORD PTR __imp_?SetVolumeMeterValue@@YAMPAUHWND__@@MMMMMM@Z
	fstp	ST(0)

; 1689 :     SetVolumeMeterValue(GetDlgItem(hwndMain, ID_MICVOLUMEMETER), micMag, micMax, micPeak);

	add	esp, 24					; 00000018H
	movss	xmm0, DWORD PTR __real@00800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00800000
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR __real@00800000
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+1188]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [edx+1196]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [eax+1204]
	movss	DWORD PTR [esp], xmm0
	push	5009					; 00001391H
	mov	ecx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	ecx
	call	DWORD PTR __imp__GetDlgItem@8
	push	eax
	call	DWORD PTR __imp_?SetVolumeMeterValue@@YAMPAUHWND__@@MMMMMM@Z
	fstp	ST(0)
	add	esp, 28					; 0000001cH

; 1690 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?UpdateAudioMeters@OBS@@AAEXXZ ENDP			; OBS::UpdateAudioMeters
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.cpp
;	COMDAT ?GetIcon@OBS@@UAEPAUHICON__@@PAUHINSTANCE__@@H@Z
_TEXT	SEGMENT
_ii$ = -20						; size = 12
_this$ = -8						; size = 4
_i$1 = -4						; size = 4
_hInst$ = 8						; size = 4
_resource$ = 12						; size = 4
?GetIcon@OBS@@UAEPAUHICON__@@PAUHINSTANCE__@@H@Z PROC	; OBS::GetIcon, COMDAT
; _this$ = ecx

; 1693 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 1694 :     for(UINT i=0; i<Icons.Num(); i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@GetIcon
$LN3@GetIcon:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@GetIcon:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1344				; 00000540H
	call	?Num@?$List@UIconInfo@@@@QBEIXZ		; List<IconInfo>::Num
	cmp	DWORD PTR _i$1[ebp], eax
	jae	SHORT $LN2@GetIcon

; 1695 :     {
; 1696 :         if(Icons[i].resource == resource && Icons[i].hInst == hInst)

	mov	ecx, DWORD PTR _i$1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1344				; 00000540H
	call	??A?$List@UIconInfo@@@@QAEAAUIconInfo@@I@Z ; List<IconInfo>::operator[]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR _resource$[ebp]
	jne	SHORT $LN1@GetIcon
	mov	eax, DWORD PTR _i$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1344				; 00000540H
	call	??A?$List@UIconInfo@@@@QAEAAUIconInfo@@I@Z ; List<IconInfo>::operator[]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _hInst$[ebp]
	jne	SHORT $LN1@GetIcon

; 1697 :             return Icons[i].hIcon;

	mov	edx, DWORD PTR _i$1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1344				; 00000540H
	call	??A?$List@UIconInfo@@@@QAEAAUIconInfo@@I@Z ; List<IconInfo>::operator[]
	mov	eax, DWORD PTR [eax+4]
	jmp	SHORT $LN5@GetIcon
$LN1@GetIcon:

; 1698 :     }

	jmp	SHORT $LN3@GetIcon
$LN2@GetIcon:

; 1699 : 
; 1700 :     //---------------------
; 1701 : 
; 1702 :     IconInfo ii;
; 1703 :     ii.hInst = hInst;

	mov	eax, DWORD PTR _hInst$[ebp]
	mov	DWORD PTR _ii$[ebp], eax

; 1704 :     ii.resource = resource;

	mov	ecx, DWORD PTR _resource$[ebp]
	mov	DWORD PTR _ii$[ebp+8], ecx

; 1705 :     ii.hIcon = LoadIcon(hInst, MAKEINTRESOURCE(resource));

	movzx	edx, WORD PTR _resource$[ebp]
	push	edx
	mov	eax, DWORD PTR _hInst$[ebp]
	push	eax
	call	DWORD PTR __imp__LoadIconW@8
	mov	DWORD PTR _ii$[ebp+4], eax

; 1706 : 
; 1707 :     Icons << ii;

	lea	ecx, DWORD PTR _ii$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1344				; 00000540H
	call	??6?$List@UIconInfo@@@@QAEAAV0@ABUIconInfo@@@Z ; List<IconInfo>::operator<<

; 1708 : 
; 1709 :     return ii.hIcon;

	mov	eax, DWORD PTR _ii$[ebp+4]
$LN5@GetIcon:

; 1710 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetIcon@OBS@@UAEPAUHICON__@@PAUHINSTANCE__@@H@Z ENDP	; OBS::GetIcon
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.cpp
;	COMDAT ?GetFont@OBS@@UAEPAUHFONT__@@PB_WHH@Z
_TEXT	SEGMENT
_hFont$ = -112						; size = 4
_fi$1 = -108						; size = 4
_this$ = -104						; size = 4
_i$2 = -100						; size = 4
_lf$ = -96						; size = 92
__$ArrayPad$ = -4					; size = 4
_lpFontFace$ = 8					; size = 4
_fontSize$ = 12						; size = 4
_fontWeight$ = 16					; size = 4
?GetFont@OBS@@UAEPAUHFONT__@@PB_WHH@Z PROC		; OBS::GetFont, COMDAT
; _this$ = ecx

; 1713 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 1714 :     for(UINT i=0; i<Fonts.Num(); i++)

	mov	DWORD PTR _i$2[ebp], 0
	jmp	SHORT $LN5@GetFont
$LN4@GetFont:
	mov	eax, DWORD PTR _i$2[ebp]
	add	eax, 1
	mov	DWORD PTR _i$2[ebp], eax
$LN5@GetFont:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1352				; 00000548H
	call	?Num@?$List@UFontInfo@@@@QBEIXZ		; List<FontInfo>::Num
	cmp	DWORD PTR _i$2[ebp], eax
	jae	SHORT $LN3@GetFont

; 1715 :     {
; 1716 :         if(Fonts[i].strFontFace.CompareI(lpFontFace) && Fonts[i].fontSize == fontSize && Fonts[i].fontWeight == fontWeight)

	mov	ecx, DWORD PTR _lpFontFace$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$2[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1352				; 00000548H
	call	??A?$List@UFontInfo@@@@QAEAAUFontInfo@@I@Z ; List<FontInfo>::operator[]
	add	eax, 4
	mov	ecx, eax
	call	DWORD PTR __imp_?CompareI@String@@QBEHPB_W@Z
	test	eax, eax
	je	SHORT $LN2@GetFont
	mov	eax, DWORD PTR _i$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1352				; 00000548H
	call	??A?$List@UFontInfo@@@@QAEAAUFontInfo@@I@Z ; List<FontInfo>::operator[]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR _fontSize$[ebp]
	jne	SHORT $LN2@GetFont
	mov	edx, DWORD PTR _i$2[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1352				; 00000548H
	call	??A?$List@UFontInfo@@@@QAEAAUFontInfo@@I@Z ; List<FontInfo>::operator[]
	mov	eax, DWORD PTR [eax+16]
	cmp	eax, DWORD PTR _fontWeight$[ebp]
	jne	SHORT $LN2@GetFont

; 1717 :             return Fonts[i].hFont;

	mov	ecx, DWORD PTR _i$2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1352				; 00000548H
	call	??A?$List@UFontInfo@@@@QAEAAUFontInfo@@I@Z ; List<FontInfo>::operator[]
	mov	eax, DWORD PTR [eax]
	jmp	$LN6@GetFont
$LN2@GetFont:

; 1718 :     }

	jmp	$LN4@GetFont
$LN3@GetFont:

; 1719 : 
; 1720 :     //---------------------
; 1721 : 
; 1722 :     HFONT hFont = NULL;

	mov	DWORD PTR _hFont$[ebp], 0

; 1723 : 
; 1724 :     LOGFONT lf;
; 1725 :     zero(&lf, sizeof(lf));

	push	92					; 0000005cH
	lea	edx, DWORD PTR _lf$[ebp]
	push	edx
	call	?zero@@YGXPAXI@Z			; zero

; 1726 :     scpy_n(lf.lfFaceName, lpFontFace, 31);

	push	31					; 0000001fH
	mov	eax, DWORD PTR _lpFontFace$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lf$[ebp+28]
	push	ecx
	call	DWORD PTR __imp_?scpy_n@@YGXPA_WPB_WI@Z

; 1727 :     lf.lfHeight = fontSize;

	mov	edx, DWORD PTR _fontSize$[ebp]
	mov	DWORD PTR _lf$[ebp], edx

; 1728 :     lf.lfWeight = fontWeight;

	mov	eax, DWORD PTR _fontWeight$[ebp]
	mov	DWORD PTR _lf$[ebp+16], eax

; 1729 :     lf.lfQuality = ANTIALIASED_QUALITY;

	mov	BYTE PTR _lf$[ebp+26], 4

; 1730 : 
; 1731 :     if(hFont = CreateFontIndirect(&lf))

	lea	ecx, DWORD PTR _lf$[ebp]
	push	ecx
	call	DWORD PTR __imp__CreateFontIndirectW@4
	mov	DWORD PTR _hFont$[ebp], eax
	cmp	DWORD PTR _hFont$[ebp], 0
	je	SHORT $LN1@GetFont

; 1732 :     {
; 1733 :         FontInfo &fi = *Fonts.CreateNew();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1352				; 00000548H
	call	?CreateNew@?$List@UFontInfo@@@@QAEPAUFontInfo@@XZ ; List<FontInfo>::CreateNew
	mov	DWORD PTR _fi$1[ebp], eax

; 1734 : 
; 1735 :         fi.hFont = hFont;

	mov	edx, DWORD PTR _fi$1[ebp]
	mov	eax, DWORD PTR _hFont$[ebp]
	mov	DWORD PTR [edx], eax

; 1736 :         fi.fontSize = fontSize;

	mov	ecx, DWORD PTR _fi$1[ebp]
	mov	edx, DWORD PTR _fontSize$[ebp]
	mov	DWORD PTR [ecx+12], edx

; 1737 :         fi.fontWeight = fontWeight;

	mov	eax, DWORD PTR _fi$1[ebp]
	mov	ecx, DWORD PTR _fontWeight$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 1738 :         fi.strFontFace = lpFontFace;

	mov	edx, DWORD PTR _lpFontFace$[ebp]
	push	edx
	mov	ecx, DWORD PTR _fi$1[ebp]
	add	ecx, 4
	call	DWORD PTR __imp_??4String@@QAEAAV0@PB_W@Z
$LN1@GetFont:

; 1739 :     }
; 1740 : 
; 1741 :     return hFont;

	mov	eax, DWORD PTR _hFont$[ebp]
$LN6@GetFont:

; 1742 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GetFont@OBS@@UAEPAUHFONT__@@PB_WHH@Z ENDP		; OBS::GetFont
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.cpp
;	COMDAT ?SetStatusBarData@OBS@@AAEXXZ
_TEXT	SEGMENT
tv90 = -8						; size = 4
_this$ = -4						; size = 4
?SetStatusBarData@OBS@@AAEXXZ PROC			; OBS::SetStatusBarData, COMDAT
; _this$ = ecx

; 1757 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1758 :     if (bRunning && OSTryEnterMutex(hStartupShutdownMutex))

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+622]
	test	ecx, ecx
	je	$LN2@SetStatusB
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1400]
	push	eax
	call	DWORD PTR __imp_?OSTryEnterMutex@@YGHPAX@Z
	test	eax, eax
	je	$LN2@SetStatusB

; 1759 :     {
; 1760 : 		/* HWND hwndStatusBar = GetDlgItem(hwndMain, ID_STATUS);
; 1761 : 
; 1762 : 		 SendMessage(hwndStatusBar, WM_SETREDRAW, 0, 0);
; 1763 : 		 SendMessage(hwndStatusBar, SB_SETTEXT, 0 | SBT_OWNERDRAW, NULL);
; 1764 : 		 SendMessage(hwndStatusBar, SB_SETTEXT, 1 | SBT_OWNERDRAW, NULL);
; 1765 : 		 SendMessage(hwndStatusBar, SB_SETTEXT, 2 | SBT_OWNERDRAW, NULL);
; 1766 : 		 SendMessage(hwndStatusBar, SB_SETTEXT, 3 | SBT_OWNERDRAW, NULL);
; 1767 : 		 SendMessage(hwndStatusBar, SB_SETTEXT, 4 | SBT_OWNERDRAW, NULL);
; 1768 : 
; 1769 : 		 SendMessage(hwndStatusBar, WM_SETREDRAW, 1, 0);
; 1770 : 		 InvalidateRect(hwndStatusBar, NULL, FALSE);*/
; 1771 :     
; 1772 :         if (bRunning && network)

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+622]
	test	edx, edx
	je	$LN1@SetStatusB
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 76					; 0000004cH
	call	??B?$unique_ptr@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@@std@@QBE_NXZ ; std::unique_ptr<NetworkStream,std::default_delete<NetworkStream> >::operator bool
	movzx	eax, al
	test	eax, eax
	je	$LN1@SetStatusB

; 1773 :         {
; 1774 :             ReportStreamStatus(bRunning, bTestStream, 
; 1775 :                 (UINT) App->bytesPerSec, App->curStrain, 
; 1776 :                 (UINT)this->totalStreamTime, (UINT)network->NumTotalVideoFrames(),
; 1777 :                 (UINT)App->curFramesDropped, (UINT) App->captureFPS);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 76					; 0000004cH
	call	??C?$unique_ptr@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@@std@@QBEPAVNetworkStream@@XZ ; std::unique_ptr<NetworkStream,std::default_delete<NetworkStream> >::operator->
	mov	DWORD PTR tv90[ebp], eax
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	edx, DWORD PTR [ecx+920]
	push	edx
	mov	eax, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	ecx, DWORD PTR [eax+924]
	push	ecx
	mov	edx, DWORD PTR tv90[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv90[ebp]
	mov	edx, DWORD PTR [eax+24]
	call	edx
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+928]
	push	ecx
	mov	edx, DWORD PTR ?App@@3PAVOBS@@A		; App
	sub	esp, 8
	movsd	xmm0, QWORD PTR [edx+936]
	movsd	QWORD PTR [esp], xmm0
	mov	eax, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	ecx, DWORD PTR [eax+916]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+620]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+622]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+108]
	call	eax
$LN1@SetStatusB:

; 1778 :         }
; 1779 : 
; 1780 :         ReportOBSStatus(bRunning, bStreaming, bRecording, bTestStream, bReconnecting);

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+697]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+620]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+623]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+627]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+622]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+104]
	call	edx

; 1781 : 
; 1782 :         OSLeaveMutex(hStartupShutdownMutex);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1400]
	push	ecx
	call	DWORD PTR __imp_?OSLeaveMutex@@YGXPAX@Z
$LN2@SetStatusB:

; 1783 :     }
; 1784 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SetStatusBarData@OBS@@AAEXXZ ENDP			; OBS::SetStatusBarData
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.cpp
;	COMDAT ?DrawStatusBar@OBS@@CAXAAUtagDRAWITEMSTRUCT@@@Z
_TEXT	SEGMENT
_networkMode$1 = -216					; size = 4
$T2 = -212						; size = 8
$T3 = -204						; size = 8
$T4 = -196						; size = 8
$T5 = -188						; size = 8
$T6 = -180						; size = 8
$T7 = -172						; size = 8
$T8 = -164						; size = 8
_percentageDropped$9 = -156				; size = 8
_streamTimeHours$10 = -148				; size = 4
_priority$11 = -144					; size = 4
_red$12 = -140						; size = 4
_redStrain$13 = -136					; size = 8
_streamTimeMinutes$14 = -128				; size = 4
_streamTimeSeconds$15 = -124				; size = 4
_strKBPS$16 = -120					; size = 8
tv643 = -112						; size = 4
_streamTimeSecondsTotal$17 = -108			; size = 4
tv647 = -104						; size = 4
tv235 = -100						; size = 4
tv364 = -96						; size = 4
_green$18 = -92						; size = 4
_numTotalFrames$19 = -88				; size = 4
tv173 = -84						; size = 4
_hColorBrush$ = -80					; size = 4
_hbmpTemp$ = -76					; size = 4
_streamTimeMinutesTotal$20 = -72			; size = 4
_color$21 = -68						; size = 4
tv373 = -64						; size = 4
_mods$22 = -60						; size = 8
_hColorBrush$23 = -52					; size = 4
_strOutString$24 = -48					; size = 8
_hdcTemp$ = -40						; size = 4
_rcBox$25 = -36						; size = 16
_rc$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_dis$ = 8						; size = 4
?DrawStatusBar@OBS@@CAXAAUtagDRAWITEMSTRUCT@@@Z PROC	; OBS::DrawStatusBar, COMDAT

; 1787 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1788 :     if(!App->bRunning && !App->bStreaming && !App->bRecording)

	mov	eax, DWORD PTR ?App@@3PAVOBS@@A		; App
	movzx	ecx, BYTE PTR [eax+622]
	test	ecx, ecx
	jne	SHORT $LN22@DrawStatus
	mov	edx, DWORD PTR ?App@@3PAVOBS@@A		; App
	movzx	eax, BYTE PTR [edx+627]
	test	eax, eax
	jne	SHORT $LN22@DrawStatus
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	movzx	edx, BYTE PTR [ecx+623]
	test	edx, edx
	jne	SHORT $LN22@DrawStatus

; 1789 :         return;

	jmp	$LN23@DrawStatus
$LN22@DrawStatus:

; 1790 : 
; 1791 :     HDC hdcTemp = CreateCompatibleDC(dis.hDC);

	mov	eax, DWORD PTR _dis$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	DWORD PTR __imp__CreateCompatibleDC@4
	mov	DWORD PTR _hdcTemp$[ebp], eax

; 1792 :     HBITMAP hbmpTemp = CreateCompatibleBitmap(dis.hDC, dis.rcItem.right-dis.rcItem.left, dis.rcItem.bottom-dis.rcItem.top);

	mov	edx, DWORD PTR _dis$[ebp]
	mov	eax, DWORD PTR _dis$[ebp]
	mov	ecx, DWORD PTR [edx+40]
	sub	ecx, DWORD PTR [eax+32]
	push	ecx
	mov	edx, DWORD PTR _dis$[ebp]
	mov	eax, DWORD PTR _dis$[ebp]
	mov	ecx, DWORD PTR [edx+36]
	sub	ecx, DWORD PTR [eax+28]
	push	ecx
	mov	edx, DWORD PTR _dis$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	call	DWORD PTR __imp__CreateCompatibleBitmap@12
	mov	DWORD PTR _hbmpTemp$[ebp], eax

; 1793 :     SelectObject(hdcTemp, hbmpTemp);

	mov	ecx, DWORD PTR _hbmpTemp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _hdcTemp$[ebp]
	push	edx
	call	DWORD PTR __imp__SelectObject@8

; 1794 : 
; 1795 :     SelectObject(hdcTemp, GetCurrentObject(dis.hDC, OBJ_FONT));

	push	6
	mov	eax, DWORD PTR _dis$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	DWORD PTR __imp__GetCurrentObject@8
	push	eax
	mov	edx, DWORD PTR _hdcTemp$[ebp]
	push	edx
	call	DWORD PTR __imp__SelectObject@8

; 1796 :     SetTextColor(hdcTemp, GetTextColor(dis.hDC));

	mov	eax, DWORD PTR _dis$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	DWORD PTR __imp__GetTextColor@4
	push	eax
	mov	edx, DWORD PTR _hdcTemp$[ebp]
	push	edx
	call	DWORD PTR __imp__SetTextColor@8

; 1797 : 
; 1798 :     HBRUSH  hColorBrush = CreateSolidBrush(RGB(50,50,50));

	push	3289650					; 00323232H
	call	DWORD PTR __imp__CreateSolidBrush@4
	mov	DWORD PTR _hColorBrush$[ebp], eax

; 1799 : 
; 1800 :     RECT rc;
; 1801 :     mcpy(&rc, &dis.rcItem, sizeof(rc));

	mov	eax, DWORD PTR _dis$[ebp]
	add	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _rc$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _rc$[ebp+4], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _rc$[ebp+8], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR _rc$[ebp+12], edx

; 1802 : 
; 1803 :     rc.left   -= dis.rcItem.left;

	mov	eax, DWORD PTR _dis$[ebp]
	mov	ecx, DWORD PTR _rc$[ebp]
	sub	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR _rc$[ebp], ecx

; 1804 :     rc.right  -= dis.rcItem.left;

	mov	edx, DWORD PTR _dis$[ebp]
	mov	eax, DWORD PTR _rc$[ebp+8]
	sub	eax, DWORD PTR [edx+28]
	mov	DWORD PTR _rc$[ebp+8], eax

; 1805 :     rc.top    -= dis.rcItem.top;

	mov	ecx, DWORD PTR _dis$[ebp]
	mov	edx, DWORD PTR _rc$[ebp+4]
	sub	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR _rc$[ebp+4], edx

; 1806 :     rc.bottom -= dis.rcItem.top;

	mov	eax, DWORD PTR _dis$[ebp]
	mov	ecx, DWORD PTR _rc$[ebp+12]
	sub	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR _rc$[ebp+12], ecx

; 1807 : 
; 1808 :     //FillRect(hdcTemp, &rc, (HBRUSH)(COLOR_BTNFACE+1));
; 1809 : 	FillRect(hdcTemp, &rc, hColorBrush);

	mov	edx, DWORD PTR _hColorBrush$[ebp]
	push	edx
	lea	eax, DWORD PTR _rc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hdcTemp$[ebp]
	push	ecx
	call	DWORD PTR __imp__FillRect@12

; 1810 :     DeleteObject(hColorBrush);

	mov	edx, DWORD PTR _hColorBrush$[ebp]
	push	edx
	call	DWORD PTR __imp__DeleteObject@4

; 1811 : 
; 1812 :     //--------------------------------
; 1813 : 
; 1814 :     if(dis.itemID == 4)

	mov	eax, DWORD PTR _dis$[ebp]
	cmp	DWORD PTR [eax+8], 4
	jne	$LN21@DrawStatus

; 1815 :     {
; 1816 :         HBRUSH hColorBrush;
; 1817 :         DWORD green = 0xFF, red;

	mov	DWORD PTR _green$18[ebp], 255		; 000000ffH

; 1818 : 
; 1819 :         statusBarData.bytesPerSec = App->bytesPerSec;

	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	edx, DWORD PTR [ecx+916]
	mov	DWORD PTR ?statusBarData@@3UStatusBarDrawData@@A, edx

; 1820 :         statusBarData.strain = App->curStrain;

	mov	eax, DWORD PTR ?App@@3PAVOBS@@A		; App
	movsd	xmm0, QWORD PTR [eax+936]
	movsd	QWORD PTR ?statusBarData@@3UStatusBarDrawData@@A+8, xmm0

; 1821 :         //statusBarData.strain = rand()%101;
; 1822 : 
; 1823 :         //show grey rather than green when not connected
; 1824 :         if (App->network && App->network->NumTotalVideoFrames() == 0)

	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	add	ecx, 76					; 0000004cH
	call	??B?$unique_ptr@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@@std@@QBE_NXZ ; std::unique_ptr<NetworkStream,std::default_delete<NetworkStream> >::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN20@DrawStatus
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	add	ecx, 76					; 0000004cH
	call	??C?$unique_ptr@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@@std@@QBEPAVNetworkStream@@XZ ; std::unique_ptr<NetworkStream,std::default_delete<NetworkStream> >::operator->
	mov	DWORD PTR tv173[ebp], eax
	mov	edx, DWORD PTR tv173[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv173[ebp]
	mov	edx, DWORD PTR [eax+24]
	call	edx
	test	eax, eax
	jne	SHORT $LN20@DrawStatus

; 1825 :         {
; 1826 :             hColorBrush = CreateSolidBrush(RGB(100,100,100));

	push	6579300					; 00646464H
	call	DWORD PTR __imp__CreateSolidBrush@4
	mov	DWORD PTR _hColorBrush$23[ebp], eax

; 1827 :         }
; 1828 :         else

	jmp	$LN19@DrawStatus
$LN20@DrawStatus:

; 1829 :         {
; 1830 :             if(statusBarData.strain > 50.0)

	movsd	xmm0, QWORD PTR ?statusBarData@@3UStatusBarDrawData@@A+8
	comisd	xmm0, QWORD PTR __real@4049000000000000
	jbe	SHORT $LN18@DrawStatus

; 1831 :                 green = DWORD(((50.0-(statusBarData.strain-50.0))/50.0)*255.0);

	movsd	xmm0, QWORD PTR ?statusBarData@@3UStatusBarDrawData@@A+8
	subsd	xmm0, QWORD PTR __real@4049000000000000
	movsd	xmm1, QWORD PTR __real@4049000000000000
	subsd	xmm1, xmm0
	divsd	xmm1, QWORD PTR __real@4049000000000000
	mulsd	xmm1, QWORD PTR __real@406fe00000000000
	movsd	xmm0, xmm1
	call	__dtoui3
	mov	DWORD PTR _green$18[ebp], eax
$LN18@DrawStatus:

; 1832 : 
; 1833 :             double redStrain = statusBarData.strain/50.0;

	movsd	xmm0, QWORD PTR ?statusBarData@@3UStatusBarDrawData@@A+8
	divsd	xmm0, QWORD PTR __real@4049000000000000
	movsd	QWORD PTR _redStrain$13[ebp], xmm0

; 1834 :             if(redStrain > 1.0)

	movsd	xmm0, QWORD PTR _redStrain$13[ebp]
	comisd	xmm0, QWORD PTR __real@3ff0000000000000
	jbe	SHORT $LN17@DrawStatus

; 1835 :                 redStrain = 1.0;

	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	movsd	QWORD PTR _redStrain$13[ebp], xmm0
$LN17@DrawStatus:

; 1836 : 
; 1837 :             red = DWORD(redStrain*255.0);

	movsd	xmm0, QWORD PTR _redStrain$13[ebp]
	mulsd	xmm0, QWORD PTR __real@406fe00000000000
	call	__dtoui3
	mov	DWORD PTR _red$12[ebp], eax

; 1838 : 
; 1839 :             //--------------------------------
; 1840 : 
; 1841 :             hColorBrush = CreateSolidBrush((green<<8)|red);

	mov	eax, DWORD PTR _green$18[ebp]
	shl	eax, 8
	or	eax, DWORD PTR _red$12[ebp]
	push	eax
	call	DWORD PTR __imp__CreateSolidBrush@4
	mov	DWORD PTR _hColorBrush$23[ebp], eax
$LN19@DrawStatus:

; 1842 :         }
; 1843 : 
; 1844 :         RECT rcBox = {0, 0, 20, 20};

	mov	DWORD PTR _rcBox$25[ebp], 0
	mov	DWORD PTR _rcBox$25[ebp+4], 0
	mov	DWORD PTR _rcBox$25[ebp+8], 20		; 00000014H
	mov	DWORD PTR _rcBox$25[ebp+12], 20		; 00000014H

; 1845 :         /*rc.left += dis.rcItem.left;
; 1846 :         rc.right += dis.rcItem.left;
; 1847 :         rc.top += dis.rcItem.top;
; 1848 :         rc.bottom += dis.rcItem.top;*/
; 1849 : 		
; 1850 :         FillRect(hdcTemp, &rcBox, hColorBrush);

	mov	ecx, DWORD PTR _hColorBrush$23[ebp]
	push	ecx
	lea	edx, DWORD PTR _rcBox$25[ebp]
	push	edx
	mov	eax, DWORD PTR _hdcTemp$[ebp]
	push	eax
	call	DWORD PTR __imp__FillRect@12

; 1851 : 
; 1852 :         DeleteObject(hColorBrush);

	mov	ecx, DWORD PTR _hColorBrush$23[ebp]
	push	ecx
	call	DWORD PTR __imp__DeleteObject@4

; 1853 : 
; 1854 :         //--------------------------------
; 1855 : 
; 1856 :         SetBkMode(hdcTemp, TRANSPARENT);

	push	1
	mov	edx, DWORD PTR _hdcTemp$[ebp]
	push	edx
	call	DWORD PTR __imp__SetBkMode@8

; 1857 : 
; 1858 :         rc.left += 22;

	mov	eax, DWORD PTR _rc$[ebp]
	add	eax, 22					; 00000016H
	mov	DWORD PTR _rc$[ebp], eax

; 1859 : 		SetTextColor(hdcTemp, RGB(0,255,0));

	push	65280					; 0000ff00H
	mov	ecx, DWORD PTR _hdcTemp$[ebp]
	push	ecx
	call	DWORD PTR __imp__SetTextColor@8

; 1860 :         String strKBPS;

	lea	ecx, DWORD PTR _strKBPS$16[ebp]
	call	DWORD PTR __imp_??0String@@QAE@XZ

; 1861 :         strKBPS << IntString((statusBarData.bytesPerSec*8) / 1000) << TEXT("kb/s");

	push	OFFSET $SG4294800409
	push	10					; 0000000aH
	mov	eax, DWORD PTR ?statusBarData@@3UStatusBarDrawData@@A
	shl	eax, 3
	xor	edx, edx
	mov	ecx, 1000				; 000003e8H
	div	ecx
	push	eax
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	call	DWORD PTR __imp_?IntString@@YA?AVString@@HH@Z
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _strKBPS$16[ebp]
	call	DWORD PTR __imp_??6String@@QAEAAV0@ABV0@@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@PB_W@Z
	lea	ecx, DWORD PTR $T3[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 1862 :         //strKBPS << IntString(rand()) << TEXT("kb/s");
; 1863 :         DrawText(hdcTemp, strKBPS, strKBPS.Length(), &rc, DT_VCENTER|DT_SINGLELINE|DT_LEFT);

	push	36					; 00000024H
	lea	eax, DWORD PTR _rc$[ebp]
	push	eax
	lea	ecx, DWORD PTR _strKBPS$16[ebp]
	call	DWORD PTR __imp_?Length@String@@QBEIXZ
	push	eax
	lea	ecx, DWORD PTR _strKBPS$16[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	mov	ecx, DWORD PTR _hdcTemp$[ebp]
	push	ecx
	call	DWORD PTR __imp__DrawTextW@20

; 1864 :     }

	lea	ecx, DWORD PTR _strKBPS$16[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 1865 :     else

	jmp	$LN16@DrawStatus
$LN21@DrawStatus:

; 1866 :     {
; 1867 :         String strOutString;

	lea	ecx, DWORD PTR _strOutString$24[ebp]
	call	DWORD PTR __imp_??0String@@QAE@XZ

; 1868 :        // DWORD color = 0x000000;
; 1869 : 		DWORD color = RGB(0,255,0);

	mov	DWORD PTR _color$21[ebp], 65280		; 0000ff00H

; 1870 :         switch(dis.itemID)

	mov	edx, DWORD PTR _dis$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR tv235[ebp], eax
	cmp	DWORD PTR tv235[ebp], 3
	ja	$LN14@DrawStatus
	mov	ecx, DWORD PTR tv235[ebp]
	jmp	DWORD PTR $LN25@DrawStatus[ecx*4]
$LN13@DrawStatus:

; 1871 :         {
; 1872 :             case 0:
; 1873 :                 {
; 1874 :                     StreamInfoPriority priority;
; 1875 :                     strOutString << App->GetMostImportantInfo(priority);

	lea	edx, DWORD PTR _priority$11[ebp]
	push	edx
	lea	eax, DWORD PTR $T8[ebp]
	push	eax
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	call	?GetMostImportantInfo@OBS@@QAE?AVString@@AAW4StreamInfoPriority@@@Z ; OBS::GetMostImportantInfo
	push	eax
	lea	ecx, DWORD PTR _strOutString$24[ebp]
	call	DWORD PTR __imp_??6String@@QAEAAV0@ABV0@@Z
	lea	ecx, DWORD PTR $T8[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 1876 :                     if (priority == StreamInfoPriority_Critical)

	cmp	DWORD PTR _priority$11[ebp], 3
	jne	SHORT $LN12@DrawStatus

; 1877 :                         color = 0x0000FF;

	mov	DWORD PTR _color$21[ebp], 255		; 000000ffH
$LN12@DrawStatus:

; 1878 :                     break;

	jmp	$LN14@DrawStatus
$LN11@DrawStatus:

; 1879 :                 }
; 1880 : 
; 1881 :             case 1:
; 1882 :                 {
; 1883 :                     DWORD streamTimeSecondsTotal = App->totalStreamTime/1000;

	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	eax, DWORD PTR [ecx+928]
	xor	edx, edx
	mov	ecx, 1000				; 000003e8H
	div	ecx
	mov	DWORD PTR _streamTimeSecondsTotal$17[ebp], eax

; 1884 :                     DWORD streamTimeMinutesTotal = streamTimeSecondsTotal/60;

	mov	eax, DWORD PTR _streamTimeSecondsTotal$17[ebp]
	xor	edx, edx
	mov	ecx, 60					; 0000003cH
	div	ecx
	mov	DWORD PTR _streamTimeMinutesTotal$20[ebp], eax

; 1885 :                     DWORD streamTimeSeconds = streamTimeSecondsTotal%60;

	mov	eax, DWORD PTR _streamTimeSecondsTotal$17[ebp]
	xor	edx, edx
	mov	ecx, 60					; 0000003cH
	div	ecx
	mov	DWORD PTR _streamTimeSeconds$15[ebp], edx

; 1886 : 
; 1887 :                     DWORD streamTimeHours = streamTimeMinutesTotal/60;

	mov	eax, DWORD PTR _streamTimeMinutesTotal$20[ebp]
	xor	edx, edx
	mov	ecx, 60					; 0000003cH
	div	ecx
	mov	DWORD PTR _streamTimeHours$10[ebp], eax

; 1888 :                     DWORD streamTimeMinutes = streamTimeMinutesTotal%60;

	mov	eax, DWORD PTR _streamTimeMinutesTotal$20[ebp]
	xor	edx, edx
	mov	ecx, 60					; 0000003cH
	div	ecx
	mov	DWORD PTR _streamTimeMinutes$14[ebp], edx

; 1889 : 
; 1890 :                     int networkMode = AppConfig->GetInt(TEXT("Publish"), TEXT("Mode"), 2);

	push	2
	push	OFFSET $SG4294800408
	push	OFFSET $SG4294800407
	mov	ecx, DWORD PTR ?AppConfig@@3PAVConfigFile@@A ; AppConfig
	call	DWORD PTR __imp_?GetInt@ConfigFile@@QAEHPB_W0H@Z
	mov	DWORD PTR _networkMode$1[ebp], eax

; 1891 : 
; 1892 :                     strOutString = FormattedString(TEXT("%u:%02u:%02u"), streamTimeHours, streamTimeMinutes, streamTimeSeconds);

	mov	edx, DWORD PTR _streamTimeSeconds$15[ebp]
	push	edx
	mov	eax, DWORD PTR _streamTimeMinutes$14[ebp]
	push	eax
	mov	ecx, DWORD PTR _streamTimeHours$10[ebp]
	push	ecx
	push	OFFSET $SG4294800406
	lea	edx, DWORD PTR $T6[ebp]
	push	edx
	call	DWORD PTR __imp_?FormattedString@@YA?AVString@@PB_WZZ
	add	esp, 20					; 00000014H
	push	eax
	lea	ecx, DWORD PTR _strOutString$24[ebp]
	call	DWORD PTR __imp_??4String@@QAEAAV0@ABV0@@Z
	lea	ecx, DWORD PTR $T6[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 1893 : 
; 1894 :                     StringList mods;

	lea	ecx, DWORD PTR _mods$22[ebp]
	call	DWORD PTR __imp_??0StringList@@QAE@XZ

; 1895 :                     if (App->bStreaming && !App->bTestStream)

	mov	eax, DWORD PTR ?App@@3PAVOBS@@A		; App
	movzx	ecx, BYTE PTR [eax+627]
	test	ecx, ecx
	je	SHORT $LN10@DrawStatus
	mov	edx, DWORD PTR ?App@@3PAVOBS@@A		; App
	movzx	eax, BYTE PTR [edx+620]
	test	eax, eax
	jne	SHORT $LN10@DrawStatus

; 1896 :                         mods << L"LIVE";

	push	OFFSET $SG4294800405
	lea	ecx, DWORD PTR _mods$22[ebp]
	call	DWORD PTR __imp_??6StringList@@QAEAAV0@PB_W@Z
$LN10@DrawStatus:

; 1897 :                     if (App->bRecording)

	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	movzx	edx, BYTE PTR [ecx+623]
	test	edx, edx
	je	SHORT $LN9@DrawStatus

; 1898 :                         mods << L"REC";

	push	OFFSET $SG4294800404
	lea	ecx, DWORD PTR _mods$22[ebp]
	call	DWORD PTR __imp_??6StringList@@QAEAAV0@PB_W@Z
$LN9@DrawStatus:

; 1899 :                     if (App->bRecordingReplayBuffer)

	mov	eax, DWORD PTR ?App@@3PAVOBS@@A		; App
	movzx	ecx, BYTE PTR [eax+624]
	test	ecx, ecx
	je	SHORT $LN8@DrawStatus

; 1900 :                         mods << L"BUF";

	push	OFFSET $SG4294800403
	lea	ecx, DWORD PTR _mods$22[ebp]
	call	DWORD PTR __imp_??6StringList@@QAEAAV0@PB_W@Z
$LN8@DrawStatus:

; 1901 :                     if (App->bTestStream)

	mov	edx, DWORD PTR ?App@@3PAVOBS@@A		; App
	movzx	eax, BYTE PTR [edx+620]
	test	eax, eax
	je	SHORT $LN7@DrawStatus

; 1902 :                         mods << L"Preview";

	push	OFFSET $SG4294800402
	lea	ecx, DWORD PTR _mods$22[ebp]
	call	DWORD PTR __imp_??6StringList@@QAEAAV0@PB_W@Z
$LN7@DrawStatus:

; 1903 : 
; 1904 :                     strOutString << FormattedString(L" (%s)", mods.Join(L" + ").Array());

	sub	esp, 8
	mov	ecx, esp
	push	OFFSET $SG4294800401
	call	DWORD PTR __imp_??0String@@QAE@PB_W@Z
	lea	ecx, DWORD PTR $T4[ebp]
	push	ecx
	lea	ecx, DWORD PTR _mods$22[ebp]
	call	DWORD PTR __imp_?Join@StringList@@QAE?AVString@@V2@@Z
	mov	ecx, eax
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	push	OFFSET $SG4294800400
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	call	DWORD PTR __imp_?FormattedString@@YA?AVString@@PB_WZZ
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _strOutString$24[ebp]
	call	DWORD PTR __imp_??6String@@QAEAAV0@ABV0@@Z
	lea	ecx, DWORD PTR $T2[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	lea	ecx, DWORD PTR $T4[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 1905 :                 }

	lea	ecx, DWORD PTR _mods$22[ebp]
	call	DWORD PTR __imp_??1StringList@@QAE@XZ

; 1906 :                 break;

	jmp	$LN14@DrawStatus
$LN6@DrawStatus:

; 1907 :             case 2:
; 1908 :                 {
; 1909 :                     double percentageDropped = 0.0;

	movsd	xmm0, QWORD PTR __real@0000000000000000
	movsd	QWORD PTR _percentageDropped$9[ebp], xmm0

; 1910 :                     if (OSTryEnterMutex(App->hStartupShutdownMutex))

	mov	eax, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	ecx, DWORD PTR [eax+1400]
	push	ecx
	call	DWORD PTR __imp_?OSTryEnterMutex@@YGHPAX@Z
	test	eax, eax
	je	$LN5@DrawStatus

; 1911 :                     {
; 1912 :                         if(App->network)

	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	add	ecx, 76					; 0000004cH
	call	??B?$unique_ptr@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@@std@@QBE_NXZ ; std::unique_ptr<NetworkStream,std::default_delete<NetworkStream> >::operator bool
	movzx	edx, al
	test	edx, edx
	je	$LN3@DrawStatus

; 1913 :                         {
; 1914 :                             UINT numTotalFrames = App->network->NumTotalVideoFrames();

	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	add	ecx, 76					; 0000004cH
	call	??C?$unique_ptr@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@@std@@QBEPAVNetworkStream@@XZ ; std::unique_ptr<NetworkStream,std::default_delete<NetworkStream> >::operator->
	mov	DWORD PTR tv364[ebp], eax
	mov	eax, DWORD PTR tv364[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv364[ebp]
	mov	eax, DWORD PTR [edx+24]
	call	eax
	mov	DWORD PTR _numTotalFrames$19[ebp], eax

; 1915 :                             if(numTotalFrames)

	cmp	DWORD PTR _numTotalFrames$19[ebp], 0
	je	SHORT $LN3@DrawStatus

; 1916 :                                 percentageDropped = (double(App->network->NumDroppedFrames())/double(numTotalFrames))*100.0;

	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	add	ecx, 76					; 0000004cH
	call	??C?$unique_ptr@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@@std@@QBEPAVNetworkStream@@XZ ; std::unique_ptr<NetworkStream,std::default_delete<NetworkStream> >::operator->
	mov	DWORD PTR tv373[ebp], eax
	mov	ecx, DWORD PTR tv373[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv373[ebp]
	mov	eax, DWORD PTR [edx+20]
	call	eax
	mov	DWORD PTR tv643[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv643[ebp]
	mov	ecx, DWORD PTR tv643[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	mov	edx, DWORD PTR _numTotalFrames$19[ebp]
	mov	DWORD PTR tv647[ebp], edx
	cvtsi2sd xmm1, DWORD PTR tv647[ebp]
	mov	eax, DWORD PTR tv647[ebp]
	shr	eax, 31					; 0000001fH
	addsd	xmm1, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	divsd	xmm0, xmm1
	mulsd	xmm0, QWORD PTR __real@4059000000000000
	movsd	QWORD PTR _percentageDropped$9[ebp], xmm0
$LN3@DrawStatus:

; 1917 :                         }
; 1918 :                         OSLeaveMutex(App->hStartupShutdownMutex);

	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	edx, DWORD PTR [ecx+1400]
	push	edx
	call	DWORD PTR __imp_?OSLeaveMutex@@YGXPAX@Z
$LN5@DrawStatus:

; 1919 :                     }
; 1920 :                     strOutString << Str("MainWindow.DroppedFrames") << FormattedString(TEXT(" %u (%0.2f%%)"), App->curFramesDropped, percentageDropped);

	sub	esp, 8
	movsd	xmm0, QWORD PTR _percentageDropped$9[ebp]
	movsd	QWORD PTR [esp], xmm0
	mov	eax, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	ecx, DWORD PTR [eax+924]
	push	ecx
	push	OFFSET $SG4294800398
	lea	edx, DWORD PTR $T7[ebp]
	push	edx
	call	DWORD PTR __imp_?FormattedString@@YA?AVString@@PB_WZZ
	add	esp, 20					; 00000014H
	push	eax
	push	OFFSET $SG4294800399
	mov	eax, DWORD PTR __imp_?locale@@3PAVLocaleStringLookup@@A
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR __imp_?LookupString@LocaleStringLookup@@QAEPB_WPB_W@Z
	push	eax
	lea	ecx, DWORD PTR _strOutString$24[ebp]
	call	DWORD PTR __imp_??6String@@QAEAAV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@ABV0@@Z
	lea	ecx, DWORD PTR $T7[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 1921 :                 }
; 1922 :                 break;

	jmp	SHORT $LN14@DrawStatus
$LN2@DrawStatus:

; 1923 :             case 3: strOutString << TEXT("FPS: ") << IntString(App->captureFPS); break;

	push	10					; 0000000aH
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	edx, DWORD PTR [ecx+920]
	push	edx
	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	call	DWORD PTR __imp_?IntString@@YA?AVString@@HH@Z
	add	esp, 12					; 0000000cH
	push	eax
	push	OFFSET $SG4294800397
	lea	ecx, DWORD PTR _strOutString$24[ebp]
	call	DWORD PTR __imp_??6String@@QAEAAV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@ABV0@@Z
	lea	ecx, DWORD PTR $T5[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
$LN14@DrawStatus:

; 1924 :         }
; 1925 : 
; 1926 :         if(strOutString.IsValid())

	lea	ecx, DWORD PTR _strOutString$24[ebp]
	call	DWORD PTR __imp_?IsValid@String@@QBEHXZ
	test	eax, eax
	je	SHORT $LN1@DrawStatus

; 1927 :         {
; 1928 :             SetTextColor(hdcTemp, color);

	mov	ecx, DWORD PTR _color$21[ebp]
	push	ecx
	mov	edx, DWORD PTR _hdcTemp$[ebp]
	push	edx
	call	DWORD PTR __imp__SetTextColor@8

; 1929 :             SetBkMode(hdcTemp, TRANSPARENT);

	push	1
	mov	eax, DWORD PTR _hdcTemp$[ebp]
	push	eax
	call	DWORD PTR __imp__SetBkMode@8

; 1930 :             DrawText(hdcTemp, strOutString, strOutString.Length(), &rc, DT_VCENTER|DT_SINGLELINE|DT_LEFT);

	push	36					; 00000024H
	lea	ecx, DWORD PTR _rc$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strOutString$24[ebp]
	call	DWORD PTR __imp_?Length@String@@QBEIXZ
	push	eax
	lea	ecx, DWORD PTR _strOutString$24[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	mov	edx, DWORD PTR _hdcTemp$[ebp]
	push	edx
	call	DWORD PTR __imp__DrawTextW@20
$LN1@DrawStatus:

; 1931 :         }
; 1932 :     }

	lea	ecx, DWORD PTR _strOutString$24[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
$LN16@DrawStatus:

; 1933 : 
; 1934 :     //--------------------------------
; 1935 : 
; 1936 :     BitBlt(dis.hDC, dis.rcItem.left, dis.rcItem.top, dis.rcItem.right-dis.rcItem.left, dis.rcItem.bottom-dis.rcItem.top, hdcTemp, 0, 0, SRCCOPY);

	push	13369376				; 00cc0020H
	push	0
	push	0
	mov	eax, DWORD PTR _hdcTemp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dis$[ebp]
	mov	edx, DWORD PTR _dis$[ebp]
	mov	eax, DWORD PTR [ecx+40]
	sub	eax, DWORD PTR [edx+32]
	push	eax
	mov	ecx, DWORD PTR _dis$[ebp]
	mov	edx, DWORD PTR _dis$[ebp]
	mov	eax, DWORD PTR [ecx+36]
	sub	eax, DWORD PTR [edx+28]
	push	eax
	mov	ecx, DWORD PTR _dis$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	mov	eax, DWORD PTR _dis$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	mov	edx, DWORD PTR _dis$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	call	DWORD PTR __imp__BitBlt@36

; 1937 : 
; 1938 :     DeleteObject(hdcTemp);

	mov	ecx, DWORD PTR _hdcTemp$[ebp]
	push	ecx
	call	DWORD PTR __imp__DeleteObject@4

; 1939 :     DeleteObject(hbmpTemp);

	mov	edx, DWORD PTR _hbmpTemp$[ebp]
	push	edx
	call	DWORD PTR __imp__DeleteObject@4
$LN23@DrawStatus:

; 1940 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN25@DrawStatus:
	DD	$LN13@DrawStatus
	DD	$LN11@DrawStatus
	DD	$LN6@DrawStatus
	DD	$LN2@DrawStatus
?DrawStatusBar@OBS@@CAXAAUtagDRAWITEMSTRUCT@@@Z ENDP	; OBS::DrawStatusBar
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.cpp
;	COMDAT ?SelectSources@OBS@@AAEXXZ
_TEXT	SEGMENT
_selectedItems$1 = -28					; size = 8
_sceneItem$2 = -20					; size = 4
_numSelected$ = -16					; size = 4
_hwndSources$ = -12					; size = 4
_iPos$3 = -8						; size = 4
_this$ = -4						; size = 4
?SelectSources@OBS@@AAEXXZ PROC				; OBS::SelectSources, COMDAT
; _this$ = ecx

; 1943 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 1944 :     if(scene)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+144], 0
	je	SHORT $LN5@SelectSour

; 1945 :         scene->DeselectAll();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+144]
	call	DWORD PTR __imp_?DeselectAll@Scene@@AAEXXZ
$LN5@SelectSour:

; 1946 : 
; 1947 :     HWND hwndSources = GetDlgItem(hwndMain, ID_SOURCES);

	push	5013					; 00001395H
	mov	edx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	edx
	call	DWORD PTR __imp__GetDlgItem@8
	mov	DWORD PTR _hwndSources$[ebp], eax

; 1948 :     UINT numSelected = ListView_GetSelectedCount(hwndSources);

	push	0
	push	0
	push	4146					; 00001032H
	mov	eax, DWORD PTR _hwndSources$[ebp]
	push	eax
	call	DWORD PTR __imp__SendMessageW@16
	mov	DWORD PTR _numSelected$[ebp], eax

; 1949 : 
; 1950 :     if(numSelected)

	cmp	DWORD PTR _numSelected$[ebp], 0
	je	SHORT $LN6@SelectSour

; 1951 :     {
; 1952 :         List<UINT> selectedItems;

	lea	ecx, DWORD PTR _selectedItems$1[ebp]
	call	??0?$List@I@@QAE@XZ			; List<unsigned int>::List<unsigned int>

; 1953 :         selectedItems.SetSize(numSelected);

	mov	ecx, DWORD PTR _numSelected$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _selectedItems$1[ebp]
	call	?SetSize@?$List@I@@QAEHI@Z		; List<unsigned int>::SetSize

; 1954 :         //SendMessage(hwndSources, LB_GETSELITEMS, numSelected, (LPARAM)selectedItems.Array());
; 1955 : 
; 1956 :         if(scene)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+144], 0
	je	SHORT $LN3@SelectSour

; 1957 :         {
; 1958 :             int iPos = ListView_GetNextItem(hwndSources, -1, LVNI_SELECTED);

	push	2
	push	-1
	push	4108					; 0000100cH
	mov	eax, DWORD PTR _hwndSources$[ebp]
	push	eax
	call	DWORD PTR __imp__SendMessageW@16
	mov	DWORD PTR _iPos$3[ebp], eax
$LN2@SelectSour:

; 1959 :             while (iPos != -1)

	cmp	DWORD PTR _iPos$3[ebp], -1
	je	SHORT $LN3@SelectSour

; 1960 :             {
; 1961 :                 SceneItem *sceneItem = scene->GetSceneItem(iPos);

	mov	ecx, DWORD PTR _iPos$3[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+144]
	call	DWORD PTR __imp_?GetSceneItem@Scene@@QBEPAVSceneItem@@I@Z
	mov	DWORD PTR _sceneItem$2[ebp], eax

; 1962 :                 sceneItem->bSelected = true;

	mov	eax, DWORD PTR _sceneItem$2[ebp]
	mov	BYTE PTR [eax+64], 1

; 1963 :                 
; 1964 :                 iPos = ListView_GetNextItem(hwndSources, iPos, LVNI_SELECTED);

	push	2
	mov	ecx, DWORD PTR _iPos$3[ebp]
	push	ecx
	push	4108					; 0000100cH
	mov	edx, DWORD PTR _hwndSources$[ebp]
	push	edx
	call	DWORD PTR __imp__SendMessageW@16
	mov	DWORD PTR _iPos$3[ebp], eax

; 1965 :             }

	jmp	SHORT $LN2@SelectSour
$LN3@SelectSour:

; 1966 :         }
; 1967 :     }

	lea	ecx, DWORD PTR _selectedItems$1[ebp]
	call	??1?$List@I@@QAE@XZ			; List<unsigned int>::~List<unsigned int>
$LN6@SelectSour:

; 1968 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SelectSources@OBS@@AAEXXZ ENDP				; OBS::SelectSources
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.cpp
;	COMDAT ?CheckSources@OBS@@AAEXXZ
_TEXT	SEGMENT
_numSources$ = -48					; size = 4
_curSceneElement$ = -44					; size = 4
_sceneItem$1 = -40					; size = 4
tv137 = -36						; size = 4
tv129 = -32						; size = 4
_sources$ = -28						; size = 4
tv87 = -24						; size = 4
_hwndSources$ = -20					; size = 4
_source$2 = -16						; size = 4
_this$ = -12						; size = 4
_i$3 = -8						; size = 4
_curRender$4 = -2					; size = 1
_checked$5 = -1						; size = 1
?CheckSources@OBS@@AAEXXZ PROC				; OBS::CheckSources, COMDAT
; _this$ = ecx

; 1971 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	DWORD PTR _this$[ebp], ecx

; 1972 :     XElement *curSceneElement = App->sceneElement;

	mov	eax, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	ecx, DWORD PTR [eax+212]
	mov	DWORD PTR _curSceneElement$[ebp], ecx

; 1973 :     XElement *sources = curSceneElement->GetElement(TEXT("sources"));

	push	OFFSET $SG4294800396
	mov	ecx, DWORD PTR _curSceneElement$[ebp]
	call	DWORD PTR __imp_?GetElement@XElement@@QBEPAV1@PB_W@Z
	mov	DWORD PTR _sources$[ebp], eax

; 1974 : 
; 1975 :     if(!sources)

	cmp	DWORD PTR _sources$[ebp], 0
	jne	SHORT $LN6@CheckSourc

; 1976 :         return;

	jmp	$LN7@CheckSourc
$LN6@CheckSourc:

; 1977 : 
; 1978 :     HWND hwndSources = GetDlgItem(hwndMain, ID_SOURCES);

	push	5013					; 00001395H
	mov	edx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	edx
	call	DWORD PTR __imp__GetDlgItem@8
	mov	DWORD PTR _hwndSources$[ebp], eax

; 1979 : 
; 1980 :     UINT numSources = ListView_GetItemCount(hwndSources);

	push	0
	push	0
	push	4100					; 00001004H
	mov	eax, DWORD PTR _hwndSources$[ebp]
	push	eax
	call	DWORD PTR __imp__SendMessageW@16
	mov	DWORD PTR _numSources$[ebp], eax

; 1981 :     for(UINT i = 0; i < numSources; i++)

	mov	DWORD PTR _i$3[ebp], 0
	jmp	SHORT $LN5@CheckSourc
$LN4@CheckSourc:
	mov	ecx, DWORD PTR _i$3[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$3[ebp], ecx
$LN5@CheckSourc:
	mov	edx, DWORD PTR _i$3[ebp]
	cmp	edx, DWORD PTR _numSources$[ebp]
	jae	$LN7@CheckSourc

; 1982 :     {
; 1983 :         bool checked = ListView_GetCheckState(hwndSources, i) > 0;

	push	61440					; 0000f000H
	mov	eax, DWORD PTR _i$3[ebp]
	push	eax
	push	4140					; 0000102cH
	mov	ecx, DWORD PTR _hwndSources$[ebp]
	push	ecx
	call	DWORD PTR __imp__SendMessageW@16
	shr	eax, 12					; 0000000cH
	sub	eax, 1
	je	SHORT $LN9@CheckSourc
	mov	DWORD PTR tv87[ebp], 1
	jmp	SHORT $LN10@CheckSourc
$LN9@CheckSourc:
	mov	DWORD PTR tv87[ebp], 0
$LN10@CheckSourc:
	mov	dl, BYTE PTR tv87[ebp]
	mov	BYTE PTR _checked$5[ebp], dl

; 1984 :         XElement *source =sources->GetElementByID(i);

	mov	eax, DWORD PTR _i$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _sources$[ebp]
	call	DWORD PTR __imp_?GetElementByID@XElement@@QBEPAV1@K@Z
	mov	DWORD PTR _source$2[ebp], eax

; 1985 :         bool curRender = source->GetInt(TEXT("render"), 0) > 0;

	push	0
	push	OFFSET $SG4294800395
	mov	ecx, DWORD PTR _source$2[ebp]
	call	DWORD PTR __imp_?GetInt@XElement@@QBEHPB_WH@Z
	test	eax, eax
	jle	SHORT $LN11@CheckSourc
	mov	DWORD PTR tv129[ebp], 1
	jmp	SHORT $LN12@CheckSourc
$LN11@CheckSourc:
	mov	DWORD PTR tv129[ebp], 0
$LN12@CheckSourc:
	mov	cl, BYTE PTR tv129[ebp]
	mov	BYTE PTR _curRender$4[ebp], cl

; 1986 :         if(curRender != checked)

	movzx	edx, BYTE PTR _curRender$4[ebp]
	movzx	eax, BYTE PTR _checked$5[ebp]
	cmp	edx, eax
	je	$LN2@CheckSourc

; 1987 :         {
; 1988 :             source->SetInt(TEXT("render"), (checked)?1:0);

	movzx	ecx, BYTE PTR _checked$5[ebp]
	test	ecx, ecx
	je	SHORT $LN13@CheckSourc
	mov	DWORD PTR tv137[ebp], 1
	jmp	SHORT $LN14@CheckSourc
$LN13@CheckSourc:
	mov	DWORD PTR tv137[ebp], 0
$LN14@CheckSourc:
	mov	edx, DWORD PTR tv137[ebp]
	push	edx
	push	OFFSET $SG4294800394
	mov	ecx, DWORD PTR _source$2[ebp]
	call	DWORD PTR __imp_?SetInt@XElement@@QAEXPB_WH@Z

; 1989 :             if(scene && i < scene->NumSceneItems())

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+144], 0
	je	SHORT $LN1@CheckSourc
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+144]
	call	DWORD PTR __imp_?NumSceneItems@Scene@@QBEIXZ
	cmp	DWORD PTR _i$3[ebp], eax
	jae	SHORT $LN1@CheckSourc

; 1990 :             {
; 1991 :                 SceneItem *sceneItem = scene->GetSceneItem(i);

	mov	edx, DWORD PTR _i$3[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+144]
	call	DWORD PTR __imp_?GetSceneItem@Scene@@QBEPAVSceneItem@@I@Z
	mov	DWORD PTR _sceneItem$1[ebp], eax

; 1992 :                 sceneItem->bRender = checked;

	mov	ecx, DWORD PTR _sceneItem$1[ebp]
	mov	dl, BYTE PTR _checked$5[ebp]
	mov	BYTE PTR [ecx+65], dl

; 1993 :                 sceneItem->SetRender(checked);

	movzx	eax, BYTE PTR _checked$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _sceneItem$1[ebp]
	call	DWORD PTR __imp_?SetRender@SceneItem@@QAEX_N@Z
$LN1@CheckSourc:

; 1994 :             }
; 1995 :             ReportSourceChanged(source->GetName(), source);

	mov	ecx, DWORD PTR _source$2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _source$2[ebp]
	call	DWORD PTR __imp_?GetName@XBaseItem@@QBEPB_WXZ
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+132]
	call	edx
$LN2@CheckSourc:

; 1996 :         }
; 1997 :     }

	jmp	$LN4@CheckSourc
$LN7@CheckSourc:

; 1998 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CheckSources@OBS@@AAEXXZ ENDP				; OBS::CheckSources
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.cpp
;	COMDAT ?SetSourceRender@OBS@@AAEXPB_W_N@Z
_TEXT	SEGMENT
__macro_lvi$1 = -108					; size = 60
_sceneItem$2 = -48					; size = 4
_numSources$ = -44					; size = 4
_curSceneElement$ = -40					; size = 4
tv158 = -36						; size = 4
tv152 = -32						; size = 4
_sources$ = -28						; size = 4
tv87 = -24						; size = 4
_source$3 = -20						; size = 4
_hwndSources$ = -16					; size = 4
_this$ = -12						; size = 4
_i$4 = -8						; size = 4
_checked$5 = -1						; size = 1
_sourceName$ = 8					; size = 4
_render$ = 12						; size = 1
?SetSourceRender@OBS@@AAEXPB_W_N@Z PROC			; OBS::SetSourceRender, COMDAT
; _this$ = ecx

; 2001 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	mov	DWORD PTR _this$[ebp], ecx

; 2002 :     XElement *curSceneElement = App->sceneElement;

	mov	eax, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	ecx, DWORD PTR [eax+212]
	mov	DWORD PTR _curSceneElement$[ebp], ecx

; 2003 :     XElement *sources = curSceneElement->GetElement(TEXT("sources"));

	push	OFFSET $SG4294800393
	mov	ecx, DWORD PTR _curSceneElement$[ebp]
	call	DWORD PTR __imp_?GetElement@XElement@@QBEPAV1@PB_W@Z
	mov	DWORD PTR _sources$[ebp], eax

; 2004 : 
; 2005 :     if(!sources)

	cmp	DWORD PTR _sources$[ebp], 0
	jne	SHORT $LN7@SetSourceR

; 2006 :         return;

	jmp	$LN8@SetSourceR
$LN7@SetSourceR:

; 2007 : 
; 2008 :     HWND hwndSources = GetDlgItem(hwndMain, ID_SOURCES);

	push	5013					; 00001395H
	mov	edx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	edx
	call	DWORD PTR __imp__GetDlgItem@8
	mov	DWORD PTR _hwndSources$[ebp], eax

; 2009 : 
; 2010 :     UINT numSources = ListView_GetItemCount(hwndSources);

	push	0
	push	0
	push	4100					; 00001004H
	mov	eax, DWORD PTR _hwndSources$[ebp]
	push	eax
	call	DWORD PTR __imp__SendMessageW@16
	mov	DWORD PTR _numSources$[ebp], eax

; 2011 :     for(UINT i = 0; i < numSources; i++)

	mov	DWORD PTR _i$4[ebp], 0
	jmp	SHORT $LN6@SetSourceR
$LN5@SetSourceR:
	mov	ecx, DWORD PTR _i$4[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$4[ebp], ecx
$LN6@SetSourceR:
	mov	edx, DWORD PTR _i$4[ebp]
	cmp	edx, DWORD PTR _numSources$[ebp]
	jae	$LN8@SetSourceR

; 2012 :     {
; 2013 :         bool checked = ListView_GetCheckState(hwndSources, i) > 0;

	push	61440					; 0000f000H
	mov	eax, DWORD PTR _i$4[ebp]
	push	eax
	push	4140					; 0000102cH
	mov	ecx, DWORD PTR _hwndSources$[ebp]
	push	ecx
	call	DWORD PTR __imp__SendMessageW@16
	shr	eax, 12					; 0000000cH
	sub	eax, 1
	je	SHORT $LN10@SetSourceR
	mov	DWORD PTR tv87[ebp], 1
	jmp	SHORT $LN11@SetSourceR
$LN10@SetSourceR:
	mov	DWORD PTR tv87[ebp], 0
$LN11@SetSourceR:
	mov	dl, BYTE PTR tv87[ebp]
	mov	BYTE PTR _checked$5[ebp], dl

; 2014 :         XElement *source =sources->GetElementByID(i);

	mov	eax, DWORD PTR _i$4[ebp]
	push	eax
	mov	ecx, DWORD PTR _sources$[ebp]
	call	DWORD PTR __imp_?GetElementByID@XElement@@QBEPAV1@K@Z
	mov	DWORD PTR _source$3[ebp], eax

; 2015 :         if(scmp(source->GetName(), sourceName) == 0 && checked != render)

	mov	ecx, DWORD PTR _sourceName$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _source$3[ebp]
	call	DWORD PTR __imp_?GetName@XBaseItem@@QBEPB_WXZ
	push	eax
	call	DWORD PTR __imp_?scmp@@YGHPB_W0@Z
	test	eax, eax
	jne	$LN3@SetSourceR
	movzx	edx, BYTE PTR _checked$5[ebp]
	movzx	eax, BYTE PTR _render$[ebp]
	cmp	edx, eax
	je	$LN3@SetSourceR

; 2016 :         {
; 2017 :             if(scene && i < scene->NumSceneItems())

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+144], 0
	je	SHORT $LN2@SetSourceR
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+144]
	call	DWORD PTR __imp_?NumSceneItems@Scene@@QBEIXZ
	cmp	DWORD PTR _i$4[ebp], eax
	jae	SHORT $LN2@SetSourceR

; 2018 :             {
; 2019 :                 SceneItem *sceneItem = scene->GetSceneItem(i);

	mov	eax, DWORD PTR _i$4[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+144]
	call	DWORD PTR __imp_?GetSceneItem@Scene@@QBEPAVSceneItem@@I@Z
	mov	DWORD PTR _sceneItem$2[ebp], eax

; 2020 :                 sceneItem->SetRender(render);

	movzx	edx, BYTE PTR _render$[ebp]
	push	edx
	mov	ecx, DWORD PTR _sceneItem$2[ebp]
	call	DWORD PTR __imp_?SetRender@SceneItem@@QAEX_N@Z

; 2021 :             }
; 2022 :             else

	jmp	SHORT $LN1@SetSourceR
$LN2@SetSourceR:

; 2023 :             {
; 2024 :                 source->SetInt(TEXT("render"), (render)?1:0);

	movzx	eax, BYTE PTR _render$[ebp]
	test	eax, eax
	je	SHORT $LN12@SetSourceR
	mov	DWORD PTR tv152[ebp], 1
	jmp	SHORT $LN13@SetSourceR
$LN12@SetSourceR:
	mov	DWORD PTR tv152[ebp], 0
$LN13@SetSourceR:
	mov	ecx, DWORD PTR tv152[ebp]
	push	ecx
	push	OFFSET $SG4294800392
	mov	ecx, DWORD PTR _source$3[ebp]
	call	DWORD PTR __imp_?SetInt@XElement@@QAEXPB_WH@Z
$LN1@SetSourceR:

; 2025 :             }
; 2026 :             App->bChangingSources = true;

	mov	edx, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	BYTE PTR [edx+705], 1

; 2027 :             ListView_SetCheckState(hwndSources, i, render);

	mov	DWORD PTR __macro_lvi$1[ebp+16], 61440	; 0000f000H
	movzx	eax, BYTE PTR _render$[ebp]
	test	eax, eax
	je	SHORT $LN14@SetSourceR
	mov	DWORD PTR tv158[ebp], 2
	jmp	SHORT $LN15@SetSourceR
$LN14@SetSourceR:
	mov	DWORD PTR tv158[ebp], 1
$LN15@SetSourceR:
	mov	ecx, DWORD PTR tv158[ebp]
	shl	ecx, 12					; 0000000cH
	mov	DWORD PTR __macro_lvi$1[ebp+12], ecx
	lea	edx, DWORD PTR __macro_lvi$1[ebp]
	push	edx
	mov	eax, DWORD PTR _i$4[ebp]
	push	eax
	push	4139					; 0000102bH
	mov	ecx, DWORD PTR _hwndSources$[ebp]
	push	ecx
	call	DWORD PTR __imp__SendMessageW@16

; 2028 :             App->bChangingSources = false;

	mov	edx, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	BYTE PTR [edx+705], 0

; 2029 : 
; 2030 :             ReportSourceChanged(sourceName, source);

	mov	eax, DWORD PTR _source$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _sourceName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+132]
	call	edx

; 2031 : 
; 2032 :             break;

	jmp	SHORT $LN8@SetSourceR
$LN3@SetSourceR:

; 2033 :         }
; 2034 :     }

	jmp	$LN5@SetSourceR
$LN8@SetSourceR:

; 2035 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?SetSourceRender@OBS@@AAEXPB_W_N@Z ENDP			; OBS::SetSourceRender
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.cpp
;	COMDAT ?SetNotificationAreaIcon@OBS@@AAEHKHABVString@@@Z
_TEXT	SEGMENT
_this$ = -968						; size = 4
_result$ = -964						; size = 4
_niData$ = -960						; size = 956
__$ArrayPad$ = -4					; size = 4
_dwMessage$ = 8						; size = 4
_idIcon$ = 12						; size = 4
_tooltip$ = 16						; size = 4
?SetNotificationAreaIcon@OBS@@AAEHKHABVString@@@Z PROC	; OBS::SetNotificationAreaIcon, COMDAT
; _this$ = ecx

; 2038 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 968				; 000003c8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 2039 :     NOTIFYICONDATA niData;
; 2040 :     BOOL result;
; 2041 :     
; 2042 :     ZeroMemory(&niData, sizeof(NOTIFYICONDATA));

	push	956					; 000003bcH
	push	0
	lea	eax, DWORD PTR _niData$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 2043 :     niData.cbSize = sizeof(niData);

	mov	DWORD PTR _niData$[ebp], 956		; 000003bcH

; 2044 :     niData.hWnd = hwndMain;

	mov	ecx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	mov	DWORD PTR _niData$[ebp+4], ecx

; 2045 :     niData.uID = 0;

	mov	DWORD PTR _niData$[ebp+8], 0

; 2046 :     
; 2047 :     if (NIM_DELETE != dwMessage)

	cmp	DWORD PTR _dwMessage$[ebp], 2
	je	SHORT $LN2@SetNotific

; 2048 :     {
; 2049 :         niData.uFlags = NIF_MESSAGE | NIF_ICON | NIF_TIP;

	mov	DWORD PTR _niData$[ebp+12], 7

; 2050 :         niData.uCallbackMessage = OBS_NOTIFICATIONAREA;

	mov	DWORD PTR _niData$[ebp+16], 1032	; 00000408H

; 2051 :         niData.hIcon = LoadIcon(hinstMain, MAKEINTRESOURCE(idIcon));

	movzx	edx, WORD PTR _idIcon$[ebp]
	push	edx
	mov	eax, DWORD PTR ?hinstMain@@3PAUHINSTANCE__@@A ; hinstMain
	push	eax
	call	DWORD PTR __imp__LoadIconW@8
	mov	DWORD PTR _niData$[ebp+20], eax

; 2052 :         scpy_n (niData.szTip, tooltip, _countof(niData.szTip)-1);

	push	127					; 0000007fH
	mov	ecx, DWORD PTR _tooltip$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	lea	ecx, DWORD PTR _niData$[ebp+24]
	push	ecx
	call	DWORD PTR __imp_?scpy_n@@YGXPA_WPB_WI@Z
$LN2@SetNotific:

; 2053 :     }
; 2054 : 
; 2055 :     result = Shell_NotifyIcon(dwMessage, &niData);

	lea	edx, DWORD PTR _niData$[ebp]
	push	edx
	mov	eax, DWORD PTR _dwMessage$[ebp]
	push	eax
	call	DWORD PTR __imp__Shell_NotifyIconW@8
	mov	DWORD PTR _result$[ebp], eax

; 2056 : 
; 2057 :     if(niData.hIcon)

	cmp	DWORD PTR _niData$[ebp+20], 0
	je	SHORT $LN1@SetNotific

; 2058 :        DestroyIcon(niData.hIcon);

	mov	ecx, DWORD PTR _niData$[ebp+20]
	push	ecx
	call	DWORD PTR __imp__DestroyIcon@4
$LN1@SetNotific:

; 2059 : 
; 2060 :     return result;

	mov	eax, DWORD PTR _result$[ebp]

; 2061 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?SetNotificationAreaIcon@OBS@@AAEHKHABVString@@@Z ENDP	; OBS::SetNotificationAreaIcon
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.cpp
;	COMDAT ?ShowNotificationAreaIcon@OBS@@QAEHXZ
_TEXT	SEGMENT
$T1 = -32						; size = 8
$T2 = -24						; size = 8
_idIcon$ = -16						; size = 4
tv70 = -12						; size = 4
_result$ = -8						; size = 4
_this$ = -4						; size = 4
?ShowNotificationAreaIcon@OBS@@QAEHXZ PROC		; OBS::ShowNotificationAreaIcon, COMDAT
; _this$ = ecx

; 2064 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 2065 :     BOOL result = FALSE;

	mov	DWORD PTR _result$[ebp], 0

; 2066 :     int idIcon = (bRunning && !bTestStream) ? IDI_ICON2 : IDI_ICON1;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+622]
	test	ecx, ecx
	je	SHORT $LN5@ShowNotifi
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+620]
	test	eax, eax
	jne	SHORT $LN5@ShowNotifi
	mov	DWORD PTR tv70[ebp], 142		; 0000008eH
	jmp	SHORT $LN6@ShowNotifi
$LN5@ShowNotifi:
	mov	DWORD PTR tv70[ebp], 109		; 0000006dH
$LN6@ShowNotifi:
	mov	ecx, DWORD PTR tv70[ebp]
	mov	DWORD PTR _idIcon$[ebp], ecx

; 2067 : 
; 2068 :     if (!bNotificationAreaIcon)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+1324]
	test	eax, eax
	jne	SHORT $LN2@ShowNotifi

; 2069 :     {
; 2070 :         bNotificationAreaIcon = true;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+1324], 1

; 2071 :         result = SetNotificationAreaIcon(NIM_ADD, idIcon, GetApplicationName());

	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	call	?GetApplicationName@OBS@@CA?AVString@@XZ ; OBS::GetApplicationName
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _idIcon$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetNotificationAreaIcon@OBS@@AAEHKHABVString@@@Z ; OBS::SetNotificationAreaIcon
	mov	DWORD PTR _result$[ebp], eax
	lea	ecx, DWORD PTR $T2[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 2072 :     }
; 2073 :     else

	jmp	SHORT $LN1@ShowNotifi
$LN2@ShowNotifi:

; 2074 :     {
; 2075 :         result = SetNotificationAreaIcon(NIM_MODIFY, idIcon, GetApplicationName());

	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	?GetApplicationName@OBS@@CA?AVString@@XZ ; OBS::GetApplicationName
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _idIcon$[ebp]
	push	edx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetNotificationAreaIcon@OBS@@AAEHKHABVString@@@Z ; OBS::SetNotificationAreaIcon
	mov	DWORD PTR _result$[ebp], eax
	lea	ecx, DWORD PTR $T1[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
$LN1@ShowNotifi:

; 2076 :     }
; 2077 :     return result;

	mov	eax, DWORD PTR _result$[ebp]

; 2078 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ShowNotificationAreaIcon@OBS@@QAEHXZ ENDP		; OBS::ShowNotificationAreaIcon
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.cpp
;	COMDAT ?HideNotificationAreaIcon@OBS@@QAEHXZ
_TEXT	SEGMENT
$T1 = -16						; size = 8
$T2 = -8						; size = 4
_this$ = -4						; size = 4
?HideNotificationAreaIcon@OBS@@QAEHXZ PROC		; OBS::HideNotificationAreaIcon, COMDAT
; _this$ = ecx

; 2088 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 2089 :     bNotificationAreaIcon = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+1324], 0

; 2090 :     return SetNotificationAreaIcon(NIM_DELETE, 0, TEXT(""));

	push	OFFSET $SG4294800391
	lea	ecx, DWORD PTR $T1[ebp]
	call	DWORD PTR __imp_??0String@@QAE@PB_W@Z
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	push	0
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetNotificationAreaIcon@OBS@@AAEHKHABVString@@@Z ; OBS::SetNotificationAreaIcon
	mov	DWORD PTR $T2[ebp], eax
	lea	ecx, DWORD PTR $T1[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	eax, DWORD PTR $T2[ebp]

; 2091 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?HideNotificationAreaIcon@OBS@@QAEHXZ ENDP		; OBS::HideNotificationAreaIcon
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.cpp
;	COMDAT ?ActuallyEnableProjector@OBS@@AAEXXZ
_TEXT	SEGMENT
$T1 = -92						; size = 4
tv184 = -88						; size = 4
_target$ = -84						; size = 4
_sys$ = -80						; size = 4
_tex$ = -76						; size = 4
_backBuffer$ = -72					; size = 4
_this$ = -68						; size = 4
_swapDesc$ = -64					; size = 60
__$ArrayPad$ = -4					; size = 4
?ActuallyEnableProjector@OBS@@AAEXXZ PROC		; OBS::ActuallyEnableProjector, COMDAT
; _this$ = ecx

; 2108 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 2109 :     DisableProjector();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DisableProjector@OBS@@AAEXXZ		; OBS::DisableProjector

; 2110 : 
; 2111 :     D3D10System *sys = static_cast<D3D10System*>(GS);

	mov	eax, DWORD PTR __imp_?GS@@3PAVGraphicsSystem@@A
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _sys$[ebp], ecx

; 2112 : 
; 2113 :     DXGI_SWAP_CHAIN_DESC swapDesc;
; 2114 :     zero(&swapDesc, sizeof(swapDesc));

	push	60					; 0000003cH
	lea	edx, DWORD PTR _swapDesc$[ebp]
	push	edx
	call	?zero@@YGXPAXI@Z			; zero

; 2115 :     swapDesc.BufferCount = 2;

	mov	DWORD PTR _swapDesc$[ebp+40], 2

; 2116 :     swapDesc.BufferDesc.Format = DXGI_FORMAT_B8G8R8A8_UNORM;

	mov	DWORD PTR _swapDesc$[ebp+16], 87	; 00000057H

; 2117 :     swapDesc.BufferDesc.Width  = projectorWidth;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+720]
	mov	DWORD PTR _swapDesc$[ebp], ecx

; 2118 :     swapDesc.BufferDesc.Height = projectorHeight;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+724]
	mov	DWORD PTR _swapDesc$[ebp+4], eax

; 2119 :     swapDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;

	mov	DWORD PTR _swapDesc$[ebp+36], 32	; 00000020H

; 2120 :     swapDesc.OutputWindow = hwndProjector;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+732]
	mov	DWORD PTR _swapDesc$[ebp+44], edx

; 2121 :     swapDesc.SampleDesc.Count = 1;

	mov	DWORD PTR _swapDesc$[ebp+28], 1

; 2122 :     swapDesc.Windowed = TRUE;

	mov	DWORD PTR _swapDesc$[ebp+48], 1

; 2123 : 
; 2124 :     if (!bShutdownEncodeThread)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+632]
	test	ecx, ecx
	jne	SHORT $LN10@ActuallyEn

; 2125 :         SetWindowPos(hwndProjector, NULL, projectorX, projectorY, projectorWidth, projectorHeight, SWP_SHOWWINDOW);

	push	64					; 00000040H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+724]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+720]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+716]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+712]
	push	eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+732]
	push	edx
	call	DWORD PTR __imp__SetWindowPos@28
$LN10@ActuallyEn:

; 2126 : 
; 2127 :     ID3D10Texture2D *backBuffer = NULL;

	mov	DWORD PTR _backBuffer$[ebp], 0

; 2128 :     ID3D10RenderTargetView *target = NULL;

	mov	DWORD PTR _target$[ebp], 0

; 2129 : 
; 2130 :     if (FAILED(sys->factory->CreateSwapChain(sys->d3d, &swapDesc, &projectorSwap))) {

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	lea	ecx, DWORD PTR _swapDesc$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sys$[ebp]
	mov	eax, DWORD PTR [edx+72]
	push	eax
	mov	ecx, DWORD PTR _sys$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	mov	eax, DWORD PTR _sys$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+40]
	call	eax
	test	eax, eax
	jge	SHORT $LN9@ActuallyEn

; 2131 :         AppWarning(L"Could not create projector swap chain");

	push	OFFSET $SG4294800390
	call	DWORD PTR __imp_?AppWarning@@YAXPB_WZZ
	add	esp, 4

; 2132 :         goto exit;

	jmp	$exit$15
	jmp	$exit$15
$LN9@ActuallyEn:

; 2133 :     }
; 2134 : 
; 2135 :     if (FAILED(projectorSwap->GetBuffer(0, IID_ID3D10Texture2D, (void**)&backBuffer))) {

	lea	ecx, DWORD PTR _backBuffer$[ebp]
	push	ecx
	push	OFFSET _IID_ID3D10Texture2D
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+36]
	call	ecx
	test	eax, eax
	jge	SHORT $LN7@ActuallyEn

; 2136 :         AppWarning(TEXT("Unable to get projector back buffer"));

	push	OFFSET $SG4294800389
	call	DWORD PTR __imp_?AppWarning@@YAXPB_WZZ
	add	esp, 4

; 2137 :         goto exit;

	jmp	$exit$15
	jmp	$exit$15
$LN7@ActuallyEn:

; 2138 :     }
; 2139 : 
; 2140 :     if(FAILED(sys->d3d->CreateRenderTargetView(backBuffer, NULL, &target))) {

	lea	edx, DWORD PTR _target$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _backBuffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sys$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	eax, DWORD PTR _sys$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+304]
	call	eax
	test	eax, eax
	jge	SHORT $LN5@ActuallyEn

; 2141 :         AppWarning(TEXT("Unable to get render view from projector back buffer"));

	push	OFFSET $SG4294800388
	call	DWORD PTR __imp_?AppWarning@@YAXPB_WZZ
	add	esp, 4

; 2142 :         goto exit;

	jmp	SHORT $exit$15
	jmp	SHORT $exit$15
$LN5@ActuallyEn:

; 2143 :     }
; 2144 : 
; 2145 :     D3D10Texture *tex = new D3D10Texture();

	push	36					; 00000024H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 0
	je	SHORT $LN13@ActuallyEn
	mov	ecx, DWORD PTR $T1[ebp]
	call	??0D3D10Texture@@QAE@XZ
	mov	DWORD PTR tv184[ebp], eax
	jmp	SHORT $LN14@ActuallyEn
$LN13@ActuallyEn:
	mov	DWORD PTR tv184[ebp], 0
$LN14@ActuallyEn:
	mov	ecx, DWORD PTR tv184[ebp]
	mov	DWORD PTR _tex$[ebp], ecx

; 2146 :     tex->width        = projectorWidth;

	mov	edx, DWORD PTR _tex$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+720]
	mov	DWORD PTR [edx+16], ecx

; 2147 :     tex->height       = projectorHeight;

	mov	edx, DWORD PTR _tex$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+724]
	mov	DWORD PTR [edx+20], ecx

; 2148 :     tex->format       = GS_BGRA;

	mov	edx, DWORD PTR _tex$[ebp]
	mov	DWORD PTR [edx+24], 6

; 2149 :     tex->texture      = backBuffer;

	mov	eax, DWORD PTR _tex$[ebp]
	mov	ecx, DWORD PTR _backBuffer$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 2150 :     tex->renderTarget = target;

	mov	edx, DWORD PTR _tex$[ebp]
	mov	eax, DWORD PTR _target$[ebp]
	mov	DWORD PTR [edx+12], eax

; 2151 : 
; 2152 :     projectorTexture = tex;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _tex$[ebp]
	mov	DWORD PTR [ecx+736], edx

; 2153 :     bProjector = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+709], 1
$exit$15:

; 2154 : 
; 2155 : exit:
; 2156 :     if (!bProjector) {

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+709]
	test	edx, edx
	jne	SHORT $LN3@ActuallyEn

; 2157 :         SafeRelease(projectorSwap);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN2@ActuallyEn
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
$LN2@ActuallyEn:

; 2158 :         SafeRelease(backBuffer);

	cmp	DWORD PTR _backBuffer$[ebp], 0
	je	SHORT $LN3@ActuallyEn
	mov	edx, DWORD PTR _backBuffer$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _backBuffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR [eax+8]
	call	edx
	mov	DWORD PTR _backBuffer$[ebp], 0
$LN3@ActuallyEn:

; 2159 :     }
; 2160 : 
; 2161 :     bPleaseEnableProjector = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+707], 0

; 2162 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?ActuallyEnableProjector@OBS@@AAEXXZ ENDP		; OBS::ActuallyEnableProjector
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.cpp
;	COMDAT ?EnableProjector@OBS@@AAEXI@Z
_TEXT	SEGMENT
_mi$ = -8						; size = 4
_this$ = -4						; size = 4
_monitorID$ = 8						; size = 4
?EnableProjector@OBS@@AAEXI@Z PROC			; OBS::EnableProjector, COMDAT
; _this$ = ecx

; 2165 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2166 :     const MonitorInfo &mi = GetMonitor(monitorID);

	mov	eax, DWORD PTR _monitorID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetMonitor@OBS@@QBEABUMonitorInfo@@I@Z	; OBS::GetMonitor
	mov	DWORD PTR _mi$[ebp], eax

; 2167 : 
; 2168 :     projectorMonitorID = monitorID;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _monitorID$[ebp]
	mov	DWORD PTR [ecx+728], edx

; 2169 :     projectorWidth     = mi.rect.right-mi.rect.left;

	mov	eax, DWORD PTR _mi$[ebp]
	mov	ecx, DWORD PTR _mi$[ebp]
	mov	edx, DWORD PTR [eax+12]
	sub	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+720], edx

; 2170 :     projectorHeight    = mi.rect.bottom-mi.rect.top;

	mov	ecx, DWORD PTR _mi$[ebp]
	mov	edx, DWORD PTR _mi$[ebp]
	mov	eax, DWORD PTR [ecx+16]
	sub	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+724], eax

; 2171 :     projectorX         = mi.rect.left;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _mi$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+712], ecx

; 2172 :     projectorY         = mi.rect.top;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _mi$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+716], ecx

; 2173 : 
; 2174 :     bPleaseEnableProjector = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+707], 1

; 2175 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?EnableProjector@OBS@@AAEXI@Z ENDP			; OBS::EnableProjector
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.cpp
;	COMDAT ?DisableProjector@OBS@@AAEXXZ
_TEXT	SEGMENT
tv89 = -16						; size = 4
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
?DisableProjector@OBS@@AAEXXZ PROC			; OBS::DisableProjector, COMDAT
; _this$ = ecx

; 2178 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 2179 :     SafeRelease(projectorSwap);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN2@DisablePro
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
$LN2@DisablePro:

; 2180 : 
; 2181 :     delete projectorTexture;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+736]
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR $T2[ebp], ecx
	cmp	DWORD PTR $T2[ebp], 0
	je	SHORT $LN5@DisablePro
	push	1
	mov	edx, DWORD PTR $T2[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR $T2[ebp]
	mov	edx, DWORD PTR [eax]
	call	edx
	mov	DWORD PTR tv89[ebp], eax
	jmp	SHORT $LN6@DisablePro
$LN5@DisablePro:
	mov	DWORD PTR tv89[ebp], 0
$LN6@DisablePro:

; 2182 :     projectorTexture = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+736], 0

; 2183 : 
; 2184 :     bProjector = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+709], 0

; 2185 :     bPleaseDisableProjector = false;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+708], 0

; 2186 : 
; 2187 :     if (!bShutdownEncodeThread)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+632]
	test	ecx, ecx
	jne	SHORT $LN3@DisablePro

; 2188 :         ShowWindow(hwndProjector, SW_HIDE);

	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+732]
	push	eax
	call	DWORD PTR __imp__ShowWindow@8
$LN3@DisablePro:

; 2189 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DisableProjector@OBS@@AAEXXZ ENDP			; OBS::DisableProjector
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.cpp
;	COMDAT ?RestartNetwork@OBS@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?RestartNetwork@OBS@@AAEXXZ PROC			; OBS::RestartNetwork, COMDAT
; _this$ = ecx

; 2205 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2206 :     OSEnterMutex(App->hStartupShutdownMutex);

	mov	eax, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	ecx, DWORD PTR [eax+1400]
	push	ecx
	call	DWORD PTR __imp_?OSEnterMutex@@YGXPAX@Z

; 2207 : 
; 2208 :     //delete the old one
; 2209 :     App->network.reset();

	push	0
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	add	ecx, 76					; 0000004cH
	call	?reset@?$unique_ptr@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@@std@@QAEXPAVNetworkStream@@@Z ; std::unique_ptr<NetworkStream,std::default_delete<NetworkStream> >::reset

; 2210 : 
; 2211 :     //start up a new one
; 2212 :     App->bSentHeaders = false;

	mov	edx, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	BYTE PTR [edx+989], 0

; 2213 :     App->network.reset(CreateRTMPPublisher());

	call	?CreateRTMPPublisher@@YAPAVNetworkStream@@XZ ; CreateRTMPPublisher
	push	eax
	mov	ecx, DWORD PTR ?App@@3PAVOBS@@A		; App
	add	ecx, 76					; 0000004cH
	call	?reset@?$unique_ptr@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@@std@@QAEXPAVNetworkStream@@@Z ; std::unique_ptr<NetworkStream,std::default_delete<NetworkStream> >::reset

; 2214 : 
; 2215 :     OSLeaveMutex(App->hStartupShutdownMutex);

	mov	eax, DWORD PTR ?App@@3PAVOBS@@A		; App
	mov	ecx, DWORD PTR [eax+1400]
	push	ecx
	call	DWORD PTR __imp_?OSLeaveMutex@@YGXPAX@Z

; 2216 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?RestartNetwork@OBS@@AAEXXZ ENDP			; OBS::RestartNetwork
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.cpp
;	COMDAT ?InitLayOut@OBS@@AAEXXZ
_TEXT	SEGMENT
_min_button_height$ = -248				; size = 4
_plugin_button_offset_top$ = -244			; size = 4
_min_button_width$ = -240				; size = 4
_setting_button_offset_top$ = -236			; size = 4
_min_button_offset_top$ = -232				; size = 4
_live_button_offset_top$ = -228				; size = 4
_min_button_offset_left$ = -224				; size = 4
_carama_button_offset_top$ = -220			; size = 4
_close_button_height$ = -216				; size = 4
_live_button_height$ = -212				; size = 4
_close_button_width$ = -208				; size = 4
_setting_button_height$ = -204				; size = 4
_close_button_offset_top$ = -200			; size = 4
_carama_button_height$ = -196				; size = 4
_close_button_offset_left$ = -192			; size = 4
_plugin_button_height$ = -188				; size = 4
_logo_button_height$ = -184				; size = 4
_record_button_offset_left$ = -180			; size = 4
_logo_button_width$ = -176				; size = 4
_live_button_width$ = -172				; size = 4
_logo_button_offset_top$ = -168				; size = 4
_live_button_offset_left$ = -164			; size = 4
_preview_button_height$ = -160				; size = 4
_logo_button_offset_left$ = -156			; size = 4
_preview_button_width$ = -152				; size = 4
_setting_button_offset_left$ = -148			; size = 4
_preview_button_offset_top$ = -144			; size = 4
_carama_button_width$ = -140				; size = 4
_preview_button_offset_left$ = -136			; size = 4
_carama_button_offset_left$ = -132			; size = 4
_record_button_height$ = -128				; size = 4
_plugin_button_width$ = -124				; size = 4
_record_button_width$ = -120				; size = 4
_plugin_button_offset_left$ = -116			; size = 4
_record_button_offset_top$ = -112			; size = 4
_setting_button_width$ = -108				; size = 4
$T1 = -104						; size = 8
$T2 = -96						; size = 8
$T3 = -88						; size = 8
$T4 = -80						; size = 8
$T5 = -72						; size = 8
$T6 = -64						; size = 8
$T7 = -56						; size = 8
$T8 = -48						; size = 8
$T9 = -40						; size = 8
_strButtonPath$ = -32					; size = 8
_this$ = -24						; size = 4
_RT$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
?InitLayOut@OBS@@AAEXXZ PROC				; OBS::InitLayOut, COMDAT
; _this$ = ecx

; 2218 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 248				; 000000f8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 2219 : 	ResizeWindow(false);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResizeWindow@OBS@@QAEX_N@Z		; OBS::ResizeWindow

; 2220 : 	String strButtonPath;

	lea	ecx, DWORD PTR _strButtonPath$[ebp]
	call	DWORD PTR __imp_??0String@@QAE@XZ

; 2221 : 	//--------------------------------------------------------------------
; 2222 : 	//btnLogo
; 2223 : 	const int logo_button_offset_left = 3;

	mov	DWORD PTR _logo_button_offset_left$[ebp], 3

; 2224 : 	const int logo_button_offset_top = 3;

	mov	DWORD PTR _logo_button_offset_top$[ebp], 3

; 2225 : 	const int logo_button_width = 200;

	mov	DWORD PTR _logo_button_width$[ebp], 200	; 000000c8H

; 2226 : 	const int logo_button_height = 80;

	mov	DWORD PTR _logo_button_height$[ebp], 80	; 00000050H

; 2227 : 	RECT RT;
; 2228 : 	RT.left = logo_button_offset_left;

	mov	DWORD PTR _RT$[ebp], 3

; 2229 : 	RT.top = logo_button_offset_top;

	mov	DWORD PTR _RT$[ebp+4], 3

; 2230 : 	RT.bottom = logo_button_offset_top + logo_button_height;

	mov	DWORD PTR _RT$[ebp+12], 83		; 00000053H

; 2231 : 	RT.right = logo_button_offset_left + logo_button_width;

	mov	DWORD PTR _RT$[ebp+8], 203		; 000000cbH

; 2232 : 	strButtonPath << lpAppPath << "//skin//staticbk.png";

	push	OFFSET $SG4294800387
	lea	ecx, DWORD PTR $T6[ebp]
	call	DWORD PTR __imp_??0String@@QAE@PBD@Z
	lea	eax, DWORD PTR $T6[ebp]
	push	eax
	push	OFFSET ?lpAppPath@@3PA_WA		; lpAppPath
	lea	ecx, DWORD PTR _strButtonPath$[ebp]
	call	DWORD PTR __imp_??6String@@QAEAAV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@ABV0@@Z
	lea	ecx, DWORD PTR $T6[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 2233 : 	btnLogo.Create(TEXT(""), RT, hwndMain, ID_LOGO, strButtonPath.Array());

	push	4
	lea	ecx, DWORD PTR _strButtonPath$[ebp]
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	push	10027					; 0000272bH
	mov	ecx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	ecx
	lea	edx, DWORD PTR _RT$[ebp]
	push	edx
	push	OFFSET $SG4294800386
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 252				; 000000fcH
	call	?Create@COBSButton@@QAEHPB_WABUtagRECT@@PAUHWND__@@I0H@Z ; COBSButton::Create

; 2234 : 	btnLogo.EnableButton(TRUE);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 252				; 000000fcH
	call	?EnableButton@COBSButton@@QAEX_N@Z	; COBSButton::EnableButton

; 2235 : 	////--------------------------------------------------------------------
; 2236 : 	//close  button
; 2237 : 	const int close_button_offset_left = 776;

	mov	DWORD PTR _close_button_offset_left$[ebp], 776 ; 00000308H

; 2238 : 	const int close_button_offset_top = 3;

	mov	DWORD PTR _close_button_offset_top$[ebp], 3

; 2239 : 	const int close_button_width = 24;

	mov	DWORD PTR _close_button_width$[ebp], 24	; 00000018H

; 2240 : 	const int close_button_height = 24;

	mov	DWORD PTR _close_button_height$[ebp], 24 ; 00000018H

; 2241 : 	//RECT RT;
; 2242 : 	RT.left = close_button_offset_left;

	mov	DWORD PTR _RT$[ebp], 776		; 00000308H

; 2243 : 	RT.top = close_button_offset_top;

	mov	DWORD PTR _RT$[ebp+4], 3

; 2244 : 	RT.bottom = close_button_offset_top + close_button_height;

	mov	DWORD PTR _RT$[ebp+12], 27		; 0000001bH

; 2245 : 	RT.right = close_button_offset_left + close_button_width;

	mov	DWORD PTR _RT$[ebp+8], 800		; 00000320H

; 2246 : 	strButtonPath.Clear();

	lea	ecx, DWORD PTR _strButtonPath$[ebp]
	call	DWORD PTR __imp_?Clear@String@@QAEAAV1@XZ

; 2247 : 	strButtonPath << lpAppPath << "//skin//btn_login_close.png";

	push	OFFSET $SG4294800385
	lea	ecx, DWORD PTR $T4[ebp]
	call	DWORD PTR __imp_??0String@@QAE@PBD@Z
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	push	OFFSET ?lpAppPath@@3PA_WA		; lpAppPath
	lea	ecx, DWORD PTR _strButtonPath$[ebp]
	call	DWORD PTR __imp_??6String@@QAEAAV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@ABV0@@Z
	lea	ecx, DWORD PTR $T4[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 2248 : 	btnClose.Create(TEXT(""), RT, hwndMain, ID_BTN_CLOSE, strButtonPath.Array());

	push	4
	lea	ecx, DWORD PTR _strButtonPath$[ebp]
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	push	10028					; 0000272cH
	mov	ecx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	ecx
	lea	edx, DWORD PTR _RT$[ebp]
	push	edx
	push	OFFSET $SG4294800384
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 292				; 00000124H
	call	?Create@COBSButton@@QAEHPB_WABUtagRECT@@PAUHWND__@@I0H@Z ; COBSButton::Create

; 2249 : 	btnClose.EnableButton(TRUE);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 292				; 00000124H
	call	?EnableButton@COBSButton@@QAEX_N@Z	; COBSButton::EnableButton

; 2250 : 	//--------------------------------------------------------------------
; 2251 : 	//min button
; 2252 : 	const int min_button_offset_left = 750;

	mov	DWORD PTR _min_button_offset_left$[ebp], 750 ; 000002eeH

; 2253 : 	const int min_button_offset_top = 3;

	mov	DWORD PTR _min_button_offset_top$[ebp], 3

; 2254 : 	const int min_button_width = 24;

	mov	DWORD PTR _min_button_width$[ebp], 24	; 00000018H

; 2255 : 	const int min_button_height = 24;

	mov	DWORD PTR _min_button_height$[ebp], 24	; 00000018H

; 2256 : 	RT.left = min_button_offset_left;

	mov	DWORD PTR _RT$[ebp], 750		; 000002eeH

; 2257 : 	RT.top = min_button_offset_top;

	mov	DWORD PTR _RT$[ebp+4], 3

; 2258 : 	RT.bottom = min_button_offset_top + min_button_height;

	mov	DWORD PTR _RT$[ebp+12], 27		; 0000001bH

; 2259 : 	RT.right = min_button_offset_left + min_button_width;

	mov	DWORD PTR _RT$[ebp+8], 774		; 00000306H

; 2260 : 	strButtonPath.Clear();

	lea	ecx, DWORD PTR _strButtonPath$[ebp]
	call	DWORD PTR __imp_?Clear@String@@QAEAAV1@XZ

; 2261 : 	strButtonPath << lpAppPath << "//skin//btn_login_min.png";

	push	OFFSET $SG4294800383
	lea	ecx, DWORD PTR $T9[ebp]
	call	DWORD PTR __imp_??0String@@QAE@PBD@Z
	lea	eax, DWORD PTR $T9[ebp]
	push	eax
	push	OFFSET ?lpAppPath@@3PA_WA		; lpAppPath
	lea	ecx, DWORD PTR _strButtonPath$[ebp]
	call	DWORD PTR __imp_??6String@@QAEAAV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@ABV0@@Z
	lea	ecx, DWORD PTR $T9[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 2262 : 	btnMin.Create(TEXT(""), RT, hwndMain, ID_BTN_MINSIZE, strButtonPath.Array());

	push	4
	lea	ecx, DWORD PTR _strButtonPath$[ebp]
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	push	10029					; 0000272dH
	mov	ecx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	ecx
	lea	edx, DWORD PTR _RT$[ebp]
	push	edx
	push	OFFSET $SG4294800382
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 332				; 0000014cH
	call	?Create@COBSButton@@QAEHPB_WABUtagRECT@@PAUHWND__@@I0H@Z ; COBSButton::Create

; 2263 : 	btnMin.EnableButton(TRUE);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 332				; 0000014cH
	call	?EnableButton@COBSButton@@QAEX_N@Z	; COBSButton::EnableButton

; 2264 : 	//--------------------------------------------------------------------
; 2265 : 	//btnPlugin
; 2266 : 	const int plugin_button_offset_left = 760;

	mov	DWORD PTR _plugin_button_offset_left$[ebp], 760 ; 000002f8H

; 2267 : 	const int plugin_button_offset_top = 40;

	mov	DWORD PTR _plugin_button_offset_top$[ebp], 40 ; 00000028H

; 2268 : 	const int plugin_button_width = 38;

	mov	DWORD PTR _plugin_button_width$[ebp], 38 ; 00000026H

; 2269 : 	const int plugin_button_height = 38;

	mov	DWORD PTR _plugin_button_height$[ebp], 38 ; 00000026H

; 2270 : 	RT.left = plugin_button_offset_left;

	mov	DWORD PTR _RT$[ebp], 760		; 000002f8H

; 2271 : 	RT.top = plugin_button_offset_top;

	mov	DWORD PTR _RT$[ebp+4], 40		; 00000028H

; 2272 : 	RT.bottom = plugin_button_offset_top + plugin_button_height;

	mov	DWORD PTR _RT$[ebp+12], 78		; 0000004eH

; 2273 : 	RT.right = plugin_button_offset_left + plugin_button_width;

	mov	DWORD PTR _RT$[ebp+8], 798		; 0000031eH

; 2274 : 	strButtonPath.Clear();

	lea	ecx, DWORD PTR _strButtonPath$[ebp]
	call	DWORD PTR __imp_?Clear@String@@QAEAAV1@XZ

; 2275 : 	strButtonPath << lpAppPath << "//skin//btn_main_plugin.png";

	push	OFFSET $SG4294800381
	lea	ecx, DWORD PTR $T2[ebp]
	call	DWORD PTR __imp_??0String@@QAE@PBD@Z
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	push	OFFSET ?lpAppPath@@3PA_WA		; lpAppPath
	lea	ecx, DWORD PTR _strButtonPath$[ebp]
	call	DWORD PTR __imp_??6String@@QAEAAV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@ABV0@@Z
	lea	ecx, DWORD PTR $T2[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 2276 : 	btnPlugin.Create(TEXT(""), RT, hwndMain, ID_PLUGINS, strButtonPath.Array());

	push	4
	lea	ecx, DWORD PTR _strButtonPath$[ebp]
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	push	5017					; 00001399H
	mov	ecx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	ecx
	lea	edx, DWORD PTR _RT$[ebp]
	push	edx
	push	OFFSET $SG4294800380
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 372				; 00000174H
	call	?Create@COBSButton@@QAEHPB_WABUtagRECT@@PAUHWND__@@I0H@Z ; COBSButton::Create

; 2277 : 	btnPlugin.EnableButton(TRUE);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 372				; 00000174H
	call	?EnableButton@COBSButton@@QAEX_N@Z	; COBSButton::EnableButton

; 2278 : 	//--------------------------------------------------------------------
; 2279 : 	//btnCarama
; 2280 : 	const int carama_button_offset_left = 350;

	mov	DWORD PTR _carama_button_offset_left$[ebp], 350 ; 0000015eH

; 2281 : 	const int carama_button_offset_top = 10;

	mov	DWORD PTR _carama_button_offset_top$[ebp], 10 ; 0000000aH

; 2282 : 	const int carama_button_width = 72;

	mov	DWORD PTR _carama_button_width$[ebp], 72 ; 00000048H

; 2283 : 	const int carama_button_height = 72;

	mov	DWORD PTR _carama_button_height$[ebp], 72 ; 00000048H

; 2284 : 	RT.left = carama_button_offset_left;

	mov	DWORD PTR _RT$[ebp], 350		; 0000015eH

; 2285 : 	RT.top = carama_button_offset_top;

	mov	DWORD PTR _RT$[ebp+4], 10		; 0000000aH

; 2286 : 	RT.bottom = carama_button_offset_top + carama_button_height;

	mov	DWORD PTR _RT$[ebp+12], 82		; 00000052H

; 2287 : 	RT.right = carama_button_offset_left + carama_button_width;

	mov	DWORD PTR _RT$[ebp+8], 422		; 000001a6H

; 2288 : 	strButtonPath.Clear();

	lea	ecx, DWORD PTR _strButtonPath$[ebp]
	call	DWORD PTR __imp_?Clear@String@@QAEAAV1@XZ

; 2289 : 	strButtonPath << lpAppPath << "//skin//btn_main_video.png";

	push	OFFSET $SG4294800379
	lea	ecx, DWORD PTR $T8[ebp]
	call	DWORD PTR __imp_??0String@@QAE@PBD@Z
	lea	eax, DWORD PTR $T8[ebp]
	push	eax
	push	OFFSET ?lpAppPath@@3PA_WA		; lpAppPath
	lea	ecx, DWORD PTR _strButtonPath$[ebp]
	call	DWORD PTR __imp_??6String@@QAEAAV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@ABV0@@Z
	lea	ecx, DWORD PTR $T8[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 2290 : 	btnCarama.Create(TEXT(""), RT, hwndMain, ID_CARAMA, strButtonPath.Array());

	push	4
	lea	ecx, DWORD PTR _strButtonPath$[ebp]
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	push	10030					; 0000272eH
	mov	ecx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	ecx
	lea	edx, DWORD PTR _RT$[ebp]
	push	edx
	push	OFFSET $SG4294800378
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 412				; 0000019cH
	call	?Create@COBSButton@@QAEHPB_WABUtagRECT@@PAUHWND__@@I0H@Z ; COBSButton::Create

; 2291 : 	btnCarama.EnableButton(TRUE);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 412				; 0000019cH
	call	?EnableButton@COBSButton@@QAEX_N@Z	; COBSButton::EnableButton

; 2292 : 	//--------------------------------------------------------------------
; 2293 : 	//btnSetting
; 2294 : 	const int setting_button_offset_left = 250;

	mov	DWORD PTR _setting_button_offset_left$[ebp], 250 ; 000000faH

; 2295 : 	const int setting_button_offset_top = 30;

	mov	DWORD PTR _setting_button_offset_top$[ebp], 30 ; 0000001eH

; 2296 : 	const int setting_button_width = 70;

	mov	DWORD PTR _setting_button_width$[ebp], 70 ; 00000046H

; 2297 : 	const int setting_button_height = 32;

	mov	DWORD PTR _setting_button_height$[ebp], 32 ; 00000020H

; 2298 : 	RT.left = setting_button_offset_left;

	mov	DWORD PTR _RT$[ebp], 250		; 000000faH

; 2299 : 	RT.top = setting_button_offset_top;

	mov	DWORD PTR _RT$[ebp+4], 30		; 0000001eH

; 2300 : 	RT.bottom = setting_button_offset_top + setting_button_height;

	mov	DWORD PTR _RT$[ebp+12], 62		; 0000003eH

; 2301 : 	RT.right = setting_button_offset_left + setting_button_width;

	mov	DWORD PTR _RT$[ebp+8], 320		; 00000140H

; 2302 : 	strButtonPath.Clear();

	lea	ecx, DWORD PTR _strButtonPath$[ebp]
	call	DWORD PTR __imp_?Clear@String@@QAEAAV1@XZ

; 2303 : 	strButtonPath << lpAppPath << "//skin//btn_main_sysSet.png";

	push	OFFSET $SG4294800377
	lea	ecx, DWORD PTR $T7[ebp]
	call	DWORD PTR __imp_??0String@@QAE@PBD@Z
	lea	eax, DWORD PTR $T7[ebp]
	push	eax
	push	OFFSET ?lpAppPath@@3PA_WA		; lpAppPath
	lea	ecx, DWORD PTR _strButtonPath$[ebp]
	call	DWORD PTR __imp_??6String@@QAEAAV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@ABV0@@Z
	lea	ecx, DWORD PTR $T7[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 2304 : 	btnSetting.Create(TEXT(""), RT, hwndMain, ID_SETTINGS, strButtonPath.Array());

	push	4
	lea	ecx, DWORD PTR _strButtonPath$[ebp]
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	push	5000					; 00001388H
	mov	ecx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	ecx
	lea	edx, DWORD PTR _RT$[ebp]
	push	edx
	push	OFFSET $SG4294800376
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 452				; 000001c4H
	call	?Create@COBSButton@@QAEHPB_WABUtagRECT@@PAUHWND__@@I0H@Z ; COBSButton::Create

; 2305 : 	btnSetting.EnableButton(TRUE);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 452				; 000001c4H
	call	?EnableButton@COBSButton@@QAEX_N@Z	; COBSButton::EnableButton

; 2306 : 	//--------------------------------------------------------------------
; 2307 : 	//btnlive
; 2308 : 	const int live_button_offset_left =400 ;

	mov	DWORD PTR _live_button_offset_left$[ebp], 400 ; 00000190H

; 2309 : 	const int live_button_offset_top = 520;

	mov	DWORD PTR _live_button_offset_top$[ebp], 520 ; 00000208H

; 2310 : 	const int live_button_width = 100;

	mov	DWORD PTR _live_button_width$[ebp], 100	; 00000064H

; 2311 : 	const int live_button_height = 32;

	mov	DWORD PTR _live_button_height$[ebp], 32	; 00000020H

; 2312 : 	RT.left = live_button_offset_left;

	mov	DWORD PTR _RT$[ebp], 400		; 00000190H

; 2313 : 	RT.top = live_button_offset_top;

	mov	DWORD PTR _RT$[ebp+4], 520		; 00000208H

; 2314 : 	RT.bottom = live_button_offset_top + live_button_height;

	mov	DWORD PTR _RT$[ebp+12], 552		; 00000228H

; 2315 : 	RT.right = live_button_offset_left + live_button_width;

	mov	DWORD PTR _RT$[ebp+8], 500		; 000001f4H

; 2316 : 	strButtonPath.Clear();

	lea	ecx, DWORD PTR _strButtonPath$[ebp]
	call	DWORD PTR __imp_?Clear@String@@QAEAAV1@XZ

; 2317 : 	strButtonPath << lpAppPath << "//skin//btn_main_openLive.png";

	push	OFFSET $SG4294800375
	lea	ecx, DWORD PTR $T5[ebp]
	call	DWORD PTR __imp_??0String@@QAE@PBD@Z
	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	push	OFFSET ?lpAppPath@@3PA_WA		; lpAppPath
	lea	ecx, DWORD PTR _strButtonPath$[ebp]
	call	DWORD PTR __imp_??6String@@QAEAAV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@ABV0@@Z
	lea	ecx, DWORD PTR $T5[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 2318 : 	btnPlayLive.Create(Str("MainWindow.StartStream"), RT, hwndMain, ID_STARTSTOP, strButtonPath.Array());

	push	4
	lea	ecx, DWORD PTR _strButtonPath$[ebp]
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	push	5003					; 0000138bH
	mov	ecx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	ecx
	lea	edx, DWORD PTR _RT$[ebp]
	push	edx
	push	OFFSET $SG4294800374
	mov	eax, DWORD PTR __imp_?locale@@3PAVLocaleStringLookup@@A
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR __imp_?LookupString@LocaleStringLookup@@QAEPB_WPB_W@Z
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 492				; 000001ecH
	call	?Create@COBSButton@@QAEHPB_WABUtagRECT@@PAUHWND__@@I0H@Z ; COBSButton::Create

; 2319 : 	btnPlayLive.EnableButton(TRUE);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 492				; 000001ecH
	call	?EnableButton@COBSButton@@QAEX_N@Z	; COBSButton::EnableButton

; 2320 : 	////--------------------------------------------------------------------
; 2321 : 	////btnTest
; 2322 : 	//const int edit_button_offset_left = 150;
; 2323 : 	//const int edit_button_offset_top = 520;
; 2324 : 	//const int edit_button_width = 100;
; 2325 : 	//const int edit_button_height = 32;
; 2326 : 	//RT.left = edit_button_offset_left;
; 2327 : 	//RT.top = edit_button_offset_top;
; 2328 : 	//RT.bottom = edit_button_offset_top + edit_button_height;
; 2329 : 	//RT.right = edit_button_offset_left + edit_button_width;
; 2330 : 	//strButtonPath.Clear();
; 2331 : 	//strButtonPath << lpAppPath << "//skin//btn_bk.png";
; 2332 : 	//btnEdit.Create(TEXT(""), RT, hwndMain, ID_SCENEEDITOR, strButtonPath.Array());
; 2333 : 	//btnEdit.EnableButton(TRUE);
; 2334 : 	//--------------------------------------------------------------------
; 2335 : 	//btnRecord
; 2336 : 	const int record_button_offset_left = 280;

	mov	DWORD PTR _record_button_offset_left$[ebp], 280 ; 00000118H

; 2337 : 	const int record_button_offset_top = 520;

	mov	DWORD PTR _record_button_offset_top$[ebp], 520 ; 00000208H

; 2338 : 	const int record_button_width = 100;

	mov	DWORD PTR _record_button_width$[ebp], 100 ; 00000064H

; 2339 : 	const int record_button_height = 32;

	mov	DWORD PTR _record_button_height$[ebp], 32 ; 00000020H

; 2340 : 	RT.left = record_button_offset_left;

	mov	DWORD PTR _RT$[ebp], 280		; 00000118H

; 2341 : 	RT.top = record_button_offset_top;

	mov	DWORD PTR _RT$[ebp+4], 520		; 00000208H

; 2342 : 	RT.bottom = record_button_offset_top + record_button_height;

	mov	DWORD PTR _RT$[ebp+12], 552		; 00000228H

; 2343 : 	RT.right = record_button_offset_left + record_button_width;

	mov	DWORD PTR _RT$[ebp+8], 380		; 0000017cH

; 2344 : 	strButtonPath.Clear();

	lea	ecx, DWORD PTR _strButtonPath$[ebp]
	call	DWORD PTR __imp_?Clear@String@@QAEAAV1@XZ

; 2345 : 	strButtonPath << lpAppPath << "//skin//btn_bk.png";

	push	OFFSET $SG4294800373
	lea	ecx, DWORD PTR $T3[ebp]
	call	DWORD PTR __imp_??0String@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	push	OFFSET ?lpAppPath@@3PA_WA		; lpAppPath
	lea	ecx, DWORD PTR _strButtonPath$[ebp]
	call	DWORD PTR __imp_??6String@@QAEAAV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@ABV0@@Z
	lea	ecx, DWORD PTR $T3[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 2346 : 	btnRecord.Create(Str("MainWindow.StartRecording"), RT, hwndMain, ID_TOGGLERECORDING, strButtonPath.Array());

	push	4
	lea	ecx, DWORD PTR _strButtonPath$[ebp]
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	push	5002					; 0000138aH
	mov	edx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	edx
	lea	eax, DWORD PTR _RT$[ebp]
	push	eax
	push	OFFSET $SG4294800372
	mov	ecx, DWORD PTR __imp_?locale@@3PAVLocaleStringLookup@@A
	mov	ecx, DWORD PTR [ecx]
	call	DWORD PTR __imp_?LookupString@LocaleStringLookup@@QAEPB_WPB_W@Z
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 532				; 00000214H
	call	?Create@COBSButton@@QAEHPB_WABUtagRECT@@PAUHWND__@@I0H@Z ; COBSButton::Create

; 2347 : 	btnRecord.EnableButton(TRUE);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 532				; 00000214H
	call	?EnableButton@COBSButton@@QAEX_N@Z	; COBSButton::EnableButton

; 2348 : 	//--------------------------------------------------------------------
; 2349 : 	//btnPreview
; 2350 : 	const int preview_button_offset_left = 160;

	mov	DWORD PTR _preview_button_offset_left$[ebp], 160 ; 000000a0H

; 2351 : 	const int  preview_button_offset_top = 520;

	mov	DWORD PTR _preview_button_offset_top$[ebp], 520 ; 00000208H

; 2352 : 	const int  preview_button_width = 100;

	mov	DWORD PTR _preview_button_width$[ebp], 100 ; 00000064H

; 2353 : 	const int  preview_button_height = 32;

	mov	DWORD PTR _preview_button_height$[ebp], 32 ; 00000020H

; 2354 : 	RT.left = preview_button_offset_left;

	mov	DWORD PTR _RT$[ebp], 160		; 000000a0H

; 2355 : 	RT.top = preview_button_offset_top;

	mov	DWORD PTR _RT$[ebp+4], 520		; 00000208H

; 2356 : 	RT.bottom = preview_button_offset_top + preview_button_height;

	mov	DWORD PTR _RT$[ebp+12], 552		; 00000228H

; 2357 : 	RT.right = preview_button_offset_left + preview_button_width;

	mov	DWORD PTR _RT$[ebp+8], 260		; 00000104H

; 2358 : 	strButtonPath.Clear();

	lea	ecx, DWORD PTR _strButtonPath$[ebp]
	call	DWORD PTR __imp_?Clear@String@@QAEAAV1@XZ

; 2359 : 	strButtonPath << lpAppPath << "//skin//btn_bk.png";

	push	OFFSET $SG4294800371
	lea	ecx, DWORD PTR $T1[ebp]
	call	DWORD PTR __imp_??0String@@QAE@PBD@Z
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	push	OFFSET ?lpAppPath@@3PA_WA		; lpAppPath
	lea	ecx, DWORD PTR _strButtonPath$[ebp]
	call	DWORD PTR __imp_??6String@@QAEAAV0@PB_W@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6String@@QAEAAV0@ABV0@@Z
	lea	ecx, DWORD PTR $T1[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ

; 2360 : 	btnPreView.Create(Str("MainWindow.TestStream"), RT, hwndMain, ID_TESTSTREAM, strButtonPath.Array());

	push	4
	lea	ecx, DWORD PTR _strButtonPath$[ebp]
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	push	5015					; 00001397H
	mov	eax, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	eax
	lea	ecx, DWORD PTR _RT$[ebp]
	push	ecx
	push	OFFSET $SG4294800370
	mov	edx, DWORD PTR __imp_?locale@@3PAVLocaleStringLookup@@A
	mov	ecx, DWORD PTR [edx]
	call	DWORD PTR __imp_?LookupString@LocaleStringLookup@@QAEPB_WPB_W@Z
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 572				; 0000023cH
	call	?Create@COBSButton@@QAEHPB_WABUtagRECT@@PAUHWND__@@I0H@Z ; COBSButton::Create

; 2361 : 	btnPreView.EnableButton(TRUE);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 572				; 0000023cH
	call	?EnableButton@COBSButton@@QAEX_N@Z	; COBSButton::EnableButton

; 2362 : 	//--------------------------------------------------------------------
; 2363 : 	//btnStop
; 2364 : 	//const int  stop_button_offset_left = 530;
; 2365 : 	//const int  stop_button_offset_top = 520;
; 2366 : 	//const int  stop_button_width = 100;
; 2367 : 	//const int  stop_button_height = 32;
; 2368 : 	//RT.left = stop_button_offset_left;
; 2369 : 	//RT.top = stop_button_offset_top;
; 2370 : 	//RT.bottom = stop_button_offset_top + stop_button_height;
; 2371 : 	//RT.right = stop_button_offset_left + stop_button_width;
; 2372 : 	//strButtonPath.Clear();
; 2373 : 	//strButtonPath << lpAppPath << "//skin//btn_bk.png";
; 2374 : 	//btnStop.Create(TEXT(""), RT, hwndMain, ID_STOP, strButtonPath.Array());
; 2375 : 	//btnStop.EnableButton(TRUE);
; 2376 : 
; 2377 : 	ShowWindow(hwndMain, SW_SHOW);

	push	5
	mov	eax, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	eax
	call	DWORD PTR __imp__ShowWindow@8

; 2378 : }

	lea	ecx, DWORD PTR _strButtonPath$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?InitLayOut@OBS@@AAEXXZ ENDP				; OBS::InitLayOut
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\source\obs.cpp
;	COMDAT ?AddVideoCaptureDevice@OBS@@QAEXXZ
_TEXT	SEGMENT
__macro_lvi$1 = -172					; size = 60
__macro_lvi$2 = -112					; size = 60
$T3 = -52						; size = 8
$T4 = -44						; size = 4
_numSources$5 = -40					; size = 4
_curSceneElement$6 = -36				; size = 4
_strName$ = -32						; size = 8
_newSourceElement$7 = -24				; size = 4
_sources$8 = -20					; size = 4
_hwndSources$9 = -16					; size = 4
_i$ = -12						; size = 4
_bFind$ = -5						; size = 1
_this$ = -4						; size = 4
?AddVideoCaptureDevice@OBS@@QAEXXZ PROC			; OBS::AddVideoCaptureDevice, COMDAT
; _this$ = ecx

; 2380 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 172				; 000000acH
	mov	DWORD PTR _this$[ebp], ecx

; 2381 : 	String strName;

	lea	ecx, DWORD PTR _strName$[ebp]
	call	DWORD PTR __imp_??0String@@QAE@XZ

; 2382 : 	int i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 2383 : 	bool bFind = false;

	mov	BYTE PTR _bFind$[ebp], 0

; 2384 : 	for (i = 0; i < imageSourceClasses.Num(); i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN11@AddVideoCa
$LN10@AddVideoCa:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN11@AddVideoCa:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1368				; 00000558H
	call	?Num@?$List@UClassInfo@@@@QBEIXZ	; List<ClassInfo>::Num
	cmp	DWORD PTR _i$[ebp], eax
	jae	SHORT $LN9@AddVideoCa

; 2385 : 	{
; 2386 : 		if (imageSourceClasses[i].strClass == String("DeviceCapture"))

	push	OFFSET $SG4294800369
	lea	ecx, DWORD PTR $T3[ebp]
	call	DWORD PTR __imp_??0String@@QAE@PBD@Z
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1368				; 00000558H
	call	??A?$List@UClassInfo@@@@QAEAAUClassInfo@@I@Z ; List<ClassInfo>::operator[]
	mov	ecx, eax
	call	DWORD PTR __imp_??8String@@QBEHABV0@@Z
	mov	DWORD PTR $T4[ebp], eax
	lea	ecx, DWORD PTR $T3[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	cmp	DWORD PTR $T4[ebp], 0
	je	SHORT $LN8@AddVideoCa

; 2387 : 		{
; 2388 : 			strName =imageSourceClasses[i].strName;

	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1368				; 00000558H
	call	??A?$List@UClassInfo@@@@QAEAAUClassInfo@@I@Z ; List<ClassInfo>::operator[]
	add	eax, 8
	push	eax
	lea	ecx, DWORD PTR _strName$[ebp]
	call	DWORD PTR __imp_??4String@@QAEAAV0@ABV0@@Z

; 2389 : 			bFind = true;

	mov	BYTE PTR _bFind$[ebp], 1

; 2390 : 			break;

	jmp	SHORT $LN9@AddVideoCa
$LN8@AddVideoCa:

; 2391 : 		}
; 2392 : 
; 2393 : 	}

	jmp	SHORT $LN10@AddVideoCa
$LN9@AddVideoCa:

; 2394 : 	if (!bFind)

	movzx	eax, BYTE PTR _bFind$[ebp]
	test	eax, eax
	jne	SHORT $LN7@AddVideoCa

; 2395 : 	{
; 2396 : 		//no pluin
; 2397 : 		return;

	lea	ecx, DWORD PTR _strName$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	jmp	$LN12@AddVideoCa
$LN7@AddVideoCa:

; 2398 : 	}
; 2399 : 	GetNewSourceName(strName);

	lea	ecx, DWORD PTR _strName$[ebp]
	push	ecx
	call	?GetNewSourceName@OBS@@CAXAAVString@@@Z	; OBS::GetNewSourceName
	add	esp, 4

; 2400 : 	if (OBSDialogBox(hinstMain, MAKEINTRESOURCE(IDD_ENTERNAME), hwndMain, OBS::EnterSourceNameDialogProc, (LPARAM)&strName) == IDOK)

	lea	edx, DWORD PTR _strName$[ebp]
	push	edx
	push	OFFSET ?EnterSourceNameDialogProc@OBS@@CGHPAUHWND__@@IIJ@Z ; OBS::EnterSourceNameDialogProc
	mov	eax, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	eax
	push	122					; 0000007aH
	mov	ecx, DWORD PTR ?hinstMain@@3PAUHINSTANCE__@@A ; hinstMain
	push	ecx
	call	DWORD PTR __imp_?OBSDialogBox@@YAHPAUHINSTANCE__@@PB_WPAUHWND__@@P6GH2IIJ@ZJ@Z
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	$LN6@AddVideoCa

; 2401 : 	{
; 2402 : 		HWND hwndSources = GetDlgItem(hwndMain, ID_SOURCES);

	push	5013					; 00001395H
	mov	edx, DWORD PTR ?hwndMain@@3PAUHWND__@@A	; hwndMain
	push	edx
	call	DWORD PTR __imp__GetDlgItem@8
	mov	DWORD PTR _hwndSources$9[ebp], eax

; 2403 : 		XElement *curSceneElement =sceneElement;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+212]
	mov	DWORD PTR _curSceneElement$6[ebp], ecx

; 2404 : 		XElement *sources = curSceneElement->GetElement(TEXT("sources"));

	push	OFFSET $SG4294800368
	mov	ecx, DWORD PTR _curSceneElement$6[ebp]
	call	DWORD PTR __imp_?GetElement@XElement@@QBEPAV1@PB_W@Z
	mov	DWORD PTR _sources$8[ebp], eax

; 2405 : 		if (!sources)

	cmp	DWORD PTR _sources$8[ebp], 0
	jne	SHORT $LN5@AddVideoCa

; 2406 : 			sources = curSceneElement->CreateElement(TEXT("sources"));

	push	OFFSET $SG4294800367
	mov	ecx, DWORD PTR _curSceneElement$6[ebp]
	call	DWORD PTR __imp_?CreateElement@XElement@@QAEPAV1@PB_W@Z
	mov	DWORD PTR _sources$8[ebp], eax
$LN5@AddVideoCa:

; 2407 : 		XElement *newSourceElement = sources->InsertElement(0, strName);

	lea	ecx, DWORD PTR _strName$[ebp]
	call	DWORD PTR __imp_??BString@@QBEPA_WXZ
	push	eax
	push	0
	mov	ecx, DWORD PTR _sources$8[ebp]
	call	DWORD PTR __imp_?InsertElement@XElement@@QAEPAV1@IPB_W@Z
	mov	DWORD PTR _newSourceElement$7[ebp], eax

; 2408 : 		newSourceElement->SetInt(TEXT("render"), 1);

	push	1
	push	OFFSET $SG4294800366
	mov	ecx, DWORD PTR _newSourceElement$7[ebp]
	call	DWORD PTR __imp_?SetInt@XElement@@QAEXPB_WH@Z

; 2409 : 
; 2410 : 		newSourceElement->SetString(TEXT("class"), TEXT("DeviceCapture"));

	push	OFFSET $SG4294800365
	push	OFFSET $SG4294800364
	mov	ecx, DWORD PTR _newSourceElement$7[ebp]
	call	DWORD PTR __imp_?SetString@XElement@@QAEXPB_W0@Z

; 2411 : 		if (imageSourceClasses[i].configProc)

	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1368				; 00000558H
	call	??A?$List@UClassInfo@@@@QAEAAUClassInfo@@I@Z ; List<ClassInfo>::operator[]
	cmp	DWORD PTR [eax+20], 0
	je	SHORT $LN4@AddVideoCa

; 2412 : 		{
; 2413 : 			if (!imageSourceClasses[i].configProc(newSourceElement, true))

	push	1
	mov	eax, DWORD PTR _newSourceElement$7[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1368				; 00000558H
	call	??A?$List@UClassInfo@@@@QAEAAUClassInfo@@I@Z ; List<ClassInfo>::operator[]
	mov	edx, DWORD PTR [eax+20]
	call	edx
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN4@AddVideoCa

; 2414 : 			{
; 2415 : 				sources->RemoveElement(newSourceElement);

	mov	ecx, DWORD PTR _newSourceElement$7[ebp]
	push	ecx
	mov	ecx, DWORD PTR _sources$8[ebp]
	call	DWORD PTR __imp_?RemoveElement@XElement@@QAEXPAV1@@Z

; 2416 : 				EnableSceneSwitching(true);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EnableSceneSwitching@OBS@@QAEX_N@Z	; OBS::EnableSceneSwitching

; 2417 : 				return;

	lea	ecx, DWORD PTR _strName$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
	jmp	$LN12@AddVideoCa
$LN4@AddVideoCa:

; 2418 : 			}
; 2419 : 		}
; 2420 : 
; 2421 : 
; 2422 : 		if (sceneElement == curSceneElement)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+212]
	cmp	eax, DWORD PTR _curSceneElement$6[ebp]
	jne	$LN6@AddVideoCa

; 2423 : 		{
; 2424 : 			if (bRunning)

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+622]
	test	edx, edx
	je	SHORT $LN1@AddVideoCa

; 2425 : 			{
; 2426 : 				EnterSceneMutex();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?EnterSceneMutex@OBS@@QAEXXZ		; OBS::EnterSceneMutex

; 2427 : 				scene->InsertImageSource(0, newSourceElement);

	mov	eax, DWORD PTR _newSourceElement$7[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+144]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+144]
	mov	eax, DWORD PTR [edx+4]
	call	eax

; 2428 : 				LeaveSceneMutex();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?LeaveSceneMutex@OBS@@QAEXXZ		; OBS::LeaveSceneMutex
$LN1@AddVideoCa:

; 2429 : 			}
; 2430 : 
; 2431 : 			UINT numSources = sources->NumElements();

	push	0
	mov	ecx, DWORD PTR _sources$8[ebp]
	call	DWORD PTR __imp_?NumElements@XElement@@QAEKPB_W@Z
	mov	DWORD PTR _numSources$5[ebp], eax

; 2432 : 
; 2433 : 			// clear selection/focus for all items before adding the new item
; 2434 : 			ListView_SetItemState(hwndSources, -1, 0, LVIS_SELECTED | LVIS_FOCUSED);

	mov	DWORD PTR __macro_lvi$2[ebp+16], 3
	mov	DWORD PTR __macro_lvi$2[ebp+12], 0
	lea	ecx, DWORD PTR __macro_lvi$2[ebp]
	push	ecx
	push	-1
	push	4139					; 0000102bH
	mov	edx, DWORD PTR _hwndSources$9[ebp]
	push	edx
	call	DWORD PTR __imp__SendMessageW@16

; 2435 : 			ListView_SetItemCount(hwndSources, numSources);

	push	0
	mov	eax, DWORD PTR _numSources$5[ebp]
	push	eax
	push	4143					; 0000102fH
	mov	ecx, DWORD PTR _hwndSources$9[ebp]
	push	ecx
	call	DWORD PTR __imp__SendMessageW@16

; 2436 : 
; 2437 : 			bChangingSources = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+705], 1

; 2438 : 			InsertSourceItem(0, (LPWSTR)strName.Array(), true);

	push	1
	lea	ecx, DWORD PTR _strName$[ebp]
	call	DWORD PTR __imp_?Array@String@@QBEPA_WXZ
	push	eax
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	call	eax

; 2439 : 			bChangingSources = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+705], 0

; 2440 : 
; 2441 : 			SetFocus(hwndSources);

	mov	edx, DWORD PTR _hwndSources$9[ebp]
	push	edx
	call	DWORD PTR __imp__SetFocus@4

; 2442 : 
; 2443 : 			// make sure the added item is visible/selected/focused and selection mark moved to it.
; 2444 : 			ListView_EnsureVisible(hwndSources, 0, false);

	push	0
	push	0
	push	4115					; 00001013H
	mov	eax, DWORD PTR _hwndSources$9[ebp]
	push	eax
	call	DWORD PTR __imp__SendMessageW@16

; 2445 : 			ListView_SetItemState(hwndSources, 0, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);

	mov	DWORD PTR __macro_lvi$1[ebp+16], 3
	mov	DWORD PTR __macro_lvi$1[ebp+12], 3
	lea	ecx, DWORD PTR __macro_lvi$1[ebp]
	push	ecx
	push	0
	push	4139					; 0000102bH
	mov	edx, DWORD PTR _hwndSources$9[ebp]
	push	edx
	call	DWORD PTR __imp__SendMessageW@16

; 2446 : 			ListView_SetSelectionMark(hwndSources, 0);

	push	0
	push	0
	push	4163					; 00001043H
	mov	eax, DWORD PTR _hwndSources$9[ebp]
	push	eax
	call	DWORD PTR __imp__SendMessageW@16

; 2447 : 
; 2448 : 			ReportSourcesAddedOrRemoved();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+136]
	call	eax
$LN6@AddVideoCa:

; 2449 : 		}
; 2450 : 	}
; 2451 : }

	lea	ecx, DWORD PTR _strName$[ebp]
	call	DWORD PTR __imp_??1String@@QAE@XZ
$LN12@AddVideoCa:
	mov	esp, ebp
	pop	ebp
	ret	0
?AddVideoCaptureDevice@OBS@@QAEXXZ ENDP			; OBS::AddVideoCaptureDevice
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??0?$List@UAudioDeviceInfo@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$List@UAudioDeviceInfo@@@@QAE@XZ PROC		; List<AudioDeviceInfo>::List<AudioDeviceInfo>, COMDAT
; _this$ = ecx

; 35   :     inline List() : array(NULL), num(0) {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$List@UAudioDeviceInfo@@@@QAE@XZ ENDP		; List<AudioDeviceInfo>::List<AudioDeviceInfo>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??1?$List@UAudioDeviceInfo@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$List@UAudioDeviceInfo@@@@QAE@XZ PROC		; List<AudioDeviceInfo>::~List<AudioDeviceInfo>, COMDAT
; _this$ = ecx

; 37   :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 38   :         Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$List@UAudioDeviceInfo@@@@QAEXXZ ; List<AudioDeviceInfo>::Clear

; 39   :     }

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$List@UAudioDeviceInfo@@@@QAE@XZ ENDP		; List<AudioDeviceInfo>::~List<AudioDeviceInfo>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Num@?$List@UAudioDeviceInfo@@@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Num@?$List@UAudioDeviceInfo@@@@QBEIXZ PROC		; List<AudioDeviceInfo>::Num, COMDAT
; _this$ = ecx

; 42   :     inline unsigned int Num() const     {return num;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	esp, ebp
	pop	ebp
	ret	0
?Num@?$List@UAudioDeviceInfo@@@@QBEIXZ ENDP		; List<AudioDeviceInfo>::Num
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??A?$List@UAudioDeviceInfo@@@@QAEAAUAudioDeviceInfo@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
??A?$List@UAudioDeviceInfo@@@@QAEAAUAudioDeviceInfo@@I@Z PROC ; List<AudioDeviceInfo>::operator[], COMDAT
; _this$ = ecx

; 379  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 380  :         assert(index < num);
; 381  :         if(index >= num) {DumpError(TEXT("Out of range!  List<%S>::operator[](%d)"), typeid(T).name(), index); return array[0];}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN1@operator
	mov	edx, DWORD PTR _index$[ebp]
	push	edx
	push	OFFSET ?__type_info_root_node@@3U__type_info_node@@A ; __type_info_root_node
	mov	ecx, OFFSET ??_R0?AUAudioDeviceInfo@@@8
	call	?name@type_info@@QBEPBDPAU__type_info_node@@@Z ; type_info::name
	push	eax
	push	OFFSET ??_C@_1FA@KCLJOBNL@?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CB?$AA?5?$AA?5?$AAL?$AAi?$AAs?$AAt?$AA?$DM?$AA?$CF?$AAS?$AA?$DO?$AA?3?$AA?3?$AAo?$AAp?$AAe?$AAr?$AAa?$AAt?$AAo@
	call	DWORD PTR __imp_?DumpError@@YAXPB_WZZ
	mov	eax, 16					; 00000010H
	imul	eax, eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN3@operator
$LN1@operator:

; 382  :         return array[index];

	mov	eax, DWORD PTR _index$[ebp]
	shl	eax, 4
	mov	edx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [edx]
$LN3@operator:

; 383  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$List@UAudioDeviceInfo@@@@QAEAAUAudioDeviceInfo@@I@Z ENDP ; List<AudioDeviceInfo>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??A?$List@UAudioDeviceInfo@@@@QBEAAUAudioDeviceInfo@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
??A?$List@UAudioDeviceInfo@@@@QBEAAUAudioDeviceInfo@@I@Z PROC ; List<AudioDeviceInfo>::operator[], COMDAT
; _this$ = ecx

; 386  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 387  :         assert(index < num);
; 388  :         if (index >= num) { DumpError(TEXT("Out of range!  List<%S>::operator[](%d)"), typeid(T).name(), index); return array[0]; }

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN1@operator
	mov	edx, DWORD PTR _index$[ebp]
	push	edx
	push	OFFSET ?__type_info_root_node@@3U__type_info_node@@A ; __type_info_root_node
	mov	ecx, OFFSET ??_R0?AUAudioDeviceInfo@@@8
	call	?name@type_info@@QBEPBDPAU__type_info_node@@@Z ; type_info::name
	push	eax
	push	OFFSET ??_C@_1FA@KCLJOBNL@?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CB?$AA?5?$AA?5?$AAL?$AAi?$AAs?$AAt?$AA?$DM?$AA?$CF?$AAS?$AA?$DO?$AA?3?$AA?3?$AAo?$AAp?$AAe?$AAr?$AAa?$AAt?$AAo@
	call	DWORD PTR __imp_?DumpError@@YAXPB_WZZ
	mov	eax, 16					; 00000010H
	imul	eax, eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN3@operator
$LN1@operator:

; 389  :         return array[index];

	mov	eax, DWORD PTR _index$[ebp]
	shl	eax, 4
	mov	edx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [edx]
$LN3@operator:

; 390  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$List@UAudioDeviceInfo@@@@QBEAAUAudioDeviceInfo@@I@Z ENDP ; List<AudioDeviceInfo>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??0?$List@UMonitorInfo@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$List@UMonitorInfo@@@@QAE@XZ PROC			; List<MonitorInfo>::List<MonitorInfo>, COMDAT
; _this$ = ecx

; 35   :     inline List() : array(NULL), num(0) {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$List@UMonitorInfo@@@@QAE@XZ ENDP			; List<MonitorInfo>::List<MonitorInfo>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??1?$List@UMonitorInfo@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$List@UMonitorInfo@@@@QAE@XZ PROC			; List<MonitorInfo>::~List<MonitorInfo>, COMDAT
; _this$ = ecx

; 37   :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 38   :         Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$List@UMonitorInfo@@@@QAEXXZ	; List<MonitorInfo>::Clear

; 39   :     }

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$List@UMonitorInfo@@@@QAE@XZ ENDP			; List<MonitorInfo>::~List<MonitorInfo>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??6?$List@UMonitorInfo@@@@QAEAAV0@ABUMonitorInfo@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_val$ = 8						; size = 4
??6?$List@UMonitorInfo@@@@QAEAAV0@ABUMonitorInfo@@@Z PROC ; List<MonitorInfo>::operator<<, COMDAT
; _this$ = ecx

; 366  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 367  :         Add(val);

	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Add@?$List@UMonitorInfo@@@@QAEIABUMonitorInfo@@@Z ; List<MonitorInfo>::Add

; 368  :         return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 369  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
??6?$List@UMonitorInfo@@@@QAEAAV0@ABUMonitorInfo@@@Z ENDP ; List<MonitorInfo>::operator<<
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ??0?$function@$$A6AXXZ@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$function@$$A6AXXZ@std@@QAE@XZ PROC			; std::function<void __cdecl(void)>::function<void __cdecl(void)>, COMDAT
; _this$ = ecx

; 556  : 	function() _NOEXCEPT

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Func_class@X$$$V@std@@QAE@XZ	; std::_Func_class<void>::_Func_class<void>

; 557  : 		{	// construct empty function wrapper
; 558  : 		this->_Reset();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Reset@?$_Func_class@X$$$V@std@@IAEXXZ	; std::_Func_class<void>::_Reset

; 559  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$function@$$A6AXXZ@std@@QAE@XZ ENDP			; std::function<void __cdecl(void)>::function<void __cdecl(void)>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ??1?$function@$$A6AXXZ@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$function@$$A6AXXZ@std@@QAE@XZ PROC			; std::function<void __cdecl(void)>::~function<void __cdecl(void)>, COMDAT
; _this$ = ecx

; 628  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 629  : 		this->_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$_Func_class@X$$$V@std@@IAEXXZ	; std::_Func_class<void>::_Tidy

; 630  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Func_class@X$$$V@std@@QAE@XZ	; std::_Func_class<void>::~_Func_class<void>
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$function@$$A6AXXZ@std@@QAE@XZ ENDP			; std::function<void __cdecl(void)>::~function<void __cdecl(void)>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\memory
;	COMDAT ??0?$unique_ptr@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$unique_ptr@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@@std@@QAE@XZ PROC ; std::unique_ptr<NetworkStream,std::default_delete<NetworkStream> >::unique_ptr<NetworkStream,std::default_delete<NetworkStream> >, COMDAT
; _this$ = ecx

; 1345 : 		{	// default construct

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Unique_ptr_base@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@$00@std@@QAE@PAVNetworkStream@@@Z ; std::_Unique_ptr_base<NetworkStream,std::default_delete<NetworkStream>,1>::_Unique_ptr_base<NetworkStream,std::default_delete<NetworkStream>,1>

; 1346 : 		static_assert(!is_pointer<_Dx>::value,
; 1347 : 			"unique_ptr constructed with null deleter pointer");
; 1348 : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$unique_ptr@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@@std@@QAE@XZ ENDP ; std::unique_ptr<NetworkStream,std::default_delete<NetworkStream> >::unique_ptr<NetworkStream,std::default_delete<NetworkStream> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\memory
;	COMDAT ??1?$unique_ptr@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$unique_ptr@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@@std@@QAE@XZ PROC ; std::unique_ptr<NetworkStream,std::default_delete<NetworkStream> >::~unique_ptr<NetworkStream,std::default_delete<NetworkStream> >, COMDAT
; _this$ = ecx

; 1446 : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1447 : 		if (this->_Myptr != pointer())

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@unique_ptr

; 1448 : 			this->get_deleter()(this->_Myptr);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?get_deleter@?$_Unique_ptr_base@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@$00@std@@QAEAAU?$default_delete@VNetworkStream@@@2@XZ ; std::_Unique_ptr_base<NetworkStream,std::default_delete<NetworkStream>,1>::get_deleter
	mov	ecx, eax
	call	??R?$default_delete@VNetworkStream@@@std@@QBEXPAVNetworkStream@@@Z ; std::default_delete<NetworkStream>::operator()
$LN2@unique_ptr:

; 1449 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$unique_ptr@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@@std@@QAE@XZ ENDP ; std::unique_ptr<NetworkStream,std::default_delete<NetworkStream> >::~unique_ptr<NetworkStream,std::default_delete<NetworkStream> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\memory
;	COMDAT ?reset@?$unique_ptr@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@@std@@QAEXPAVNetworkStream@@@Z
_TEXT	SEGMENT
__Old$ = -8						; size = 4
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?reset@?$unique_ptr@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@@std@@QAEXPAVNetworkStream@@@Z PROC ; std::unique_ptr<NetworkStream,std::default_delete<NetworkStream> >::reset, COMDAT
; _this$ = ecx

; 1479 : 		{	// establish new pointer

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1480 : 		pointer _Old = this->_Myptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Old$[ebp], ecx

; 1481 : 		this->_Myptr = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [edx], eax

; 1482 : 		if (_Old != pointer())

	cmp	DWORD PTR __Old$[ebp], 0
	je	SHORT $LN2@reset

; 1483 : 			this->get_deleter()(_Old);

	mov	ecx, DWORD PTR __Old$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?get_deleter@?$_Unique_ptr_base@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@$00@std@@QAEAAU?$default_delete@VNetworkStream@@@2@XZ ; std::_Unique_ptr_base<NetworkStream,std::default_delete<NetworkStream>,1>::get_deleter
	mov	ecx, eax
	call	??R?$default_delete@VNetworkStream@@@std@@QBEXPAVNetworkStream@@@Z ; std::default_delete<NetworkStream>::operator()
$LN2@reset:

; 1484 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?reset@?$unique_ptr@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@@std@@QAEXPAVNetworkStream@@@Z ENDP ; std::unique_ptr<NetworkStream,std::default_delete<NetworkStream> >::reset
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??0?$List@PAVAudioSource@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$List@PAVAudioSource@@@@QAE@XZ PROC			; List<AudioSource *>::List<AudioSource *>, COMDAT
; _this$ = ecx

; 35   :     inline List() : array(NULL), num(0) {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$List@PAVAudioSource@@@@QAE@XZ ENDP			; List<AudioSource *>::List<AudioSource *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??1?$List@PAVAudioSource@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$List@PAVAudioSource@@@@QAE@XZ PROC			; List<AudioSource *>::~List<AudioSource *>, COMDAT
; _this$ = ecx

; 37   :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 38   :         Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$List@PAVAudioSource@@@@QAEXXZ	; List<AudioSource *>::Clear

; 39   :     }

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$List@PAVAudioSource@@@@QAE@XZ ENDP			; List<AudioSource *>::~List<AudioSource *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??0?$List@USceneHotkeyInfo@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$List@USceneHotkeyInfo@@@@QAE@XZ PROC		; List<SceneHotkeyInfo>::List<SceneHotkeyInfo>, COMDAT
; _this$ = ecx

; 35   :     inline List() : array(NULL), num(0) {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$List@USceneHotkeyInfo@@@@QAE@XZ ENDP		; List<SceneHotkeyInfo>::List<SceneHotkeyInfo>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??1?$List@USceneHotkeyInfo@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$List@USceneHotkeyInfo@@@@QAE@XZ PROC		; List<SceneHotkeyInfo>::~List<SceneHotkeyInfo>, COMDAT
; _this$ = ecx

; 37   :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 38   :         Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$List@USceneHotkeyInfo@@@@QAEXXZ ; List<SceneHotkeyInfo>::Clear

; 39   :     }

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$List@USceneHotkeyInfo@@@@QAE@XZ ENDP		; List<SceneHotkeyInfo>::~List<SceneHotkeyInfo>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??6?$List@USceneHotkeyInfo@@@@QAEAAV0@ABUSceneHotkeyInfo@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_val$ = 8						; size = 4
??6?$List@USceneHotkeyInfo@@@@QAEAAV0@ABUSceneHotkeyInfo@@@Z PROC ; List<SceneHotkeyInfo>::operator<<, COMDAT
; _this$ = ecx

; 366  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 367  :         Add(val);

	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Add@?$List@USceneHotkeyInfo@@@@QAEIABUSceneHotkeyInfo@@@Z ; List<SceneHotkeyInfo>::Add

; 368  :         return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 369  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
??6?$List@USceneHotkeyInfo@@@@QAEAAV0@ABUSceneHotkeyInfo@@@Z ENDP ; List<SceneHotkeyInfo>::operator<<
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??0?$List@PAVSettingsPane@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$List@PAVSettingsPane@@@@QAE@XZ PROC		; List<SettingsPane *>::List<SettingsPane *>, COMDAT
; _this$ = ecx

; 35   :     inline List() : array(NULL), num(0) {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$List@PAVSettingsPane@@@@QAE@XZ ENDP		; List<SettingsPane *>::List<SettingsPane *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??1?$List@PAVSettingsPane@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$List@PAVSettingsPane@@@@QAE@XZ PROC		; List<SettingsPane *>::~List<SettingsPane *>, COMDAT
; _this$ = ecx

; 37   :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 38   :         Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$List@PAVSettingsPane@@@@QAEXXZ	; List<SettingsPane *>::Clear

; 39   :     }

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$List@PAVSettingsPane@@@@QAE@XZ ENDP		; List<SettingsPane *>::~List<SettingsPane *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Num@?$List@PAVSettingsPane@@@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Num@?$List@PAVSettingsPane@@@@QBEIXZ PROC		; List<SettingsPane *>::Num, COMDAT
; _this$ = ecx

; 42   :     inline unsigned int Num() const     {return num;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	esp, ebp
	pop	ebp
	ret	0
?Num@?$List@PAVSettingsPane@@@@QBEIXZ ENDP		; List<SettingsPane *>::Num
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??A?$List@PAVSettingsPane@@@@QAEAAPAVSettingsPane@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
??A?$List@PAVSettingsPane@@@@QAEAAPAVSettingsPane@@I@Z PROC ; List<SettingsPane *>::operator[], COMDAT
; _this$ = ecx

; 379  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 380  :         assert(index < num);
; 381  :         if(index >= num) {DumpError(TEXT("Out of range!  List<%S>::operator[](%d)"), typeid(T).name(), index); return array[0];}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN1@operator
	mov	edx, DWORD PTR _index$[ebp]
	push	edx
	push	OFFSET ?__type_info_root_node@@3U__type_info_node@@A ; __type_info_root_node
	mov	ecx, OFFSET ??_R0PAVSettingsPane@@@8
	call	?name@type_info@@QBEPBDPAU__type_info_node@@@Z ; type_info::name
	push	eax
	push	OFFSET ??_C@_1FA@KCLJOBNL@?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CB?$AA?5?$AA?5?$AAL?$AAi?$AAs?$AAt?$AA?$DM?$AA?$CF?$AAS?$AA?$DO?$AA?3?$AA?3?$AAo?$AAp?$AAe?$AAr?$AAa?$AAt?$AAo@
	call	DWORD PTR __imp_?DumpError@@YAXPB_WZZ
	mov	eax, 4
	imul	eax, eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN3@operator
$LN1@operator:

; 382  :         return array[index];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _index$[ebp]
	lea	eax, DWORD PTR [eax+ecx*4]
$LN3@operator:

; 383  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$List@PAVSettingsPane@@@@QAEAAPAVSettingsPane@@I@Z ENDP ; List<SettingsPane *>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\map
;	COMDAT ??0?$map@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -2						; size = 1
$T2 = -1						; size = 1
??0?$map@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@QAE@XZ PROC ; std::map<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::map<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >, COMDAT
; _this$ = ecx

; 95   : 		{	// construct empty map from defaults

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@QAE@XZ ; std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >
	push	eax
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@ABV?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >

; 96   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$map@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@QAE@XZ ENDP ; std::map<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::map<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xtree
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::~_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >, COMDAT
; _this$ = ecx

; 1191 : 		{	// destroy tree

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1192 : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::_Tidy

; 1193 : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Tree_comp@$0A@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@QAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::~_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??0?$List@UVideoSegment@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$List@UVideoSegment@@@@QAE@XZ PROC			; List<VideoSegment>::List<VideoSegment>, COMDAT
; _this$ = ecx

; 35   :     inline List() : array(NULL), num(0) {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$List@UVideoSegment@@@@QAE@XZ ENDP			; List<VideoSegment>::List<VideoSegment>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??1?$List@UVideoSegment@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$List@UVideoSegment@@@@QAE@XZ PROC			; List<VideoSegment>::~List<VideoSegment>, COMDAT
; _this$ = ecx

; 37   :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 38   :         Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$List@UVideoSegment@@@@QAEXXZ	; List<VideoSegment>::Clear

; 39   :     }

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$List@UVideoSegment@@@@QAE@XZ ENDP			; List<VideoSegment>::~List<VideoSegment>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??0?$CircularList@_K@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$CircularList@_K@@QAE@XZ PROC			; CircularList<unsigned __int64>::CircularList<unsigned __int64>, COMDAT
; _this$ = ecx

; 784  :     inline CircularList() : startID(0), endID(0), storedNum(0) {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$List@_K@@QAE@XZ			; List<unsigned __int64>::List<unsigned __int64>
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$CircularList@_K@@QAE@XZ ENDP			; CircularList<unsigned __int64>::CircularList<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??0?$List@UFrameAudio@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$List@UFrameAudio@@@@QAE@XZ PROC			; List<FrameAudio>::List<FrameAudio>, COMDAT
; _this$ = ecx

; 35   :     inline List() : array(NULL), num(0) {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$List@UFrameAudio@@@@QAE@XZ ENDP			; List<FrameAudio>::List<FrameAudio>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??1?$List@UFrameAudio@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$List@UFrameAudio@@@@QAE@XZ PROC			; List<FrameAudio>::~List<FrameAudio>, COMDAT
; _this$ = ecx

; 37   :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 38   :         Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$List@UFrameAudio@@@@QAEXXZ	; List<FrameAudio>::Clear

; 39   :     }

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$List@UFrameAudio@@@@QAE@XZ ENDP			; List<FrameAudio>::~List<FrameAudio>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??0?$List@UIconInfo@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$List@UIconInfo@@@@QAE@XZ PROC			; List<IconInfo>::List<IconInfo>, COMDAT
; _this$ = ecx

; 35   :     inline List() : array(NULL), num(0) {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$List@UIconInfo@@@@QAE@XZ ENDP			; List<IconInfo>::List<IconInfo>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??1?$List@UIconInfo@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$List@UIconInfo@@@@QAE@XZ PROC			; List<IconInfo>::~List<IconInfo>, COMDAT
; _this$ = ecx

; 37   :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 38   :         Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$List@UIconInfo@@@@QAEXXZ	; List<IconInfo>::Clear

; 39   :     }

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$List@UIconInfo@@@@QAE@XZ ENDP			; List<IconInfo>::~List<IconInfo>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Num@?$List@UIconInfo@@@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Num@?$List@UIconInfo@@@@QBEIXZ PROC			; List<IconInfo>::Num, COMDAT
; _this$ = ecx

; 42   :     inline unsigned int Num() const     {return num;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	esp, ebp
	pop	ebp
	ret	0
?Num@?$List@UIconInfo@@@@QBEIXZ ENDP			; List<IconInfo>::Num
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Clear@?$List@UIconInfo@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Clear@?$List@UIconInfo@@@@QAEXXZ PROC			; List<IconInfo>::Clear, COMDAT
; _this$ = ecx

; 334  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 335  :         if(array)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@Clear

; 336  :         {
; 337  :             /*if(IsBadWritePtr(array, sizeof(T)*num))
; 338  :                 CrashError(TEXT("what the.."));*/
; 339  :             Free(array);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	?Free@@YAXPAX@Z				; Free
	add	esp, 4

; 340  :             array = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 341  :             num = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
$LN2@Clear:

; 342  :         }
; 343  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?Clear@?$List@UIconInfo@@@@QAEXXZ ENDP			; List<IconInfo>::Clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??6?$List@UIconInfo@@@@QAEAAV0@ABUIconInfo@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_val$ = 8						; size = 4
??6?$List@UIconInfo@@@@QAEAAV0@ABUIconInfo@@@Z PROC	; List<IconInfo>::operator<<, COMDAT
; _this$ = ecx

; 366  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 367  :         Add(val);

	mov	eax, DWORD PTR _val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Add@?$List@UIconInfo@@@@QAEIABUIconInfo@@@Z ; List<IconInfo>::Add

; 368  :         return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 369  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
??6?$List@UIconInfo@@@@QAEAAV0@ABUIconInfo@@@Z ENDP	; List<IconInfo>::operator<<
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??A?$List@UIconInfo@@@@QAEAAUIconInfo@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
??A?$List@UIconInfo@@@@QAEAAUIconInfo@@I@Z PROC		; List<IconInfo>::operator[], COMDAT
; _this$ = ecx

; 379  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 380  :         assert(index < num);
; 381  :         if(index >= num) {DumpError(TEXT("Out of range!  List<%S>::operator[](%d)"), typeid(T).name(), index); return array[0];}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN1@operator
	mov	edx, DWORD PTR _index$[ebp]
	push	edx
	push	OFFSET ?__type_info_root_node@@3U__type_info_node@@A ; __type_info_root_node
	mov	ecx, OFFSET ??_R0?AUIconInfo@@@8
	call	?name@type_info@@QBEPBDPAU__type_info_node@@@Z ; type_info::name
	push	eax
	push	OFFSET ??_C@_1FA@KCLJOBNL@?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CB?$AA?5?$AA?5?$AAL?$AAi?$AAs?$AAt?$AA?$DM?$AA?$CF?$AAS?$AA?$DO?$AA?3?$AA?3?$AAo?$AAp?$AAe?$AAr?$AAa?$AAt?$AAo@
	call	DWORD PTR __imp_?DumpError@@YAXPB_WZZ
	mov	eax, 12					; 0000000cH
	imul	eax, eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN3@operator
$LN1@operator:

; 382  :         return array[index];

	imul	eax, DWORD PTR _index$[ebp], 12
	mov	edx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [edx]
$LN3@operator:

; 383  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$List@UIconInfo@@@@QAEAAUIconInfo@@I@Z ENDP		; List<IconInfo>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??0?$List@UFontInfo@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$List@UFontInfo@@@@QAE@XZ PROC			; List<FontInfo>::List<FontInfo>, COMDAT
; _this$ = ecx

; 35   :     inline List() : array(NULL), num(0) {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$List@UFontInfo@@@@QAE@XZ ENDP			; List<FontInfo>::List<FontInfo>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??1?$List@UFontInfo@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$List@UFontInfo@@@@QAE@XZ PROC			; List<FontInfo>::~List<FontInfo>, COMDAT
; _this$ = ecx

; 37   :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 38   :         Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$List@UFontInfo@@@@QAEXXZ	; List<FontInfo>::Clear

; 39   :     }

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$List@UFontInfo@@@@QAE@XZ ENDP			; List<FontInfo>::~List<FontInfo>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Num@?$List@UFontInfo@@@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Num@?$List@UFontInfo@@@@QBEIXZ PROC			; List<FontInfo>::Num, COMDAT
; _this$ = ecx

; 42   :     inline unsigned int Num() const     {return num;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	esp, ebp
	pop	ebp
	ret	0
?Num@?$List@UFontInfo@@@@QBEIXZ ENDP			; List<FontInfo>::Num
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Clear@?$List@UFontInfo@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Clear@?$List@UFontInfo@@@@QAEXXZ PROC			; List<FontInfo>::Clear, COMDAT
; _this$ = ecx

; 334  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 335  :         if(array)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@Clear

; 336  :         {
; 337  :             /*if(IsBadWritePtr(array, sizeof(T)*num))
; 338  :                 CrashError(TEXT("what the.."));*/
; 339  :             Free(array);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	?Free@@YAXPAX@Z				; Free
	add	esp, 4

; 340  :             array = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 341  :             num = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
$LN2@Clear:

; 342  :         }
; 343  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?Clear@?$List@UFontInfo@@@@QAEXXZ ENDP			; List<FontInfo>::Clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?CreateNew@?$List@UFontInfo@@@@QAEPAUFontInfo@@XZ
_TEXT	SEGMENT
_value$ = -8						; size = 4
_this$ = -4						; size = 4
?CreateNew@?$List@UFontInfo@@@@QAEPAUFontInfo@@XZ PROC	; List<FontInfo>::CreateNew, COMDAT
; _this$ = ecx

; 346  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 347  :         SetSize(num+1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSize@?$List@UFontInfo@@@@QAEHI@Z	; List<FontInfo>::SetSize

; 348  : 
; 349  :         T *value = &array[num-1];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1
	imul	ecx, eax, 20
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx]
	mov	DWORD PTR _value$[ebp], ecx

; 350  : 
; 351  :         return value;

	mov	eax, DWORD PTR _value$[ebp]

; 352  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?CreateNew@?$List@UFontInfo@@@@QAEPAUFontInfo@@XZ ENDP	; List<FontInfo>::CreateNew
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??A?$List@UFontInfo@@@@QAEAAUFontInfo@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
??A?$List@UFontInfo@@@@QAEAAUFontInfo@@I@Z PROC		; List<FontInfo>::operator[], COMDAT
; _this$ = ecx

; 379  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 380  :         assert(index < num);
; 381  :         if(index >= num) {DumpError(TEXT("Out of range!  List<%S>::operator[](%d)"), typeid(T).name(), index); return array[0];}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN1@operator
	mov	edx, DWORD PTR _index$[ebp]
	push	edx
	push	OFFSET ?__type_info_root_node@@3U__type_info_node@@A ; __type_info_root_node
	mov	ecx, OFFSET ??_R0?AUFontInfo@@@8
	call	?name@type_info@@QBEPBDPAU__type_info_node@@@Z ; type_info::name
	push	eax
	push	OFFSET ??_C@_1FA@KCLJOBNL@?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CB?$AA?5?$AA?5?$AAL?$AAi?$AAs?$AAt?$AA?$DM?$AA?$CF?$AAS?$AA?$DO?$AA?3?$AA?3?$AAo?$AAp?$AAe?$AAr?$AAa?$AAt?$AAo@
	call	DWORD PTR __imp_?DumpError@@YAXPB_WZZ
	mov	eax, 20					; 00000014H
	imul	eax, eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN3@operator
$LN1@operator:

; 382  :         return array[index];

	imul	eax, DWORD PTR _index$[ebp], 20
	mov	edx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [edx]
$LN3@operator:

; 383  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$List@UFontInfo@@@@QAEAAUFontInfo@@I@Z ENDP		; List<FontInfo>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??0?$List@UClassInfo@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$List@UClassInfo@@@@QAE@XZ PROC			; List<ClassInfo>::List<ClassInfo>, COMDAT
; _this$ = ecx

; 35   :     inline List() : array(NULL), num(0) {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$List@UClassInfo@@@@QAE@XZ ENDP			; List<ClassInfo>::List<ClassInfo>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??1?$List@UClassInfo@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$List@UClassInfo@@@@QAE@XZ PROC			; List<ClassInfo>::~List<ClassInfo>, COMDAT
; _this$ = ecx

; 37   :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 38   :         Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$List@UClassInfo@@@@QAEXXZ	; List<ClassInfo>::Clear

; 39   :     }

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$List@UClassInfo@@@@QAE@XZ ENDP			; List<ClassInfo>::~List<ClassInfo>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??0?$List@UGlobalSourceInfo@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$List@UGlobalSourceInfo@@@@QAE@XZ PROC		; List<GlobalSourceInfo>::List<GlobalSourceInfo>, COMDAT
; _this$ = ecx

; 35   :     inline List() : array(NULL), num(0) {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$List@UGlobalSourceInfo@@@@QAE@XZ ENDP		; List<GlobalSourceInfo>::List<GlobalSourceInfo>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??1?$List@UGlobalSourceInfo@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$List@UGlobalSourceInfo@@@@QAE@XZ PROC		; List<GlobalSourceInfo>::~List<GlobalSourceInfo>, COMDAT
; _this$ = ecx

; 37   :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 38   :         Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$List@UGlobalSourceInfo@@@@QAEXXZ ; List<GlobalSourceInfo>::Clear

; 39   :     }

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$List@UGlobalSourceInfo@@@@QAE@XZ ENDP		; List<GlobalSourceInfo>::~List<GlobalSourceInfo>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??0?$List@UStreamInfo@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$List@UStreamInfo@@@@QAE@XZ PROC			; List<StreamInfo>::List<StreamInfo>, COMDAT
; _this$ = ecx

; 35   :     inline List() : array(NULL), num(0) {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$List@UStreamInfo@@@@QAE@XZ ENDP			; List<StreamInfo>::List<StreamInfo>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??1?$List@UStreamInfo@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$List@UStreamInfo@@@@QAE@XZ PROC			; List<StreamInfo>::~List<StreamInfo>, COMDAT
; _this$ = ecx

; 37   :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 38   :         Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$List@UStreamInfo@@@@QAEXXZ	; List<StreamInfo>::Clear

; 39   :     }

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$List@UStreamInfo@@@@QAE@XZ ENDP			; List<StreamInfo>::~List<StreamInfo>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??0?$List@UPluginInfo@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$List@UPluginInfo@@@@QAE@XZ PROC			; List<PluginInfo>::List<PluginInfo>, COMDAT
; _this$ = ecx

; 35   :     inline List() : array(NULL), num(0) {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$List@UPluginInfo@@@@QAE@XZ ENDP			; List<PluginInfo>::List<PluginInfo>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??1?$List@UPluginInfo@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$List@UPluginInfo@@@@QAE@XZ PROC			; List<PluginInfo>::~List<PluginInfo>, COMDAT
; _this$ = ecx

; 37   :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 38   :         Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$List@UPluginInfo@@@@QAEXXZ	; List<PluginInfo>::Clear

; 39   :     }

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$List@UPluginInfo@@@@QAE@XZ ENDP			; List<PluginInfo>::~List<PluginInfo>
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?CreateNew@?$List@UPluginInfo@@@@QAEPAUPluginInfo@@XZ
_TEXT	SEGMENT
_value$ = -8						; size = 4
_this$ = -4						; size = 4
?CreateNew@?$List@UPluginInfo@@@@QAEPAUPluginInfo@@XZ PROC ; List<PluginInfo>::CreateNew, COMDAT
; _this$ = ecx

; 346  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 347  :         SetSize(num+1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSize@?$List@UPluginInfo@@@@QAEHI@Z	; List<PluginInfo>::SetSize

; 348  : 
; 349  :         T *value = &array[num-1];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1
	imul	ecx, eax, 96
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx]
	mov	DWORD PTR _value$[ebp], ecx

; 350  : 
; 351  :         return value;

	mov	eax, DWORD PTR _value$[ebp]

; 352  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?CreateNew@?$List@UPluginInfo@@@@QAEPAUPluginInfo@@XZ ENDP ; List<PluginInfo>::CreateNew
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ??A?$List@UPluginInfo@@@@QAEAAUPluginInfo@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
??A?$List@UPluginInfo@@@@QAEAAUPluginInfo@@I@Z PROC	; List<PluginInfo>::operator[], COMDAT
; _this$ = ecx

; 379  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 380  :         assert(index < num);
; 381  :         if(index >= num) {DumpError(TEXT("Out of range!  List<%S>::operator[](%d)"), typeid(T).name(), index); return array[0];}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jb	SHORT $LN1@operator
	mov	edx, DWORD PTR _index$[ebp]
	push	edx
	push	OFFSET ?__type_info_root_node@@3U__type_info_node@@A ; __type_info_root_node
	mov	ecx, OFFSET ??_R0?AUPluginInfo@@@8
	call	?name@type_info@@QBEPBDPAU__type_info_node@@@Z ; type_info::name
	push	eax
	push	OFFSET ??_C@_1FA@KCLJOBNL@?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CB?$AA?5?$AA?5?$AAL?$AAi?$AAs?$AAt?$AA?$DM?$AA?$CF?$AAS?$AA?$DO?$AA?3?$AA?3?$AAo?$AAp?$AAe?$AAr?$AAa?$AAt?$AAo@
	call	DWORD PTR __imp_?DumpError@@YAXPB_WZZ
	mov	eax, 96					; 00000060H
	imul	eax, eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN3@operator
$LN1@operator:

; 382  :         return array[index];

	imul	eax, DWORD PTR _index$[ebp], 96
	mov	edx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [edx]
$LN3@operator:

; 383  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$List@UPluginInfo@@@@QAEAAUPluginInfo@@I@Z ENDP	; List<PluginInfo>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\list
;	COMDAT ??0?$list@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
??0?$list@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAE@XZ PROC ; std::list<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >::list<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >, COMDAT
; _this$ = ecx

; 891  : 		{	// construct empty list

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@QAE@XZ ; std::allocator<std::unique_ptr<void,ThreadTerminator<0> > >::allocator<std::unique_ptr<void,ThreadTerminator<0> > >
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_List_buy@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAE@ABV?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@1@@Z ; std::_List_buy<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >::_List_buy<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >

; 892  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$list@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAE@XZ ENDP ; std::list<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >::list<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\list
;	COMDAT ??1?$list@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$list@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAE@XZ PROC ; std::list<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >::~list<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >, COMDAT
; _this$ = ecx

; 1094 : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1095 : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$list@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAEXXZ ; std::list<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >::_Tidy

; 1096 : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_List_buy@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$list@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAE@XZ ENDP ; std::list<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >::~list<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$_Tree_comp@$0A@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Tree_comp@$0A@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_comp<0,std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::~_Tree_comp<0,std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Tree_buy@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@QAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Tree_comp@$0A@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_comp<0,std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::~_Tree_comp<0,std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$_List_buy@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_List_buy@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAE@XZ PROC ; std::_List_buy<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >::~_List_buy<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_List_alloc@$0A@U?$_List_base_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@@std@@QAE@XZ ; std::_List_alloc<0,std::_List_base_types<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > > >::~_List_alloc<0,std::_List_base_types<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > > >
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_List_buy@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAE@XZ ENDP ; std::_List_buy<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >::~_List_buy<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$_Tree_buy@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Tree_buy@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@QAE@XZ PROC ; std::_Tree_buy<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::~_Tree_buy<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@@std@@QAE@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > > >::~_Tree_alloc<0,std::_Tree_base_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > > >
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Tree_buy@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@QAE@XZ ENDP ; std::_Tree_buy<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::~_Tree_buy<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Add@?$List@UMonitorInfo@@@@QAEIABUMonitorInfo@@@Z
_TEXT	SEGMENT
tv73 = -8						; size = 4
_this$ = -4						; size = 4
_val$ = 8						; size = 4
?Add@?$List@UMonitorInfo@@@@QAEIABUMonitorInfo@@@Z PROC	; List<MonitorInfo>::Add, COMDAT
; _this$ = ecx

; 45   :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 46   :         array = (T*)ReAllocate(array, sizeof(T)*++num);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	DWORD PTR tv73[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR tv73[ebp]
	mov	DWORD PTR [edx+4], eax
	imul	ecx, DWORD PTR tv73[ebp], 24
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 47   :         mcpy(&array[(num-1)], (void*)&val, sizeof(T));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1
	imul	ecx, eax, 24
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, ecx
	mov	ecx, DWORD PTR _val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx
	mov	ecx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], ecx

; 48   :         return num-1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1

; 49   :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?Add@?$List@UMonitorInfo@@@@QAEIABUMonitorInfo@@@Z ENDP	; List<MonitorInfo>::Add
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ??0?$_Func_class@X$$$V@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Func_class@X$$$V@std@@QAE@XZ PROC			; std::_Func_class<void>::_Func_class<void>, COMDAT
; _this$ = ecx

; 308  : 		{	// construct without stored object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 309  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Func_class@X$$$V@std@@QAE@XZ ENDP			; std::_Func_class<void>::_Func_class<void>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ??1?$_Func_class@X$$$V@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Func_class@X$$$V@std@@QAE@XZ PROC			; std::_Func_class<void>::~_Func_class<void>, COMDAT
; _this$ = ecx

; 324  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 325  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$_Func_class@X$$$V@std@@IAEXXZ	; std::_Func_class<void>::_Tidy

; 326  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Func_class@X$$$V@std@@QAE@XZ ENDP			; std::_Func_class<void>::~_Func_class<void>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ?_Reset@?$_Func_class@X$$$V@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Reset@?$_Func_class@X$$$V@std@@IAEXXZ PROC		; std::_Func_class<void>::_Reset, COMDAT
; _this$ = ecx

; 330  : 		{	// remove stored object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 331  : 		_Set(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set@?$_Func_class@X$$$V@std@@AAEXPAV?$_Func_base@X$$$V@2@@Z ; std::_Func_class<void>::_Set

; 332  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Reset@?$_Func_class@X$$$V@std@@IAEXXZ ENDP		; std::_Func_class<void>::_Reset
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ?_Tidy@?$_Func_class@X$$$V@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv77 = -1						; size = 1
?_Tidy@?$_Func_class@X$$$V@std@@IAEXXZ PROC		; std::_Func_class<void>::_Tidy, COMDAT
; _this$ = ecx

; 446  : 		{	// clean up

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 447  : 		if (_Impl != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $LN2@Tidy

; 448  : 			{	// destroy callable object and maybe delete it
; 449  : 			_Impl->_Delete_this(!_Local());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Local@?$_Func_class@X$$$V@std@@ABE_NXZ ; std::_Func_class<void>::_Local
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN4@Tidy
	mov	BYTE PTR tv77[ebp], 1
	jmp	SHORT $LN5@Tidy
$LN4@Tidy:
	mov	BYTE PTR tv77[ebp], 0
$LN5@Tidy:
	movzx	edx, BYTE PTR tv77[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+16]
	mov	edx, DWORD PTR [eax+16]
	call	edx

; 450  : 			_Impl = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0
$LN2@Tidy:

; 451  : 			}
; 452  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$_Func_class@X$$$V@std@@IAEXXZ ENDP		; std::_Func_class<void>::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\memory
;	COMDAT ??R?$default_delete@VNetworkStream@@@std@@QBEXPAVNetworkStream@@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv74 = -12						; size = 4
$T1 = -8						; size = 4
$T2 = -4						; size = 4
__Ptr$ = 8						; size = 4
??R?$default_delete@VNetworkStream@@@std@@QBEXPAVNetworkStream@@@Z PROC ; std::default_delete<NetworkStream>::operator(), COMDAT
; _this$ = ecx

; 1197 : 		{	// delete a pointer

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1198 : 		static_assert(0 < sizeof (_Ty),
; 1199 : 			"can't delete an incomplete type");
; 1200 : 		delete _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR $T2[ebp], ecx
	cmp	DWORD PTR $T2[ebp], 0
	je	SHORT $LN3@operator
	push	1
	mov	edx, DWORD PTR $T2[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR $T2[ebp]
	mov	edx, DWORD PTR [eax]
	call	edx
	mov	DWORD PTR tv74[ebp], eax
	jmp	SHORT $LN1@operator
$LN3@operator:
	mov	DWORD PTR tv74[ebp], 0
$LN1@operator:

; 1201 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??R?$default_delete@VNetworkStream@@@std@@QBEXPAVNetworkStream@@@Z ENDP ; std::default_delete<NetworkStream>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\memory
;	COMDAT ??0?$_Unique_ptr_base@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@$00@std@@QAE@PAVNetworkStream@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??0?$_Unique_ptr_base@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@$00@std@@QAE@PAVNetworkStream@@@Z PROC ; std::_Unique_ptr_base<NetworkStream,std::default_delete<NetworkStream>,1>::_Unique_ptr_base<NetworkStream,std::default_delete<NetworkStream>,1>, COMDAT
; _this$ = ecx

; 1295 : 		{	// construct with pointer and deleter

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$default_delete@VNetworkStream@@@std@@QAE@XZ ; std::default_delete<NetworkStream>::default_delete<NetworkStream>
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [eax], ecx

; 1296 : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Unique_ptr_base@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@$00@std@@QAE@PAVNetworkStream@@@Z ENDP ; std::_Unique_ptr_base<NetworkStream,std::default_delete<NetworkStream>,1>::_Unique_ptr_base<NetworkStream,std::default_delete<NetworkStream>,1>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\memory
;	COMDAT ?get_deleter@?$_Unique_ptr_base@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@$00@std@@QAEAAU?$default_delete@VNetworkStream@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get_deleter@?$_Unique_ptr_base@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@$00@std@@QAEAAU?$default_delete@VNetworkStream@@@2@XZ PROC ; std::_Unique_ptr_base<NetworkStream,std::default_delete<NetworkStream>,1>::get_deleter, COMDAT
; _this$ = ecx

; 1312 : 		{	// return reference to deleter

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1313 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 1314 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?get_deleter@?$_Unique_ptr_base@VNetworkStream@@U?$default_delete@VNetworkStream@@@std@@$00@std@@QAEAAU?$default_delete@VNetworkStream@@@2@XZ ENDP ; std::_Unique_ptr_base<NetworkStream,std::default_delete<NetworkStream>,1>::get_deleter
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Clear@?$List@PAVAudioSource@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Clear@?$List@PAVAudioSource@@@@QAEXXZ PROC		; List<AudioSource *>::Clear, COMDAT
; _this$ = ecx

; 334  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 335  :         if(array)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@Clear

; 336  :         {
; 337  :             /*if(IsBadWritePtr(array, sizeof(T)*num))
; 338  :                 CrashError(TEXT("what the.."));*/
; 339  :             Free(array);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	?Free@@YAXPAX@Z				; Free
	add	esp, 4

; 340  :             array = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 341  :             num = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
$LN2@Clear:

; 342  :         }
; 343  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?Clear@?$List@PAVAudioSource@@@@QAEXXZ ENDP		; List<AudioSource *>::Clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Add@?$List@USceneHotkeyInfo@@@@QAEIABUSceneHotkeyInfo@@@Z
_TEXT	SEGMENT
tv73 = -8						; size = 4
_this$ = -4						; size = 4
_val$ = 8						; size = 4
?Add@?$List@USceneHotkeyInfo@@@@QAEIABUSceneHotkeyInfo@@@Z PROC ; List<SceneHotkeyInfo>::Add, COMDAT
; _this$ = ecx

; 45   :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 46   :         array = (T*)ReAllocate(array, sizeof(T)*++num);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	DWORD PTR tv73[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR tv73[ebp]
	mov	DWORD PTR [edx+4], eax
	imul	ecx, DWORD PTR tv73[ebp], 12
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 47   :         mcpy(&array[(num-1)], (void*)&val, sizeof(T));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1
	imul	ecx, eax, 12
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, ecx
	mov	ecx, DWORD PTR _val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ecx

; 48   :         return num-1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1

; 49   :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?Add@?$List@USceneHotkeyInfo@@@@QAEIABUSceneHotkeyInfo@@@Z ENDP ; List<SceneHotkeyInfo>::Add
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Clear@?$List@USceneHotkeyInfo@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Clear@?$List@USceneHotkeyInfo@@@@QAEXXZ PROC		; List<SceneHotkeyInfo>::Clear, COMDAT
; _this$ = ecx

; 334  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 335  :         if(array)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@Clear

; 336  :         {
; 337  :             /*if(IsBadWritePtr(array, sizeof(T)*num))
; 338  :                 CrashError(TEXT("what the.."));*/
; 339  :             Free(array);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	?Free@@YAXPAX@Z				; Free
	add	esp, 4

; 340  :             array = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 341  :             num = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
$LN2@Clear:

; 342  :         }
; 343  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?Clear@?$List@USceneHotkeyInfo@@@@QAEXXZ ENDP		; List<SceneHotkeyInfo>::Clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Clear@?$List@PAVSettingsPane@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Clear@?$List@PAVSettingsPane@@@@QAEXXZ PROC		; List<SettingsPane *>::Clear, COMDAT
; _this$ = ecx

; 334  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 335  :         if(array)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@Clear

; 336  :         {
; 337  :             /*if(IsBadWritePtr(array, sizeof(T)*num))
; 338  :                 CrashError(TEXT("what the.."));*/
; 339  :             Free(array);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	?Free@@YAXPAX@Z				; Free
	add	esp, 4

; 340  :             array = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 341  :             num = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
$LN2@Clear:

; 342  :         }
; 343  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?Clear@?$List@PAVSettingsPane@@@@QAEXXZ ENDP		; List<SettingsPane *>::Clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xtree
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@ABV?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 4
??0?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@ABV?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >, COMDAT
; _this$ = ecx

; 1066 : 		{	// construct empty tree

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Parg$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tree_comp@$0A@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@ABV?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@1@@Z ; std::_Tree_comp<0,std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::_Tree_comp<0,std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >

; 1067 : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@ABV?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xtree
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T1 = -24						; size = 4
$T2 = -20						; size = 4
$T3 = -16						; size = 4
$T4 = -12						; size = 4
$T5 = -8						; size = 4
_this$ = -4						; size = 4
?_Tidy@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::_Tidy, COMDAT
; _this$ = ecx

; 2229 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 2230 : 		erase(begin(), end());

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::end
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T5[ebp], ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::begin
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR $T4[ebp], eax
	mov	ecx, DWORD PTR $T5[ebp]
	push	ecx
	mov	edx, DWORD PTR $T4[ebp]
	push	edx
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::erase

; 2231 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??0?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@QAE@XZ PROC ; std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >, COMDAT
; _this$ = ecx

; 552  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@QAE@XZ ENDP ; std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xtree
;	COMDAT ??1?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@@std@@QAE@XZ PROC ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > > >::~_Tree_alloc<0,std::_Tree_base_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > > >, COMDAT
; _this$ = ecx

; 777  : 		{	// destroy head node

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 778  : 		_Freeheadnode(this->_Myhead);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Freeheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > > >::_Freeheadnode

; 779  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@@std@@QAE@XZ ENDP ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > > >::~_Tree_alloc<0,std::_Tree_base_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Clear@?$List@UVideoSegment@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Clear@?$List@UVideoSegment@@@@QAEXXZ PROC		; List<VideoSegment>::Clear, COMDAT
; _this$ = ecx

; 334  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 335  :         if(array)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@Clear

; 336  :         {
; 337  :             /*if(IsBadWritePtr(array, sizeof(T)*num))
; 338  :                 CrashError(TEXT("what the.."));*/
; 339  :             Free(array);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	?Free@@YAXPAX@Z				; Free
	add	esp, 4

; 340  :             array = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 341  :             num = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
$LN2@Clear:

; 342  :         }
; 343  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?Clear@?$List@UVideoSegment@@@@QAEXXZ ENDP		; List<VideoSegment>::Clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Clear@?$List@UFrameAudio@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Clear@?$List@UFrameAudio@@@@QAEXXZ PROC		; List<FrameAudio>::Clear, COMDAT
; _this$ = ecx

; 334  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 335  :         if(array)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@Clear

; 336  :         {
; 337  :             /*if(IsBadWritePtr(array, sizeof(T)*num))
; 338  :                 CrashError(TEXT("what the.."));*/
; 339  :             Free(array);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	?Free@@YAXPAX@Z				; Free
	add	esp, 4

; 340  :             array = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 341  :             num = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
$LN2@Clear:

; 342  :         }
; 343  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?Clear@?$List@UFrameAudio@@@@QAEXXZ ENDP		; List<FrameAudio>::Clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Add@?$List@UIconInfo@@@@QAEIABUIconInfo@@@Z
_TEXT	SEGMENT
tv73 = -8						; size = 4
_this$ = -4						; size = 4
_val$ = 8						; size = 4
?Add@?$List@UIconInfo@@@@QAEIABUIconInfo@@@Z PROC	; List<IconInfo>::Add, COMDAT
; _this$ = ecx

; 45   :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 46   :         array = (T*)ReAllocate(array, sizeof(T)*++num);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	DWORD PTR tv73[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR tv73[ebp]
	mov	DWORD PTR [edx+4], eax
	imul	ecx, DWORD PTR tv73[ebp], 12
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 47   :         mcpy(&array[(num-1)], (void*)&val, sizeof(T));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1
	imul	ecx, eax, 12
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, ecx
	mov	ecx, DWORD PTR _val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ecx

; 48   :         return num-1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1

; 49   :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?Add@?$List@UIconInfo@@@@QAEIABUIconInfo@@@Z ENDP	; List<IconInfo>::Add
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?SetSize@?$List@UFontInfo@@@@QAEHI@Z
_TEXT	SEGMENT
_bClear$ = -16						; size = 4
_oldNum$ = -12						; size = 4
tv70 = -8						; size = 4
_this$ = -4						; size = 4
_n$ = 8							; size = 4
?SetSize@?$List@UFontInfo@@@@QAEHI@Z PROC		; List<FontInfo>::SetSize, COMDAT
; _this$ = ecx

; 205  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 206  :         if(num == n)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _n$[ebp]
	jne	SHORT $LN4@SetSize

; 207  :             return FALSE;

	xor	eax, eax
	jmp	$LN5@SetSize
	jmp	SHORT $LN3@SetSize
$LN4@SetSize:

; 208  :         else if(!n)

	cmp	DWORD PTR _n$[ebp], 0
	jne	SHORT $LN3@SetSize

; 209  :         {
; 210  :             Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$List@UFontInfo@@@@QAEXXZ	; List<FontInfo>::Clear

; 211  :             return TRUE;

	mov	eax, 1
	jmp	$LN5@SetSize
$LN3@SetSize:

; 212  :         }
; 213  : 
; 214  :         BOOL bClear=(n>num);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _n$[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jbe	SHORT $LN7@SetSize
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN8@SetSize
$LN7@SetSize:
	mov	DWORD PTR tv70[ebp], 0
$LN8@SetSize:
	mov	ecx, DWORD PTR tv70[ebp]
	mov	DWORD PTR _bClear$[ebp], ecx

; 215  :         UINT oldNum=num;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _oldNum$[ebp], eax

; 216  : 
; 217  :         num = n;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _n$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 218  :         array = (T*)ReAllocate(array, sizeof(T)*num);

	mov	eax, DWORD PTR _this$[ebp]
	imul	ecx, DWORD PTR [eax+4], 20
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 219  : 
; 220  :         if(bClear)

	cmp	DWORD PTR _bClear$[ebp], 0
	je	SHORT $LN1@SetSize

; 221  :             zero(&array[oldNum], sizeof(T)*(num-oldNum));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, DWORD PTR _oldNum$[ebp]
	imul	ecx, eax, 20
	push	ecx
	imul	edx, DWORD PTR _oldNum$[ebp], 20
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax]
	push	edx
	call	?zero@@YGXPAXI@Z			; zero
$LN1@SetSize:

; 222  : 
; 223  :         return TRUE;

	mov	eax, 1
$LN5@SetSize:

; 224  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetSize@?$List@UFontInfo@@@@QAEHI@Z ENDP		; List<FontInfo>::SetSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?SetSize@?$List@UPluginInfo@@@@QAEHI@Z
_TEXT	SEGMENT
_bClear$ = -16						; size = 4
_oldNum$ = -12						; size = 4
tv70 = -8						; size = 4
_this$ = -4						; size = 4
_n$ = 8							; size = 4
?SetSize@?$List@UPluginInfo@@@@QAEHI@Z PROC		; List<PluginInfo>::SetSize, COMDAT
; _this$ = ecx

; 205  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 206  :         if(num == n)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _n$[ebp]
	jne	SHORT $LN4@SetSize

; 207  :             return FALSE;

	xor	eax, eax
	jmp	$LN5@SetSize
	jmp	SHORT $LN3@SetSize
$LN4@SetSize:

; 208  :         else if(!n)

	cmp	DWORD PTR _n$[ebp], 0
	jne	SHORT $LN3@SetSize

; 209  :         {
; 210  :             Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$List@UPluginInfo@@@@QAEXXZ	; List<PluginInfo>::Clear

; 211  :             return TRUE;

	mov	eax, 1
	jmp	$LN5@SetSize
$LN3@SetSize:

; 212  :         }
; 213  : 
; 214  :         BOOL bClear=(n>num);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _n$[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jbe	SHORT $LN7@SetSize
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN8@SetSize
$LN7@SetSize:
	mov	DWORD PTR tv70[ebp], 0
$LN8@SetSize:
	mov	ecx, DWORD PTR tv70[ebp]
	mov	DWORD PTR _bClear$[ebp], ecx

; 215  :         UINT oldNum=num;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _oldNum$[ebp], eax

; 216  : 
; 217  :         num = n;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _n$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 218  :         array = (T*)ReAllocate(array, sizeof(T)*num);

	mov	eax, DWORD PTR _this$[ebp]
	imul	ecx, DWORD PTR [eax+4], 96
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __imp_?MainAllocator@@3PAVAlloc@@A
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 219  : 
; 220  :         if(bClear)

	cmp	DWORD PTR _bClear$[ebp], 0
	je	SHORT $LN1@SetSize

; 221  :             zero(&array[oldNum], sizeof(T)*(num-oldNum));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, DWORD PTR _oldNum$[ebp]
	imul	ecx, eax, 96
	push	ecx
	imul	edx, DWORD PTR _oldNum$[ebp], 96
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax]
	push	edx
	call	?zero@@YGXPAXI@Z			; zero
$LN1@SetSize:

; 222  : 
; 223  :         return TRUE;

	mov	eax, 1
$LN5@SetSize:

; 224  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetSize@?$List@UPluginInfo@@@@QAEHI@Z ENDP		; List<PluginInfo>::SetSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\template.h
;	COMDAT ?Clear@?$List@UPluginInfo@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Clear@?$List@UPluginInfo@@@@QAEXXZ PROC		; List<PluginInfo>::Clear, COMDAT
; _this$ = ecx

; 334  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 335  :         if(array)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@Clear

; 336  :         {
; 337  :             /*if(IsBadWritePtr(array, sizeof(T)*num))
; 338  :                 CrashError(TEXT("what the.."));*/
; 339  :             Free(array);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	?Free@@YAXPAX@Z				; Free
	add	esp, 4

; 340  :             array = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 341  :             num = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
$LN2@Clear:

; 342  :         }
; 343  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?Clear@?$List@UPluginInfo@@@@QAEXXZ ENDP		; List<PluginInfo>::Clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\list
;	COMDAT ?_Tidy@?$list@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$list@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAEXXZ PROC ; std::list<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >::_Tidy, COMDAT
; _this$ = ecx

; 1882 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1883 : 		clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$list@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAEXXZ ; std::list<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >::clear

; 1884 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$list@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAEXXZ ENDP ; std::list<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\list
;	COMDAT ??0?$_List_buy@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAE@ABV?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 4
??0?$_List_buy@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAE@ABV?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@1@@Z PROC ; std::_List_buy<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >::_List_buy<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >, COMDAT
; _this$ = ecx

; 823  : 		{	// construct from allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_List_alloc@$0A@U?$_List_base_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@1@@Z ; std::_List_alloc<0,std::_List_base_types<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > > >::_List_alloc<0,std::_List_base_types<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > > >

; 824  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_List_buy@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAE@ABV?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@1@@Z ENDP ; std::_List_buy<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >::_List_buy<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??0?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@QAE@XZ PROC ; std::allocator<std::unique_ptr<void,ThreadTerminator<0> > >::allocator<std::unique_ptr<void,ThreadTerminator<0> > >, COMDAT
; _this$ = ecx

; 552  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@QAE@XZ ENDP ; std::allocator<std::unique_ptr<void,ThreadTerminator<0> > >::allocator<std::unique_ptr<void,ThreadTerminator<0> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\list
;	COMDAT ??1?$_List_alloc@$0A@U?$_List_base_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_List_alloc@$0A@U?$_List_base_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@@std@@QAE@XZ PROC ; std::_List_alloc<0,std::_List_base_types<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > > >::~_List_alloc<0,std::_List_base_types<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > > >, COMDAT
; _this$ = ecx

; 706  : 		{	// destroy head node

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 707  : 		_Freeheadnode(this->_Myhead);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Freeheadnode@?$_List_alloc@$0A@U?$_List_base_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@@std@@QAEXPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@@Z ; std::_List_alloc<0,std::_List_base_types<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > > >::_Freeheadnode

; 708  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_List_alloc@$0A@U?$_List_base_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@@std@@QAE@XZ ENDP ; std::_List_alloc<0,std::_List_base_types<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > > >::~_List_alloc<0,std::_List_base_types<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ?_Set@?$_Func_class@X$$$V@std@@AAEXPAV?$_Func_base@X$$$V@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Set@?$_Func_class@X$$$V@std@@AAEXPAV?$_Func_base@X$$$V@2@@Z PROC ; std::_Func_class<void>::_Set, COMDAT
; _this$ = ecx

; 510  : 		{	// store pointer to object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 511  : 		_Impl = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 512  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Set@?$_Func_class@X$$$V@std@@AAEXPAV?$_Func_base@X$$$V@2@@Z ENDP ; std::_Func_class<void>::_Set
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\functional
;	COMDAT ?_Local@?$_Func_class@X$$$V@std@@ABE_NXZ
_TEXT	SEGMENT
tv67 = -8						; size = 4
_this$ = -4						; size = 4
?_Local@?$_Func_class@X$$$V@std@@ABE_NXZ PROC		; std::_Func_class<void>::_Local, COMDAT
; _this$ = ecx

; 515  : 		{	// test for locally stored copy of object

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 516  : 		return ((void *)_Impl == (void *)&_Space);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+16], eax
	jne	SHORT $LN3@Local
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@Local
$LN3@Local:
	mov	DWORD PTR tv67[ebp], 0
$LN4@Local:
	mov	al, BYTE PTR tv67[ebp]

; 517  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Local@?$_Func_class@X$$$V@std@@ABE_NXZ ENDP		; std::_Func_class<void>::_Local
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\memory
;	COMDAT ??0?$default_delete@VNetworkStream@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$default_delete@VNetworkStream@@@std@@QAE@XZ PROC	; std::default_delete<NetworkStream>::default_delete<NetworkStream>, COMDAT
; _this$ = ecx

; 1185 : 	default_delete() _NOEXCEPT

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1186 : 		{	// default construct
; 1187 : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$default_delete@VNetworkStream@@@std@@QAE@XZ ENDP	; std::default_delete<NetworkStream>::default_delete<NetworkStream>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xtree
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::begin, COMDAT
; _this$ = ecx

; 1211 : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1212 : 		return (iterator(_Lmost(), this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::_Lmost
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1213 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::begin
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xtree
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::end, COMDAT
; _this$ = ecx

; 1221 : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1222 : 		return (iterator(this->_Myhead, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1223 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::end
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xtree
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
$T1 = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
$T4 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@@2@0@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::erase, COMDAT
; _this$ = ecx

; 1511 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 1512 : 		if (_First == begin() && _Last == end())

	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::begin
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > > >::operator==
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@erase
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::end
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > > >::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@erase

; 1513 : 			{	// erase all
; 1514 : 			clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::clear

; 1515 : 			return (begin());

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::begin
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN5@erase

; 1516 : 			}
; 1517 : 		else

	jmp	SHORT $LN5@erase
$LN2@erase:

; 1518 : 			{	// partial erase, one at a time
; 1519 : 			while (_First != _Last)

	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > > >::operator!=
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@erase

; 1520 : 				erase(_First++);

	push	0
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	ecx, DWORD PTR __First$[ebp]
	call	??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > > >::operator++
	mov	edx, DWORD PTR [eax]
	push	edx
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::erase
	jmp	SHORT $LN2@erase
$LN1@erase:

; 1521 : 			return (iterator(_First._Ptr, this));

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN5@erase:

; 1522 : 			}
; 1523 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@@2@0@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xtree
;	COMDAT ??0?$_Tree_comp@$0A@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@ABV?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
__Al$ = 12						; size = 4
??0?$_Tree_comp@$0A@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@ABV?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@1@@Z PROC ; std::_Tree_comp<0,std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::_Tree_comp<0,std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >, COMDAT
; _this$ = ecx

; 1002 : 		{	// construct ordering predicate

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tree_buy@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@1@@Z ; std::_Tree_buy<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Tree_buy<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >

; 1003 : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Tree_comp@$0A@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@1@ABV?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@1@@Z ENDP ; std::_Tree_comp<0,std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::_Tree_comp<0,std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xtree
;	COMDAT ?_Freeheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -4						; size = 1
$T2 = -3						; size = 1
$T3 = -2						; size = 1
$T4 = -1						; size = 1
__Pnode$ = 8						; size = 4
?_Freeheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z PROC ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > > >::_Freeheadnode, COMDAT
; _this$ = ecx

; 857  : 		{	// free head node using current allocator

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 858  : 		this->_Getal().destroy(
; 859  : 			_STD addressof(this->_Left(_Pnode)));

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Left
	add	esp, 4
	push	eax
	call	??$addressof@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@0@AAPAU10@@Z ; std::addressof<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR $T4[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > > >::_Getal
	mov	ecx, eax
	call	??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> > >::destroy<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> *>

; 860  : 		this->_Getal().destroy(
; 861  : 			_STD addressof(this->_Parent(_Pnode)));

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Parent
	add	esp, 4
	push	eax
	call	??$addressof@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@0@AAPAU10@@Z ; std::addressof<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> *>
	add	esp, 4
	push	eax
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > > >::_Getal
	mov	ecx, eax
	call	??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> > >::destroy<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> *>

; 862  : 		this->_Getal().destroy(
; 863  : 			_STD addressof(this->_Right(_Pnode)));

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Right
	add	esp, 4
	push	eax
	call	??$addressof@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@0@AAPAU10@@Z ; std::addressof<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > > >::_Getal
	mov	ecx, eax
	call	??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> > >::destroy<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> *>

; 864  : 		this->_Getal().deallocate(_Pnode, 1);

	push	1
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> > >::deallocate

; 865  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Freeheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z ENDP ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > > >::_Freeheadnode
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\list
;	COMDAT ?clear@?$list@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAEXXZ
_TEXT	SEGMENT
__Pnext$1 = -12						; size = 4
__Pnode$ = -8						; size = 4
_this$ = -4						; size = 4
?clear@?$list@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAEXXZ PROC ; std::list<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >::clear, COMDAT
; _this$ = ecx

; 1491 : 		{	// erase all

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1492 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1493 : 		this->_Orphan_ptr(*this, nullptr);
; 1494 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1495 : 
; 1496 : 		_Nodeptr _Pnode = this->_Nextnode(this->_Myhead);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Nextnode@?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@SAAAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@PAU32@@Z ; std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > >::_Nextnode
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], edx

; 1497 : 		this->_Nextnode(this->_Myhead) = this->_Myhead;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Nextnode@?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@SAAAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@PAU32@@Z ; std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > >::_Nextnode
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx

; 1498 : 		this->_Prevnode(this->_Myhead) = this->_Myhead;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	?_Prevnode@?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@SAAAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@PAU32@@Z ; std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > >::_Prevnode
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 1499 : 		this->_Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 1500 : 
; 1501 : 		for (_Nodeptr _Pnext; _Pnode != this->_Myhead; _Pnode = _Pnext)

	jmp	SHORT $LN3@clear
$LN2@clear:
	mov	ecx, DWORD PTR __Pnext$1[ebp]
	mov	DWORD PTR __Pnode$[ebp], ecx
$LN3@clear:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Pnode$[ebp]
	cmp	eax, DWORD PTR [edx]
	je	SHORT $LN4@clear

; 1502 : 			{	// delete an element
; 1503 : 			_Pnext = this->_Nextnode(_Pnode);

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Nextnode@?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@SAAAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@PAU32@@Z ; std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > >::_Nextnode
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Pnext$1[ebp], edx

; 1504 : 			this->_Freenode(_Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Freenode@?$_List_buy@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAEXPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@@Z ; std::_List_buy<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >::_Freenode

; 1505 : 			}

	jmp	SHORT $LN2@clear
$LN4@clear:

; 1506 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$list@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAEXXZ ENDP ; std::list<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >::clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\list
;	COMDAT ??0?$_List_alloc@$0A@U?$_List_base_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$_List_alloc@$0A@U?$_List_base_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@1@@Z PROC ; std::_List_alloc<0,std::_List_base_types<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > > >::_List_alloc<0,std::_List_base_types<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > > >, COMDAT
; _this$ = ecx

; 700  : 	_List_alloc(const _Alloc& = _Alloc())

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@QAE@XZ ; std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > >::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > >

; 701  : 		{	// construct head node, allocator from _Al
; 702  : 		this->_Myhead = _Buyheadnode();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buyheadnode@?$_List_alloc@$0A@U?$_List_base_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@@std@@QAEPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@XZ ; std::_List_alloc<0,std::_List_base_types<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > > >::_Buyheadnode
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 703  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_List_alloc@$0A@U?$_List_base_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@@std@@QAE@ABV?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@1@@Z ENDP ; std::_List_alloc<0,std::_List_base_types<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > > >::_List_alloc<0,std::_List_base_types<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\list
;	COMDAT ?_Freeheadnode@?$_List_alloc@$0A@U?$_List_base_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@@std@@QAEXPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -3						; size = 1
$T2 = -2						; size = 1
$T3 = -1						; size = 1
__Pnode$ = 8						; size = 4
?_Freeheadnode@?$_List_alloc@$0A@U?$_List_base_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@@std@@QAEXPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@@Z PROC ; std::_List_alloc<0,std::_List_base_types<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > > >::_Freeheadnode, COMDAT
; _this$ = ecx

; 771  : 		{	// free head node using current allocator

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 772  : 		this->_Getal().destroy(
; 773  : 			_STD addressof(this->_Nextnode(_Pnode)));

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Nextnode@?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@SAAAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@PAU32@@Z ; std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > >::_Nextnode
	add	esp, 4
	push	eax
	call	??$addressof@PAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@YAPAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@0@AAPAU10@@Z ; std::addressof<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_List_alloc@$0A@U?$_List_base_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@2@XZ ; std::_List_alloc<0,std::_List_base_types<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > > >::_Getal
	mov	ecx, eax
	call	??$destroy@PAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> > >::destroy<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> *>

; 774  : 		this->_Getal().destroy(
; 775  : 			_STD addressof(this->_Prevnode(_Pnode)));

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Prevnode@?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@SAAAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@PAU32@@Z ; std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > >::_Prevnode
	add	esp, 4
	push	eax
	call	??$addressof@PAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@YAPAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@0@AAPAU10@@Z ; std::addressof<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> *>
	add	esp, 4
	push	eax
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_List_alloc@$0A@U?$_List_base_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@2@XZ ; std::_List_alloc<0,std::_List_base_types<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > > >::_Getal
	mov	ecx, eax
	call	??$destroy@PAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> > >::destroy<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> *>

; 776  : 		this->_Getal().deallocate(_Pnode, 1);

	push	1
	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_List_alloc@$0A@U?$_List_base_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@2@XZ ; std::_List_alloc<0,std::_List_base_types<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> > >::deallocate

; 777  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Freeheadnode@?$_List_alloc@$0A@U?$_List_base_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@@std@@QAEXPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@@Z ENDP ; std::_List_alloc<0,std::_List_base_types<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > > >::_Freeheadnode
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xtree
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
tv171 = -32						; size = 4
tv159 = -28						; size = 4
_this$ = -24						; size = 4
__Erasednode$ = -20					; size = 4
__Fixnode$ = -16					; size = 4
__Fixnodeparent$ = -12					; size = 4
__Pnode$ = -8						; size = 4
$T1 = -2						; size = 1
$T2 = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::erase, COMDAT
; _this$ = ecx

; 1328 : 		{	// erase element at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1329 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1330 : 		if (_Where._Getcont() != this || this->_Isnil(_Where._Mynode()))
; 1331 : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 1332 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1333 : 		++_Where;	// save successor iterator for return
; 1334 : 		_Orphan_ptr(*this, _Erasednode);
; 1335 : 
; 1336 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1337 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase

	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >,std::_Iterator_base0>::_Mynode
	mov	DWORD PTR __Erasednode$[ebp], eax

; 1338 : 		++_Where;	// save successor iterator for return

	lea	ecx, DWORD PTR __Where$[ebp]
	call	??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > > >::operator++

; 1339 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1340 : 
; 1341 : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 1342 : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 1343 : 		_Nodeptr _Pnode = _Erasednode;

	mov	eax, DWORD PTR __Erasednode$[ebp]
	mov	DWORD PTR __Pnode$[ebp], eax

; 1344 : 
; 1345 : 		if (this->_Isnil(this->_Left(_Pnode)))

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Left
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	je	SHORT $LN39@erase

; 1346 : 			_Fixnode = this->_Right(_Pnode);	// stitch up right subtree

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Right
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Fixnode$[ebp], edx
	jmp	SHORT $LN38@erase
$LN39@erase:

; 1347 : 		else if (this->_Isnil(this->_Right(_Pnode)))

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Isnil
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	je	SHORT $LN37@erase

; 1348 : 			_Fixnode = this->_Left(_Pnode);	// stitch up left subtree

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Fixnode$[ebp], ecx

; 1349 : 		else

	jmp	SHORT $LN38@erase
$LN37@erase:

; 1350 : 			{	// two subtrees, must lift successor node to replace erased
; 1351 : 			_Pnode = _Where._Mynode();	// _Pnode is successor node

	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >,std::_Iterator_base0>::_Mynode
	mov	DWORD PTR __Pnode$[ebp], eax

; 1352 : 			_Fixnode = this->_Right(_Pnode);	// _Fixnode is only subtree

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Fixnode$[ebp], eax
$LN38@erase:

; 1353 : 			}
; 1354 : 
; 1355 : 		if (_Pnode == _Erasednode)

	mov	ecx, DWORD PTR __Pnode$[ebp]
	cmp	ecx, DWORD PTR __Erasednode$[ebp]
	jne	$LN35@erase

; 1356 : 			{	// at most one subtree, relink it
; 1357 : 			_Fixnodeparent = this->_Parent(_Erasednode);

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Fixnodeparent$[ebp], eax

; 1358 : 			if (!this->_Isnil(_Fixnode))

	mov	ecx, DWORD PTR __Fixnode$[ebp]
	push	ecx
	call	?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Isnil
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	jne	SHORT $LN34@erase

; 1359 : 				this->_Parent(_Fixnode) = _Fixnodeparent;	// link up

	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR [eax], ecx
$LN34@erase:

; 1360 : 
; 1361 : 			if (_Root() == _Erasednode)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::_Root
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN33@erase

; 1362 : 				_Root() = _Fixnode;	// link down from root

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::_Root
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN32@erase
$LN33@erase:

; 1363 : 			else if (this->_Left(_Fixnodeparent) == _Erasednode)

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	cmp	eax, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN31@erase

; 1364 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link down to left

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	push	ecx
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Left
	add	esp, 4
	mov	edx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [eax], edx

; 1365 : 			else

	jmp	SHORT $LN32@erase
$LN31@erase:

; 1366 : 				this->_Right(_Fixnodeparent) =
; 1367 : 					_Fixnode;	// link down to right

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	push	eax
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN32@erase:

; 1368 : 
; 1369 : 			if (_Lmost() == _Erasednode)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::_Lmost
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN29@erase

; 1370 : 				_Lmost() = this->_Isnil(_Fixnode)
; 1371 : 					? _Fixnodeparent	// smallest is parent of erased node
; 1372 : 					: this->_Min(_Fixnode);	// smallest in relinked subtree

	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN42@erase
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR tv159[ebp], edx
	jmp	SHORT $LN43@erase
$LN42@erase:
	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Min
	add	esp, 4
	mov	DWORD PTR tv159[ebp], eax
$LN43@erase:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::_Lmost
	mov	ecx, DWORD PTR tv159[ebp]
	mov	DWORD PTR [eax], ecx
$LN29@erase:

; 1373 : 
; 1374 : 			if (_Rmost() == _Erasednode)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::_Rmost
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN28@erase

; 1375 : 				_Rmost() = this->_Isnil(_Fixnode)
; 1376 : 					? _Fixnodeparent	// largest is parent of erased node
; 1377 : 					: this->_Max(_Fixnode);	// largest in relinked subtree

	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN44@erase
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR tv171[ebp], edx
	jmp	SHORT $LN45@erase
$LN44@erase:
	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Max
	add	esp, 4
	mov	DWORD PTR tv171[ebp], eax
$LN45@erase:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::_Rmost
	mov	ecx, DWORD PTR tv171[ebp]
	mov	DWORD PTR [eax], ecx
$LN28@erase:

; 1378 : 			}
; 1379 : 		else

	jmp	$LN27@erase
$LN35@erase:

; 1380 : 			{	// erased has two subtrees, _Pnode is successor to erased
; 1381 : 			this->_Parent(this->_Left(_Erasednode)) =
; 1382 : 				_Pnode;	// link left up

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1383 : 			this->_Left(_Pnode) =
; 1384 : 				this->_Left(_Erasednode);	// link successor down

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Left
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 1385 : 
; 1386 : 			if (_Pnode == this->_Right(_Erasednode))

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN26@erase

; 1387 : 				_Fixnodeparent = _Pnode;	// successor is next to erased

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR __Fixnodeparent$[ebp], edx

; 1388 : 			else

	jmp	$LN25@erase
$LN26@erase:

; 1389 : 				{	// successor further down, link in place of erased
; 1390 : 				_Fixnodeparent =
; 1391 : 					this->_Parent(_Pnode);	// parent is successor's

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Fixnodeparent$[ebp], ecx

; 1392 : 				if (!this->_Isnil(_Fixnode))

	mov	edx, DWORD PTR __Fixnode$[ebp]
	push	edx
	call	?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	jne	SHORT $LN24@erase

; 1393 : 					this->_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

	mov	ecx, DWORD PTR __Fixnode$[ebp]
	push	ecx
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Parent
	add	esp, 4
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR [eax], edx
$LN24@erase:

; 1394 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link fix down

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	push	eax
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1395 : 				this->_Right(_Pnode) =
; 1396 : 					this->_Right(_Erasednode);	// link next down

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Right
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 1397 : 				this->_Parent(this->_Right(_Erasednode)) =
; 1398 : 					_Pnode;	// right up

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN25@erase:

; 1399 : 				}
; 1400 : 
; 1401 : 			if (_Root() == _Erasednode)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::_Root
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN23@erase

; 1402 : 				_Root() = _Pnode;	// link down from root

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::_Root
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN22@erase
$LN23@erase:

; 1403 : 			else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN21@erase

; 1404 : 				this->_Left(this->_Parent(_Erasednode)) =
; 1405 : 					_Pnode;	// link down to left

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1406 : 			else

	jmp	SHORT $LN22@erase
$LN21@erase:

; 1407 : 				this->_Right(this->_Parent(_Erasednode)) =
; 1408 : 					_Pnode;	// link down to right

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN22@erase:

; 1409 : 
; 1410 : 			this->_Parent(_Pnode) =
; 1411 : 				this->_Parent(_Erasednode);	// link successor up

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Parent
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 1412 : 			_STD swap(this->_Color(_Pnode),
; 1413 : 				this->_Color(_Erasednode));	// recolor it

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Color
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Color
	add	esp, 4
	push	eax
	call	??$swap@D@std@@YAXAAD0@Z		; std::swap<char>
	add	esp, 8
$LN27@erase:

; 1414 : 			}
; 1415 : 
; 1416 : 		if (this->_Color(_Erasednode) == this->_Black)

	mov	ecx, DWORD PTR __Erasednode$[ebp]
	push	ecx
	call	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Color
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	cmp	edx, 1
	jne	$LN19@erase

; 1417 : 			{	// erasing black link, must recolor/rebalance tree
; 1418 : 			for (; _Fixnode != _Root()
; 1419 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1420 : 				_Fixnodeparent = this->_Parent(_Fixnode))

	jmp	SHORT $LN18@erase
$LN17@erase:
	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Fixnodeparent$[ebp], ecx
$LN18@erase:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::_Root
	mov	edx, DWORD PTR __Fixnode$[ebp]
	cmp	edx, DWORD PTR [eax]
	je	$LN16@erase
	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Color
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 1
	jne	$LN16@erase

; 1421 : 				if (_Fixnode == this->_Left(_Fixnodeparent))

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	$LN15@erase

; 1422 : 					{	// fixup left subtree
; 1423 : 					_Pnode = this->_Right(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], eax

; 1424 : 					if (this->_Color(_Pnode) == this->_Red)

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Color
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	jne	SHORT $LN14@erase

; 1425 : 						{	// rotate red up from right subtree
; 1426 : 						this->_Color(_Pnode) = this->_Black;

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 1427 : 						this->_Color(_Fixnodeparent) = this->_Red;

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	push	ecx
	call	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 1428 : 						_Lrotate(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::_Lrotate

; 1429 : 						_Pnode = this->_Right(_Fixnodeparent);

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	push	eax
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx
$LN14@erase:

; 1430 : 						}
; 1431 : 
; 1432 : 					if (this->_Isnil(_Pnode))

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	je	SHORT $LN13@erase

; 1433 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], ecx

; 1434 : 					else if (this->_Color(this->_Left(_Pnode)) == this->_Black

	jmp	$LN12@erase
$LN13@erase:

; 1435 : 						&& this->_Color(this->_Right(_Pnode)) == this->_Black)

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Color
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 1
	jne	SHORT $LN11@erase
	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Color
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 1
	jne	SHORT $LN11@erase

; 1436 : 						{	// redden right subtree with black children
; 1437 : 						this->_Color(_Pnode) = this->_Red;

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 1438 : 						_Fixnode = _Fixnodeparent;

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], eax

; 1439 : 						}
; 1440 : 					else

	jmp	$LN12@erase
$LN11@erase:

; 1441 : 						{	// must rearrange right subtree
; 1442 : 						if (this->_Color(this->_Right(_Pnode))
; 1443 : 							== this->_Black)

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Right
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Color
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	cmp	eax, 1
	jne	SHORT $LN9@erase

; 1444 : 							{	// rotate red up from left sub-subtree
; 1445 : 							this->_Color(this->_Left(_Pnode)) = this->_Black;

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Left
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 1446 : 							this->_Color(_Pnode) = this->_Red;

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 1447 : 							_Rrotate(_Pnode);

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::_Rrotate

; 1448 : 							_Pnode = this->_Right(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], eax
$LN9@erase:

; 1449 : 							}
; 1450 : 
; 1451 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	push	ecx
	call	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Color
	add	esp, 4
	mov	esi, eax
	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Color
	add	esp, 4
	mov	cl, BYTE PTR [esi]
	mov	BYTE PTR [eax], cl

; 1452 : 						this->_Color(_Fixnodeparent) = this->_Black;

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 1453 : 						this->_Color(this->_Right(_Pnode)) = this->_Black;

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 1454 : 						_Lrotate(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::_Lrotate

; 1455 : 						break;	// tree now recolored/rebalanced

	jmp	$LN16@erase
$LN12@erase:

; 1456 : 						}
; 1457 : 					}
; 1458 : 				else

	jmp	$LN8@erase
$LN15@erase:

; 1459 : 					{	// fixup right subtree
; 1460 : 					_Pnode = this->_Left(_Fixnodeparent);

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	push	eax
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 1461 : 					if (this->_Color(_Pnode) == this->_Red)

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Color
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	jne	SHORT $LN7@erase

; 1462 : 						{	// rotate red up from left subtree
; 1463 : 						this->_Color(_Pnode) = this->_Black;

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 1464 : 						this->_Color(_Fixnodeparent) = this->_Red;

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 1465 : 						_Rrotate(_Fixnodeparent);

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::_Rrotate

; 1466 : 						_Pnode = this->_Left(_Fixnodeparent);

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	push	ecx
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Left
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], edx
$LN7@erase:

; 1467 : 						}
; 1468 : 
; 1469 : 					if (this->_Isnil(_Pnode))

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN6@erase

; 1470 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], edx

; 1471 : 					else if (this->_Color(this->_Right(_Pnode)) ==

	jmp	$LN8@erase
$LN6@erase:

; 1472 : 						this->_Black
; 1473 : 						&& this->_Color(this->_Left(_Pnode)) == this->_Black)

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Color
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	cmp	edx, 1
	jne	SHORT $LN4@erase
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Color
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	cmp	edx, 1
	jne	SHORT $LN4@erase

; 1474 : 						{	// redden left subtree with black children
; 1475 : 						this->_Color(_Pnode) = this->_Red;

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 1476 : 						_Fixnode = _Fixnodeparent;

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], ecx

; 1477 : 						}
; 1478 : 					else

	jmp	$LN8@erase
$LN4@erase:

; 1479 : 						{	// must rearrange left subtree
; 1480 : 						if (this->_Color(this->_Left(_Pnode)) == this->_Black)

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Color
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 1
	jne	SHORT $LN2@erase

; 1481 : 							{	// rotate red up from right sub-subtree
; 1482 : 							this->_Color(this->_Right(_Pnode)) = this->_Black;

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 1483 : 							this->_Color(_Pnode) = this->_Red;

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 1484 : 							_Lrotate(_Pnode);

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::_Lrotate

; 1485 : 							_Pnode = this->_Left(_Fixnodeparent);

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	push	eax
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx
$LN2@erase:

; 1486 : 							}
; 1487 : 
; 1488 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Color
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Color
	add	esp, 4
	mov	cl, BYTE PTR [esi]
	mov	BYTE PTR [eax], cl

; 1489 : 						this->_Color(_Fixnodeparent) = this->_Black;

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 1490 : 						this->_Color(this->_Left(_Pnode)) = this->_Black;

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 1491 : 						_Rrotate(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::_Rrotate

; 1492 : 						break;	// tree now recolored/rebalanced

	jmp	SHORT $LN16@erase
$LN8@erase:

; 1493 : 						}
; 1494 : 					}

	jmp	$LN17@erase
$LN16@erase:

; 1495 : 
; 1496 : 			this->_Color(_Fixnode) = this->_Black;	// stopping node is black

	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1
$LN19@erase:

; 1497 : 			}
; 1498 : 
; 1499 : 		this->_Getal().destroy(
; 1500 : 			_STD addressof(this->_Myval(_Erasednode)));	// delete erased node

	mov	ecx, DWORD PTR __Erasednode$[ebp]
	push	ecx
	call	?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAU?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@2@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Myval
	add	esp, 4
	push	eax
	call	??$addressof@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@YAPAU?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@AAU10@@Z ; std::addressof<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > > >::_Getal
	mov	ecx, eax
	call	??$destroy@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> > >::destroy<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >

; 1501 : 
; 1502 : 		this->_Getal().deallocate(_Erasednode, 1);

	push	1
	mov	eax, DWORD PTR __Erasednode$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> > >::deallocate

; 1503 : 
; 1504 : 		if (0 < this->_Mysize)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jbe	SHORT $LN1@erase

; 1505 : 			--this->_Mysize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx
$LN1@erase:

; 1506 : 
; 1507 : 		return (iterator(_Where._Ptr, this));	// return successor iterator

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1508 : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xtree
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?clear@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::clear, COMDAT
; _this$ = ecx

; 1535 : 		{	// erase all

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1536 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1537 : 		this->_Orphan_ptr(*this, 0);
; 1538 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 
; 1540 : 		_Erase(_Root());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::_Root
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::_Erase

; 1541 : 		_Root() = this->_Myhead;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::_Root
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 1542 : 		_Lmost() = this->_Myhead;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::_Lmost
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 1543 : 		_Rmost() = this->_Myhead;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::_Rmost
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 1544 : 		this->_Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 1545 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xtree
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Lmost@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@XZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::_Lmost, COMDAT
; _this$ = ecx

; 2122 : 		{	// return leftmost node in nonmutable tree

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2123 : 		return (this->_Left(this->_Myhead));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Left
	add	esp, 4

; 2124 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Lmost@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::_Lmost
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xtree
;	COMDAT ??0?$_Tree_buy@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 4
??0?$_Tree_buy@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@1@@Z PROC ; std::_Tree_buy<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Tree_buy<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >, COMDAT
; _this$ = ecx

; 889  : 		{	// construct from allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@1@@Z ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > > >::_Tree_alloc<0,std::_Tree_base_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > > >

; 890  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Tree_buy@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@1@@Z ENDP ; std::_Tree_buy<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Tree_buy<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xtree
;	COMDAT ?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@@2@XZ PROC ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > > >::_Getal, COMDAT
; _this$ = ecx

; 868  : 		{	// get allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 869  : 		return (_Alty());

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 870  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@@2@XZ ENDP ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> > >::deallocate, COMDAT
; _this$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 858  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@I@Z ; std::allocator<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> >::deallocate

; 859  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xtree
;	COMDAT ?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Left, COMDAT

; 588  : 		{	// return reference to left pointer in node

	push	ebp
	mov	ebp, esp

; 589  : 		return ((_Nodepref)_Pnode->_Left);

	mov	eax, DWORD PTR __Pnode$[ebp]

; 590  : 		}

	pop	ebp
	ret	0
?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Left
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xtree
;	COMDAT ?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Parent, COMDAT

; 593  : 		{	// return reference to parent pointer in node

	push	ebp
	mov	ebp, esp

; 594  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 4

; 595  : 		}

	pop	ebp
	ret	0
?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Parent
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xtree
;	COMDAT ?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Right, COMDAT

; 598  : 		{	// return reference to right pointer in node

	push	ebp
	mov	ebp, esp

; 599  : 		return ((_Nodepref)_Pnode->_Right);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 8

; 600  : 		}

	pop	ebp
	ret	0
?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Right
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\list
;	COMDAT ?_Freenode@?$_List_buy@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAEXPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -4						; size = 1
$T2 = -3						; size = 1
$T3 = -2						; size = 1
$T4 = -1						; size = 1
__Pnode$ = 8						; size = 4
?_Freenode@?$_List_buy@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAEXPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@@Z PROC ; std::_List_buy<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >::_Freenode, COMDAT
; _this$ = ecx

; 846  : 		{	// give node back

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 847  : 		this->_Getal().destroy(
; 848  : 			_STD addressof(this->_Nextnode(_Pnode)));

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Nextnode@?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@SAAAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@PAU32@@Z ; std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > >::_Nextnode
	add	esp, 4
	push	eax
	call	??$addressof@PAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@YAPAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@0@AAPAU10@@Z ; std::addressof<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR $T4[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_List_alloc@$0A@U?$_List_base_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@2@XZ ; std::_List_alloc<0,std::_List_base_types<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > > >::_Getal
	mov	ecx, eax
	call	??$destroy@PAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> > >::destroy<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> *>

; 849  : 		this->_Getal().destroy(
; 850  : 			_STD addressof(this->_Prevnode(_Pnode)));

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Prevnode@?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@SAAAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@PAU32@@Z ; std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > >::_Prevnode
	add	esp, 4
	push	eax
	call	??$addressof@PAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@YAPAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@0@AAPAU10@@Z ; std::addressof<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> *>
	add	esp, 4
	push	eax
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_List_alloc@$0A@U?$_List_base_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@2@XZ ; std::_List_alloc<0,std::_List_base_types<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > > >::_Getal
	mov	ecx, eax
	call	??$destroy@PAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> > >::destroy<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> *>

; 851  : 		this->_Getal().destroy(
; 852  : 			_STD addressof(this->_Myval(_Pnode)));

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Myval@?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@SAAAV?$unique_ptr@XU?$ThreadTerminator@$0A@@@@2@PAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@@Z ; std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > >::_Myval
	add	esp, 4
	push	eax
	call	??$addressof@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@YAPAV?$unique_ptr@XU?$ThreadTerminator@$0A@@@@0@AAV10@@Z ; std::addressof<std::unique_ptr<void,ThreadTerminator<0> > >
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_List_alloc@$0A@U?$_List_base_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@2@XZ ; std::_List_alloc<0,std::_List_base_types<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > > >::_Getal
	mov	ecx, eax
	call	??$destroy@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@QAEXPAV?$unique_ptr@XU?$ThreadTerminator@$0A@@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> > >::destroy<std::unique_ptr<void,ThreadTerminator<0> > >

; 853  : 		this->_Getal().deallocate(_Pnode, 1);

	push	1
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_List_alloc@$0A@U?$_List_base_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@2@XZ ; std::_List_alloc<0,std::_List_base_types<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> > >::deallocate

; 854  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Freenode@?$_List_buy@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@QAEXPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@@Z ENDP ; std::_List_buy<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > >::_Freenode
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\list
;	COMDAT ?_Buyheadnode@?$_List_alloc@$0A@U?$_List_base_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@@std@@QAEPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Buyheadnode@?$_List_alloc@$0A@U?$_List_base_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@@std@@QAEPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@XZ PROC ; std::_List_alloc<0,std::_List_base_types<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > > >::_Buyheadnode, COMDAT
; _this$ = ecx

; 766  : 		{	// get head node using current allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 767  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@@std@@QAEPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@PAU32@0@Z ; std::_List_alloc<0,std::_List_base_types<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > > >::_Buynode0

; 768  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Buyheadnode@?$_List_alloc@$0A@U?$_List_base_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@@std@@QAEPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@XZ ENDP ; std::_List_alloc<0,std::_List_base_types<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > > >::_Buyheadnode
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\list
;	COMDAT ?_Getal@?$_List_alloc@$0A@U?$_List_base_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_List_alloc@$0A@U?$_List_base_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@2@XZ PROC ; std::_List_alloc<0,std::_List_base_types<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > > >::_Getal, COMDAT
; _this$ = ecx

; 803  : 		{	// get reference to allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 804  : 		return (_Alty());

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> > >::_Wrap_alloc<std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 805  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Getal@?$_List_alloc@$0A@U?$_List_base_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@2@XZ ENDP ; std::_List_alloc<0,std::_List_base_types<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> > >::deallocate, COMDAT
; _this$ = ecx

; 857  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 858  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@QAEXPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@I@Z ; std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> >::deallocate

; 859  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\list
;	COMDAT ??0?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@QAE@XZ PROC ; std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > >::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > >, COMDAT
; _this$ = ecx

; 525  : 	_List_val()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 526  : 		{	// initialize data
; 527  : 		this->_Myhead = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 528  : 		this->_Mysize = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 529  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > >::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\list
;	COMDAT ?_Nextnode@?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@SAAAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Nextnode@?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@SAAAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@PAU32@@Z PROC ; std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > >::_Nextnode, COMDAT

; 532  : 		{	// return reference to successor pointer in node

	push	ebp
	mov	ebp, esp

; 533  : 		return ((_Nodepref)_Pnode->_Next);

	mov	eax, DWORD PTR __Pnode$[ebp]

; 534  : 		}

	pop	ebp
	ret	0
?_Nextnode@?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@SAAAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@PAU32@@Z ENDP ; std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > >::_Nextnode
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\list
;	COMDAT ?_Prevnode@?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@SAAAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Prevnode@?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@SAAAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@PAU32@@Z PROC ; std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > >::_Prevnode, COMDAT

; 537  : 		{	// return reference to predecessor pointer in node

	push	ebp
	mov	ebp, esp

; 538  : 		return ((_Nodepref)_Pnode->_Prev);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 4

; 539  : 		}

	pop	ebp
	ret	0
?_Prevnode@?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@SAAAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@PAU32@@Z ENDP ; std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > >::_Prevnode
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xtree
;	COMDAT ??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@1@@Z PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > > >, COMDAT
; _this$ = ecx

; 384  : 		{	// construct with node pointer _Pnode

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Plist$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@1@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > > >

; 385  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@1@@Z ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xtree
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
__Tmp$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > > >::operator++, COMDAT
; _this$ = ecx

; 276  : 		{	// postincrement

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 277  : 		_Myiter _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$[ebp], ecx

; 278  : 		++*this;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > > >::operator++

; 279  : 		return (_Tmp);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __Tmp$[ebp]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 280  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xtree
;	COMDAT ??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv75 = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > > >::operator==, COMDAT
; _this$ = ecx

; 322  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv75[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv75[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv75[ebp]

; 337  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > > >::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xtree
;	COMDAT ??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv69 = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > > >::operator!=, COMDAT
; _this$ = ecx

; 340  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 341  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > > >::operator==
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv69[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv69[ebp]

; 342  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > > >::operator!=
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xtree
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Pnode$1 = -8						; size = 4
$T2 = -2						; size = 1
$T3 = -1						; size = 1
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::_Erase, COMDAT
; _this$ = ecx

; 2074 : 		{	// free entire subtree, recursively

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2075 : 		for (_Nodeptr _Pnode = _Rootnode;

	mov	eax, DWORD PTR __Rootnode$[ebp]
	mov	DWORD PTR __Pnode$1[ebp], eax

; 2076 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

	jmp	SHORT $LN3@Erase
$LN2@Erase:
	mov	ecx, DWORD PTR __Pnode$1[ebp]
	mov	DWORD PTR __Rootnode$[ebp], ecx
$LN3@Erase:
	mov	edx, DWORD PTR __Pnode$1[ebp]
	push	edx
	call	?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	jne	SHORT $LN4@Erase

; 2077 : 			{	// free subtrees, then node
; 2078 : 			_Erase(this->_Right(_Pnode));

	mov	ecx, DWORD PTR __Pnode$1[ebp]
	push	ecx
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Right
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::_Erase

; 2079 : 			_Pnode = this->_Left(_Pnode);

	mov	eax, DWORD PTR __Pnode$1[ebp]
	push	eax
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$1[ebp], ecx

; 2080 : 			this->_Getal().destroy(
; 2081 : 				_STD addressof(this->_Myval(_Rootnode)));

	mov	edx, DWORD PTR __Rootnode$[ebp]
	push	edx
	call	?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAU?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@2@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Myval
	add	esp, 4
	push	eax
	call	??$addressof@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@YAPAU?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@AAU10@@Z ; std::addressof<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >
	add	esp, 4
	push	eax
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > > >::_Getal
	mov	ecx, eax
	call	??$destroy@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> > >::destroy<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >

; 2082 : 
; 2083 : 			this->_Getal().deallocate(_Rootnode, 1);

	push	1
	mov	ecx, DWORD PTR __Rootnode$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> > >::deallocate

; 2084 : 			}

	jmp	$LN2@Erase
$LN4@Erase:

; 2085 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::_Erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xtree
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::_Lrotate, COMDAT
; _this$ = ecx

; 2127 : 		{	// promote right node to root of subtree

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 2128 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 2129 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Left
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 2130 : 
; 2131 : 		if (!this->_Isnil(this->_Left(_Pnode)))

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN5@Lrotate

; 2132 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN5@Lrotate:

; 2133 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Parent
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 2134 : 
; 2135 : 		if (_Wherenode == _Root())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::_Root
	mov	edx, DWORD PTR __Wherenode$[ebp]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN4@Lrotate

; 2136 : 			_Root() = _Pnode;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::_Root
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN3@Lrotate
$LN4@Lrotate:

; 2137 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN2@Lrotate

; 2138 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 2139 : 		else

	jmp	SHORT $LN3@Lrotate
$LN2@Lrotate:

; 2140 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN3@Lrotate:

; 2141 : 
; 2142 : 		this->_Left(_Pnode) = _Wherenode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax], ecx

; 2143 : 		this->_Parent(_Wherenode) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 2144 : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?_Lrotate@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::_Lrotate
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xtree
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Rmost@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@XZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::_Rmost, COMDAT
; _this$ = ecx

; 2147 : 		{	// return rightmost node in nonmutable tree

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2148 : 		return (this->_Right(this->_Myhead));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Right
	add	esp, 4

; 2149 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Rmost@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::_Rmost
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xtree
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Root@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@XZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::_Root, COMDAT
; _this$ = ecx

; 2152 : 		{	// return root of nonmutable tree

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2153 : 		return (this->_Parent(this->_Myhead));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Parent
	add	esp, 4

; 2154 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Root@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::_Root
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xtree
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::_Rrotate, COMDAT
; _this$ = ecx

; 2157 : 		{	// promote left node to root of subtree

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 2158 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 2159 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Right
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 2160 : 
; 2161 : 		if (!this->_Isnil(this->_Right(_Pnode)))

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN5@Rrotate

; 2162 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN5@Rrotate:

; 2163 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Parent
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 2164 : 
; 2165 : 		if (_Wherenode == _Root())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::_Root
	mov	edx, DWORD PTR __Wherenode$[ebp]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN4@Rrotate

; 2166 : 			_Root() = _Pnode;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::_Root
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN3@Rrotate
$LN4@Rrotate:

; 2167 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN2@Rrotate

; 2168 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 2169 : 		else

	jmp	SHORT $LN3@Rrotate
$LN2@Rrotate:

; 2170 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN3@Rrotate:

; 2171 : 
; 2172 : 		this->_Right(_Pnode) = _Wherenode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax], ecx

; 2173 : 		this->_Parent(_Wherenode) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 2174 : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?_Rrotate@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_NU?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,bool,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >,0> >::_Rrotate
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xtree
;	COMDAT ??0?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@1@@Z PROC ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > > >::_Tree_alloc<0,std::_Tree_base_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > > >, COMDAT
; _this$ = ecx

; 771  : 	_Tree_alloc(const _Alloc& = _Alloc())

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >

; 772  : 		{	// construct head node, allocator from _Al
; 773  : 		this->_Myhead = _Buyheadnode();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > > >::_Buyheadnode
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 774  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@1@@Z ENDP ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > > >::_Tree_alloc<0,std::_Tree_base_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> > >, COMDAT
; _this$ = ecx

; 801  : 		{	// construct default allocator (do nothing)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@QAE@XZ ; std::allocator<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> >::allocator<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> >

; 802  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@I@Z PROC ; std::allocator<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> >::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 573  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 574  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@I@Z ENDP ; std::allocator<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xtree
;	COMDAT ?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Color, COMDAT

; 578  : 		{	// return reference to color in node

	push	ebp
	mov	ebp, esp

; 579  : 		return ((char&)_Pnode->_Color);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 12					; 0000000cH

; 580  : 		}

	pop	ebp
	ret	0
?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Color
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xtree
;	COMDAT ?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Isnil, COMDAT

; 583  : 		{	// return reference to nil flag in node

	push	ebp
	mov	ebp, esp

; 584  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 13					; 0000000dH

; 585  : 		}

	pop	ebp
	ret	0
?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Isnil
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xtree
;	COMDAT ?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAU?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@2@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAU?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@2@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Myval, COMDAT

; 603  : 		{	// return reference to value in node

	push	ebp
	mov	ebp, esp

; 604  : 		return ((reference)_Pnode->_Myval);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 16					; 00000010H

; 605  : 		}

	pop	ebp
	ret	0
?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAU?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@2@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Myval
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xtree
;	COMDAT ?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Max, COMDAT

; 608  : 		{	// return rightmost node in subtree at _Pnode

	push	ebp
	mov	ebp, esp
$LN2@Max:

; 609  : 		while (!_Isnil(_Right(_Pnode)))

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Isnil
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	jne	SHORT $LN1@Max

; 610  : 			_Pnode = _Right(_Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx
	jmp	SHORT $LN2@Max
$LN1@Max:

; 611  : 		return (_Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]

; 612  : 		}

	pop	ebp
	ret	0
?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Max
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xtree
;	COMDAT ?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Min, COMDAT

; 615  : 		{	// return leftmost node in subtree at _Pnode

	push	ebp
	mov	ebp, esp
$LN2@Min:

; 616  : 		while (!_Isnil(_Left(_Pnode)))

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Isnil
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	jne	SHORT $LN1@Min

; 617  : 			_Pnode = _Left(_Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx
	jmp	SHORT $LN2@Min
$LN1@Min:

; 618  : 		return (_Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]

; 619  : 		}

	pop	ebp
	ret	0
?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Min
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\list
;	COMDAT ?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@@std@@QAEPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@PAU32@0@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
__Pnode$ = -24						; size = 4
$T2 = -20						; size = 1
$T3 = -19						; size = 1
$T4 = -18						; size = 1
$T5 = -17						; size = 1
__$EHRec$ = -16						; size = 16
__Next$ = 8						; size = 4
__Prev$ = 12						; size = 4
?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@@std@@QAEPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@PAU32@0@Z PROC ; std::_List_alloc<0,std::_List_base_types<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > > >::_Buynode0, COMDAT
; _this$ = ecx

; 781  : 		{	// allocate a node and set links

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@@std@@QAEPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@PAU32@0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 782  : 		_Nodeptr _Pnode = this->_Getal().allocate(1);

	push	1
	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_List_alloc@$0A@U?$_List_base_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@2@XZ ; std::_List_alloc<0,std::_List_base_types<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > > >::_Getal
	mov	ecx, eax
	call	?allocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> > >::allocate
	mov	DWORD PTR __Pnode$[ebp], eax

; 783  : 
; 784  : 		if (_Next == _Nodeptr())

	cmp	DWORD PTR __Next$[ebp], 0
	jne	SHORT $LN2@Buynode0

; 785  : 			{	// point at self
; 786  : 			_Next = _Pnode;

	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR __Next$[ebp], ecx

; 787  : 			_Prev = _Pnode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR __Prev$[ebp], edx
$LN2@Buynode0:

; 788  : 			}
; 789  : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 790  : 		this->_Getal().construct(
; 791  : 			_STD addressof(this->_Nextnode(_Pnode)), _Next);

	lea	eax, DWORD PTR __Next$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Nextnode@?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@SAAAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@PAU32@@Z ; std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > >::_Nextnode
	add	esp, 4
	push	eax
	call	??$addressof@PAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@YAPAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@0@AAPAU10@@Z ; std::addressof<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_List_alloc@$0A@U?$_List_base_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@2@XZ ; std::_List_alloc<0,std::_List_base_types<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > > >::_Getal
	mov	ecx, eax
	call	??$construct@PAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@AAPAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> > >::construct<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> *,std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> * &>

; 792  : 		this->_Getal().construct(
; 793  : 			_STD addressof(this->_Prevnode(_Pnode)), _Prev);

	lea	eax, DWORD PTR __Prev$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Prevnode@?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@SAAAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@PAU32@@Z ; std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > >::_Prevnode
	add	esp, 4
	push	eax
	call	??$addressof@PAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@YAPAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@0@AAPAU10@@Z ; std::addressof<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_List_alloc@$0A@U?$_List_base_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@2@XZ ; std::_List_alloc<0,std::_List_base_types<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > > >::_Getal
	mov	ecx, eax
	call	??$construct@PAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@AAPAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> > >::construct<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> *,std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> * &>
	jmp	SHORT $LN5@Buynode0
__catch$?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@@std@@QAEPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@PAU32@0@Z$0:

; 794  : 		_CATCH_ALL
; 795  : 		this->_Getal().deallocate(_Pnode, 1);

	push	1
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_List_alloc@$0A@U?$_List_base_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@2@XZ ; std::_List_alloc<0,std::_List_base_types<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> > >::deallocate

; 796  : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 797  : 		_CATCH_END

	mov	eax, $LN8@Buynode0
	ret	0
$LN5@Buynode0:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT __tryend$?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@@std@@QAEPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@PAU32@0@Z$1
$LN8@Buynode0:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@@std@@QAEPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@PAU32@0@Z$1:

; 798  : 
; 799  : 		return (_Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]
$LN4@Buynode0:

; 800  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@@std@@QAEPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@PAU32@0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-32]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@@std@@QAEPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@PAU32@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@V?$allocator@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@2@@std@@@std@@QAEPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@PAU32@0@Z ENDP ; std::_List_alloc<0,std::_List_base_types<std::unique_ptr<void,ThreadTerminator<0> >,std::allocator<std::unique_ptr<void,ThreadTerminator<0> > > > >::_Buynode0
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> > >::_Wrap_alloc<std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> > >, COMDAT
; _this$ = ecx

; 801  : 		{	// construct default allocator (do nothing)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@QAE@XZ ; std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> >::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> >

; 802  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> > >::_Wrap_alloc<std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@QAEXPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@QAEXPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@I@Z PROC ; std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> >::deallocate, COMDAT
; _this$ = ecx

; 572  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 573  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 574  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@QAEXPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@I@Z ENDP ; std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\list
;	COMDAT ?_Myval@?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@SAAAV?$unique_ptr@XU?$ThreadTerminator@$0A@@@@2@PAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@SAAAV?$unique_ptr@XU?$ThreadTerminator@$0A@@@@2@PAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@@Z PROC ; std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > >::_Myval, COMDAT

; 542  : 		{	// return reference to value in node

	push	ebp
	mov	ebp, esp

; 543  : 		return ((reference)_Pnode->_Myval);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 8

; 544  : 		}

	pop	ebp
	ret	0
?_Myval@?$_List_val@U?$_List_simple_types@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@@std@@SAAAV?$unique_ptr@XU?$ThreadTerminator@$0A@@@@2@PAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@@Z ENDP ; std::_List_val<std::_List_simple_types<std::unique_ptr<void,ThreadTerminator<0> > > >::_Myval
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xtree
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@1@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > > >, COMDAT
; _this$ = ecx

; 214  : 		{	// construct with node pointer _Pnode

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Plist$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >,std::_Iterator_base0>

; 215  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@1@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xtree
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > > >::operator++, COMDAT
; _this$ = ecx

; 256  : 		{	// preincrement

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >,std::_Iterator_base0>::operator++

; 272  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 273  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xtree
;	COMDAT ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >,std::_Iterator_base0>::_Mynode, COMDAT
; _this$ = ecx

; 122  : 		{	// return node pointer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 123  : 		return (_Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 124  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >,std::_Iterator_base0>::_Mynode
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xtree
;	COMDAT ?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@XZ
_TEXT	SEGMENT
_this$ = -32						; size = 4
__Pnode$ = -28						; size = 4
$T2 = -21						; size = 1
$T3 = -20						; size = 1
$T4 = -19						; size = 1
$T5 = -18						; size = 1
$T6 = -17						; size = 1
__$EHRec$ = -16						; size = 16
?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@XZ PROC ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > > >::_Buyheadnode, COMDAT
; _this$ = ecx

; 836  : 		{	// get head node using current allocator

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 837  : 		_Nodeptr _Pnode = this->_Getal().allocate(1);

	push	1
	lea	eax, DWORD PTR $T6[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > > >::_Getal
	mov	ecx, eax
	call	?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> > >::allocate
	mov	DWORD PTR __Pnode$[ebp], eax

; 838  : 
; 839  : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 840  : 		this->_Getal().construct(
; 841  : 			_STD addressof(this->_Left(_Pnode)), _Pnode);

	lea	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Left
	add	esp, 4
	push	eax
	call	??$addressof@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@0@AAPAU10@@Z ; std::addressof<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> *>
	add	esp, 4
	push	eax
	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > > >::_Getal
	mov	ecx, eax
	call	??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@1@AAPAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> > >::construct<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> *,std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> * &>

; 842  : 		this->_Getal().construct(
; 843  : 			_STD addressof(this->_Parent(_Pnode)), _Pnode);

	lea	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Parent
	add	esp, 4
	push	eax
	call	??$addressof@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@0@AAPAU10@@Z ; std::addressof<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> *>
	add	esp, 4
	push	eax
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > > >::_Getal
	mov	ecx, eax
	call	??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@1@AAPAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> > >::construct<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> *,std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> * &>

; 844  : 		this->_Getal().construct(
; 845  : 			_STD addressof(this->_Right(_Pnode)), _Pnode);

	lea	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Right
	add	esp, 4
	push	eax
	call	??$addressof@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@0@AAPAU10@@Z ; std::addressof<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> *>
	add	esp, 4
	push	eax
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > > >::_Getal
	mov	ecx, eax
	call	??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@1@AAPAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> > >::construct<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> *,std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> * &>
	jmp	SHORT $LN4@Buyheadnod
__catch$?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@XZ$0:

; 846  : 		_CATCH_ALL
; 847  : 		this->_Getal().deallocate(_Pnode, 1);

	push	1
	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> > >::deallocate

; 848  : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 849  : 		_CATCH_END

	mov	eax, $LN7@Buyheadnod
	ret	0
$LN4@Buyheadnod:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT __tryend$?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@XZ$1
$LN7@Buyheadnod:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@XZ$1:

; 850  : 
; 851  : 		this->_Color(_Pnode) = this->_Black;

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 852  : 		this->_Isnil(_Pnode) = true;

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Isnil
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 853  : 		return (_Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]
$LN3@Buyheadnod:

; 854  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@2@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@XZ ENDP ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > > >::_Buyheadnode
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??0?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@QAE@XZ PROC ; std::allocator<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> >::allocator<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> >, COMDAT
; _this$ = ecx

; 552  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@QAE@XZ ENDP ; std::allocator<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> >::allocator<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xtree
;	COMDAT ??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >, COMDAT
; _this$ = ecx

; 567  : 	_Tree_val()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 568  : 		{	// initialize data
; 569  : 		this->_Myhead = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 570  : 		this->_Mysize = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 571  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> > >::allocate, COMDAT
; _this$ = ecx

; 846  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 847  : 		return (_Mybase::allocate(_Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@QAEPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@I@Z ; std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> >::allocate

; 848  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> > >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??0?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@QAE@XZ PROC ; std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> >::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> >, COMDAT
; _this$ = ecx

; 552  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 553  : 		{	// construct default allocator (do nothing)
; 554  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@QAE@XZ ENDP ; std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> >::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xtree
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@1@@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 44   : 		{	// construct with node pointer _Pnode

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 45   : 		this->_Adopt(_Plist);

	mov	edx, DWORD PTR __Plist$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z	; std::_Iterator_base0::_Adopt

; 46   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@1@@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xtree
;	COMDAT ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
__Pnode$1 = -8						; size = 4
_this$ = -4						; size = 4
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >,std::_Iterator_base0>::operator++, COMDAT
; _this$ = ecx

; 59   : 		{	// preincrement

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 60   : 		if (_Mytree::_Isnil(_Ptr))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Isnil
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	je	SHORT $LN6@operator
	jmp	$LN5@operator
$LN6@operator:

; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Right
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	jne	SHORT $LN2@operator

; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Min
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 65   : 		else

	jmp	SHORT $LN5@operator
$LN2@operator:

; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$1[ebp], ecx
	mov	edx, DWORD PTR __Pnode$1[ebp]
	push	edx
	call	?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	jne	SHORT $LN1@operator
	mov	ecx, DWORD PTR __Pnode$1[ebp]
	push	ecx
	call	?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@SAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >::_Right
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN1@operator

; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Pnode$1[ebp]
	mov	DWORD PTR [edx], eax
	jmp	SHORT $LN2@operator
$LN1@operator:

; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Pnode$1[ebp]
	mov	DWORD PTR [ecx], edx
$LN5@operator:

; 72   : 			}
; 73   : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 74   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> > >,std::_Iterator_base0>::operator++
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> > >::allocate, COMDAT
; _this$ = ecx

; 846  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 847  : 		return (_Mybase::allocate(_Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@I@Z ; std::allocator<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> >::allocate

; 848  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> > >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@QAEPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@QAEPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@I@Z PROC ; std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> >::allocate, COMDAT
; _this$ = ecx

; 577  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 578  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@YAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@0@IPAU10@@Z ; std::_Allocate<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> >
	add	esp, 8

; 579  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@QAEPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@2@I@Z ENDP ; std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@I@Z PROC ; std::allocator<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> >::allocate, COMDAT
; _this$ = ecx

; 577  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 578  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@YAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@0@IPAU10@@Z ; std::_Allocate<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> >
	add	esp, 8

; 579  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@2@I@Z ENDP ; std::allocator<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xstddef
;	COMDAT ??$addressof@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@0@AAPAU10@@Z PROC ; std::addressof<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> *>, COMDAT

; 92   : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR __Val$[ebp]

; 96   : 	}

	pop	ebp
	ret	0
??$addressof@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@0@AAPAU10@@Z ENDP ; std::addressof<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> > >::destroy<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> *>, COMDAT
; _this$ = ecx

; 877  : 		void destroy(_Ty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 878  : 		{	// destroy object at _Ptr
; 879  : 		_Mytraits::destroy(*this, _Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@1@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> > >::destroy<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> *>
	add	esp, 8

; 880  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> > >::destroy<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xstddef
;	COMDAT ??$addressof@PAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@YAPAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@YAPAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@0@AAPAU10@@Z PROC ; std::addressof<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> *>, COMDAT

; 92   : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR __Val$[ebp]

; 96   : 	}

	pop	ebp
	ret	0
??$addressof@PAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@YAPAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@0@AAPAU10@@Z ENDP ; std::addressof<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> > >::destroy<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> *>, COMDAT
; _this$ = ecx

; 877  : 		void destroy(_Ty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 878  : 		{	// destroy object at _Ptr
; 879  : 		_Mytraits::destroy(*this, _Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$destroy@PAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@1@PAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@@Z ; std::allocator_traits<std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> > >::destroy<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> *>
	add	esp, 8

; 880  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> > >::destroy<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\utility
;	COMDAT ??$swap@D@std@@YAXAAD0@Z
_TEXT	SEGMENT
__Tmp$ = -1						; size = 1
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@D@std@@YAXAAD0@Z PROC				; std::swap<char>, COMDAT

; 51   : 	{	// exchange values stored at _Left and _Right

	push	ebp
	mov	ebp, esp
	push	ecx

; 52   : 	_Ty _Tmp = _Move(_Left);

	mov	eax, DWORD PTR __Left$[ebp]
	push	eax
	call	??$_Move@AAD@std@@YA$$QADAAD@Z		; std::_Move<char &>
	add	esp, 4
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR __Tmp$[ebp], cl

; 53   : 	_Left = _Move(_Right);

	mov	edx, DWORD PTR __Right$[ebp]
	push	edx
	call	??$_Move@AAD@std@@YA$$QADAAD@Z		; std::_Move<char &>
	add	esp, 4
	mov	ecx, DWORD PTR __Left$[ebp]
	mov	dl, BYTE PTR [eax]
	mov	BYTE PTR [ecx], dl

; 54   : 	_Right = _Move(_Tmp);

	lea	eax, DWORD PTR __Tmp$[ebp]
	push	eax
	call	??$_Move@AAD@std@@YA$$QADAAD@Z		; std::_Move<char &>
	add	esp, 4
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	dl, BYTE PTR [eax]
	mov	BYTE PTR [ecx], dl

; 55   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$swap@D@std@@YAXAAD0@Z ENDP				; std::swap<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xstddef
;	COMDAT ??$addressof@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@YAPAU?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@AAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@YAPAU?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@AAU10@@Z PROC ; std::addressof<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >, COMDAT

; 92   : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR __Val$[ebp]

; 96   : 	}

	pop	ebp
	ret	0
??$addressof@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@std@@YAPAU?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@0@AAU10@@Z ENDP ; std::addressof<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$destroy@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> > >::destroy<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >, COMDAT
; _this$ = ecx

; 877  : 		void destroy(_Ty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 878  : 		{	// destroy object at _Ptr
; 879  : 		_Mytraits::destroy(*this, _Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$destroy@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@1@PAU?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@1@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> > >::destroy<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >
	add	esp, 8

; 880  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> > >::destroy<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xstddef
;	COMDAT ??$addressof@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@YAPAV?$unique_ptr@XU?$ThreadTerminator@$0A@@@@0@AAV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@YAPAV?$unique_ptr@XU?$ThreadTerminator@$0A@@@@0@AAV10@@Z PROC ; std::addressof<std::unique_ptr<void,ThreadTerminator<0> > >, COMDAT

; 92   : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR __Val$[ebp]

; 96   : 	}

	pop	ebp
	ret	0
??$addressof@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@std@@YAPAV?$unique_ptr@XU?$ThreadTerminator@$0A@@@@0@AAV10@@Z ENDP ; std::addressof<std::unique_ptr<void,ThreadTerminator<0> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$destroy@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@QAEXPAV?$unique_ptr@XU?$ThreadTerminator@$0A@@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@QAEXPAV?$unique_ptr@XU?$ThreadTerminator@$0A@@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> > >::destroy<std::unique_ptr<void,ThreadTerminator<0> > >, COMDAT
; _this$ = ecx

; 877  : 		void destroy(_Ty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 878  : 		{	// destroy object at _Ptr
; 879  : 		_Mytraits::destroy(*this, _Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$destroy@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@?$allocator_traits@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@1@PAV?$unique_ptr@XU?$ThreadTerminator@$0A@@@@1@@Z ; std::allocator_traits<std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> > >::destroy<std::unique_ptr<void,ThreadTerminator<0> > >
	add	esp, 8

; 880  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@QAEXPAV?$unique_ptr@XU?$ThreadTerminator@$0A@@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> > >::destroy<std::unique_ptr<void,ThreadTerminator<0> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@AAPAU21@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@AAPAU21@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> > >::construct<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> *,std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> * &>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	eax
	call	??$forward@AAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@YAAAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@0@AAPAU10@@Z ; std::forward<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@PAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@1@PAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@AAPAU31@@Z ; std::allocator_traits<std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> > >::construct<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> *,std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> * &>
	add	esp, 12					; 0000000cH

; 873  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@PAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@AAPAU21@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> > >::construct<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> *,std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@1@AAPAU21@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@1@AAPAU21@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> > >::construct<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> *,std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> * &>, COMDAT
; _this$ = ecx

; 868  : 		void construct(_Ty *_Ptr,

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	eax
	call	??$forward@AAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@0@AAPAU10@@Z ; std::forward<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@1@AAPAU31@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> > >::construct<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> *,std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> * &>
	add	esp, 12					; 0000000cH

; 873  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@1@AAPAU21@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> > >::construct<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> *,std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$_Allocate@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@YAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@0@IPAU10@@Z
_TEXT	SEGMENT
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@YAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@0@IPAU10@@Z PROC ; std::_Allocate<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> >, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	push	ecx

; 23   : 	void *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

	jmp	SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	DWORD PTR __Count$[ebp], 357913941	; 15555555H
	ja	SHORT $LN1@Allocate
	imul	eax, DWORD PTR __Count$[ebp], 12
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax
	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@YAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@0@IPAU10@@Z ENDP ; std::_Allocate<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$_Allocate@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@YAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@0@IPAU10@@Z
_TEXT	SEGMENT
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@YAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@0@IPAU10@@Z PROC ; std::_Allocate<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> >, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	push	ecx

; 23   : 	void *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

	jmp	SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	DWORD PTR __Count$[ebp], 97612893	; 05d1745dH
	ja	SHORT $LN1@Allocate
	imul	eax, DWORD PTR __Count$[ebp], 44
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax
	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@YAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@0@IPAU10@@Z ENDP ; std::_Allocate<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@1@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> > >::destroy<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> *>, COMDAT

; 728  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

	push	ebp
	mov	ebp, esp

; 729  : 		{	// destroy object at _Ptr
; 730  : 		_Al.destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@1@@Z ; std::allocator<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> >::destroy<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> *>

; 731  : 		}

	pop	ebp
	ret	0
??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> > >::destroy<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@1@PAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@1@PAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@@Z PROC ; std::allocator_traits<std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> > >::destroy<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> *>, COMDAT

; 728  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

	push	ebp
	mov	ebp, esp

; 729  : 		{	// destroy object at _Ptr
; 730  : 		_Al.destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$destroy@PAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@QAEXPAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@@Z ; std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> >::destroy<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> *>

; 731  : 		}

	pop	ebp
	ret	0
??$destroy@PAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@1@PAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> > >::destroy<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\type_traits
;	COMDAT ??$_Move@AAD@std@@YA$$QADAAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$_Move@AAD@std@@YA$$QADAAD@Z PROC			; std::_Move<char &>, COMDAT

; 1527 : 	{	// forward _Arg as movable

	push	ebp
	mov	ebp, esp

; 1528 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

	mov	eax, DWORD PTR __Arg$[ebp]

; 1529 : 	}

	pop	ebp
	ret	0
??$_Move@AAD@std@@YA$$QADAAD@Z ENDP			; std::_Move<char &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$destroy@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@1@PAU?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@1@PAU?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@1@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> > >::destroy<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >, COMDAT

; 728  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

	push	ebp
	mov	ebp, esp

; 729  : 		{	// destroy object at _Ptr
; 730  : 		_Al.destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$destroy@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@1@@Z ; std::allocator<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> >::destroy<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >

; 731  : 		}

	pop	ebp
	ret	0
??$destroy@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@1@PAU?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> > >::destroy<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$destroy@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@?$allocator_traits@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@1@PAV?$unique_ptr@XU?$ThreadTerminator@$0A@@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@?$allocator_traits@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@1@PAV?$unique_ptr@XU?$ThreadTerminator@$0A@@@@1@@Z PROC ; std::allocator_traits<std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> > >::destroy<std::unique_ptr<void,ThreadTerminator<0> > >, COMDAT

; 728  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

	push	ebp
	mov	ebp, esp

; 729  : 		{	// destroy object at _Ptr
; 730  : 		_Al.destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$destroy@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@QAEXPAV?$unique_ptr@XU?$ThreadTerminator@$0A@@@@1@@Z ; std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> >::destroy<std::unique_ptr<void,ThreadTerminator<0> > >

; 731  : 		}

	pop	ebp
	ret	0
??$destroy@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@?$allocator_traits@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@1@PAV?$unique_ptr@XU?$ThreadTerminator@$0A@@@@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> > >::destroy<std::unique_ptr<void,ThreadTerminator<0> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\type_traits
;	COMDAT ??$forward@AAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@YAAAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@YAAAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@0@AAPAU10@@Z PROC ; std::forward<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> * &>, COMDAT

; 1504 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

	pop	ebp
	ret	0
??$forward@AAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@YAAAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@0@AAPAU10@@Z ENDP ; std::forward<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@1@PAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@AAPAU31@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@1@PAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@AAPAU31@@Z PROC ; std::allocator_traits<std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> > >::construct<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> *,std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> * &>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

	push	ebp
	mov	ebp, esp

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	eax
	call	??$forward@AAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@YAAAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@0@AAPAU10@@Z ; std::forward<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@PAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@AAPAU12@@?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@QAEXPAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@AAPAU21@@Z ; std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> >::construct<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> *,std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> * &>

; 724  : 		}

	pop	ebp
	ret	0
??$construct@PAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@1@PAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@AAPAU31@@Z ENDP ; std::allocator_traits<std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> > >::construct<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> *,std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\type_traits
;	COMDAT ??$forward@AAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@0@AAPAU10@@Z PROC ; std::forward<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> * &>, COMDAT

; 1504 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1506 : 	}

	pop	ebp
	ret	0
??$forward@AAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@0@AAPAU10@@Z ENDP ; std::forward<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@1@AAPAU31@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@1@AAPAU31@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> > >::construct<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> *,std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> * &>, COMDAT

; 720  : 		static void construct(_Alloc& _Al, _Objty *_Ptr,

	push	ebp
	mov	ebp, esp

; 721  : 			_Types&&... _Args)
; 722  : 		{	// construct _Objty(_Types...) at _Ptr
; 723  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	eax
	call	??$forward@AAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@0@AAPAU10@@Z ; std::forward<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@1@AAPAU21@@Z ; std::allocator<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> >::construct<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> *,std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> * &>

; 724  : 		}

	pop	ebp
	ret	0
??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@1@AAPAU31@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> > >::construct<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> *,std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@1@@Z PROC ; std::allocator<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> >::destroy<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> *>, COMDAT
; _this$ = ecx

; 605  : 		void destroy(_Uty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 606  : 		{	// destroy object at _Ptr
; 607  : 		_Ptr->~_Uty();
; 608  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@1@@Z ENDP ; std::allocator<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> >::destroy<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@QAEXPAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@QAEXPAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@@Z PROC ; std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> >::destroy<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> *>, COMDAT
; _this$ = ecx

; 605  : 		void destroy(_Uty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 606  : 		{	// destroy object at _Ptr
; 607  : 		_Ptr->~_Uty();
; 608  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@QAEXPAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@@Z ENDP ; std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> >::destroy<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$destroy@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@1@@Z PROC ; std::allocator<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> >::destroy<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >, COMDAT
; _this$ = ecx

; 605  : 		void destroy(_Uty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 606  : 		{	// destroy object at _Ptr
; 607  : 		_Ptr->~_Uty();

	push	0
	mov	ecx, DWORD PTR __Ptr$[ebp]
	call	??_G?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@QAEPAXI@Z

; 608  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@1@@Z ENDP ; std::allocator<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> >::destroy<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$destroy@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@QAEXPAV?$unique_ptr@XU?$ThreadTerminator@$0A@@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@QAEXPAV?$unique_ptr@XU?$ThreadTerminator@$0A@@@@1@@Z PROC ; std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> >::destroy<std::unique_ptr<void,ThreadTerminator<0> > >, COMDAT
; _this$ = ecx

; 605  : 		void destroy(_Uty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 606  : 		{	// destroy object at _Ptr
; 607  : 		_Ptr->~_Uty();

	push	0
	mov	ecx, DWORD PTR __Ptr$[ebp]
	call	??_G?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@QAEPAXI@Z

; 608  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@@?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@QAEXPAV?$unique_ptr@XU?$ThreadTerminator@$0A@@@@1@@Z ENDP ; std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> >::destroy<std::unique_ptr<void,ThreadTerminator<0> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@AAPAU12@@?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@QAEXPAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@AAPAU21@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
tv70 = -8						; size = 4
$T1 = -4						; size = 4
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@AAPAU12@@?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@QAEXPAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@AAPAU21@@Z PROC ; std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> >::construct<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> *,std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> * &>, COMDAT
; _this$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	push	ecx
	call	??$forward@AAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@YAAAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@0@AAPAU10@@Z ; std::forward<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> * &>
	add	esp, 4
	mov	edx, DWORD PTR $T1[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR tv70[ebp], ecx
	jmp	SHORT $LN1@construct
$LN3@construct:
	mov	DWORD PTR tv70[ebp], 0
$LN1@construct:

; 601  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@PAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@AAPAU12@@?$allocator@U?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@std@@@std@@QAEXPAPAU?$_List_node@V?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@PAX@1@AAPAU21@@Z ENDP ; std::allocator<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> >::construct<std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> *,std::_List_node<std::unique_ptr<void,ThreadTerminator<0> >,void *> * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@1@AAPAU21@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
tv70 = -8						; size = 4
$T1 = -4						; size = 4
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@1@AAPAU21@@Z PROC ; std::allocator<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> >::construct<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> *,std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> * &>, COMDAT
; _this$ = ecx

; 598  : 		void construct(_Objty *_Ptr, _Types&&... _Args)

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 599  : 		{	// construct _Objty(_Types...) at _Ptr
; 600  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	push	ecx
	call	??$forward@AAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@0@AAPAU10@@Z ; std::forward<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> * &>
	add	esp, 4
	mov	edx, DWORD PTR $T1[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR tv70[ebp], ecx
	jmp	SHORT $LN1@construct
$LN3@construct:
	mov	DWORD PTR tv70[ebp], 0
$LN1@construct:

; 601  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@PAX@1@AAPAU21@@Z ENDP ; std::allocator<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> >::construct<std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> *,std::_Tree_node<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@QAEPAXI@Z PROC ; std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@QAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@QAEPAXI@Z ENDP ; std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@QAEPAXI@Z PROC ; std::unique_ptr<void,ThreadTerminator<0> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@QAE@XZ ; std::unique_ptr<void,ThreadTerminator<0> >::~unique_ptr<void,ThreadTerminator<0> >
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@QAEPAXI@Z ENDP ; std::unique_ptr<void,ThreadTerminator<0> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@QAE@XZ PROC ; std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>::~pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_N@std@@QAE@XZ ENDP ; std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>::~pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,bool>
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\memory
;	COMDAT ??1?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@QAE@XZ PROC ; std::unique_ptr<void,ThreadTerminator<0> >::~unique_ptr<void,ThreadTerminator<0> >, COMDAT
; _this$ = ecx

; 1446 : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1447 : 		if (this->_Myptr != pointer())

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@unique_ptr

; 1448 : 			this->get_deleter()(this->_Myptr);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?get_deleter@?$_Unique_ptr_base@XU?$ThreadTerminator@$0A@@@$00@std@@QAEAAU?$ThreadTerminator@$0A@@@XZ ; std::_Unique_ptr_base<void,ThreadTerminator<0>,1>::get_deleter
	mov	ecx, eax
	call	??R?$ThreadTerminator@$0A@@@QBEXPAX@Z	; ThreadTerminator<0>::operator()
$LN2@unique_ptr:

; 1449 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$unique_ptr@XU?$ThreadTerminator@$0A@@@@std@@QAE@XZ ENDP ; std::unique_ptr<void,ThreadTerminator<0> >::~unique_ptr<void,ThreadTerminator<0> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File f:\songmm_moon_stone_obs\obs\obsapi\utility\raiihelpers.h
;	COMDAT ??R?$ThreadTerminator@$0A@@@QBEXPAX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_h$ = 8							; size = 4
??R?$ThreadTerminator@$0A@@@QBEXPAX@Z PROC		; ThreadTerminator<0>::operator(), COMDAT
; _this$ = ecx

; 51   :     void operator()(HANDLE h) const { if (!h) return; Log(L"Terminating 0x%x", GetThreadId(h)); TerminateThread(h, exitCode); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	cmp	DWORD PTR _h$[ebp], 0
	jne	SHORT $LN1@operator
	jmp	SHORT $LN2@operator
$LN1@operator:
	mov	eax, DWORD PTR _h$[ebp]
	push	eax
	call	DWORD PTR __imp__GetThreadId@4
	push	eax
	push	OFFSET ??_C@_1CC@HOAGLCLM@?$AAT?$AAe?$AAr?$AAm?$AAi?$AAn?$AAa?$AAt?$AAi?$AAn?$AAg?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?$AA@
	call	DWORD PTR __imp_?Log@@YAXPB_WZZ
	add	esp, 8
	push	0
	mov	ecx, DWORD PTR _h$[ebp]
	push	ecx
	call	DWORD PTR __imp__TerminateThread@8
$LN2@operator:
	mov	esp, ebp
	pop	ebp
	ret	4
??R?$ThreadTerminator@$0A@@@QBEXPAX@Z ENDP		; ThreadTerminator<0>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File d:\vs2013\vc\include\memory
;	COMDAT ?get_deleter@?$_Unique_ptr_base@XU?$ThreadTerminator@$0A@@@$00@std@@QAEAAU?$ThreadTerminator@$0A@@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get_deleter@?$_Unique_ptr_base@XU?$ThreadTerminator@$0A@@@$00@std@@QAEAAU?$ThreadTerminator@$0A@@@XZ PROC ; std::_Unique_ptr_base<void,ThreadTerminator<0>,1>::get_deleter, COMDAT
; _this$ = ecx

; 1312 : 		{	// return reference to deleter

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1313 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 1314 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?get_deleter@?$_Unique_ptr_base@XU?$ThreadTerminator@$0A@@@$00@std@@QAEAAU?$ThreadTerminator@$0A@@@XZ ENDP ; std::_Unique_ptr_base<void,ThreadTerminator<0>,1>::get_deleter
_TEXT	ENDS
END
